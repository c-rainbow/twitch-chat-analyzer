/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 102);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Enumerable_1 = __webpack_require__(111);
var __export_Enumerable = Enumerable_1.Enumerable;
exports.Enumerable = __export_Enumerable;
var __export_NonEnumerable = Enumerable_1.NonEnumerable;
exports.NonEnumerable = __export_NonEnumerable;
var flatten_1 = __webpack_require__(112);
var __export_flatten = flatten_1.flatten;
exports.flatten = __export_flatten;
var resolveConfigValue_1 = __webpack_require__(113);
var __export_resolveConfigValue = resolveConfigValue_1.resolveConfigValue;
exports.resolveConfigValue = __export_resolveConfigValue;
var deprecateClass_1 = __webpack_require__(114);
var __export_deprecateClass = deprecateClass_1.deprecateClass;
exports.deprecateClass = __export_deprecateClass;
var match_1 = __webpack_require__(115);
var __export_match = match_1.match;
exports.match = __export_match;
var __export_eq = match_1.eq;
exports.eq = __export_eq;
var arrayToObject_1 = __webpack_require__(28);
var __export_arrayToObject = arrayToObject_1.arrayToObject;
exports.arrayToObject = __export_arrayToObject;
var entriesToObject_1 = __webpack_require__(116);
var __export_entriesToObject = entriesToObject_1.entriesToObject;
exports.entriesToObject = __export_entriesToObject;
var forEachObjectEntry_1 = __webpack_require__(117);
var __export_forEachObjectEntry = forEachObjectEntry_1.forEachObjectEntry;
exports.forEachObjectEntry = __export_forEachObjectEntry;
var indexBy_1 = __webpack_require__(118);
var __export_indexBy = indexBy_1.indexBy;
exports.indexBy = __export_indexBy;
var mapObject_1 = __webpack_require__(119);
var __export_mapObject = mapObject_1.mapObject;
exports.mapObject = __export_mapObject;
var omit_1 = __webpack_require__(120);
var __export_omit = omit_1.omit;
exports.omit = __export_omit;
var pick_1 = __webpack_require__(46);
var __export_pick = pick_1.pick;
exports.pick = __export_pick;
var delay_1 = __webpack_require__(121);
var __export_delay = delay_1.delay;
exports.delay = __export_delay;
var padLeft_1 = __webpack_require__(122);
var __export_padLeft = padLeft_1.padLeft;
exports.padLeft = __export_padLeft;
var splitWithLimit_1 = __webpack_require__(123);
var __export_splitWithLimit = splitWithLimit_1.splitWithLimit;
exports.splitWithLimit = __export_splitWithLimit;
var utf8Length_1 = __webpack_require__(124);
var __export_utf8Length = utf8Length_1.utf8Length;
exports.utf8Length = __export_utf8Length;
var utf8Substring_1 = __webpack_require__(125);
var __export_utf8Substring = utf8Substring_1.utf8Substring;
exports.utf8Substring = __export_utf8Substring;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Enumerable = __export_Enumerable;
exports.NonEnumerable = __export_NonEnumerable;
exports.flatten = __export_flatten;
exports.resolveConfigValue = __export_resolveConfigValue;
exports.deprecateClass = __export_deprecateClass;
exports.match = __export_match;
exports.eq = __export_eq;
exports.arrayToObject = __export_arrayToObject;
exports.entriesToObject = __export_entriesToObject;
exports.forEachObjectEntry = __export_forEachObjectEntry;
exports.indexBy = __export_indexBy;
exports.mapObject = __export_mapObject;
exports.omit = __export_omit;
exports.pick = __export_pick;
exports.delay = __export_delay;
exports.padLeft = __export_padLeft;
exports.splitWithLimit = __export_splitWithLimit;
exports.utf8Length = __export_utf8Length;
exports.utf8Substring = __export_utf8Substring;
//# sourceMappingURL=index.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* globals
	Atomics,
	SharedArrayBuffer,
*/

var undefined;

var $TypeError = TypeError;

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () { throw new $TypeError(); };
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(23)();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var generator; // = function * () {};
var generatorFunction = generator ? getProto(generator) : undefined;
var asyncFn; // async function() {};
var asyncFunction = asyncFn ? asyncFn.constructor : undefined;
var asyncGen; // async function * () {};
var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;
var asyncGenIterator = asyncGen ? asyncGen() : undefined;

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%ArrayPrototype%': Array.prototype,
	'%ArrayProto_entries%': Array.prototype.entries,
	'%ArrayProto_forEach%': Array.prototype.forEach,
	'%ArrayProto_keys%': Array.prototype.keys,
	'%ArrayProto_values%': Array.prototype.values,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': asyncFunction,
	'%AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,
	'%AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,
	'%AsyncGeneratorFunction%': asyncGenFunction,
	'%AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,
	'%AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%Boolean%': Boolean,
	'%BooleanPrototype%': Boolean.prototype,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,
	'%Date%': Date,
	'%DatePrototype%': Date.prototype,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%ErrorPrototype%': Error.prototype,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%EvalErrorPrototype%': EvalError.prototype,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,
	'%Function%': Function,
	'%FunctionPrototype%': Function.prototype,
	'%Generator%': generator ? getProto(generator()) : undefined,
	'%GeneratorFunction%': generatorFunction,
	'%GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,
	'%Math%': Math,
	'%Number%': Number,
	'%NumberPrototype%': Number.prototype,
	'%Object%': Object,
	'%ObjectPrototype%': Object.prototype,
	'%ObjProto_toString%': Object.prototype.toString,
	'%ObjProto_valueOf%': Object.prototype.valueOf,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,
	'%PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,
	'%Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,
	'%Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,
	'%Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%RangeErrorPrototype%': RangeError.prototype,
	'%ReferenceError%': ReferenceError,
	'%ReferenceErrorPrototype%': ReferenceError.prototype,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%RegExpPrototype%': RegExp.prototype,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%StringPrototype%': String.prototype,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,
	'%SyntaxError%': SyntaxError,
	'%SyntaxErrorPrototype%': SyntaxError.prototype,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,
	'%TypeError%': $TypeError,
	'%TypeErrorPrototype%': $TypeError.prototype,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,
	'%URIError%': URIError,
	'%URIErrorPrototype%': URIError.prototype,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
	'%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype
};

var bind = __webpack_require__(35);
var $replace = bind.call(Function.call, String.prototype.replace);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	if (!(name in INTRINSICS)) {
		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
	}

	// istanbul ignore if // hopefully this is impossible to test :-)
	if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
		throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
	}

	return INTRINSICS[name];
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);

	var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);
	for (var i = 1; i < parts.length; i += 1) {
		if (value != null) {
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, parts[i]);
				if (!allowMissing && !(parts[i] in value)) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				value = desc ? (desc.get || desc.value) : value[parts[i]];
			} else {
				value = value[parts[i]];
			}
		}
	}
	return value;
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/** @private */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(client) {
        this._client = client;
    }
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], BaseAPI.prototype, "_client", void 0);
    return BaseAPI;
}());
exports.default = BaseAPI;
module.exports = exports = BaseAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseAPI;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/// <reference lib="dom" />
var cache_decorators_1 = __webpack_require__(5);
var cross_fetch_1 = __webpack_require__(103);
var logger_1 = __webpack_require__(104);
var qs_1 = __webpack_require__(107);
var AccessToken_1 = __webpack_require__(27);
var BadgesAPI_1 = __webpack_require__(110);
var HelixAPIGroup_1 = __webpack_require__(126);
var HelixRateLimiter_1 = __webpack_require__(139);
var CheermoteList_1 = __webpack_require__(37);
var KrakenAPIGroup_1 = __webpack_require__(194);
var TokenInfo_1 = __webpack_require__(96);
var UnsupportedAPI_1 = __webpack_require__(207);
var ClientCredentialsAuthProvider_1 = __webpack_require__(208);
var RefreshableAuthProvider_1 = __webpack_require__(98);
var StaticAuthProvider_1 = __webpack_require__(99);
var ConfigError_1 = __webpack_require__(100);
var HTTPStatusCodeError_1 = __webpack_require__(19);
var InvalidTokenError_1 = __webpack_require__(101);
/**
 * The endpoint to call, i.e. /kraken, /helix or a custom (potentially unsupported) endpoint.
 */
var TwitchAPICallType;
(function (TwitchAPICallType) {
    /**
     * Call a Kraken API endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Kraken"] = 0] = "Kraken";
    /**
     * Call a Helix API endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Helix"] = 1] = "Helix";
    /**
     * Call an authentication endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Auth"] = 2] = "Auth";
    /**
     * Call a custom (potentially unsupported) endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Custom"] = 3] = "Custom";
})(TwitchAPICallType || (TwitchAPICallType = {}));
exports.TwitchAPICallType = TwitchAPICallType;
/**
 * The main entry point of this library. Manages API calls and the use of access tokens in these.
 */
var TwitchClient = /** @class */ (function () {
    /**
     * Creates a new Twitch client instance.
     *
     * @param config Configuration for the client instance.
     */
    function TwitchClient(config) {
        var authProvider = config.authProvider, restConfig = tslib_1.__rest(config, ["authProvider"]);
        if (!authProvider) {
            throw new ConfigError_1.default('No auth provider given');
        }
        this._helixRateLimiter = new HelixRateLimiter_1.default(config.logLevel || logger_1.LogLevel.CRITICAL);
        this._config = tslib_1.__assign({ preAuth: false, cheermotes: {
                defaultBackground: CheermoteList_1.CheermoteBackground.dark,
                defaultState: CheermoteList_1.CheermoteState.animated,
                defaultScale: CheermoteList_1.CheermoteScale.x1
            }, authProvider: authProvider }, restConfig);
        if (this._config.preAuth) {
            // tslint:disable-next-line:no-floating-promises
            authProvider.getAccessToken(this._config.initialScopes);
        }
    }
    TwitchClient_1 = TwitchClient;
    // TODO 5.0: config object!
    /**
     * Creates a new instance with fixed credentials.
     *
     * @param clientId The client ID of your application.
     * @param accessToken The access token to call the API with.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     * @param scopes The scopes your supplied token has.
     *
     * If this argument is given, the scopes need to be correct, or weird things might happen. If it's not (i.e. it's `undefined`), we fetch the correct scopes for you.
     *
     * If you can't exactly say which scopes your token has, don't use this parameter/set it to `undefined`.
     * @param refreshConfig Configuration to automatically refresh expired tokens.
     * @param config Additional configuration to pass to the constructor.
     *
     * Note that if you provide a custom `authProvider`, this method will overwrite it. In this case, you should use the constructor directly.
     * @param tokenType The type of token you passed.
     *
     * This should almost always be 'user' (which is the default).
     *
     * If you're passing 'app' here, please consider using {@TwitchClient.withClientCredentials} instead.
     */
    TwitchClient.withCredentials = function (clientId, accessToken, scopes, refreshConfig, config, tokenType) {
        if (config === void 0) { config = {}; }
        if (tokenType === void 0) { tokenType = 'user'; }
        var authProvider = refreshConfig
            ? new RefreshableAuthProvider_1.default(new StaticAuthProvider_1.default(clientId, accessToken, scopes, tokenType), refreshConfig)
            : new StaticAuthProvider_1.default(clientId, accessToken, scopes, tokenType);
        return new this(tslib_1.__assign(tslib_1.__assign({}, config), { authProvider: authProvider }));
    };
    /**
     * Creates a new instance with client credentials.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param config Additional configuration to pass to the constructor.
     *
     * Note that if you provide a custom `authProvider`, this method will overwrite it. In this case, you should use the constructor directly.
     */
    TwitchClient.withClientCredentials = function (clientId, clientSecret, config) {
        if (config === void 0) { config = {}; }
        var authProvider = clientSecret
            ? new ClientCredentialsAuthProvider_1.default(clientId, clientSecret)
            : new StaticAuthProvider_1.default(clientId);
        return new this(tslib_1.__assign(tslib_1.__assign({}, config), { authProvider: authProvider }));
    };
    /**
     * Makes a call to the Twitch API using given credentials.
     *
     * @param options The configuration of the call.
     * @param clientId The client ID of your application.
     * @param accessToken The access token to call the API with.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    TwitchClient.callAPI = function (options, clientId, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._callAPIRaw(options, clientId, accessToken)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, this._transformResponse(response)];
                }
            });
        });
    };
    /**
     * Retrieves an access token with your client credentials and an authorization code.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param code The authorization code.
     * @param redirectUri The redirect URI. This serves no real purpose here, but must still match with the redirect URI you configured in the Twitch Developer dashboard.
     */
    TwitchClient.getAccessToken = function (clientId, clientSecret, code, redirectUri) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = AccessToken_1.default.bind;
                        return [4 /*yield*/, this.callAPI({
                                type: TwitchAPICallType.Auth,
                                url: 'token',
                                method: 'POST',
                                query: {
                                    grant_type: 'authorization_code',
                                    client_id: clientId,
                                    client_secret: clientSecret,
                                    code: code,
                                    redirect_uri: redirectUri
                                }
                            })];
                    case 1: return [2 /*return*/, new (_a.apply(AccessToken_1.default, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    /**
     * Retrieves an app access token with your client credentials.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param clientSecret
     */
    TwitchClient.getAppAccessToken = function (clientId, clientSecret) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = AccessToken_1.default.bind;
                        return [4 /*yield*/, this.callAPI({
                                type: TwitchAPICallType.Auth,
                                url: 'token',
                                method: 'POST',
                                query: {
                                    grant_type: 'client_credentials',
                                    client_id: clientId,
                                    client_secret: clientSecret
                                }
                            })];
                    case 1: return [2 /*return*/, new (_a.apply(AccessToken_1.default, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    /**
     * Refreshes an expired access token with your client credentials and the refresh token that was given by the initial authentication.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param refreshToken The refresh token.
     */
    TwitchClient.refreshAccessToken = function (clientId, clientSecret, refreshToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = AccessToken_1.default.bind;
                        return [4 /*yield*/, this.callAPI({
                                type: TwitchAPICallType.Auth,
                                url: 'token',
                                method: 'POST',
                                query: {
                                    grant_type: 'refresh_token',
                                    client_id: clientId,
                                    client_secret: clientSecret,
                                    refresh_token: refreshToken
                                }
                            })];
                    case 1: return [2 /*return*/, new (_a.apply(AccessToken_1.default, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    /**
     * Retrieves information about an access token.
     *
     * @param clientId The client ID of your application.
     * @param accessToken The access token to get the information of.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     */
    TwitchClient.getTokenInfo = function (accessToken, clientId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.callAPI({ type: TwitchAPICallType.Auth, url: 'validate' }, clientId, accessToken)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new TokenInfo_1.default(data)];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default && e_1.statusCode === 401) {
                            throw new InvalidTokenError_1.default();
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @private
     */
    TwitchClient._callAPIRaw = function (options, clientId, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var type, url, params, headers, body, requestOptions;
            return tslib_1.__generator(this, function (_a) {
                type = options.type === undefined ? TwitchAPICallType.Kraken : options.type;
                url = this._getUrl(options.url, type);
                params = qs_1.stringify(options.query, { arrayFormat: 'repeat' });
                headers = new cross_fetch_1.Headers({
                    Accept: type === TwitchAPICallType.Kraken
                        ? "application/vnd.twitchtv.v" + (options.version || 5) + "+json"
                        : 'application/json'
                });
                if (options.body) {
                    body = qs_1.stringify(options.body);
                    headers.append('Content-Type', 'application/x-www-form-urlencoded');
                }
                else if (options.jsonBody) {
                    body = JSON.stringify(options.jsonBody);
                    headers.append('Content-Type', 'application/json');
                }
                if (clientId && type !== TwitchAPICallType.Auth) {
                    headers.append('Client-ID', clientId);
                }
                if (accessToken) {
                    headers.append('Authorization', (type === TwitchAPICallType.Helix ? 'Bearer' : 'OAuth') + " " + accessToken);
                }
                requestOptions = {
                    method: options.method || 'GET',
                    headers: headers,
                    body: body
                };
                return [2 /*return*/, cross_fetch_1.default(params ? url + "?" + params : url, requestOptions)];
            });
        });
    };
    /**
     * Retrieves information about your access token.
     */
    TwitchClient.prototype.getTokenInfo = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.callAPI({ type: TwitchAPICallType.Auth, url: 'validate' })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new TokenInfo_1.default(data)];
                    case 2:
                        e_2 = _a.sent();
                        if (e_2 instanceof HTTPStatusCodeError_1.default && e_2.statusCode === 401) {
                            throw new InvalidTokenError_1.default();
                        }
                        throw e_2;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves an access token for the authentication provider.
     *
     * @param scopes The scopes to request.
     */
    TwitchClient.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._config.authProvider.getAccessToken(scopes)];
            });
        });
    };
    /**
     * Forces the authentication provider to refresh the access token, if possible.
     */
    TwitchClient.prototype.refreshAccessToken = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._config.authProvider.refresh && this._config.authProvider.refresh()];
            });
        });
    };
    Object.defineProperty(TwitchClient.prototype, "tokenType", {
        /**
         * The type of token used by the client.
         */
        get: function () {
            return this._config.authProvider.tokenType || 'user';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Makes a call to the Twitch API using your access token.
     *
     * @param options The configuration of the call.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    TwitchClient.prototype.callAPI = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var authProvider, accessToken, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        authProvider = this._config.authProvider;
                        return [4 /*yield*/, authProvider.getAccessToken(options.scope ? [options.scope] : undefined)];
                    case 1:
                        accessToken = _a.sent();
                        if (!accessToken) {
                            return [2 /*return*/, TwitchClient_1.callAPI(options, authProvider.clientId)];
                        }
                        if (!(accessToken.isExpired && authProvider.refresh)) return [3 /*break*/, 3];
                        return [4 /*yield*/, authProvider.refresh()];
                    case 2:
                        accessToken = _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this._callAPIInternal(options, authProvider.clientId, accessToken.accessToken)];
                    case 4:
                        response = _a.sent();
                        if (!(response.status === 401 && authProvider.refresh)) return [3 /*break*/, 8];
                        return [4 /*yield*/, authProvider.refresh()];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, authProvider.getAccessToken(options.scope ? [options.scope] : [])];
                    case 6:
                        accessToken = _a.sent();
                        if (!accessToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, this._callAPIInternal(options, authProvider.clientId, accessToken.accessToken)];
                    case 7:
                        response = _a.sent();
                        _a.label = 8;
                    case 8: return [2 /*return*/, TwitchClient_1._transformResponse(response)];
                }
            });
        });
    };
    Object.defineProperty(TwitchClient.prototype, "cheermoteDefaults", {
        /**
         * The default specs for cheermotes.
         */
        get: function () {
            return this._config.cheermotes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "kraken", {
        /**
         * A group of Kraken API methods.
         */
        get: function () {
            return new KrakenAPIGroup_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "helix", {
        /**
         * A group of Helix API methods.
         */
        get: function () {
            return new HelixAPIGroup_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "badges", {
        /**
         * The API methods that deal with badges.
         */
        get: function () {
            return new BadgesAPI_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "unsupported", {
        /**
         * Various API methods that are not officially supported by Twitch.
         */
        get: function () {
            return new UnsupportedAPI_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    /** @private */
    TwitchClient.prototype._getAuthProvider = function () {
        return this._config.authProvider;
    };
    TwitchClient.prototype._callAPIInternal = function (options, clientId, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (options.type === TwitchAPICallType.Helix) {
                    return [2 /*return*/, this._helixRateLimiter.request({ options: options, clientId: clientId, accessToken: accessToken })];
                }
                return [2 /*return*/, TwitchClient_1._callAPIRaw(options, clientId, accessToken)];
            });
        });
    };
    TwitchClient._getUrl = function (url, type) {
        switch (type) {
            case TwitchAPICallType.Kraken:
            case TwitchAPICallType.Helix:
                var typeName = type === TwitchAPICallType.Kraken ? 'kraken' : 'helix';
                return "https://api.twitch.tv/" + typeName + "/" + url.replace(/^\//, '');
            case TwitchAPICallType.Auth:
                return "https://id.twitch.tv/oauth2/" + url.replace(/^\//, '');
            case TwitchAPICallType.Custom:
                return url;
            default:
                return url; // wat
        }
    };
    TwitchClient._transformResponse = function (response) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, _b, text;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!!response.ok) return [3 /*break*/, 2];
                        _a = HTTPStatusCodeError_1.default.bind;
                        _b = [void 0, response.status, response.statusText];
                        return [4 /*yield*/, response.json()];
                    case 1: throw new (_a.apply(HTTPStatusCodeError_1.default, _b.concat([_c.sent()])))();
                    case 2:
                        if (response.status === 204) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            return [2 /*return*/, undefined]; // oof
                        }
                        return [4 /*yield*/, response.text()];
                    case 3:
                        text = _c.sent();
                        if (!text) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            return [2 /*return*/, undefined]; // mega oof - twitch doesn't return a response when it should
                        }
                        return [2 /*return*/, JSON.parse(text)];
                }
            });
        });
    };
    var TwitchClient_1;
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "kraken", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "helix", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "badges", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "unsupported", null);
    TwitchClient = TwitchClient_1 = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], TwitchClient);
    return TwitchClient;
}());
exports.default = TwitchClient;
module.exports = exports = TwitchClient;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TwitchAPICallType = TwitchAPICallType;
exports.default = TwitchClient;


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "Cacheable", function() { return /* reexport */ Cacheable; });
__webpack_require__.d(__webpack_exports__, "Cached", function() { return /* reexport */ Cached; });
__webpack_require__.d(__webpack_exports__, "CachedGetter", function() { return /* reexport */ CachedGetter; });
__webpack_require__.d(__webpack_exports__, "ClearsCache", function() { return /* reexport */ ClearsCache; });
__webpack_require__.d(__webpack_exports__, "createCacheKey", function() { return /* reexport */ createCacheKey; });

// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/utils/createCacheKey.js

function createSingleCacheKey(param) {
    // noinspection FallThroughInSwitchStatementJS
    switch (typeof param) {
        case 'undefined': {
            return '';
        }
        case 'object': {
            if (param === null) {
                return '';
            }
            if ('cacheKey' in param) {
                return param.cacheKey;
            }
            var objKey = JSON.stringify(param);
            if (objKey !== '{}') {
                return objKey;
            }
        }
        // fallthrough
        default: {
            return param.toString();
        }
    }
}
function createCacheKey(propName, params, prefix) {
    return __spread([propName], params.map(createSingleCacheKey)).join('/') + (prefix ? '/' : '');
}
//# sourceMappingURL=createCacheKey.js.map
// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/decorators/Cacheable.js


function Cacheable(cls) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.cache = new Map();
            return _this;
        }
        class_1.prototype.getFromCache = function (cacheKey) {
            this._cleanCache();
            if (this.cache.has(cacheKey)) {
                var entry = this.cache.get(cacheKey);
                if (entry) {
                    return entry.value;
                }
            }
            return undefined;
        };
        class_1.prototype.setCache = function (cacheKey, value, timeInSeconds) {
            this.cache.set(cacheKey, {
                value: value,
                expires: Date.now() + timeInSeconds * 1000
            });
        };
        class_1.prototype.removeFromCache = function (cacheKey, prefix) {
            var _this = this;
            var internalCacheKey;
            if (typeof cacheKey === 'string') {
                internalCacheKey = cacheKey;
                if (!internalCacheKey.endsWith('/')) {
                    internalCacheKey += '/';
                }
            }
            else {
                var propName = cacheKey.shift();
                internalCacheKey = createCacheKey(propName, cacheKey, prefix);
            }
            if (prefix) {
                this.cache.forEach(function (val, key) {
                    if (key.startsWith(internalCacheKey)) {
                        _this.cache.delete(key);
                    }
                });
            }
            else {
                this.cache.delete(internalCacheKey);
            }
        };
        class_1.prototype._cleanCache = function () {
            var _this = this;
            var now = Date.now();
            this.cache.forEach(function (val, key) {
                if (val.expires < now) {
                    _this.cache.delete(key);
                }
            });
        };
        return class_1;
    }(cls));
}
//# sourceMappingURL=Cacheable.js.map
// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/decorators/Cached.js


function Cached(timeInSeconds, cacheFailures) {
    if (timeInSeconds === void 0) { timeInSeconds = Infinity; }
    if (cacheFailures === void 0) { cacheFailures = false; }
    return function (target, propName, descriptor) {
        var origFn = descriptor.value;
        descriptor.value = function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            return __awaiter(this, void 0, void 0, function () {
                var cacheKey, cachedValue, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            cacheKey = createCacheKey(propName, params);
                            cachedValue = this.getFromCache(cacheKey);
                            if (cachedValue) {
                                return [2 /*return*/, cachedValue];
                            }
                            return [4 /*yield*/, origFn.apply(this, params)];
                        case 1:
                            result = _a.sent();
                            if (result != null || cacheFailures) {
                                this.setCache(cacheKey, result, timeInSeconds);
                            }
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        return descriptor;
    };
}
//# sourceMappingURL=Cached.js.map
// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/decorators/CachedGetter.js

function CachedGetter(timeInSeconds) {
    if (timeInSeconds === void 0) { timeInSeconds = Infinity; }
    return function (target, propName, descriptor) {
        if (descriptor.get) {
            var origFn_1 = descriptor.get;
            descriptor.get = function () {
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                var cacheKey = createCacheKey(propName, params);
                var cachedValue = this.getFromCache(cacheKey);
                if (cachedValue) {
                    return cachedValue;
                }
                var result = origFn_1.apply(this, params);
                this.setCache(cacheKey, result, timeInSeconds);
                return result;
            };
        }
        return descriptor;
    };
}
//# sourceMappingURL=CachedGetter.js.map
// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/decorators/ClearsCache.js

function ClearsCache(cacheName, numberOfArguments) {
    return function (target, propName, descriptor) {
        var origFn = descriptor.value;
        descriptor.value = function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            return __awaiter(this, void 0, void 0, function () {
                var result, args;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, origFn.apply(this, params)];
                        case 1:
                            result = _a.sent();
                            args = numberOfArguments === undefined ? params.slice() : params.slice(0, numberOfArguments);
                            this.removeFromCache(__spread([cacheName], args), true);
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        return descriptor;
    };
}
//# sourceMappingURL=ClearsCache.js.map
// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/index.js





//# sourceMappingURL=index.js.map

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Extracts the user ID from an argument that is possibly an object containing that ID.
 *
 * @param user The user ID or object.
 */
function extractUserId(user) {
    if (typeof user === 'string') {
        return user;
    }
    else if (typeof user === 'number') {
        return user.toString(10);
    }
    else {
        return user.id;
    }
}
exports.extractUserId = extractUserId;
/**
 * Extracts the user name from an argument that is possibly an object containing that name.
 *
 * @param user The user name or object.
 */
function extractUserName(user) {
    return typeof user === 'string' ? user : user.name;
}
exports.extractUserName = extractUserName;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ES5Type = __webpack_require__(151);

// https://ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	return ES5Type(x);
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var callBind = __webpack_require__(34);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/// <reference lib="esnext.asynciterable" />
var shared_utils_1 = __webpack_require__(1);
var TwitchClient_1 = __webpack_require__(4);
if (!Object.prototype.hasOwnProperty.call(Symbol, 'asyncIterator')) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for('Symbol.asyncIterator');
}
/**
 * Represents a request to the new Twitch API (Helix) that utilizes a cursor to paginate through its results.
 *
 * Aside from the methods described below, you can also utilize the async iterator using `for await .. of`:
 *
 * ```ts
 * const result = client.helix.videos.getVideosByUser('125328655');
 * for await (const video of result) {
 *     console.log(video.title);
 * }
 * ```
 */
var HelixPaginatedRequest = /** @class */ (function () {
    /** @private */
    function HelixPaginatedRequest(_callOptions, client, _mapper) {
        this._callOptions = _callOptions;
        this._mapper = _mapper;
        /** @private */
        this._isFinished = false;
        this._client = client;
    }
    Object.defineProperty(HelixPaginatedRequest.prototype, "current", {
        /**
         * The last retrieved page of data associated to the requested resource.
         *
         * Only works with {@HelixPaginatedRequest#getNext} and not with any other methods of data retrieval.
         */
        get: function () {
            return this._currentData ? this._currentData.data : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves and returns the next available page of data associated to the requested resource, or an empty array if there are no more available pages.
     */
    HelixPaginatedRequest.prototype.getNext = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._isFinished) {
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, this._fetchData()];
                    case 1:
                        result = _a.sent();
                        if (!result.data.length) {
                            this._isFinished = true;
                            return [2 /*return*/, []];
                        }
                        return [2 /*return*/, this._processResult(result)];
                }
            });
        });
    };
    /**
     * Retrieves and returns all data associated to the requested resource.
     *
     * Be aware that this makes multiple calls to the Twitch API. Due to this, you might be more suspectible to rate limits.
     *
     * Also be aware that this resets the internal cursor, so avoid using this and {@HelixPaginatedRequest#getNext} together.
     */
    HelixPaginatedRequest.prototype.getAll = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.reset();
                        result = [];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, this.getNext()];
                    case 2:
                        data = _a.sent();
                        if (!data.length) {
                            return [3 /*break*/, 4];
                        }
                        result.push.apply(result, tslib_1.__spread(data));
                        _a.label = 3;
                    case 3:
                        if (this._currentCursor) return [3 /*break*/, 1];
                        _a.label = 4;
                    case 4:
                        this.reset();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    Object.defineProperty(HelixPaginatedRequest.prototype, "currentCursor", {
        /**
         * Retrieves the current cursor.
         *
         * Only useful if you want to make manual requests to the API.
         */
        get: function () {
            return this._currentCursor;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the internal cursor.
     *
     * This will make {@HelixPaginatedRequest#getNext} start from the first page again.
     */
    HelixPaginatedRequest.prototype.reset = function () {
        this._currentCursor = undefined;
        this._isFinished = false;
        this._currentData = undefined;
    };
    HelixPaginatedRequest.prototype[Symbol.asyncIterator] = function () {
        return tslib_1.__asyncGenerator(this, arguments, function _a() {
            var data;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.reset();
                        _b.label = 1;
                    case 1:
                        if (false) {}
                        return [4 /*yield*/, tslib_1.__await(this.getNext())];
                    case 2:
                        data = _b.sent();
                        if (!data.length) {
                            return [3 /*break*/, 5];
                        }
                        return [5 /*yield**/, tslib_1.__values(tslib_1.__asyncDelegator(tslib_1.__asyncValues(data[Symbol.iterator]())))];
                    case 3: return [4 /*yield*/, tslib_1.__await.apply(void 0, [_b.sent()])];
                    case 4:
                        _b.sent();
                        return [3 /*break*/, 1];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /** @private */
    HelixPaginatedRequest.prototype._fetchData = function (additionalOptions) {
        if (additionalOptions === void 0) { additionalOptions = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.callAPI(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ type: TwitchClient_1.TwitchAPICallType.Helix }, this._callOptions), additionalOptions), { query: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this._callOptions.query), { after: this._currentCursor, first: '100' }), additionalOptions.query) }))];
            });
        });
    };
    /** @private */
    HelixPaginatedRequest.prototype._processResult = function (result) {
        var _this = this;
        this._currentCursor = result.pagination ? result.pagination.cursor : undefined;
        if (this._currentCursor === undefined) {
            this._isFinished = true;
        }
        this._currentData = result;
        return result.data.reduce(function (acc, elem) {
            var mapped = _this._mapper(elem);
            return Array.isArray(mapped) ? tslib_1.__spread(acc, mapped) : tslib_1.__spread(acc, [mapped]);
        }, []);
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixPaginatedRequest.prototype, "_client", void 0);
    return HelixPaginatedRequest;
}());
exports.default = HelixPaginatedRequest;
module.exports = exports = HelixPaginatedRequest;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixPaginatedRequest;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var NoSubscriptionProgramError_1 = __webpack_require__(15);
var ChannelPlaceholder_1 = __webpack_require__(38);
/**
 * A Twitch user.
 */
var User = /** @class */ (function () {
    /** @private */
    function User(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(User.prototype, "cacheKey", {
        /** @private */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "id", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "bio", {
        /**
         * The bio of the user.
         */
        get: function () {
            return this._data.bio;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "creationDate", {
        /**
         * The date when the user was created, i.e. when they registered on Twitch.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "updateDate", {
        /**
         * The last date when the user changed anything in their profile, e.g. their description or their profile picture.
         */
        get: function () {
            return new Date(this._data.updated_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "name", {
        /**
         * The user name of the user.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "displayName", {
        /**
         * The display name of the user.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "logoUrl", {
        /**
         * The URL to the profile picture of the user.
         */
        get: function () {
            return this._data.logo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "type", {
        /**
         * The type of the user.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the channel data of the user.
     */
    User.prototype.getChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannel(this)];
            });
        });
    };
    /**
     * Gets a channel placeholder object for the user, which can do anything you can do to a channel with just the ID.
     */
    User.prototype.getChannelPlaceholder = function () {
        return new ChannelPlaceholder_1.default(this._data._id, this._client);
    };
    /**
     * Retrieves the currently running stream of the user.
     */
    User.prototype.getStream = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getChannelPlaceholder().getStream()];
            });
        });
    };
    /**
     * Retrieves the subscription data for the user to the given channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the user. If you only have access to the channel,
     * use {@ChannelPlaceholder#getSubscriptionBy} instead.
     *
     * @param channel The channel you want to get the subscription data for.
     */
    User.prototype.getSubscriptionTo = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getSubscriptionData(this, channel)];
            });
        });
    };
    /**
     * Checks whether the user is subscribed to the given channel.
     *
     * @param channel The channel you want to check the subscription for.
     */
    User.prototype.isSubscribedTo = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getSubscriptionTo(channel)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof NoSubscriptionProgramError_1.default) {
                            return [2 /*return*/, false];
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a list of channels followed by the user.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderBy The field to order by.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    User.prototype.getFollows = function (page, limit, orderBy, orderDirection) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getFollowedChannels(this, page, limit, orderBy, orderDirection)];
            });
        });
    };
    /**
     * Retrieves the follow data of the user to a given channel.
     *
     * @param channel The channel to retrieve the follow data for.
     */
    User.prototype.getFollowTo = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getFollowedChannel(this, channel)];
            });
        });
    };
    /**
     * Checks whether the user is following the given channel.
     *
     * @param channel The channel to check for the user's follow.
     */
    User.prototype.follows = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getFollowTo(channel)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_2 = _a.sent();
                        throw e_2;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Follows the channel with the authenticated user.
     */
    User.prototype.follow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.followChannel(this)];
                }
            });
        });
    };
    /**
     * Unfollows the channel with the authenticated user.
     */
    User.prototype.unfollow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.unfollowChannel(this)];
                }
            });
        });
    };
    /**
     * Retrieves the emotes the user can use.
     */
    User.prototype.getEmotes = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getUserEmotes(this)];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], User.prototype, "_client", void 0);
    return User;
}());
exports.default = User;
module.exports = exports = User;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = User;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @private */
function createPaginatedResult(response, type, client) {
    var _a, _b, _c;
    return {
        data: (_b = (_a = response.data) === null || _a === void 0 ? void 0 : _a.map(function (data) { return new type(data, client); }), (_b !== null && _b !== void 0 ? _b : [])),
        cursor: (_c = response.pagination) === null || _c === void 0 ? void 0 : _c.cursor
    };
}
exports.createPaginatedResult = createPaginatedResult;
/** @private */
function createPaginatedResultWithTotal(response, type, client) {
    return {
        data: response.data.map(function (data) { return new type(data, client); }),
        cursor: response.pagination.cursor,
        total: response.total
    };
}
exports.createPaginatedResultWithTotal = createPaginatedResultWithTotal;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/** @private */
var CustomError = /** @class */ (function (_super) {
    tslib_1.__extends(CustomError, _super);
    function CustomError() {
        var _newTarget = this.constructor;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var _this = _super.apply(this, tslib_1.__spread(params)) || this;
        // restore prototype chain
        var actualProto = _newTarget.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(_this, actualProto);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            _this.__proto__ = actualProto;
        }
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _newTarget.constructor);
        }
        return _this;
    }
    Object.defineProperty(CustomError.prototype, "name", {
        get: function () {
            return this.constructor.name;
        },
        enumerable: true,
        configurable: true
    });
    return CustomError;
}(Error));
exports.default = CustomError;
module.exports = exports = CustomError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CustomError;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var ChannelPlaceholder_1 = __webpack_require__(38);
/**
 * A Twitch Channel.
 */
var Channel = /** @class */ (function (_super) {
    tslib_1.__extends(Channel, _super);
    /** @private */
    function Channel(data, client) {
        var _this = _super.call(this, data._id, client) || this;
        _this._data = data;
        return _this;
    }
    // override parent's method so we avoid the API/cache request here if someone wrongly assumes this is a placeholder
    /** @private */
    Channel.prototype.getChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this];
            });
        });
    };
    /**
     * Retrieves a list of the teams of the channel.
     */
    Channel.prototype.getTeams = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelTeams(this._data._id)];
            });
        });
    };
    /**
     * Updates the game, title or delay of a channel or toggles the channel feed.
     */
    Channel.prototype.update = function (data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.updateChannel(this, data)];
            });
        });
    };
    Object.defineProperty(Channel.prototype, "name", {
        /**
         * The name of the channel.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "displayName", {
        /**
         * The display name of the channel, with proper capitalization or as Asian script.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "broadcasterLanguage", {
        /**
         * The broadcaster's language.
         */
        get: function () {
            return this._data.broadcaster_language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "broadcasterType", {
        /**
         * The broadcaster's type, i.e. "partner", "affiliate" or "" (empty string, so neither of them).
         */
        get: function () {
            return this._data.broadcaster_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "creationDate", {
        /**
         * The date when the channel was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "description", {
        /**
         * The description of the channel.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "followers", {
        /**
         * The number of people following the channel.
         */
        get: function () {
            return this._data.followers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "game", {
        /**
         * The game that is currently being played on the channel (or was played when it was last online).
         */
        get: function () {
            return this._data.game;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "language", {
        /**
         * The language of the channel.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "logo", {
        /**
         * The URL to the logo of the channel.
         */
        get: function () {
            return this._data.logo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "isMature", {
        /**
         * Whether the channel is flagged as suitable for mature audiences only.
         */
        get: function () {
            return this._data.mature;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "isPartner", {
        /**
         * Whether the channel is partnered.
         */
        get: function () {
            return this._data.partner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "profileBanner", {
        /**
         * The URL to the profile's banner image.
         */
        get: function () {
            return this._data.profile_banner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "profileBannerBackgroundColor", {
        /**
         * The background color of the profile's banner.
         */
        get: function () {
            return this._data.profile_banner_background_color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "status", {
        /**
         * The current status message (i.e. the title) of the channel.
         */
        get: function () {
            return this._data.status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "updateDate", {
        /**
         * The date when the channel was last updated.
         */
        get: function () {
            return new Date(this._data.updated_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "url", {
        /**
         * The URL to the channel.
         */
        get: function () {
            return this._data.url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "videoBanner", {
        /**
         * The URL to the channel's video banner, i.e. the offline image.
         */
        get: function () {
            return this._data.video_banner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "views", {
        /**
         * The total number of views of the channel.
         */
        get: function () {
            return this._data.views;
        },
        enumerable: true,
        configurable: true
    });
    return Channel;
}(ChannelPlaceholder_1.default));
exports.default = Channel;
module.exports = exports = Channel;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Channel;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = false;



/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever you try accessing a subscription-related resource
 * (for example {@ChannelAPI#getChannelSubscriptions})
 * and the given channel does not have a subscription program.
 */
var NoSubscriptionProgramError = /** @class */ (function (_super) {
    tslib_1.__extends(NoSubscriptionProgramError, _super);
    /** @private */
    function NoSubscriptionProgramError(channelId) {
        return _super.call(this, "Channel " + channelId + " does not have a subscription program") || this;
    }
    return NoSubscriptionProgramError;
}(CustomError_1.default));
exports.default = NoSubscriptionProgramError;
module.exports = exports = NoSubscriptionProgramError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = NoSubscriptionProgramError;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://www.ecma-international.org/ecma-262/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return typeof argument === 'string' || typeof argument === 'symbol';
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(35);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @private */
function makePaginationQuery(_a) {
    var _b = _a === void 0 ? {} : _a, after = _b.after, before = _b.before, limit = _b.limit;
    return {
        after: after,
        before: before,
        first: limit
    };
}
exports.makePaginationQuery = makePaginationQuery;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever a HTTP error occurs. Some HTTP errors are handled in the library when they're expected.
 */
var HTTPStatusCodeError = /** @class */ (function (_super) {
    tslib_1.__extends(HTTPStatusCodeError, _super);
    /** @private */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function HTTPStatusCodeError(statusCode, statusText, body) {
        var _this = _super.call(this, "Encountered HTTP status code " + statusCode + ": " + statusText + "\n\nBody:\n" + JSON.stringify(body, null, 2)) || this;
        _this._statusCode = statusCode;
        _this._body = body;
        return _this;
    }
    Object.defineProperty(HTTPStatusCodeError.prototype, "statusCode", {
        get: function () {
            return this._statusCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPStatusCodeError.prototype, "body", {
        get: function () {
            return this._body;
        },
        enumerable: true,
        configurable: true
    });
    return HTTPStatusCodeError;
}(CustomError_1.default));
exports.default = HTTPStatusCodeError;
module.exports = exports = HTTPStatusCodeError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HTTPStatusCodeError;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * These are the kind of errors that should never happen.
 *
 * If you see one thrown, please file a bug in the GitHub issue tracker.
 */
var HellFreezesOverError = /** @class */ (function (_super) {
    tslib_1.__extends(HellFreezesOverError, _super);
    function HellFreezesOverError(message) {
        return _super.call(this, message + " - this should never happen, please file a bug in the GitHub issue tracker") || this;
    }
    return HellFreezesOverError;
}(CustomError_1.default));
exports.default = HellFreezesOverError;
module.exports = exports = HellFreezesOverError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HellFreezesOverError;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var isNode = __webpack_require__(14);
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["CRITICAL"] = 0] = "CRITICAL";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["WARNING"] = 2] = "WARNING";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG1"] = 4] = "DEBUG1";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG2"] = 4] = "DEBUG2";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG3"] = 4] = "DEBUG3";
    LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
    LogLevel[LogLevel["TRACE"] = 7] = "TRACE";
})(LogLevel || (LogLevel = {}));
exports.default = LogLevel;
function resolveLogLevel(level) {
    if (typeof level === 'number') {
        if (Object.prototype.hasOwnProperty.call(LogLevel, level)) {
            return level;
        }
        var eligibleLevels = Object.keys(LogLevel)
            .map(function (k) { return parseInt(k, 10); })
            .filter(function (k) { return !isNaN(k) && k < level; });
        if (!eligibleLevels) {
            return LogLevel.WARNING;
        }
        return Math.max.apply(Math, eligibleLevels);
    }
    var strLevel = level.toUpperCase();
    if (!Object.prototype.hasOwnProperty.call(LogLevel, strLevel)) {
        throw new Error("Unknown log level string: " + strLevel);
    }
    return LogLevel[strLevel];
}
exports.resolveLogLevel = resolveLogLevel;
// Node 8+ defines console.debug as noop, and earlier versions don't define it at all
var debugFunction = isNode ? console.log.bind(console) : console.debug.bind(console);
var __export_LogLevelToConsoleFunction = (_a = {},
    _a[LogLevel.CRITICAL] = console.error.bind(console),
    _a[LogLevel.ERROR] = console.error.bind(console),
    _a[LogLevel.WARNING] = console.warn.bind(console),
    _a[LogLevel.INFO] = console.info.bind(console),
    _a[LogLevel.DEBUG] = debugFunction.bind(console),
    _a[LogLevel.TRACE] = console.trace.bind(console),
    _a);
exports.LogLevelToConsoleFunction = __export_LogLevelToConsoleFunction;
module.exports = exports = LogLevel;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LogLevel;
exports.resolveLogLevel = resolveLogLevel;
exports.LogLevelToConsoleFunction = __export_LogLevelToConsoleFunction;
//# sourceMappingURL=LogLevel.js.map

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var isNode = __webpack_require__(14);
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["CRITICAL"] = 0] = "CRITICAL";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["WARNING"] = 2] = "WARNING";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG1"] = 4] = "DEBUG1";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG2"] = 4] = "DEBUG2";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG3"] = 4] = "DEBUG3";
    LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
    LogLevel[LogLevel["TRACE"] = 7] = "TRACE";
})(LogLevel || (LogLevel = {}));
exports.LogLevel = LogLevel;
function resolveLogLevel(level) {
    if (typeof level === 'number') {
        if (Object.prototype.hasOwnProperty.call(LogLevel, level)) {
            return level;
        }
        var eligibleLevels = Object.keys(LogLevel)
            .map(function (k) { return parseInt(k, 10); })
            .filter(function (k) { return !isNaN(k) && k < level; });
        if (!eligibleLevels) {
            return LogLevel.WARNING;
        }
        return Math.max.apply(Math, eligibleLevels);
    }
    var strLevel = level.toUpperCase();
    if (!Object.prototype.hasOwnProperty.call(LogLevel, strLevel)) {
        throw new Error("Unknown log level string: " + strLevel);
    }
    return LogLevel[strLevel];
}
exports.resolveLogLevel = resolveLogLevel;
// Node 8+ defines console.debug as noop, and earlier versions don't define it at all
var debugFunction = isNode ? console.log.bind(console) : console.debug.bind(console);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.LogLevelToConsoleFunction = (_a = {},
    _a[LogLevel.CRITICAL] = console.error.bind(console),
    _a[LogLevel.ERROR] = console.error.bind(console),
    _a[LogLevel.WARNING] = console.warn.bind(console),
    _a[LogLevel.INFO] = console.info.bind(console),
    _a[LogLevel.DEBUG] = debugFunction.bind(console),
    _a[LogLevel.TRACE] = console.trace.bind(console),
    _a);
//# sourceMappingURL=LogLevel.js.map

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var origSymbol = global.Symbol;
var hasSymbolSham = __webpack_require__(67);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(147)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = __webpack_require__(148);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function requirePromise() {
	if (typeof Promise !== 'function') {
		throw new TypeError('`Promise.allSettled` requires a global `Promise` be available.');
	}
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the data of an OAuth access token returned by Twitch.
 */
var AccessToken = /** @class */ (function () {
    /** @private */
    function AccessToken(_data, obtainmentDate) {
        this._data = _data;
        this._obtainmentDate = obtainmentDate || new Date();
    }
    Object.defineProperty(AccessToken.prototype, "accessToken", {
        /**
         * The access token which is necessary for every request to the Twitch API.
         */
        get: function () {
            return this._data.access_token;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "refreshToken", {
        /**
         * The refresh token which is necessary to refresh the access token once it expires.
         */
        get: function () {
            return this._data.refresh_token;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "expiryDate", {
        /**
         * The time when the access token will expire.
         *
         * May be `null`, in which case the token does not expire.
         * This can only be the case with very old Client IDs.
         */
        get: function () {
            if (!this._data.expires_in) {
                return null;
            }
            return new Date(this._obtainmentDate.getTime() + this._data.expires_in * 1000);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "isExpired", {
        get: function () {
            if (!this._data.expires_in) {
                return false;
            }
            return Date.now() > this._obtainmentDate.getTime() + this._data.expires_in * 1000;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "scope", {
        /**
         * The scope the access token is valid for, i.e. what this token enables you to do.
         */
        get: function () {
            return this._data.scope || [];
        },
        enumerable: true,
        configurable: true
    });
    return AccessToken;
}());
exports.default = AccessToken;
module.exports = exports = AccessToken;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = AccessToken;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function arrayToObject(arr, fn) {
    return Object.assign.apply(Object, tslib_1.__spread([{}], arr.map(fn)));
}
exports.arrayToObject = arrayToObject;
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayToObject = arrayToObject;
//# sourceMappingURL=arrayToObject.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * Information about the ban of a user.
 */
var HelixBan = /** @class */ (function () {
    /** @private */
    function HelixBan(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixBan.prototype, "userId", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the user.
     */
    HelixBan.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixBan.prototype, "userName", {
        /**
         * The name of the user.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBan.prototype, "expiryDate", {
        /**
         * The date when the ban will expire; null for permanent bans.
         */
        get: function () {
            return this._data.expires_at ? new Date(this._data.expires_at) : null;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixBan.prototype, "_client", void 0);
    return HelixBan;
}());
exports.default = HelixBan;
module.exports = exports = HelixBan;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixBan;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * Information about the moderator status of a user.
 */
var HelixModerator = /** @class */ (function () {
    /** @private */
    function HelixModerator(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixModerator.prototype, "userId", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the user.
     */
    HelixModerator.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixModerator.prototype, "userName", {
        /**
         * The name of the user.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixModerator.prototype, "_client", void 0);
    return HelixModerator;
}());
exports.default = HelixModerator;
module.exports = exports = HelixModerator;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixModerator;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A (paid) subscription of a user to a broadcaster.
 */
var HelixSubscription = /** @class */ (function () {
    /** @private */
    function HelixSubscription(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixSubscription.prototype, "broadcasterId", {
        /**
         * The user ID of the broadcaster.
         */
        get: function () {
            return this._data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "broadcasterDisplayName", {
        /**
         * The display name of the broadcaster.
         */
        get: function () {
            return this._data.broadcaster_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the broadcaster.
     */
    HelixSubscription.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this.broadcasterId)];
            });
        });
    };
    Object.defineProperty(HelixSubscription.prototype, "isGift", {
        /**
         * Whether the subscription has been gifted by another user.
         */
        get: function () {
            return this._data.is_gift;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "tier", {
        /**
         * The tier of the subscription.
         */
        get: function () {
            return this._data.tier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "userId", {
        /**
         * The user ID of the subscribed user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "userDisplayName", {
        /**
         * The display name of the subscribed user.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the subscribed user.
     */
    HelixSubscription.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this.userId)];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixSubscription.prototype, "_client", void 0);
    return HelixSubscription;
}());
exports.default = HelixSubscription;
module.exports = exports = HelixSubscription;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixSubscription;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var NoSubscriptionProgramError_1 = __webpack_require__(15);
/**
 * The type of a broadcaster.
 */
var HelixBroadcasterType;
(function (HelixBroadcasterType) {
    /**
     * A Twitch Partner.
     */
    HelixBroadcasterType["Partner"] = "partner";
    /**
     * A Twitch Affiliate.
     */
    HelixBroadcasterType["Affiliate"] = "affiliate";
    /**
     * A user that's neither a partner nor an affiliate.
     */
    HelixBroadcasterType["None"] = "";
})(HelixBroadcasterType || (HelixBroadcasterType = {}));
exports.HelixBroadcasterType = HelixBroadcasterType;
/**
 * The type of a user.
 */
var HelixUserType;
(function (HelixUserType) {
    /**
     * A Twitch staff member.
     */
    HelixUserType["Staff"] = "staff";
    /**
     * A Twitch administrator.
     */
    HelixUserType["Admin"] = "admin";
    /**
     * A global moderator.
     */
    HelixUserType["GlobalMod"] = "global_mod";
    /**
     * A user with no special permissions across Twitch.
     */
    HelixUserType["None"] = "";
})(HelixUserType || (HelixUserType = {}));
exports.HelixUserType = HelixUserType;
/**
 * A Twitch user.
 */
var HelixUser = /** @class */ (function () {
    /** @private */
    function HelixUser(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixUser.prototype, "cacheKey", {
        /** @private */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "id", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "name", {
        /**
         * The user name of the user.
         */
        get: function () {
            return this._data.login;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "displayName", {
        /**
         * The display name of the user.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "description", {
        /**
         * The description of the user.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "type", {
        /**
         * The type of the user.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "broadcasterType", {
        /**
         * The type of the user.
         */
        get: function () {
            return this._data.broadcaster_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "profilePictureUrl", {
        /**
         * The URL to the profile picture of the user.
         */
        get: function () {
            return this._data.profile_image_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "offlinePlaceholderUrl", {
        /**
         * The URL to the offline video placeholder of the user.
         */
        get: function () {
            return this._data.offline_image_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "views", {
        /**
         * The total number of views of the user's channel.
         */
        get: function () {
            return this._data.view_count;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the channel's stream data.
     */
    HelixUser.prototype.getStream = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.streams.getStreamByUserId(this)];
            });
        });
    };
    /**
     * Retrieves a list of broadcasters the user follows.
     */
    HelixUser.prototype.getFollows = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getFollows({ user: this })];
            });
        });
    };
    /**
     * Retrieves the follow data of the user to the given broadcaster.
     *
     * @param broadcaster The broadcaster to check the follow to.
     */
    HelixUser.prototype.getFollowTo = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var params, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            user: this.id,
                            followedUser: broadcaster
                        };
                        return [4 /*yield*/, this._client.helix.users.getFollows(params)];
                    case 1:
                        result = (_a.sent()).data;
                        return [2 /*return*/, result.length ? result[0] : null];
                }
            });
        });
    };
    /**
     * Checks whether the user is following the given broadcaster.
     *
     * @param broadcaster The broadcaster to check the user's follow to.
     */
    HelixUser.prototype.follows = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getFollowTo(broadcaster)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                }
            });
        });
    };
    /**
     * Follows the broadcaster.
     */
    HelixUser.prototype.follow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.followChannel(this)];
                }
            });
        });
    };
    /**
     * Unfollows the broadcaster.
     */
    HelixUser.prototype.unfollow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.unfollowChannel(this)];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for the user to the given broadcaster, or `null` if the user is not subscribed.
     *
     * @param broadcaster The broadcaster you want to get the subscription data for.
     */
    HelixUser.prototype.getSubscriptionTo = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.subscriptions.getSubscriptionForUser(broadcaster, this)];
            });
        });
    };
    /**
     * Checks whether the user is subscribed to the given broadcaster.
     *
     * @param broadcaster The broadcaster you want to check the subscription for.
     */
    HelixUser.prototype.isSubscribedTo = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getSubscriptionTo(broadcaster)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof NoSubscriptionProgramError_1.default) {
                            return [2 /*return*/, false];
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixUser.prototype, "_client", void 0);
    return HelixUser;
}());
exports.default = HelixUser;
module.exports = exports = HelixUser;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixBroadcasterType = HelixBroadcasterType;
exports.HelixUserType = HelixUserType;
exports.default = HelixUser;


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(35);

var GetIntrinsic = __webpack_require__(2);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

module.exports = function callBind() {
	return $reflectApply(bind, $call, arguments);
};

module.exports.apply = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(146);

module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');
var $SyntaxError = GetIntrinsic('%SyntaxError%');

var has = __webpack_require__(17);

var predicates = {
	// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
	'Property Descriptor': function isPropertyDescriptor(Type, Desc) {
		if (Type(Desc) !== 'Object') {
			return false;
		}
		var allowed = {
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Get]]': true,
			'[[Set]]': true,
			'[[Value]]': true,
			'[[Writable]]': true
		};

		for (var key in Desc) { // eslint-disable-line
			if (has(Desc, key) && !allowed[key]) {
				return false;
			}
		}

		var isData = has(Desc, '[[Value]]');
		var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');
		if (isData && IsAccessor) {
			throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
		}
		return true;
	}
};

module.exports = function assertRecord(Type, recordType, argumentName, value) {
	var predicate = predicates[recordType];
	if (typeof predicate !== 'function') {
		throw new $SyntaxError('unknown record type: ' + recordType);
	}
	if (!predicate(Type, value)) {
		throw new $TypeError(argumentName + ' must be a ' + recordType);
	}
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var HellFreezesOverError_1 = __webpack_require__(20);
/**
 * The type of background a cheermote is supposed to appear on.
 *
 * We will supply a fitting graphic that does not show any artifacts
 * on the given type of background.
 */
var CheermoteBackground;
(function (CheermoteBackground) {
    /**
     * A dark background.
     *
     * Cheermotes might show artifacts on bright backgrounds.
     */
    CheermoteBackground["dark"] = "dark";
    /**
     * A bright background.
     *
     * Cheermotes might show artifacts on dark backgrounds.
     */
    CheermoteBackground["light"] = "light";
})(CheermoteBackground || (CheermoteBackground = {}));
exports.CheermoteBackground = CheermoteBackground;
/**
 * The state of a cheermote, i.e. whether it's animated or not.
 */
var CheermoteState;
(function (CheermoteState) {
    /**
     * The cheermote should be animated.
     */
    CheermoteState["animated"] = "animated";
    /**
     * The cheermote should not be animated.
     */
    CheermoteState["static"] = "static";
})(CheermoteState || (CheermoteState = {}));
exports.CheermoteState = CheermoteState;
/**
 * The scale of the cheermote, which usually relates to the pixel density of the device in use.
 */
var CheermoteScale;
(function (CheermoteScale) {
    /**
     * The cheermote should not be scaled.
     */
    CheermoteScale["x1"] = "1";
    /**
     * The cheermote should be scaled 1.5x.
     */
    CheermoteScale["x1_5"] = "1.5";
    /**
     * The cheermote should be scaled 2x.
     */
    CheermoteScale["x2"] = "2";
    /**
     * The cheermote should be scaled 3x.
     */
    CheermoteScale["x3"] = "3";
    /**
     * The cheermote should be scaled 4x.
     */
    CheermoteScale["x4"] = "4";
})(CheermoteScale || (CheermoteScale = {}));
exports.CheermoteScale = CheermoteScale;
/**
 * A list of cheermotes you can use globally or in a specific channel, depending on how you fetched the list.
 */
var CheermoteList = /** @class */ (function () {
    /** @private */
    function CheermoteList(data, client) {
        this._client = client;
        this._data = shared_utils_1.indexBy(data, function (action) { return action.prefix.toLowerCase(); });
    }
    /**
     * Gets the URL and color needed to properly represent a cheer of the given amount of bits with the given prefix.
     *
     * @param name The name/prefix of the cheermote.
     * @param bits The amount of bits cheered.
     * @param format The format of the cheermote you want to request.
     */
    CheermoteList.prototype.getCheermoteDisplayInfo = function (name, bits, format) {
        if (format === void 0) { format = {}; }
        name = name.toLowerCase();
        var cheermoteDefaults = this._client.cheermoteDefaults;
        var fullOptions = tslib_1.__assign({ background: cheermoteDefaults.defaultBackground, state: cheermoteDefaults.defaultState, scale: cheermoteDefaults.defaultScale }, format);
        var tiers = this._data[name].tiers;
        var correctTier = tiers.sort(function (a, b) { return b.min_bits - a.min_bits; }).find(function (tier) { return tier.min_bits <= bits; });
        if (!correctTier) {
            throw new HellFreezesOverError_1.default("Cheermote \"" + name + "\" does not have an applicable tier for " + bits + " bits");
        }
        return {
            url: correctTier.images[fullOptions.background][fullOptions.state][fullOptions.scale],
            color: correctTier.color
        };
    };
    /**
     * Gets all possible cheermote names.
     */
    CheermoteList.prototype.getPossibleNames = function () {
        return Object.keys(this._data);
    };
    /**
     * Parses all the cheermotes out of a message.
     *
     * @param message The message.
     */
    CheermoteList.prototype.parseMessage = function (message) {
        var result = [];
        var names = this.getPossibleNames();
        // TODO fix this regex so it works in firefox, which does not support lookbehind
        var re = new RegExp('(?<=^|\\s)([a-z0-9]+?)(\\d+)(?=\\s|$)', 'gi');
        var match;
        while ((match = re.exec(message))) {
            var name_1 = match[1].toLowerCase();
            if (names.includes(name_1)) {
                var amount = Number(match[2]);
                result.push({
                    name: name_1,
                    amount: amount,
                    position: shared_utils_1.utf8Length(message.substr(0, match.index)),
                    length: match[0].length,
                    displayInfo: this.getCheermoteDisplayInfo(name_1, amount)
                });
            }
        }
        return result;
    };
    /**
     * Transforms all the cheermotes in a message and returns an array of all the message parts.
     *
     * @param message The message.
     * @param transformer A function that transforms a message part into an arbitrary structure.
     */
    CheermoteList.prototype.transformCheerMessage = function (message, transformer) {
        var e_1, _a;
        var result = [];
        var currentPosition = 0;
        try {
            for (var _b = tslib_1.__values(this.parseMessage(message)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var foundCheermote = _c.value;
                if (currentPosition < foundCheermote.position) {
                    result.push(message.substring(currentPosition, foundCheermote.position));
                }
                result.push(transformer(foundCheermote));
                currentPosition = foundCheermote.position + foundCheermote.length;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (currentPosition < message.length) {
            result.push(message.substr(currentPosition));
        }
        return result;
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], CheermoteList.prototype, "_client", void 0);
    return CheermoteList;
}());
exports.default = CheermoteList;
module.exports = exports = CheermoteList;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheermoteBackground = CheermoteBackground;
exports.CheermoteState = CheermoteState;
exports.CheermoteScale = CheermoteScale;
exports.default = CheermoteList;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var NoSubscriptionProgramError_1 = __webpack_require__(15);
/**
 * A placeholder for a channel.
 *
 * This is used for example when you only have retrieved user data, but not channel data.
 * This can do anything you can do with only a channel ID, as it's equivalent to the user ID.
 */
var ChannelPlaceholder = /** @class */ (function () {
    /** @private */
    function ChannelPlaceholder(id, client) {
        this._data = { _id: id };
        this._client = client;
    }
    Object.defineProperty(ChannelPlaceholder.prototype, "cacheKey", {
        /** @private */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelPlaceholder.prototype, "id", {
        /**
         * The ID of the channel.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the list of cheermotes you can use in the channel.
     */
    ChannelPlaceholder.prototype.getCheermotes = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.bits.getCheermotes(this)];
            });
        });
    };
    /**
     * Retrieves the channel data.
     */
    ChannelPlaceholder.prototype.getChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannel(this)];
            });
        });
    };
    /**
     * Retrieves the channel's stream data.
     */
    ChannelPlaceholder.prototype.getStream = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.streams.getStreamByChannel(this)];
            });
        });
    };
    /**
     * Retrieves the channel's followers.
     */
    ChannelPlaceholder.prototype.getFollowers = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelFollowers(this)];
            });
        });
    };
    /**
     * Retrieves the channel's subscribers.
     */
    ChannelPlaceholder.prototype.getSubscriptions = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelSubscriptions(this)];
            });
        });
    };
    /**
     * Retrieves the subscription data for the given user to the channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the channel. If you only have access to the user,
     * use {@User#getSubscriptionTo} instead.
     *
     * @param user The user you want to get the subscription data for.
     */
    ChannelPlaceholder.prototype.getSubscriptionBy = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelSubscriptionByUser(this, user)];
            });
        });
    };
    /**
     * Checks whether the given user is subscribed to the channel.
     *
     * @param user The user you want to check the subscription for.
     */
    ChannelPlaceholder.prototype.hasSubscriber = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getSubscriptionBy(user)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof NoSubscriptionProgramError_1.default) {
                            return [2 /*return*/, false];
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChannelPlaceholder.prototype, "_client", void 0);
    return ChannelPlaceholder;
}());
exports.default = ChannelPlaceholder;
module.exports = exports = ChannelPlaceholder;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChannelPlaceholder;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A subscription to a Twitch channel.
 */
var Subscription = /** @class */ (function () {
    /** @private */
    function Subscription(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(Subscription.prototype, "id", {
        /**
         * The ID of the subscription.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Subscription.prototype, "subPlan", {
        /**
         * The identifier of the subscription plan.
         */
        get: function () {
            return this._data.sub_plan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Subscription.prototype, "subPlanName", {
        /**
         * The name of the subscription plan.
         */
        get: function () {
            return this._data.sub_plan_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Subscription.prototype, "startDate", {
        /**
         * The date when the subscription was started.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], Subscription.prototype, "_client", void 0);
    return Subscription;
}());
exports.default = Subscription;
module.exports = exports = Subscription;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Subscription;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A Twitch team.
 */
var Team = /** @class */ (function () {
    /** @private */
    function Team(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(Team.prototype, "id", {
        /**
         * The ID of the team.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "background", {
        /**
         * The background url of the team.
         */
        get: function () {
            return this._data.background;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "banner", {
        /**
         * The banner url of the team.
         */
        get: function () {
            return this._data.banner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "creationDate", {
        /**
         * The date when the team was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "updateDate", {
        /**
         * The last date when the team changed anything.
         */
        get: function () {
            return new Date(this._data.updated_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "name", {
        /**
         * The name of the team.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "info", {
        /**
         * The info of the team.
         */
        get: function () {
            return this._data.info;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "displayName", {
        /**
         * The display name of the team.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "logoUrl", {
        /**
         * The URL to the profile picture of the team.
         */
        get: function () {
            return this._data.logo;
        },
        enumerable: true,
        configurable: true
    });
    Team.prototype.getUsers = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var team;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.teams.getTeamByName(this.name)];
                    case 1:
                        team = _a.sent();
                        return [2 /*return*/, team.getUsers()];
                }
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], Team.prototype, "_client", void 0);
    return Team;
}());
exports.default = Team;
module.exports = exports = Team;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Team;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var Channel_1 = __webpack_require__(13);
/**
 * The type of a stream.
 */
var StreamType;
(function (StreamType) {
    /**
     * A live stream.
     */
    StreamType["Live"] = "live";
    /**
     * An upload to the channel (VoD) that is streamed live for the first time.
     */
    StreamType["Premiere"] = "premiere";
    /**
     * A rerun of a past live stream.
     */
    StreamType["ReRun"] = "rerun";
    /**
     * All types of streams. Used for filtering.
     */
    StreamType["All"] = "all";
})(StreamType || (StreamType = {}));
exports.StreamType = StreamType;
/**
 * A Twitch stream.
 */
var Stream = /** @class */ (function () {
    /** @private */
    function Stream(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(Stream.prototype, "id", {
        /**
         * The ID of the stream.
         */
        get: function () {
            return this._data._id.toString();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "game", {
        /**
         * The game played on the stream.
         */
        get: function () {
            return this._data.game;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "viewers", {
        /**
         * The current number of concurrent viewers.
         */
        get: function () {
            return this._data.viewers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "videoHeight", {
        /**
         * The height of the stream video.
         */
        get: function () {
            return this._data.video_height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "averageFPS", {
        /**
         * The average FPS (frames per second) that are shown on the stream.
         */
        get: function () {
            return this._data.average_fps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "delay", {
        /**
         * The delay of the stream, in seconds.
         */
        get: function () {
            return this._data.delay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "startDate", {
        /**
         * The time when the stream started.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "isPlaylist", {
        /**
         * Whether the stream is running a playlist.
         */
        get: function () {
            return this._data.is_playlist;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "type", {
        /**
         * The type of the stream.
         */
        get: function () {
            return this._data.stream_type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the URL of a preview image for the stream
     *
     * @param size The size of the image.
     */
    Stream.prototype.getPreviewUrl = function (size) {
        return this._data.preview[size];
    };
    Object.defineProperty(Stream.prototype, "channel", {
        /**
         * The channel where the stream is shown.
         */
        get: function () {
            return new Channel_1.default(this._data.channel, this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], Stream.prototype, "_client", void 0);
    return Stream;
}());
exports.default = Stream;
module.exports = exports = Stream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamType = StreamType;
exports.default = Stream;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable filenames/match-exported */
var TwitchClient_1 = __webpack_require__(4);
exports.TwitchAPICallType = TwitchClient_1.TwitchAPICallType;
exports.default = TwitchClient_1.default;
var ConfigError_1 = __webpack_require__(100);
exports.ConfigError = ConfigError_1.default;
var HellFreezesOverError_1 = __webpack_require__(20);
exports.HellFreezesOverError = HellFreezesOverError_1.default;
var HTTPStatusCodeError_1 = __webpack_require__(19);
exports.HTTPStatusCodeError = HTTPStatusCodeError_1.default;
var InvalidTokenError_1 = __webpack_require__(101);
exports.InvalidTokenError = InvalidTokenError_1.default;
var InvalidTokenTypeError_1 = __webpack_require__(209);
exports.InvalidTokenTypeError = InvalidTokenTypeError_1.default;
var NoSubscriptionProgramError_1 = __webpack_require__(15);
exports.NoSubscriptionProgramError = NoSubscriptionProgramError_1.default;
var StreamNotLiveError_1 = __webpack_require__(57);
exports.StreamNotLiveError = StreamNotLiveError_1.default;
var StaticAuthProvider_1 = __webpack_require__(99);
exports.StaticAuthProvider = StaticAuthProvider_1.default;
var RefreshableAuthProvider_1 = __webpack_require__(98);
exports.RefreshableAuthProvider = RefreshableAuthProvider_1.default;
var AccessToken_1 = __webpack_require__(27);
exports.AccessToken = AccessToken_1.default;
var TokenInfo_1 = __webpack_require__(96);
exports.TokenInfo = TokenInfo_1.default;
var Subscription_1 = __webpack_require__(39);
exports.Subscription = Subscription_1.default;
var CheermoteList_1 = __webpack_require__(37);
exports.CheermoteList = CheermoteList_1.default;
exports.CheermoteBackground = CheermoteList_1.CheermoteBackground;
exports.CheermoteScale = CheermoteList_1.CheermoteScale;
exports.CheermoteState = CheermoteList_1.CheermoteState;
var Channel_1 = __webpack_require__(13);
exports.Channel = Channel_1.default;
var ChannelFollow_1 = __webpack_require__(88);
exports.ChannelFollow = ChannelFollow_1.default;
var ChannelPlaceholder_1 = __webpack_require__(38);
exports.ChannelPlaceholder = ChannelPlaceholder_1.default;
var ChannelSubscription_1 = __webpack_require__(89);
exports.ChannelSubscription = ChannelSubscription_1.default;
var EmoteSetList_1 = __webpack_require__(91);
exports.EmoteSetList = EmoteSetList_1.default;
var PrivilegedChannel_1 = __webpack_require__(90);
exports.PrivilegedChannel = PrivilegedChannel_1.default;
var Stream_1 = __webpack_require__(41);
exports.Stream = Stream_1.default;
exports.StreamType = Stream_1.StreamType;
var ChattersList_1 = __webpack_require__(97);
exports.ChattersList = ChattersList_1.default;
var PrivilegedUser_1 = __webpack_require__(92);
exports.PrivilegedUser = PrivilegedUser_1.default;
var User_1 = __webpack_require__(10);
exports.User = User_1.default;
var UserBlock_1 = __webpack_require__(93);
exports.UserBlock = UserBlock_1.default;
var UserFollow_1 = __webpack_require__(94);
exports.UserFollow = UserFollow_1.default;
var UserSubscription_1 = __webpack_require__(95);
exports.UserSubscription = UserSubscription_1.default;
var HelixPaginatedRequest_1 = __webpack_require__(9);
exports.HelixPaginatedRequest = HelixPaginatedRequest_1.default;
var HelixBitsLeaderboard_1 = __webpack_require__(50);
exports.HelixBitsLeaderboard = HelixBitsLeaderboard_1.default;
var HelixBitsLeaderboardEntry_1 = __webpack_require__(51);
exports.HelixBitsLeaderboardEntry = HelixBitsLeaderboardEntry_1.default;
var HelixClip_1 = __webpack_require__(52);
exports.HelixClip = HelixClip_1.default;
var HelixExtensionTransaction_1 = __webpack_require__(53);
exports.HelixExtensionTransaction = HelixExtensionTransaction_1.default;
var HelixGame_1 = __webpack_require__(54);
exports.HelixGame = HelixGame_1.default;
var HelixBan_1 = __webpack_require__(29);
exports.HelixBan = HelixBan_1.default;
var HelixBanEvent_1 = __webpack_require__(55);
exports.HelixBanEvent = HelixBanEvent_1.default;
var HelixModerator_1 = __webpack_require__(30);
exports.HelixModerator = HelixModerator_1.default;
var HelixModeratorEvent_1 = __webpack_require__(56);
exports.HelixModeratorEvent = HelixModeratorEvent_1.default;
var HelixStream_1 = __webpack_require__(58);
exports.HelixStream = HelixStream_1.default;
exports.HelixStreamType = HelixStream_1.HelixStreamType;
var HelixFollow_1 = __webpack_require__(62);
exports.HelixFollow = HelixFollow_1.default;
var HelixPrivilegedUser_1 = __webpack_require__(63);
exports.HelixPrivilegedUser = HelixPrivilegedUser_1.default;
var HelixUser_1 = __webpack_require__(32);
exports.HelixUser = HelixUser_1.default;
exports.HelixBroadcasterType = HelixUser_1.HelixBroadcasterType;
exports.HelixUserType = HelixUser_1.HelixUserType;
var HelixVideo_1 = __webpack_require__(64);
exports.HelixVideo = HelixVideo_1.default;
var HelixSubscription_1 = __webpack_require__(31);
exports.HelixSubscription = HelixSubscription_1.default;
var HelixSubscriptionEvent_1 = __webpack_require__(60);
exports.HelixSubscriptionEvent = HelixSubscriptionEvent_1.default;
var ChatBadgeList_1 = __webpack_require__(47);
exports.ChatBadgeList = ChatBadgeList_1.default;
var ChatBadgeSet_1 = __webpack_require__(48);
exports.ChatBadgeSet = ChatBadgeSet_1.default;
var ChatBadgeVersion_1 = __webpack_require__(49);
exports.ChatBadgeVersion = ChatBadgeVersion_1.default;
var UserTools_1 = __webpack_require__(6);
exports.extractUserId = UserTools_1.extractUserId;
exports.extractUserName = UserTools_1.extractUserName;
module.exports = exports = TwitchClient_1.default;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TwitchAPICallType = TwitchClient_1.TwitchAPICallType;
exports.default = TwitchClient_1.default;
exports.ConfigError = ConfigError_1.default;
exports.HellFreezesOverError = HellFreezesOverError_1.default;
exports.HTTPStatusCodeError = HTTPStatusCodeError_1.default;
exports.InvalidTokenError = InvalidTokenError_1.default;
exports.InvalidTokenTypeError = InvalidTokenTypeError_1.default;
exports.NoSubscriptionProgramError = NoSubscriptionProgramError_1.default;
exports.StreamNotLiveError = StreamNotLiveError_1.default;
exports.StaticAuthProvider = StaticAuthProvider_1.default;
exports.RefreshableAuthProvider = RefreshableAuthProvider_1.default;
exports.AccessToken = AccessToken_1.default;
exports.TokenInfo = TokenInfo_1.default;
exports.Subscription = Subscription_1.default;
exports.CheermoteList = CheermoteList_1.default;
exports.CheermoteBackground = CheermoteList_1.CheermoteBackground;
exports.CheermoteScale = CheermoteList_1.CheermoteScale;
exports.CheermoteState = CheermoteList_1.CheermoteState;
exports.Channel = Channel_1.default;
exports.ChannelFollow = ChannelFollow_1.default;
exports.ChannelPlaceholder = ChannelPlaceholder_1.default;
exports.ChannelSubscription = ChannelSubscription_1.default;
exports.EmoteSetList = EmoteSetList_1.default;
exports.PrivilegedChannel = PrivilegedChannel_1.default;
exports.Stream = Stream_1.default;
exports.StreamType = Stream_1.StreamType;
exports.ChattersList = ChattersList_1.default;
exports.PrivilegedUser = PrivilegedUser_1.default;
exports.User = User_1.default;
exports.UserBlock = UserBlock_1.default;
exports.UserFollow = UserFollow_1.default;
exports.UserSubscription = UserSubscription_1.default;
exports.HelixPaginatedRequest = HelixPaginatedRequest_1.default;
exports.HelixBitsLeaderboard = HelixBitsLeaderboard_1.default;
exports.HelixBitsLeaderboardEntry = HelixBitsLeaderboardEntry_1.default;
exports.HelixClip = HelixClip_1.default;
exports.HelixExtensionTransaction = HelixExtensionTransaction_1.default;
exports.HelixGame = HelixGame_1.default;
exports.HelixBan = HelixBan_1.default;
exports.HelixBanEvent = HelixBanEvent_1.default;
exports.HelixModerator = HelixModerator_1.default;
exports.HelixModeratorEvent = HelixModeratorEvent_1.default;
exports.HelixStream = HelixStream_1.default;
exports.HelixStreamType = HelixStream_1.HelixStreamType;
exports.HelixFollow = HelixFollow_1.default;
exports.HelixPrivilegedUser = HelixPrivilegedUser_1.default;
exports.HelixUser = HelixUser_1.default;
exports.HelixBroadcasterType = HelixUser_1.HelixBroadcasterType;
exports.HelixUserType = HelixUser_1.HelixUserType;
exports.HelixVideo = HelixVideo_1.default;
exports.HelixSubscription = HelixSubscription_1.default;
exports.HelixSubscriptionEvent = HelixSubscriptionEvent_1.default;
exports.ChatBadgeList = ChatBadgeList_1.default;
exports.ChatBadgeSet = ChatBadgeSet_1.default;
exports.ChatBadgeVersion = ChatBadgeVersion_1.default;
exports.extractUserId = UserTools_1.extractUserId;
exports.extractUserName = UserTools_1.extractUserName;


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LogLevel_1 = __webpack_require__(21);
var isNode = __webpack_require__(14);
var BaseLogger = /** @class */ (function () {
    function BaseLogger(_a) {
        var name = _a.name, _b = _a.minLevel, minLevel = _b === void 0 ? LogLevel_1.default.WARNING : _b, _c = _a.emoji, emoji = _c === void 0 ? false : _c, _d = _a.colors, colors = _d === void 0 ? true : _d, _e = _a.timestamps, timestamps = _e === void 0 ? isNode : _e;
        this._name = name;
        this._minLevel = LogLevel_1.resolveLogLevel(minLevel);
        this._emoji = emoji;
        this._colors = colors;
        this._timestamps = timestamps;
    }
    // region convenience methods
    BaseLogger.prototype.crit = function (message) {
        this.log(LogLevel_1.default.CRITICAL, message);
    };
    BaseLogger.prototype.critical = function (message) {
        this.log(LogLevel_1.default.CRITICAL, message);
    };
    BaseLogger.prototype.err = function (message) {
        this.log(LogLevel_1.default.ERROR, message);
    };
    BaseLogger.prototype.error = function (message) {
        this.log(LogLevel_1.default.ERROR, message);
    };
    BaseLogger.prototype.warn = function (message) {
        this.log(LogLevel_1.default.WARNING, message);
    };
    BaseLogger.prototype.warning = function (message) {
        this.log(LogLevel_1.default.WARNING, message);
    };
    BaseLogger.prototype.info = function (message) {
        this.log(LogLevel_1.default.INFO, message);
    };
    BaseLogger.prototype.debug = function (message) {
        this.log(LogLevel_1.default.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug1 = function (message) {
        this.log(LogLevel_1.default.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug2 = function (message) {
        this.log(LogLevel_1.default.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug3 = function (message) {
        this.log(LogLevel_1.default.DEBUG, message);
    };
    BaseLogger.prototype.trace = function (message) {
        this.log(LogLevel_1.default.TRACE, message);
    };
    return BaseLogger;
}());
exports.default = BaseLogger;
module.exports = exports = BaseLogger;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseLogger;
//# sourceMappingURL=BaseLogger.js.map

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var util = __webpack_require__(26);

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = util.assign(
    {
        'default': Format.RFC3986,
        formatters: {
            RFC1738: function (value) {
                return replace.call(value, percentTwenties, '+');
            },
            RFC3986: function (value) {
                return String(value);
            }
        }
    },
    Format
);


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function pick(obj, keys) {
    return Object.assign.apply(Object, tslib_1.__spread([{}], Object.entries(obj)
        .filter(function (_a) {
        var _b = tslib_1.__read(_a, 1), key = _b[0];
        return keys.includes(key);
    })
        .map(function (_a) {
        var _b;
        var _c = tslib_1.__read(_a, 2), key = _c[0], value = _c[1];
        return (_b = {}, _b[key] = value, _b);
    })));
}
exports.pick = pick;
Object.defineProperty(exports, "__esModule", { value: true });
exports.pick = pick;
//# sourceMappingURL=pick.js.map

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var ChatBadgeSet_1 = __webpack_require__(48);
/**
 * A list of badge sets.
 */
var ChatBadgeList = /** @class */ (function () {
    /** @private */
    function ChatBadgeList(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatBadgeList.prototype, "badgeSetNames", {
        /**
         * Names of all badge sets in the list.
         */
        get: function () {
            return Object.keys(this._data);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a specific badge set by name.
     *
     * @param name The name of the badge set.
     */
    ChatBadgeList.prototype.getBadgeSet = function (name) {
        return new ChatBadgeSet_1.default(this._data[name], this._client);
    };
    /** @private */
    ChatBadgeList.prototype._merge = function (additionalData) {
        if (additionalData instanceof ChatBadgeList) {
            additionalData = additionalData._data;
        }
        return new ChatBadgeList(tslib_1.__assign(tslib_1.__assign({}, this._data), additionalData), this._client);
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatBadgeList.prototype, "_client", void 0);
    return ChatBadgeList;
}());
exports.default = ChatBadgeList;
module.exports = exports = ChatBadgeList;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatBadgeList;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var ChatBadgeVersion_1 = __webpack_require__(49);
/**
 * A set of badges.
 */
var ChatBadgeSet = /** @class */ (function () {
    /** @private */
    function ChatBadgeSet(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatBadgeSet.prototype, "versionNames", {
        /**
         * Names of all versions of the badge set.
         */
        get: function () {
            return Object.keys(this._data.versions);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a specific version of a badge by name.
     *
     * @param name The name of the version.
     */
    ChatBadgeSet.prototype.getVersion = function (name) {
        return new ChatBadgeVersion_1.default(this._data.versions[name], this._client);
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatBadgeSet.prototype, "_client", void 0);
    return ChatBadgeSet;
}());
exports.default = ChatBadgeSet;
module.exports = exports = ChatBadgeSet;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatBadgeSet;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A version of a badge.
 */
var ChatBadgeVersion = /** @class */ (function () {
    /** @private */
    function ChatBadgeVersion(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatBadgeVersion.prototype, "clickAction", {
        /**
         * The action to execute when the badge is clicked.
         */
        get: function () {
            return this._data.click_action;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatBadgeVersion.prototype, "clickUrl", {
        /**
         * The URL to visit when the badge is clicked.
         *
         * Only applies if clickAction === 'visit_url'.
         */
        get: function () {
            return this._data.click_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatBadgeVersion.prototype, "description", {
        /**
         * The description of the badge.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets an image URL for the given scale.
     *
     * @param scale The scale of the badge image.
     */
    ChatBadgeVersion.prototype.getImageUrl = function (scale) {
        return this._data["image_url_" + scale + "x"];
    };
    Object.defineProperty(ChatBadgeVersion.prototype, "title", {
        /**
         * The title of the badge.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatBadgeVersion.prototype, "_client", void 0);
    return ChatBadgeVersion;
}());
exports.default = ChatBadgeVersion;
module.exports = exports = ChatBadgeVersion;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatBadgeVersion;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var shared_utils_1 = __webpack_require__(1);
var HelixBitsLeaderboardEntry_1 = __webpack_require__(51);
/**
 * A leaderboard where the users who used the most bits to a broadcaster are listed.
 */
var HelixBitsLeaderboard = /** @class */ (function () {
    /** @private */
    function HelixBitsLeaderboard(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixBitsLeaderboard.prototype, "entries", {
        /**
         * The entries of the leaderboard.
         */
        get: function () {
            var _this = this;
            return this._data.data.map(function (entry) { return new HelixBitsLeaderboardEntry_1.default(entry, _this._client); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboard.prototype, "totalCount", {
        /**
         * The total amount of people on the requested leaderboard.
         */
        get: function () {
            return this._data.total;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixBitsLeaderboard.prototype, "_client", void 0);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixBitsLeaderboard.prototype, "entries", null);
    HelixBitsLeaderboard = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], HelixBitsLeaderboard);
    return HelixBitsLeaderboard;
}());
exports.default = HelixBitsLeaderboard;
module.exports = exports = HelixBitsLeaderboard;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixBitsLeaderboard;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A Bits leaderboard entry.
 */
var HelixBitsLeaderboardEntry = /** @class */ (function () {
    /** @private */
    function HelixBitsLeaderboardEntry(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "userId", {
        /**
         * The ID of the user on the leaderboard.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "userDisplayName", {
        /**
         * The display name of the user on the leaderboard.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "rank", {
        /**
         * The position of the user on the leaderboard.
         */
        get: function () {
            return this._data.rank;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "amount", {
        /**
         * The amount of bits used in the given period of time.
         */
        get: function () {
            return this._data.score;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the user that's on this place on the leaderboard.
     */
    HelixBitsLeaderboardEntry.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixBitsLeaderboardEntry.prototype, "_client", void 0);
    return HelixBitsLeaderboardEntry;
}());
exports.default = HelixBitsLeaderboardEntry;
module.exports = exports = HelixBitsLeaderboardEntry;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixBitsLeaderboardEntry;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var HelixClip = /** @class */ (function () {
    /** @private */
    function HelixClip(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixClip.prototype, "id", {
        /**
         * The clip ID.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "url", {
        /**
         * The URL of the clip.
         */
        get: function () {
            return this._data.url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "embedUrl", {
        /**
         * The embed URL of the clip.
         */
        get: function () {
            return this._data.embed_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "broadcasterId", {
        /**
         * The user ID of the broadcaster of the stream where the clip was created.
         */
        get: function () {
            return this._data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "broadcasterDisplayName", {
        /**
         * The display name of the broadcaster of the stream where the clip was created.
         */
        get: function () {
            return this._data.broadcaster_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the broadcaster of the stream where the clip was created.
     */
    HelixClip.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "creatorId", {
        /**
         * The user ID of the creator of the clip.
         */
        get: function () {
            return this._data.creator_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "creatorDisplayName", {
        /**
         * The display name of the creator of the clip.
         */
        get: function () {
            return this._data.creator_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the creator of the clip.
     */
    HelixClip.prototype.getCreator = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.creator_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "videoId", {
        /**
         * The ID of the video the clip is taken from.
         */
        get: function () {
            return this._data.video_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the video the clip is taken from.
     */
    HelixClip.prototype.getVideo = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.videos.getVideoById(this._data.video_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "gameId", {
        /**
         * The ID of the game that was being played when the clip was created.
         */
        get: function () {
            return this._data.game_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the game that was being played when the clip was created.
     */
    HelixClip.prototype.getGame = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.games.getGameById(this._data.game_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "language", {
        /**
         * The language of the stream where the clip was created.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "title", {
        /**
         * The title of the clip.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "views", {
        /**
         * The number of views of the clip.
         */
        get: function () {
            return this._data.view_count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "creationDate", {
        /**
         * The date when the clip was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "thumbnailUrl", {
        /**
         * The URL of the thumbnail of the clip.
         */
        get: function () {
            return this._data.thumbnail_url;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixClip.prototype, "_client", void 0);
    return HelixClip;
}());
exports.default = HelixClip;
module.exports = exports = HelixClip;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixClip;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A bits transaction made inside an extension.
 */
var HelixExtensionTransaction = /** @class */ (function () {
    /** @private */
    function HelixExtensionTransaction(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixExtensionTransaction.prototype, "id", {
        /**
         * The ID of the transaction.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "transactionDate", {
        /**
         * The time when the transaction was made.
         */
        get: function () {
            return new Date(this._data.timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "broadcasterId", {
        /**
         * The ID of the broadcaster that runs the extension on their channel.
         */
        get: function () {
            return this._data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "broadcasterDisplayName", {
        /**
         * The display name of the broadcaster that runs the extension on their channel.
         */
        get: function () {
            return this._data.broadcaster_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the broadcaster that runs the extension on their channel.
     */
    HelixExtensionTransaction.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixExtensionTransaction.prototype, "userId", {
        /**
         * The ID of the user that made the transaction.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "userDisplayName", {
        /**
         * The display name of the user that made the transaction.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the user that made the transaction.
     */
    HelixExtensionTransaction.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixExtensionTransaction.prototype, "productType", {
        /**
         * The product type. Currently always BITS_IN_EXTENSION.
         */
        get: function () {
            return this._data.product_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productSKU", {
        /**
         * The product SKU.
         */
        get: function () {
            return this._data.product_data.sku;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productCost", {
        /**
         * The cost of the product, in bits.
         */
        get: function () {
            return this._data.product_data.cost.amount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productDisplayName", {
        /**
         * The display name of the product.
         */
        get: function () {
            return this._data.product_data.displayName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productInDevelopment", {
        /**
         * Whether the product is in development.
         */
        get: function () {
            return this._data.product_data.inDevelopment;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixExtensionTransaction.prototype, "_client", void 0);
    return HelixExtensionTransaction;
}());
exports.default = HelixExtensionTransaction;
module.exports = exports = HelixExtensionTransaction;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixExtensionTransaction;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A game as displayed on Twitch.
 */
var HelixGame = /** @class */ (function () {
    /** @private */
    function HelixGame(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixGame.prototype, "id", {
        /**
         * The ID of the game.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixGame.prototype, "name", {
        /**
         * The name of the game.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixGame.prototype, "boxArtUrl", {
        /**
         * The URL of the box art of the game.
         */
        get: function () {
            return this._data.box_art_url;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixGame.prototype, "_client", void 0);
    return HelixGame;
}());
exports.default = HelixGame;
module.exports = exports = HelixGame;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixGame;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixBan_1 = __webpack_require__(29);
/**
 * The different types a ban event can have.
 */
var HelixBanEventType;
(function (HelixBanEventType) {
    /**
     * Sent when a user gets banned.
     */
    HelixBanEventType["Ban"] = "moderation.user.ban";
    /**
     * Sent when a user gets unbanned.
     */
    HelixBanEventType["Unban"] = "moderation.user.unban";
})(HelixBanEventType || (HelixBanEventType = {}));
exports.HelixBanEventType = HelixBanEventType;
/**
 * An event that indicates the change of a ban status, i.e. banning or unbanning a user.
 */
var HelixBanEvent = /** @class */ (function (_super) {
    tslib_1.__extends(HelixBanEvent, _super);
    /** @private */
    function HelixBanEvent(_eventData, client) {
        var _this = _super.call(this, _eventData.event_data, client) || this;
        _this._eventData = _eventData;
        return _this;
    }
    Object.defineProperty(HelixBanEvent.prototype, "eventId", {
        /**
         * The unique ID of the ban event.
         */
        get: function () {
            return this._eventData.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "eventType", {
        /**
         * The type of the ban event.
         */
        get: function () {
            return this._eventData.event_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "eventDate", {
        /**
         * The date of the ban event.
         */
        get: function () {
            return new Date(this._eventData.event_timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "eventVersion", {
        /**
         * The version of the ban event.
         */
        get: function () {
            return this._eventData.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "broadcasterId", {
        /**
         * The id of the broadcaster from whose chat the user was banned/unbanned.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the broadcaster.
     */
    HelixBanEvent.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._eventData.event_data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixBanEvent.prototype, "broadcasterName", {
        /**
         * The name of the broadcaster from whose chat the user was banned/unbanned.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    return HelixBanEvent;
}(HelixBan_1.default));
exports.default = HelixBanEvent;
module.exports = exports = HelixBanEvent;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixBanEventType = HelixBanEventType;
exports.default = HelixBanEvent;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixModerator_1 = __webpack_require__(30);
/**
 * The different types a moderator event can have.
 */
var HelixModeratorEventType;
(function (HelixModeratorEventType) {
    /**
     * Sent when a user gains moderation privileges.
     */
    HelixModeratorEventType["Add"] = "moderation.moderator.add";
    /**
     * Sent when a user loses moderation privileges.
     */
    HelixModeratorEventType["Remove"] = "moderation.moderator.remove";
})(HelixModeratorEventType || (HelixModeratorEventType = {}));
exports.HelixModeratorEventType = HelixModeratorEventType;
/**
 * An event that indicates the change of a moderator status, i.e. gaining or losing moderation privileges.
 */
var HelixModeratorEvent = /** @class */ (function (_super) {
    tslib_1.__extends(HelixModeratorEvent, _super);
    /** @private */
    function HelixModeratorEvent(_eventData, client) {
        var _this = _super.call(this, _eventData.event_data, client) || this;
        _this._eventData = _eventData;
        return _this;
    }
    Object.defineProperty(HelixModeratorEvent.prototype, "eventId", {
        /**
         * The unique ID of the moderator event.
         */
        get: function () {
            return this._eventData.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "eventType", {
        /**
         * The type of the moderator event.
         */
        get: function () {
            return this._eventData.event_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "eventDate", {
        /**
         * The date of the moderator event.
         */
        get: function () {
            return new Date(this._eventData.event_timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "eventVersion", {
        /**
         * The version of the moderator event.
         */
        get: function () {
            return this._eventData.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "broadcasterId", {
        /**
         * The id of the broadcaster where the user gained/lost moderation privileges.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the broadcaster.
     */
    HelixModeratorEvent.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._eventData.event_data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixModeratorEvent.prototype, "broadcasterName", {
        /**
         * The name of the broadcaster where the user gained/lost moderation privileges.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    return HelixModeratorEvent;
}(HelixModerator_1.default));
exports.default = HelixModeratorEvent;
module.exports = exports = HelixModeratorEvent;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixModeratorEventType = HelixModeratorEventType;
exports.default = HelixModeratorEvent;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever you try something that requires your own stream to be live.
 */
var StreamNotLiveError = /** @class */ (function (_super) {
    tslib_1.__extends(StreamNotLiveError, _super);
    /** @private */
    function StreamNotLiveError() {
        return _super.call(this, 'Your stream needs to be live to do this') || this;
    }
    return StreamNotLiveError;
}(CustomError_1.default));
exports.default = StreamNotLiveError;
module.exports = exports = StreamNotLiveError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StreamNotLiveError;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * The type of a stream.
 */
var HelixStreamType;
(function (HelixStreamType) {
    /**
     * Returned by Twitch in case of an error.
     */
    HelixStreamType["None"] = "";
    /**
     * A live stream.
     */
    HelixStreamType["Live"] = "live";
    /**
     * A vodcast.
     *
     * Currently not supported by Twitch - but one can only hope and leave it in here.
     */
    HelixStreamType["Vodcast"] = "vodcast";
})(HelixStreamType || (HelixStreamType = {}));
exports.HelixStreamType = HelixStreamType;
/**
 * A Twitch stream.
 */
var HelixStream = /** @class */ (function () {
    /** @private */
    function HelixStream(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixStream.prototype, "id", {
        /**
         * The stream ID.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "userId", {
        /**
         * The user ID.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "userDisplayName", {
        /**
         * The user's display name.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the user broadcasting the stream.
     */
    HelixStream.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixStream.prototype, "gameId", {
        /**
         * The game ID.
         */
        get: function () {
            return this._data.game_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the game that is being played on this stream.
     */
    HelixStream.prototype.getGame = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.games.getGameById(this._data.game_id)];
            });
        });
    };
    Object.defineProperty(HelixStream.prototype, "type", {
        /**
         * The type of the stream.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "title", {
        /**
         * The title of the stream.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "viewers", {
        /**
         * The number of viewers the stream currently has.
         */
        get: function () {
            return this._data.viewer_count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "startDate", {
        /**
         * The time when the stream started.
         */
        get: function () {
            return new Date(this._data.started_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "language", {
        /**
         * The language of the stream.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "thumbnailUrl", {
        /**
         * The URL of the thumbnail of the stream.
         */
        get: function () {
            return this._data.thumbnail_url;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixStream.prototype, "_client", void 0);
    return HelixStream;
}());
exports.default = HelixStream;
module.exports = exports = HelixStream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixStreamType = HelixStreamType;
exports.default = HelixStream;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var HelixStreamMarker = /** @class */ (function () {
    /** @private */
    function HelixStreamMarker(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixStreamMarker.prototype, "id", {
        /**
         * The ID of the marker.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarker.prototype, "creationDate", {
        /**
         * The date and time when the marker was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarker.prototype, "description", {
        /**
         * The description of the marker.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarker.prototype, "positionInSeconds", {
        /**
         * The position in the stream when the marker was created, in seconds.
         */
        get: function () {
            return this._data.position_seconds;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixStreamMarker.prototype, "_client", void 0);
    return HelixStreamMarker;
}());
exports.default = HelixStreamMarker;
module.exports = exports = HelixStreamMarker;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixStreamMarker;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixSubscription_1 = __webpack_require__(31);
/**
 * The different types a subscription event can have.
 */
var HelixSubscriptionEventType;
(function (HelixSubscriptionEventType) {
    /**
     * Sent when a new user subscribes.
     */
    HelixSubscriptionEventType["Subscribe"] = "subscriptions.subscribe";
    /**
     * Sent when a previous subscriber stops subscribing.
     */
    HelixSubscriptionEventType["Unsubscribe"] = "subscriptions.unsubscribe";
    /**
     * Sent when a new or recurring subscriber sends their monthly notification.
     */
    HelixSubscriptionEventType["Notification"] = "subscriptions.notification";
})(HelixSubscriptionEventType || (HelixSubscriptionEventType = {}));
exports.HelixSubscriptionEventType = HelixSubscriptionEventType;
/**
 * An event that indicates the change of a subscription status, i.e. subscribing, unsubscribing or sending the monthly notification.
 */
var HelixSubscriptionEvent = /** @class */ (function (_super) {
    tslib_1.__extends(HelixSubscriptionEvent, _super);
    /** @private */
    function HelixSubscriptionEvent(_eventData, client) {
        var _this = _super.call(this, _eventData.event_data, client) || this;
        _this._eventData = _eventData;
        return _this;
    }
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventId", {
        /**
         * The unique ID of the subscription event.
         */
        get: function () {
            return this._eventData.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventType", {
        /**
         * The type of the subscription event.
         */
        get: function () {
            return this._eventData.event_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventDate", {
        /**
         * The date of the subscription event.
         */
        get: function () {
            return new Date(this._eventData.event_timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventVersion", {
        /**
         * The version of the subscription event.
         */
        get: function () {
            return this._eventData.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventMessage", {
        /**
         * The message sent with the subscription event.
         */
        get: function () {
            return this._eventData.event_data.message || '';
        },
        enumerable: true,
        configurable: true
    });
    return HelixSubscriptionEvent;
}(HelixSubscription_1.default));
exports.default = HelixSubscriptionEvent;
module.exports = exports = HelixSubscriptionEvent;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixSubscriptionEventType = HelixSubscriptionEventType;
exports.default = HelixSubscriptionEvent;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixPaginatedRequest_1 = __webpack_require__(9);
/**
 * A special case of {@HelixPaginatedRequest} with support for fetching the total number of entities, whenever an endpoint supports it.
 */
var HelixPaginatedRequestWithTotal = /** @class */ (function (_super) {
    tslib_1.__extends(HelixPaginatedRequestWithTotal, _super);
    function HelixPaginatedRequestWithTotal() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves and returns the total number of entities existing in the queried result set.
     */
    HelixPaginatedRequestWithTotal.prototype.getTotalCount = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this._currentData;
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._fetchData({ query: { after: undefined } })];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        data = _a;
                        return [2 /*return*/, data.total];
                }
            });
        });
    };
    return HelixPaginatedRequestWithTotal;
}(HelixPaginatedRequest_1.default));
exports.default = HelixPaginatedRequestWithTotal;
module.exports = exports = HelixPaginatedRequestWithTotal;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixPaginatedRequestWithTotal;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A relation of a user following a broadcaster.
 */
var HelixFollow = /** @class */ (function () {
    /** @private */
    function HelixFollow(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixFollow.prototype, "userId", {
        /**
         * The user ID of the following user.
         */
        get: function () {
            return this._data.from_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixFollow.prototype, "userDisplayName", {
        /**
         * The display name of the following user.
         */
        get: function () {
            return this._data.from_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the data of the following user.
     */
    HelixFollow.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.from_id)];
            });
        });
    };
    Object.defineProperty(HelixFollow.prototype, "followedUserId", {
        /**
         * The user ID of the followed broadcaster.
         */
        get: function () {
            return this._data.to_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixFollow.prototype, "followedUserDisplayName", {
        /**
         * The display name of the followed user.
         */
        get: function () {
            return this._data.to_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the data of the followed broadcaster.
     */
    HelixFollow.prototype.getFollowedUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.to_id)];
            });
        });
    };
    Object.defineProperty(HelixFollow.prototype, "followDate", {
        /**
         * The date when the user followed the broadcaster.
         */
        get: function () {
            return new Date(this._data.followed_at);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixFollow.prototype, "_client", void 0);
    return HelixFollow;
}());
exports.default = HelixFollow;
module.exports = exports = HelixFollow;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixFollow;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixUser_1 = __webpack_require__(32);
/**
 * A user you have extended privilges for, i.e. yourself.
 *
 * @inheritDoc
 */
var HelixPrivilegedUser = /** @class */ (function (_super) {
    tslib_1.__extends(HelixPrivilegedUser, _super);
    function HelixPrivilegedUser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(HelixPrivilegedUser.prototype, "email", {
        /**
         * The email address of the user.
         */
        get: function () {
            return this._data.email;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Changes the description of the user.
     *
     * @param description The new description.
     */
    HelixPrivilegedUser.prototype.setDescription = function (description) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.updateUser({ description: description })];
            });
        });
    };
    return HelixPrivilegedUser;
}(HelixUser_1.default));
exports.default = HelixPrivilegedUser;
module.exports = exports = HelixPrivilegedUser;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixPrivilegedUser;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var shared_utils_1 = __webpack_require__(1);
var HellFreezesOverError_1 = __webpack_require__(20);
/**
 * A video on Twitch.
 */
var HelixVideo = /** @class */ (function () {
    /** @private */
    function HelixVideo(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixVideo.prototype, "id", {
        /**
         * The ID of the video.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "userId", {
        /**
         * The ID of the user who created the video.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "userDisplayName", {
        /**
         * The display name of the user who created the video.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the user who created the video.
     */
    HelixVideo.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixVideo.prototype, "title", {
        /**
         * The title of the video.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "description", {
        /**
         * The description of the video.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "creationDate", {
        /**
         * The date when the video was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "publishDate", {
        /**
         * The date when the video was published.
         */
        get: function () {
            return new Date(this._data.published_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "url", {
        /**
         * The URL of the video.
         */
        get: function () {
            return this._data.url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "thumbnailUrl", {
        /**
         * The URL of the thumbnail of the video.
         */
        get: function () {
            return this._data.thumbnail_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "isPublic", {
        /**
         * Whether the video is public or not.
         */
        get: function () {
            return this._data.viewable === 'public';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "views", {
        /**
         * The number of views of the video.
         */
        get: function () {
            return this._data.view_count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "language", {
        /**
         * The language of the video.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "type", {
        /**
         * The type of the video.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "duration", {
        /**
         * The duration of the video, as formatted by Twitch.
         */
        get: function () {
            return this._data.duration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "durationInSeconds", {
        /**
         * The duration of the video, in seconds.
         */
        get: function () {
            var parts = this._data.duration.match(/\d+[hms]/g);
            if (!parts) {
                throw new HellFreezesOverError_1.default("Could not parse duration string: " + this._data.duration);
            }
            return parts
                .map(function (part) {
                var partialMatch = part.match(/(\d+)([hms])/);
                if (!partialMatch) {
                    throw new HellFreezesOverError_1.default("Could not parse partial duration string: " + part);
                }
                var _a = tslib_1.__read(partialMatch, 3), num = _a[1], unit = _a[2];
                return parseInt(num, 10) * { h: 3600, m: 60, s: 1 }[unit];
            })
                .reduce(function (a, b) { return a + b; });
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixVideo.prototype, "_client", void 0);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixVideo.prototype, "durationInSeconds", null);
    HelixVideo = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], HelixVideo);
    return HelixVideo;
}());
exports.default = HelixVideo;
module.exports = exports = HelixVideo;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixVideo;


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LogLevel_1 = __webpack_require__(22);
var isNode = __webpack_require__(14);
var BaseLogger = /** @class */ (function () {
    function BaseLogger(_a) {
        var name = _a.name, _b = _a.minLevel, minLevel = _b === void 0 ? LogLevel_1.LogLevel.WARNING : _b, _c = _a.emoji, emoji = _c === void 0 ? false : _c, _d = _a.colors, colors = _d === void 0 ? true : _d, _e = _a.timestamps, timestamps = _e === void 0 ? isNode : _e;
        this._name = name;
        this._minLevel = LogLevel_1.resolveLogLevel(minLevel);
        this._emoji = emoji;
        this._colors = colors;
        this._timestamps = timestamps;
    }
    // region convenience methods
    BaseLogger.prototype.crit = function (message) {
        this.log(LogLevel_1.LogLevel.CRITICAL, message);
    };
    BaseLogger.prototype.critical = function (message) {
        this.log(LogLevel_1.LogLevel.CRITICAL, message);
    };
    BaseLogger.prototype.err = function (message) {
        this.log(LogLevel_1.LogLevel.ERROR, message);
    };
    BaseLogger.prototype.error = function (message) {
        this.log(LogLevel_1.LogLevel.ERROR, message);
    };
    BaseLogger.prototype.warn = function (message) {
        this.log(LogLevel_1.LogLevel.WARNING, message);
    };
    BaseLogger.prototype.warning = function (message) {
        this.log(LogLevel_1.LogLevel.WARNING, message);
    };
    BaseLogger.prototype.info = function (message) {
        this.log(LogLevel_1.LogLevel.INFO, message);
    };
    BaseLogger.prototype.debug = function (message) {
        this.log(LogLevel_1.LogLevel.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug1 = function (message) {
        this.log(LogLevel_1.LogLevel.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug2 = function (message) {
        this.log(LogLevel_1.LogLevel.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug3 = function (message) {
        this.log(LogLevel_1.LogLevel.DEBUG, message);
    };
    BaseLogger.prototype.trace = function (message) {
        this.log(LogLevel_1.LogLevel.TRACE, message);
    };
    return BaseLogger;
}());
exports.BaseLogger = BaseLogger;
//# sourceMappingURL=BaseLogger.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var requirePromise = __webpack_require__(25);

requirePromise();

var PromiseResolve = __webpack_require__(150);
var Type = __webpack_require__(7);
var iterate = __webpack_require__(152);
var map = __webpack_require__(160);
var callBound = __webpack_require__(8);

var all = callBound('Promise.all');
var reject = callBound('Promise.reject');

module.exports = function allSettled(iterable) {
	var C = this;
	if (Type(C) !== 'Object') {
		throw new TypeError('`this` value must be an object');
	}
	var values = iterate(iterable);
	return all(C, map(values, function (item) {
		var onFulfill = function (value) {
			return { status: 'fulfilled', value: value };
		};
		var onReject = function (reason) {
			return { status: 'rejected', reason: reason };
		};
		var itemPromise = PromiseResolve(C, item);
		try {
			return itemPromise.then(onFulfill, onReject);
		} catch (e) {
			return reject(C, e);
		}
	}));
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject(value) {
	try {
		strValue.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var strClass = '[object String]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isString(value) {
	if (typeof value === 'string') {
		return true;
	}
	if (typeof value !== 'object') {
		return false;
	}
	return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(161);


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArraySpeciesCreate = __webpack_require__(162);
var Call = __webpack_require__(171);
var CreateDataPropertyOrThrow = __webpack_require__(172);
var Get = __webpack_require__(73);
var HasProperty = __webpack_require__(179);
var IsCallable = __webpack_require__(82);
var ToUint32 = __webpack_require__(180);
var ToObject = __webpack_require__(188);
var ToString = __webpack_require__(189);
var callBound = __webpack_require__(8);
var isString = __webpack_require__(70);

// Check failure of by-index access of string characters (IE < 9) and failure of `0 in boxedString` (Rhino)
var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var strSplit = callBound('String.prototype.split');

module.exports = function map(callbackfn) {
	var O = ToObject(this);
	var self = splitString && isString(O) ? strSplit(O, '') : O;
	var len = ToUint32(self.length);

	// If no callback function or if callback is not a callable function
	if (!IsCallable(callbackfn)) {
		throw new TypeError('Array.prototype.map callback must be a function');
	}

	var T;
	if (arguments.length > 1) {
		T = arguments[1];
	}

	var A = ArraySpeciesCreate(O, len);
	var k = 0;
	while (k < len) {
		var Pk = ToString(k);
		var kPresent = HasProperty(O, Pk);
		if (kPresent) {
			var kValue = Get(O, Pk);
			var mappedValue = Call(callbackfn, T, [kValue, k, O]);
			CreateDataPropertyOrThrow(A, Pk, mappedValue);
		}
		k += 1;
	}

	return A;
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var inspect = __webpack_require__(163);

var IsPropertyKey = __webpack_require__(16);
var Type = __webpack_require__(7);

/**
 * 7.3.1 Get (O, P) - https://ecma-international.org/ecma-262/6.0/#sec-get-o-p
 * 1. Assert: Type(O) is Object.
 * 2. Assert: IsPropertyKey(P) is true.
 * 3. Return O.[[Get]](P, O).
 */

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $Array = GetIntrinsic('%Array%');

// eslint-disable-next-line global-require
var toStr = !$Array.isArray && __webpack_require__(8)('Object.prototype.toString');

// https://www.ecma-international.org/ecma-262/6.0/#sec-isarray

module.exports = $Array.isArray || function IsArray(argument) {
	return toStr(argument) === '[object Array]';
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

var callBound = __webpack_require__(8);

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

// eslint-disable-next-line max-params
module.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
	if (!$defineProperty) {
		if (!IsDataDescriptor(desc)) {
			// ES3 does not support getters/setters
			return false;
		}
		if (!desc['[[Configurable]]'] || !desc['[[Writable]]']) {
			return false;
		}

		// fallback for ES3
		if (P in O && $isEnumerable(O, P) !== !!desc['[[Enumerable]]']) {
			// a non-enumerable existing property
			return false;
		}

		// property does not exist at all, or exists but is enumerable
		var V = desc['[[Value]]'];
		// eslint-disable-next-line no-param-reassign
		O[P] = V; // will use [[Define]]
		return SameValue(O[P], V);
	}
	$defineProperty(O, P, FromPropertyDescriptor(desc));
	return true;
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assertRecord = __webpack_require__(36);

var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return Desc;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	var obj = {};
	if ('[[Value]]' in Desc) {
		obj.value = Desc['[[Value]]'];
	}
	if ('[[Writable]]' in Desc) {
		obj.writable = Desc['[[Writable]]'];
	}
	if ('[[Get]]' in Desc) {
		obj.get = Desc['[[Get]]'];
	}
	if ('[[Set]]' in Desc) {
		obj.set = Desc['[[Set]]'];
	}
	if ('[[Enumerable]]' in Desc) {
		obj.enumerable = Desc['[[Enumerable]]'];
	}
	if ('[[Configurable]]' in Desc) {
		obj.configurable = Desc['[[Configurable]]'];
	}
	return obj;
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(17);

var assertRecord = __webpack_require__(36);

var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-isdatadescriptor

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	if (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $isNaN = __webpack_require__(79);

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(17);

var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var Type = __webpack_require__(7);
var ToBoolean = __webpack_require__(81);
var IsCallable = __webpack_require__(82);

// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (Type(Obj) !== 'Object') {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (has(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (has(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (has(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (has(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (has(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (has(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://www.ecma-international.org/ecma-262/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://www.ecma-international.org/ecma-262/5.1/#sec-9.11

module.exports = __webpack_require__(83);


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
	} catch (_) {
		reflectApply = null;
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = reflectApply
	? function isCallable(value) {
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value);
	}
	: function isCallable(value) {
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayMethodBoxesProperly = __webpack_require__(190);

var implementation = __webpack_require__(72);

module.exports = function getPolyfill() {
	var method = Array.prototype.map;
	return arrayMethodBoxesProperly(method) ? method : implementation;
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var requirePromise = __webpack_require__(25);

var implementation = __webpack_require__(69);

module.exports = function getPolyfill() {
	requirePromise();
	return typeof Promise.allSettled === 'function' ? Promise.allSettled : implementation;
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(33);
var CustomError_1 = __webpack_require__(193);
var RetryAfterError = /** @class */ (function (_super) {
    tslib_1.__extends(RetryAfterError, _super);
    function RetryAfterError(after) {
        var _this = _super.call(this, "Need to retry after " + after + " ms") || this;
        _this._retryAt = Date.now() + after;
        return _this;
    }
    Object.defineProperty(RetryAfterError.prototype, "retryAt", {
        get: function () {
            return this._retryAt;
        },
        enumerable: true,
        configurable: true
    });
    return RetryAfterError;
}(CustomError_1.CustomError));
exports.RetryAfterError = RetryAfterError;
//# sourceMappingURL=RetryAfterError.js.map

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var User_1 = __webpack_require__(10);
/**
 * A relation of a user following a previously given channel.
 */
var ChannelFollow = /** @class */ (function () {
    /** @private */
    function ChannelFollow(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChannelFollow.prototype, "user", {
        /**
         * The user following the given channel.
         */
        get: function () {
            return new User_1.default(this._data.user, this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelFollow.prototype, "hasNotifications", {
        /**
         * Whether the user has notifications enabled for the channel.
         */
        get: function () {
            return this._data.notifications;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelFollow.prototype, "followDate", {
        /**
         * The date when the user followed.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChannelFollow.prototype, "_client", void 0);
    return ChannelFollow;
}());
exports.default = ChannelFollow;
module.exports = exports = ChannelFollow;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChannelFollow;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Subscription_1 = __webpack_require__(39);
var User_1 = __webpack_require__(10);
/**
 * A relation of a user subscribing to a previously given channel.
 */
var ChannelSubscription = /** @class */ (function (_super) {
    tslib_1.__extends(ChannelSubscription, _super);
    function ChannelSubscription() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ChannelSubscription.prototype, "user", {
        /**
         * The user subscribing to the given channel.
         */
        get: function () {
            return new User_1.default(this._data.user, this._client);
        },
        enumerable: true,
        configurable: true
    });
    return ChannelSubscription;
}(Subscription_1.default));
exports.default = ChannelSubscription;
module.exports = exports = ChannelSubscription;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChannelSubscription;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Channel_1 = __webpack_require__(13);
/**
 * A channel you have extended privileges for, i.e. the channel of the currently authenticated user.
 */
var PrivilegedChannel = /** @class */ (function (_super) {
    tslib_1.__extends(PrivilegedChannel, _super);
    function PrivilegedChannel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PrivilegedChannel.prototype, "streamKey", {
        /**
         * The channel's stream key.
         */
        get: function () {
            return this._data.stream_key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedChannel.prototype, "email", {
        /**
         * The channel's email address.
         */
        get: function () {
            return this._data.email;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the list of editors of the channel.
     */
    PrivilegedChannel.prototype.getEditors = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelEditors(this)];
            });
        });
    };
    /**
     * Starts a commercial in the channel.
     *
     * @param length The length of the commercial.
     */
    PrivilegedChannel.prototype.startCommercial = function (length) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.startChannelCommercial(this, length)];
            });
        });
    };
    /**
     * Resets the given channel's stream key.
     */
    PrivilegedChannel.prototype.resetStreamKey = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelData, streamKey;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.channels.resetChannelStreamKey(this)];
                    case 1:
                        channelData = _a.sent();
                        streamKey = channelData.stream_key;
                        this._data.stream_key = streamKey;
                        return [2 /*return*/, streamKey];
                }
            });
        });
    };
    return PrivilegedChannel;
}(Channel_1.default));
exports.default = PrivilegedChannel;
module.exports = exports = PrivilegedChannel;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PrivilegedChannel;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
/**
 * A list of emotes, grouped into emote sets, that a user can use.
 */
var EmoteSetList = /** @class */ (function () {
    /** @private */
    function EmoteSetList(_data) {
        this._data = _data;
    }
    /**
     * Finds the emote ID for the given emote code.
     *
     * @param emoteCode The emote code to check for.
     */
    EmoteSetList.prototype.findEmoteId = function (emoteCode) {
        var e_1, _a, e_2, _b;
        try {
            for (var _c = tslib_1.__values(Object.values(this._data)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var emoteSet = _d.value;
                try {
                    for (var emoteSet_1 = (e_2 = void 0, tslib_1.__values(emoteSet)), emoteSet_1_1 = emoteSet_1.next(); !emoteSet_1_1.done; emoteSet_1_1 = emoteSet_1.next()) {
                        var emote = emoteSet_1_1.value;
                        if (new RegExp(emote.code).test(emoteCode)) {
                            return emote.id;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (emoteSet_1_1 && !emoteSet_1_1.done && (_b = emoteSet_1.return)) _b.call(emoteSet_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return undefined;
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(Infinity, true)
    ], EmoteSetList.prototype, "findEmoteId", null);
    EmoteSetList = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], EmoteSetList);
    return EmoteSetList;
}());
exports.default = EmoteSetList;
module.exports = exports = EmoteSetList;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EmoteSetList;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var User_1 = __webpack_require__(10);
/**
 * A user you have extended privileges for, i.e. the currently authenticated user.
 *
 * @inheritDoc
 */
var PrivilegedUser = /** @class */ (function (_super) {
    tslib_1.__extends(PrivilegedUser, _super);
    function PrivilegedUser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PrivilegedUser.prototype, "email", {
        /**
         * The user's email address.
         */
        get: function () {
            return this._data.email;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "isEmailVerified", {
        /**
         * Whether the user's email address is verified.
         */
        get: function () {
            return this._data.email_verified;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "hasEmailNotifications", {
        /**
         * Whether the user has email notifications enabled.
         */
        get: function () {
            return this._data.notifications.email;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "hasPushNotifications", {
        /**
         * Whether the user has push notifications enabled.
         */
        get: function () {
            return this._data.notifications.push;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "isPartnered", {
        /**
         * Whether the user is partnered.
         */
        get: function () {
            return this._data.partnered;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "hasTwitter", {
        /**
         * Whether the user has a Twitter account connected.
         */
        get: function () {
            return this._data.twitter_connected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Follows a channel.
     *
     * @param channel The channel to follow.
     * @param notifications Whether the user will receive notifications.
     */
    PrivilegedUser.prototype.followChannel = function (channel, notifications) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.followChannel(this, channel, notifications)];
            });
        });
    };
    /**
     * Unfollows a channel.
     *
     * @param channel The channel to unfollow.
     */
    PrivilegedUser.prototype.unfollowChannel = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.unfollowChannel(this, channel)];
            });
        });
    };
    /**
     * Blocks a user.
     *
     * @param userToBlock The user to block.
     */
    PrivilegedUser.prototype.blockUser = function (userToBlock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.blockUser(this, userToBlock)];
            });
        });
    };
    /**
     * Unblocks a user.
     *
     * @param userToUnblock The user to unblock.
     */
    PrivilegedUser.prototype.unblockUser = function (userToUnblock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.unblockUser(this, userToUnblock)];
            });
        });
    };
    return PrivilegedUser;
}(User_1.default));
exports.default = PrivilegedUser;
module.exports = exports = PrivilegedUser;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PrivilegedUser;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var User_1 = __webpack_require__(10);
/**
 * A relation of a previously givn user blocking another user.
 */
var UserBlock = /** @class */ (function () {
    /** @private */
    function UserBlock(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(UserBlock.prototype, "blockedUser", {
        /**
         * The blocked user.
         */
        get: function () {
            return new User_1.default(this._data.user, this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], UserBlock.prototype, "_client", void 0);
    return UserBlock;
}());
exports.default = UserBlock;
module.exports = exports = UserBlock;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UserBlock;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var Channel_1 = __webpack_require__(13);
/**
 * A relation of a previously given user following a channel.
 */
var UserFollow = /** @class */ (function () {
    /** @private */
    function UserFollow(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(UserFollow.prototype, "followDate", {
        /**
         * The date when the user followed the channel.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserFollow.prototype, "hasNotifications", {
        /**
         * Whether the user has notifications enabled for the channel.
         */
        get: function () {
            return this._data.notifications;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserFollow.prototype, "channel", {
        /**
         * The followed channel.
         */
        get: function () {
            return new Channel_1.default(this._data.channel, this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], UserFollow.prototype, "_client", void 0);
    return UserFollow;
}());
exports.default = UserFollow;
module.exports = exports = UserFollow;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UserFollow;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Subscription_1 = __webpack_require__(39);
var Channel_1 = __webpack_require__(13);
/**
 * A relation of a previously given user subscribing to a channel.
 */
var UserSubscription = /** @class */ (function (_super) {
    tslib_1.__extends(UserSubscription, _super);
    function UserSubscription() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(UserSubscription.prototype, "channel", {
        /**
         * The subscribed channel.
         */
        get: function () {
            return new Channel_1.default(this._data.channel, this._client);
        },
        enumerable: true,
        configurable: true
    });
    return UserSubscription;
}(Subscription_1.default));
exports.default = UserSubscription;
module.exports = exports = UserSubscription;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UserSubscription;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Information about an access token.
 */
var TokenInfo = /** @class */ (function () {
    /** @private */
    function TokenInfo(_data) {
        this._data = _data;
        this._obtainmentDate = new Date();
    }
    Object.defineProperty(TokenInfo.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._data.client_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "userId", {
        /**
         * The ID of the authenticated user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "userName", {
        /**
         * The user name of the authenticated user.
         */
        get: function () {
            return this._data.login;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "scopes", {
        /**
         * The scopes for which this token is valid.
         */
        get: function () {
            return this._data.scopes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "expiryDate", {
        /**
         * The time when the token will expire.
         *
         * If this returns null, it means that the token is either invalid or never expires (happens with old client IDs).
         */
        get: function () {
            if (!this._data.expires_in) {
                return null;
            }
            return new Date(this._obtainmentDate.getTime() + this._data.expires_in * 1000);
        },
        enumerable: true,
        configurable: true
    });
    return TokenInfo;
}());
exports.default = TokenInfo;
module.exports = exports = TokenInfo;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TokenInfo;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A list of chatters in a Twitch chat.
 */
var ChattersList = /** @class */ (function () {
    /** @private */
    function ChattersList(_data) {
        this._data = _data;
    }
    Object.defineProperty(ChattersList.prototype, "allChatters", {
        /**
         * A list of user names of all chatters in the chat.
         */
        get: function () {
            return shared_utils_1.flatten(Object.values(this._data.chatters));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChattersList.prototype, "allChattersWithStatus", {
        /**
         * A map of user names of all chatters in the chat, mapped to their status in the channel.
         */
        get: function () {
            return new Map(shared_utils_1.flatten(Object.entries(this._data.chatters).map(function (_a) {
                var _b = tslib_1.__read(_a, 2), status = _b[0], names = _b[1];
                return names.map(function (name) { return [name, status]; });
            })));
        },
        enumerable: true,
        configurable: true
    });
    return ChattersList;
}());
exports.default = ChattersList;
module.exports = exports = ChattersList;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChattersList;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var TwitchClient_1 = __webpack_require__(4);
/**
 * Enhances another auth provider with the ability to make use of refresh
 * tokens, automatically refreshing the access token whenever necessary.
 */
var RefreshableAuthProvider = /** @class */ (function () {
    /**
     * Creates a new auth provider based on the given one that can automatically
     * refresh access tokens.
     *
     * You don't usually have to create this manually. You should use `TwitchClient.withCredentials`
     * with the `refreshConfig` parameter instead.
     *
     * @param childProvider The base auth provider.
     * @param refreshConfig The information necessary to automatically refresh an access token.
     */
    function RefreshableAuthProvider(childProvider, refreshConfig) {
        this._clientSecret = refreshConfig.clientSecret;
        this._refreshToken = refreshConfig.refreshToken;
        this._childProvider = childProvider;
        this._initialExpiry = refreshConfig.expiry;
        this._onRefresh = refreshConfig.onRefresh;
    }
    Object.defineProperty(RefreshableAuthProvider.prototype, "tokenType", {
        /**
         * The type of tokens this provider generates.
         *
         * It is the same as the underlying base auth provider's token type.
         */
        get: function () {
            return this._childProvider.tokenType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves an access token.
     *
     * If the current access token does not have the requested scopes, the base auth
     * provider is called.
     *
     * If the current access token is expired, automatically renew it.
     *
     * @param scopes The requested scopes.
     */
    RefreshableAuthProvider.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var oldToken, newToken, now, refreshedToken;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof scopes === 'string') {
                            scopes = scopes.split(' ');
                        }
                        return [4 /*yield*/, this._childProvider.getAccessToken()];
                    case 1:
                        oldToken = _a.sent();
                        if (!(oldToken && scopes && scopes.some(function (scope) { return !_this.currentScopes.includes(scope); }))) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._childProvider.getAccessToken(scopes)];
                    case 2:
                        newToken = _a.sent();
                        // ...but if the token doesn't change, carry on
                        if (newToken !== oldToken) {
                            return [2 /*return*/, newToken];
                        }
                        _a.label = 3;
                    case 3:
                        // if we don't have a current token, we just pass this and refresh right away
                        if (oldToken) {
                            if (this._initialExpiry) {
                                now = new Date();
                                if (now < this._initialExpiry) {
                                    return [2 /*return*/, oldToken];
                                }
                            }
                            else if (!oldToken.isExpired) {
                                return [2 /*return*/, oldToken];
                            }
                        }
                        return [4 /*yield*/, this.refresh()];
                    case 4:
                        refreshedToken = _a.sent();
                        if (oldToken) {
                            return [2 /*return*/, refreshedToken];
                        }
                        // need to check again for scopes after refreshing, in case a refresh token was passed without an access token
                        return [2 /*return*/, this._childProvider.getAccessToken(scopes)];
                }
            });
        });
    };
    /**
     * Force a refresh of the access token.
     */
    RefreshableAuthProvider.prototype.refresh = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tokenData;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, TwitchClient_1.default.refreshAccessToken(this.clientId, this._clientSecret, this._refreshToken)];
                    case 1:
                        tokenData = _a.sent();
                        this.setAccessToken(tokenData);
                        this._refreshToken = tokenData.refreshToken;
                        this._initialExpiry = undefined;
                        if (this._onRefresh) {
                            this._onRefresh(tokenData);
                        }
                        return [2 /*return*/, tokenData];
                }
            });
        });
    };
    /** @private */
    RefreshableAuthProvider.prototype.setAccessToken = function (token) {
        this._childProvider.setAccessToken(token);
    };
    Object.defineProperty(RefreshableAuthProvider.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._childProvider.clientId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RefreshableAuthProvider.prototype, "currentScopes", {
        /**
         * The scopes that are currently available using the access token.
         */
        get: function () {
            return this._childProvider.currentScopes;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], RefreshableAuthProvider.prototype, "_clientSecret", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], RefreshableAuthProvider.prototype, "_refreshToken", void 0);
    return RefreshableAuthProvider;
}());
exports.default = RefreshableAuthProvider;
module.exports = exports = RefreshableAuthProvider;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RefreshableAuthProvider;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var AccessToken_1 = __webpack_require__(27);
var TwitchClient_1 = __webpack_require__(4);
/**
 * An auth provider that always returns the same initially given credentials.
 *
 * You are advised to roll your own auth provider that can handle scope upgrades,
 * or to plan ahead and supply only access tokens that account for all scopes
 * you will ever need.
 */
var StaticAuthProvider = /** @class */ (function () {
    /**
     * Creates a new auth provider with static credentials.
     *
     * You don't usually have to create this manually. You should use `TwitchClient.withCredentials` instead.
     *
     * @param clientId The client ID.
     * @param accessToken The access token to provide.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     * @param scopes The scopes this token has.
     * @param tokenType The type of the supplied token.
     */
    function StaticAuthProvider(clientId, accessToken, scopes, tokenType) {
        if (tokenType === void 0) { tokenType = 'user'; }
        this._clientId = clientId || '';
        this.tokenType = tokenType;
        if (accessToken) {
            this._accessToken =
                typeof accessToken === 'string'
                    ? new AccessToken_1.default({
                        access_token: accessToken,
                        scope: scopes,
                        refresh_token: ''
                    })
                    : accessToken;
            this._scopes = scopes;
        }
    }
    /**
     * Retrieves an access token.
     *
     * If the current access token does not have the requested scopes, this method throws.
     * This makes supplying an access token with the correct scopes from the beginning necessary.
     *
     * @param scopes The requested scopes.
     */
    StaticAuthProvider.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tokenInfo;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(scopes && scopes.length > 0)) return [3 /*break*/, 3];
                        if (!!this._scopes) return [3 /*break*/, 2];
                        if (!this._accessToken) {
                            throw new Error('Auth provider has not been initialized with a token yet and is requesting scopes');
                        }
                        return [4 /*yield*/, TwitchClient_1.default.getTokenInfo(this._accessToken.accessToken, this._clientId)];
                    case 1:
                        tokenInfo = _a.sent();
                        this._scopes = tokenInfo.scopes;
                        _a.label = 2;
                    case 2:
                        if (typeof scopes === 'string') {
                            scopes = scopes.split(' ');
                        }
                        if (scopes.some(function (scope) { return !_this._scopes.includes(scope); })) {
                            throw new Error("This token does not have the requested scopes (" + scopes.join(', ') + ") and can not be upgraded");
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/, this._accessToken || null];
                }
            });
        });
    };
    /** @private */
    StaticAuthProvider.prototype.setAccessToken = function (token) {
        this._accessToken = token;
    };
    Object.defineProperty(StaticAuthProvider.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._clientId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StaticAuthProvider.prototype, "currentScopes", {
        /**
         * The scopes that are currently available using the access token.
         */
        get: function () {
            return this._scopes || [];
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], StaticAuthProvider.prototype, "_clientId", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], StaticAuthProvider.prototype, "_accessToken", void 0);
    return StaticAuthProvider;
}());
exports.default = StaticAuthProvider;
module.exports = exports = StaticAuthProvider;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StaticAuthProvider;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever you try using invalid values in the client configuration.
 */
var ConfigError = /** @class */ (function (_super) {
    tslib_1.__extends(ConfigError, _super);
    function ConfigError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ConfigError;
}(CustomError_1.default));
exports.default = ConfigError;
module.exports = exports = ConfigError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ConfigError;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever an invalid token is supplied.
 */
var InvalidTokenError = /** @class */ (function (_super) {
    tslib_1.__extends(InvalidTokenError, _super);
    /** @private */
    function InvalidTokenError() {
        return _super.call(this, 'Invalid token supplied') || this;
    }
    return InvalidTokenError;
}(CustomError_1.default));
exports.default = InvalidTokenError;
module.exports = exports = InvalidTokenError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = InvalidTokenError;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(210);


/***/ }),
/* 103 */
/***/ (function(module, exports) {

var __self__ = (function (root) {
function F() {
this.fetch = false;
this.DOMException = root.DOMException
}
F.prototype = root;
return new F();
})(typeof self !== 'undefined' ? self : this);
(function(self) {

var irrelevant = (function (exports) {
  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  return exports;

}({}));
})(__self__);
delete __self__.fetch.polyfill
exports = __self__.fetch // To enable: import fetch from 'cross-fetch'
exports.default = __self__.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = __self__.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = __self__.Headers
exports.Request = __self__.Request
exports.Response = __self__.Response
module.exports = exports


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable filenames/match-exported */
var isNode = __webpack_require__(14);
var NodeLogger_1 = __webpack_require__(105);
var BrowserLogger_1 = __webpack_require__(106);
var Logger = isNode ? NodeLogger_1.default : BrowserLogger_1.default;
exports.default = Logger;
var LogLevel_1 = __webpack_require__(21);
var __export_LogLevel = LogLevel_1.default;
exports.LogLevel = __export_LogLevel;
module.exports = exports = Logger;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Logger;
exports.LogLevel = __export_LogLevel;
//# sourceMappingURL=index.js.map

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(43);
var LogLevel_1 = __webpack_require__(21);
var BaseLogger_1 = __webpack_require__(44);
var __export_LogLevelToEmoji = (_a = {},
    _a[LogLevel_1.default.CRITICAL] = "\uD83D\uDED1",
    _a[LogLevel_1.default.ERROR] = "\u274C",
    // these following two need extra spaces at the end because somehow they consume less space in a terminal than they should...
    _a[LogLevel_1.default.WARNING] = "\u26A0\uFE0F ",
    _a[LogLevel_1.default.INFO] = "\u2139\uFE0F ",
    _a[LogLevel_1.default.DEBUG] = "\uD83D\uDC1E",
    _a[LogLevel_1.default.TRACE] = "\uD83D\uDC3E",
    _a);
exports.LogLevelToEmoji = __export_LogLevelToEmoji;
var colors = {
    black: 30,
    red: 31,
    green: 32,
    yellow: 33,
    blue: 34,
    magenta: 35,
    cyan: 36,
    white: 37,
    blackBright: 90,
    redBright: 91,
    greenBright: 92,
    yellowBright: 93,
    blueBright: 94,
    magentaBright: 95,
    cyanBright: 96,
    whiteBright: 97
};
var bgColors = {
    bgBlack: 40,
    bgRed: 41,
    bgGreen: 42,
    bgYellow: 43,
    bgBlue: 44,
    bgMagenta: 45,
    bgCyan: 46,
    bgWhite: 47,
    bgBlackBright: 100,
    bgRedBright: 101,
    bgGreenBright: 102,
    bgYellowBright: 103,
    bgBlueBright: 104,
    bgMagentaBright: 105,
    bgCyanBright: 106,
    bgWhiteBright: 107
};
function createGenericWrapper(color, ending, inner) {
    return function (str) { return "\u001B[" + color + "m" + (inner ? inner(str) : str) + "\u001B[" + ending + "m"; };
}
function createColorWrapper(color) {
    return createGenericWrapper(colors[color], 39);
}
function createBgWrapper(color, fgWrapper) {
    return createGenericWrapper(bgColors[color], 49, fgWrapper);
}
var __export_LogLevelToColor = (_b = {},
    _b[LogLevel_1.default.CRITICAL] = createColorWrapper('red'),
    _b[LogLevel_1.default.ERROR] = createColorWrapper('redBright'),
    _b[LogLevel_1.default.WARNING] = createColorWrapper('yellow'),
    _b[LogLevel_1.default.INFO] = createColorWrapper('blue'),
    _b[LogLevel_1.default.DEBUG] = createColorWrapper('magenta'),
    _b[LogLevel_1.default.TRACE] = createGenericWrapper(0, 0),
    _b);
exports.LogLevelToColor = __export_LogLevelToColor;
var __export_LogLevelToBackgroundColor = (_c = {},
    _c[LogLevel_1.default.CRITICAL] = createBgWrapper('bgRed', createColorWrapper('white')),
    _c[LogLevel_1.default.ERROR] = createBgWrapper('bgRedBright', createColorWrapper('white')),
    _c[LogLevel_1.default.WARNING] = createBgWrapper('bgYellow', createColorWrapper('black')),
    _c[LogLevel_1.default.INFO] = createBgWrapper('bgBlue', createColorWrapper('white')),
    _c[LogLevel_1.default.DEBUG] = createBgWrapper('bgMagenta', createColorWrapper('black')),
    _c[LogLevel_1.default.TRACE] = createGenericWrapper(7, 27),
    _c);
exports.LogLevelToBackgroundColor = __export_LogLevelToBackgroundColor;
var NodeLogger = /** @class */ (function (_super) {
    tslib_1.__extends(NodeLogger, _super);
    function NodeLogger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeLogger.prototype.log = function (level, message) {
        if (level > this._minLevel) {
            return;
        }
        var logFn = LogLevel_1.LogLevelToConsoleFunction[level];
        var builtMessage = '';
        if (this._timestamps) {
            builtMessage += "[" + new Date().toISOString() + "] ";
        }
        if (this._emoji) {
            var emoji = exports.LogLevelToEmoji[level];
            builtMessage += emoji + " ";
        }
        if (this._colors) {
            builtMessage += exports.LogLevelToBackgroundColor[level](this._name) + " " + exports.LogLevelToBackgroundColor[level](LogLevel_1.default[level]) + " " + exports.LogLevelToColor[level](message);
        }
        else {
            builtMessage += "[" + this._name + ":" + LogLevel_1.default[level].toLowerCase() + "] " + message;
        }
        logFn(builtMessage);
    };
    return NodeLogger;
}(BaseLogger_1.default));
exports.default = NodeLogger;
module.exports = exports = NodeLogger;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogLevelToEmoji = __export_LogLevelToEmoji;
exports.LogLevelToColor = __export_LogLevelToColor;
exports.LogLevelToBackgroundColor = __export_LogLevelToBackgroundColor;
exports.default = NodeLogger;
//# sourceMappingURL=NodeLogger.js.map

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(43);
var LogLevel_1 = __webpack_require__(21);
var BaseLogger_1 = __webpack_require__(44);
var BrowserLogger = /** @class */ (function (_super) {
    tslib_1.__extends(BrowserLogger, _super);
    function BrowserLogger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BrowserLogger.prototype.log = function (level, message) {
        if (level > this._minLevel) {
            return;
        }
        var logFn = LogLevel_1.LogLevelToConsoleFunction[level];
        var formattedMessage = "[" + this._name + "] " + message;
        if (this._timestamps) {
            formattedMessage = "[" + new Date().toISOString() + "] " + message;
        }
        logFn(formattedMessage);
    };
    return BrowserLogger;
}(BaseLogger_1.default));
exports.default = BrowserLogger;
module.exports = exports = BrowserLogger;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BrowserLogger;
//# sourceMappingURL=BrowserLogger.js.map

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(108);
var parse = __webpack_require__(109);
var formats = __webpack_require__(45);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(26);
var formats = __webpack_require__(45);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = obj.join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key') : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key');
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value'))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(26);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj; // eslint-disable-line no-param-reassign
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var ChatBadgeList_1 = __webpack_require__(47);
/**
 * The API methods that deal with badges.
 *
 * Can be accessed using `client.badges` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const cheermotes = await client.badges.getGlobalBadges();
 * ```
 */
var BadgesAPI = /** @class */ (function (_super) {
    tslib_1.__extends(BadgesAPI, _super);
    function BadgesAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves all globally applicable chat badges.
     */
    BadgesAPI.prototype.getGlobalBadges = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'https://badges.twitch.tv/v1/badges/global/display',
                            type: TwitchClient_1.TwitchAPICallType.Custom
                        })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new ChatBadgeList_1.default(data.badge_sets, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves all applicable chat badges for a given channel.
     *
     * @param channel The channel to retrieve the chat badges for.
     * @param includeGlobal Whether to include global badges in the result list.
     */
    BadgesAPI.prototype.getChannelBadges = function (channel, includeGlobal) {
        if (includeGlobal === void 0) { includeGlobal = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, channelBadges;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: "https://badges.twitch.tv/v1/badges/channels/" + UserTools_1.extractUserId(channel) + "/display",
                            type: TwitchClient_1.TwitchAPICallType.Custom
                        })];
                    case 1:
                        data = _a.sent();
                        channelBadges = new ChatBadgeList_1.default(data.badge_sets, this._client);
                        if (!includeGlobal) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getGlobalBadges()];
                    case 2: return [2 /*return*/, (_a.sent())._merge(channelBadges)];
                    case 3: return [2 /*return*/, channelBadges];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], BadgesAPI.prototype, "getGlobalBadges", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], BadgesAPI.prototype, "getChannelBadges", null);
    BadgesAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], BadgesAPI);
    return BadgesAPI;
}(BaseAPI_1.default));
exports.default = BadgesAPI;
module.exports = exports = BadgesAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BadgesAPI;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
function Enumerable(enumerable) {
    if (enumerable === void 0) { enumerable = true; }
    return function (target, key) {
        // first property defined in prototype, that's why we use getters/setters
        // (otherwise assignment in object will override property in prototype)
        Object.defineProperty(target, key, {
            get: function () {
                return;
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            set: function (val) {
                // here we have a reference to the instance and can set property directly to it
                Object.defineProperty(this, key, {
                    value: val,
                    writable: true,
                    enumerable: enumerable
                });
            },
            enumerable: enumerable
        });
    };
}
exports.Enumerable = Enumerable;
/** @deprecated use Enumerable(false) instead */
function NonEnumerable(target, key) {
    return Enumerable(false)(target, key);
}
exports.NonEnumerable = NonEnumerable;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Enumerable = Enumerable;
exports.NonEnumerable = NonEnumerable;
//# sourceMappingURL=Enumerable.js.map

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function flatten(arr) {
    var _a;
    return (_a = []).concat.apply(_a, tslib_1.__spread(arr));
}
exports.flatten = flatten;
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatten = flatten;
//# sourceMappingURL=flatten.js.map

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function resolveConfigValue(value) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            if (typeof value === 'function') {
                return [2 /*return*/, value()];
            }
            return [2 /*return*/, value];
        });
    });
}
exports.resolveConfigValue = resolveConfigValue;
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveConfigValue = resolveConfigValue;
//# sourceMappingURL=resolveConfigValue.js.map

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
// eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/naming-convention
function deprecateClass(Base, msg) {
    var deprecateNoticeShown = false;
    return /** @class */ (function (_super) {
        tslib_1.__extends(class_1, _super);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = this;
            if (!deprecateNoticeShown) {
                // eslint-disable-next-line no-console
                console.warn("[deprecated] " + msg);
                deprecateNoticeShown = true;
            }
            _this = _super.apply(this, tslib_1.__spread(args)) || this;
            return _this;
        }
        return class_1;
    }(Base));
}
exports.deprecateClass = deprecateClass;
Object.defineProperty(exports, "__esModule", { value: true });
exports.deprecateClass = deprecateClass;
//# sourceMappingURL=deprecateClass.js.map

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var matched = function (x) { return ({
    otherwise: function () { return x; },
    on: function () { return matched(x); }
}); };
var match = function (x) { return ({
    on: function (predicate, fn) { return (predicate(x) ? matched(fn(x)) : match(x)); },
    otherwise: function (fn) { return fn(x); }
}); };
exports.match = match;
var __export_eq = function (x) { return function (y) { return x === y; }; };
exports.eq = __export_eq;
match.eq = exports.eq;
Object.defineProperty(exports, "__esModule", { value: true });
exports.match = match;
exports.eq = __export_eq;
//# sourceMappingURL=match.js.map

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var arrayToObject_1 = __webpack_require__(28);
function entriesToObject(obj) {
    return arrayToObject_1.arrayToObject(obj, function (_a) {
        var _b;
        var _c = tslib_1.__read(_a, 2), key = _c[0], val = _c[1];
        return (_b = {}, _b[key] = val, _b);
    });
}
exports.entriesToObject = entriesToObject;
Object.defineProperty(exports, "__esModule", { value: true });
exports.entriesToObject = entriesToObject;
//# sourceMappingURL=entriesToObject.js.map

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function forEachObjectEntry(obj, fn) {
    Object.entries(obj).forEach(function (_a) {
        var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
        return fn(value, key);
    });
}
exports.forEachObjectEntry = forEachObjectEntry;
Object.defineProperty(exports, "__esModule", { value: true });
exports.forEachObjectEntry = forEachObjectEntry;
//# sourceMappingURL=forEachObjectEntry.js.map

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var arrayToObject_1 = __webpack_require__(28);
function indexBy(arr, keyFn) {
    if (typeof keyFn !== 'function') {
        var key_1 = keyFn;
        keyFn = (function (value) { return value[key_1].toString(); });
    }
    return arrayToObject_1.arrayToObject(arr, function (val) {
        var _a;
        return (_a = {}, _a[keyFn(val)] = val, _a);
    });
}
exports.indexBy = indexBy;
Object.defineProperty(exports, "__esModule", { value: true });
exports.indexBy = indexBy;
//# sourceMappingURL=indexBy.js.map

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function mapObject(obj, fn) {
    var mapped = Object.entries(obj).map(
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    function (_a) {
        var _b;
        var _c = tslib_1.__read(_a, 2), key = _c[0], value = _c[1];
        return (_b = {}, _b[key] = fn(value, key), _b);
    });
    return Object.assign.apply(Object, tslib_1.__spread([{}], mapped));
}
exports.mapObject = mapObject;
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapObject = mapObject;
//# sourceMappingURL=mapObject.js.map

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var pick_1 = __webpack_require__(46);
function omit(obj, keys) {
    return pick_1.pick(obj, Object.keys(obj).filter(function (key) { return !keys.includes(key); }));
}
exports.omit = omit;
Object.defineProperty(exports, "__esModule", { value: true });
exports.omit = omit;
//# sourceMappingURL=omit.js.map

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function delay(ms) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, ms); })];
        });
    });
}
exports.delay = delay;
Object.defineProperty(exports, "__esModule", { value: true });
exports.delay = delay;
//# sourceMappingURL=delay.js.map

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function padLeft(str, length, padding) {
    if (typeof str === 'number') {
        str = str.toString();
    }
    length = length - str.length;
    if (length <= 0) {
        return str;
    }
    if (padding === undefined) {
        padding = ' ';
    }
    var paddingStr = '';
    do {
        /* eslint-disable no-bitwise */
        if ((length & 1) === 1) {
            paddingStr += padding;
        }
        length >>= 1;
        if (length) {
            padding += padding;
        }
        /* eslint-enable no-bitwise */
    } while (length);
    return paddingStr + str;
}
exports.padLeft = padLeft;
Object.defineProperty(exports, "__esModule", { value: true });
exports.padLeft = padLeft;
//# sourceMappingURL=padLeft.js.map

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function splitWithLimit(str, delim, count) {
    var parts = str.split(delim);
    if (parts.length <= count) {
        return parts;
    }
    return tslib_1.__spread(parts.slice(0, count - 1), [parts.slice(count - 1).join(delim)]);
}
exports.splitWithLimit = splitWithLimit;
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitWithLimit = splitWithLimit;
//# sourceMappingURL=splitWithLimit.js.map

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function utf8Length(str) {
    return tslib_1.__spread(str).length;
}
exports.utf8Length = utf8Length;
Object.defineProperty(exports, "__esModule", { value: true });
exports.utf8Length = utf8Length;
//# sourceMappingURL=utf8Length.js.map

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function utf8Substring(str, start, end) {
    return tslib_1.__spread(str).slice(start, end).join('');
}
exports.utf8Substring = utf8Substring;
Object.defineProperty(exports, "__esModule", { value: true });
exports.utf8Substring = utf8Substring;
//# sourceMappingURL=utf8Substring.js.map

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var BaseAPI_1 = __webpack_require__(3);
var HelixBitsAPI_1 = __webpack_require__(127);
var HelixClipAPI_1 = __webpack_require__(128);
var HelixExtensionsAPI_1 = __webpack_require__(129);
var HelixGameAPI_1 = __webpack_require__(130);
var HelixModerationAPI_1 = __webpack_require__(131);
var HelixStreamAPI_1 = __webpack_require__(132);
var HelixSubscriptionAPI_1 = __webpack_require__(134);
var HelixUserAPI_1 = __webpack_require__(135);
var HelixVideoAPI_1 = __webpack_require__(136);
var HelixWebHooksAPI_1 = __webpack_require__(137);
/**
 * Groups all API calls available in Helix a.k.a. the "New Twitch API".
 *
 * Can be accessed using {@TwitchClient#helix}.
 */
var HelixAPIGroup = /** @class */ (function (_super) {
    tslib_1.__extends(HelixAPIGroup, _super);
    function HelixAPIGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(HelixAPIGroup.prototype, "bits", {
        /**
         * The Helix bits API methods.
         */
        get: function () {
            return new HelixBitsAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "clips", {
        /**
         * The Helix clips API methods.
         */
        get: function () {
            return new HelixClipAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "extensions", {
        /**
         * The Helix extensions API methods.
         */
        get: function () {
            return new HelixExtensionsAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "games", {
        /**
         * The Helix game API methods.
         */
        get: function () {
            return new HelixGameAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "moderation", {
        /**
         * The Helix moderation API methods.
         */
        get: function () {
            return new HelixModerationAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "streams", {
        /**
         * The Helix stream API methods.
         */
        get: function () {
            return new HelixStreamAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "subscriptions", {
        /**
         * The Helix subscription API methods.
         */
        get: function () {
            return new HelixSubscriptionAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "users", {
        /**
         * The Helix user API methods.
         */
        get: function () {
            return new HelixUserAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "webHooks", {
        /**
         * The Helix WebHook API methods.
         */
        get: function () {
            return new HelixWebHooksAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "videos", {
        /**
         * The Helix video API methods.
         */
        get: function () {
            return new HelixVideoAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "bits", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "clips", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "extensions", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "games", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "moderation", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "streams", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "subscriptions", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "users", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "webHooks", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "videos", null);
    HelixAPIGroup = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], HelixAPIGroup);
    return HelixAPIGroup;
}(BaseAPI_1.default));
exports.default = HelixAPIGroup;
module.exports = exports = HelixAPIGroup;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixAPIGroup;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseAPI_1 = __webpack_require__(3);
var TwitchClient_1 = __webpack_require__(4);
var HelixBitsLeaderboard_1 = __webpack_require__(50);
/**
 * The Helix API methods that deal with bits.
 *
 * Can be accessed using `client.helix.bits` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const leaderboard = await client.helix.bits.getLeaderboard({ period: 'day' });
 * ```
 */
var HelixBitsAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixBitsAPI, _super);
    function HelixBitsAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a bits leaderboard of your channel.
     *
     * @expandParams
     */
    HelixBitsAPI.prototype.getLeaderboard = function (params) {
        if (params === void 0) { params = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, count, _b, period, startDate, contextUserId, result;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = params.count, count = _a === void 0 ? 10 : _a, _b = params.period, period = _b === void 0 ? 'all' : _b, startDate = params.startDate, contextUserId = params.contextUserId;
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'bits/leaderboard',
                                scope: 'bits:read',
                                query: {
                                    count: count.toString(),
                                    period: period,
                                    started_at: startDate ? startDate.toISOString() : undefined,
                                    user_id: contextUserId
                                }
                            })];
                    case 1:
                        result = _c.sent();
                        return [2 /*return*/, new HelixBitsLeaderboard_1.default(result, this._client)];
                }
            });
        });
    };
    return HelixBitsAPI;
}(BaseAPI_1.default));
exports.default = HelixBitsAPI;
module.exports = exports = HelixBitsAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixBitsAPI;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixClip_1 = __webpack_require__(52);
/**
 * The Helix API methods that deal with clips.
 *
 * Can be accessed using `client.helix.clips` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const clipId = await client.helix.clips.createClip({ channelId: '125328655' });
 * ```
 */
var HelixClipAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixClipAPI, _super);
    function HelixClipAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the latest clips for the specified broadcaster.
     *
     * @param userId The broadcaster's user ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForBroadcaster = function (userId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getClips(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'broadcaster_id', ids: userId }))];
            });
        });
    };
    /**
     * Creates a paginator for the latest clips for the specified broadcaster.
     *
     * @param userId The broadcaster's user ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForBroadcasterPaginated = function (userId, filter) {
        if (filter === void 0) { filter = {}; }
        return this._getClipsPaginated(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'broadcaster_id', ids: userId }));
    };
    /**
     * Retrieves the latest clips for the specified game.
     *
     * @param gameId The game ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForGame = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getClips(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'game_id', ids: gameId }))];
            });
        });
    };
    /**
     * Creates a paginator for the latest clips for the specified game.
     *
     * @param gameId The game ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForGamePaginated = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return this._getClipsPaginated(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'game_id', ids: gameId }));
    };
    /**
     * Retrieves the clips identified by the given IDs.
     *
     * @param ids The clip IDs.
     */
    HelixClipAPI.prototype.getClipsByIds = function (ids) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getClips({
                            filterType: 'id',
                            ids: ids
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data];
                }
            });
        });
    };
    /**
     * Retrieves the clip identified by the given ID.
     *
     * @param id The clip ID.
     */
    HelixClipAPI.prototype.getClipById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var clips;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getClipsByIds([id])];
                    case 1:
                        clips = _a.sent();
                        return [2 /*return*/, clips.length ? clips[0] : null];
                }
            });
        });
    };
    /**
     * Creates a clip of a running stream.
     *
     * Returns the ID of the clip.
     *
     * @expandParams
     */
    HelixClipAPI.prototype.createClip = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, _a, createAfterDelay, result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        channelId = params.channelId, _a = params.createAfterDelay, createAfterDelay = _a === void 0 ? false : _a;
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'clips',
                                method: 'POST',
                                scope: 'clips:edit',
                                query: {
                                    broadcaster_id: channelId,
                                    has_delay: createAfterDelay.toString()
                                }
                            })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, result.data[0].id];
                }
            });
        });
    };
    HelixClipAPI.prototype._getClips = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var filterType, ids, startDate, endDate, _a, limit, result;
            var _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        filterType = params.filterType, ids = params.ids, startDate = params.startDate, endDate = params.endDate, _a = params.limit, limit = _a === void 0 ? 20 : _a;
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'clips',
                                query: (_b = {},
                                    _b[filterType] = ids,
                                    _b.started_at = startDate,
                                    _b.ended_at = endDate,
                                    _b.first = limit.toString(),
                                    _b)
                            })];
                    case 1:
                        result = _c.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixClip_1.default, this._client)];
                }
            });
        });
    };
    HelixClipAPI.prototype._getClipsPaginated = function (params) {
        var _a;
        var _this = this;
        var filterType = params.filterType, ids = params.ids, startDate = params.startDate, endDate = params.endDate;
        return new HelixPaginatedRequest_1.default({
            url: 'clips',
            query: (_a = {},
                _a[filterType] = ids,
                _a.started_at = startDate,
                _a.ended_at = endDate,
                _a)
        }, this._client, function (data) { return new HelixClip_1.default(data, _this._client); });
    };
    return HelixClipAPI;
}(BaseAPI_1.default));
exports.default = HelixClipAPI;
module.exports = exports = HelixClipAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixClipAPI;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixPagination_1 = __webpack_require__(18);
var HelixExtensionTransaction_1 = __webpack_require__(53);
/**
 * The Helix API methods that deal with extensions.
 *
 * Can be accessed using `client.helix.extensions` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const transactions = await client.helix.extionsions.getExtensionTransactions('abcd');
 * ```
 */
var HelixExtensionsAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixExtensionsAPI, _super);
    function HelixExtensionsAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of transactions for the given extension.
     *
     * @param extensionId The ID of the extension to retrieve transactions for.
     * @param filter Additional filters.
     */
    HelixExtensionsAPI.prototype.getExtensionTransactions = function (extensionId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'extensions/transactions',
                            query: tslib_1.__assign({ extension_id: extensionId, id: filter.transactionIds }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixExtensionTransaction_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for transactions for the given extension.
     *
     * @param extensionId The ID of the extension to retrieve transactions for.
     * @param filter Additional filters.
     */
    HelixExtensionsAPI.prototype.getExtensionTransactionsPaginated = function (extensionId, filter) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        return new HelixPaginatedRequest_1.default({
            url: 'extensions/transactions',
            query: {
                extension_id: extensionId,
                id: filter.transactionIds
            }
        }, this._client, function (data) { return new HelixExtensionTransaction_1.default(data, _this._client); });
    };
    return HelixExtensionsAPI;
}(BaseAPI_1.default));
exports.default = HelixExtensionsAPI;
module.exports = exports = HelixExtensionsAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixExtensionsAPI;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixPagination_1 = __webpack_require__(18);
var HelixGame_1 = __webpack_require__(54);
/**
 * The Helix API methods that deal with games.
 *
 * Can be accessed using `client.helix.games` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const game = await client.helix.games.getGameByName('Hearthstone');
 * ```
 */
var HelixGameAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixGameAPI, _super);
    function HelixGameAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the game data for the given list of game IDs.
     *
     * @param ids The game IDs you want to look up.
     */
    HelixGameAPI.prototype.getGamesByIds = function (ids) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getGames('id', ids)];
            });
        });
    };
    /**
     * Retrieves the game data for the given list of game names.
     *
     * @param names The game names you want to look up.
     */
    HelixGameAPI.prototype.getGamesByNames = function (names) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getGames('name', names)];
            });
        });
    };
    /**
     * Retrieves the game data for the given game ID.
     *
     * @param id The game ID you want to look up.
     */
    HelixGameAPI.prototype.getGameById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var games;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getGames('id', id)];
                    case 1:
                        games = _a.sent();
                        return [2 /*return*/, games.length ? games[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the game data for the given game name.
     *
     * @param name The game name you want to look up.
     */
    HelixGameAPI.prototype.getGameByName = function (name) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var games;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getGames('name', name)];
                    case 1:
                        games = _a.sent();
                        return [2 /*return*/, games.length ? games[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves a list of the most viewed games at the moment.
     *
     * @param pagination Pagination info.
     */
    HelixGameAPI.prototype.getTopGames = function (pagination) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'games/top',
                            query: HelixPagination_1.makePaginationQuery(pagination)
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixGame_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for the most viewed games at the moment.
     */
    HelixGameAPI.prototype.getTopGamesPaginated = function () {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'games/top'
        }, this._client, function (data) { return new HelixGame_1.default(data, _this._client); });
    };
    HelixGameAPI.prototype._getGames = function (filterType, filterValues) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'games',
                            query: (_a = {},
                                _a[filterType] = filterValues,
                                _a)
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, result.data.map(function (entry) { return new HelixGame_1.default(entry, _this._client); })];
                }
            });
        });
    };
    return HelixGameAPI;
}(BaseAPI_1.default));
exports.default = HelixGameAPI;
module.exports = exports = HelixGameAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixGameAPI;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixPagination_1 = __webpack_require__(18);
var HelixBan_1 = __webpack_require__(29);
var HelixBanEvent_1 = __webpack_require__(55);
var HelixModerator_1 = __webpack_require__(30);
var HelixModeratorEvent_1 = __webpack_require__(56);
/**
 * The Helix API methods that deal with moderation.
 *
 * Can be accessed using `client.helix.moderation` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const game = await client.helix.moderation.getBannedUsers('61369223');
 * ```
 */
var HelixModerationAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixModerationAPI, _super);
    function HelixModerationAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of banned users in a given channel.
     *
     * @param channel The channel to retrieve the banned users from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getBannedUsers = function (channel, filter) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/banned',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixBan_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for banned users in a given channel.
     *
     * @param channel The channel to retrieve the banned users from.
     */
    HelixModerationAPI.prototype.getBannedUsersPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/banned',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixBan_1.default(data, _this._client); });
    };
    /**
     * Checks whether a given user is banned in a given channel.
     *
     * @param channel The channel to check for a ban of the given user.
     * @param user The user to check for a ban in the given channel.
     */
    HelixModerationAPI.prototype.checkUserBan = function (channel, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this.getBannedUsers(channel, { userId: userId })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.some(function (ban) { return ban.userId === userId; })];
                }
            });
        });
    };
    /**
     * Retrieves a list of ban events for a given channel.
     *
     * @param channel The channel to retrieve the ban events from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getBanEvents = function (channel, filter) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _this = this;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/banned/events',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _c.sent();
                        return [2 /*return*/, {
                                data: result.data.map(function (data) { return new HelixBanEvent_1.default(data, _this._client); }),
                                cursor: (_b = result.pagination) === null || _b === void 0 ? void 0 : _b.cursor
                            }];
                }
            });
        });
    };
    /**
     * Creates a paginator for ban events for a given channel.
     *
     * @param channel The channel to retrieve the ban events from.
     */
    HelixModerationAPI.prototype.getBanEventsPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/banned/events',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixBanEvent_1.default(data, _this._client); });
    };
    /**
     * Retrieves a list of moderators in a given channel.
     *
     * @param channel The channel to retrieve moderators from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getModerators = function (channel, filter) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/moderators',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixModerator_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for moderators in a given channel.
     *
     * @param channel The channel to retrieve moderators from.
     */
    HelixModerationAPI.prototype.getModeratorsPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/moderators',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixModerator_1.default(data, _this._client); });
    };
    /**
     * Checks whether a given user is a moderator of a given channel.
     *
     * @param channel The channel to check.
     * @param user The user to check.
     */
    HelixModerationAPI.prototype.checkUserMod = function (channel, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this.getModerators(channel, { userId: userId })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.some(function (mod) { return mod.userId === userId; })];
                }
            });
        });
    };
    /**
     * Retrieves a list of moderator events for a given channel.
     *
     * @param channel The channel to retrieve the moderator events from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getModeratorEvents = function (channel, filter) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/moderators/events',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixModeratorEvent_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for moderator events for a given channel.
     *
     * @param channel The channel to retrieve the moderator events from.
     */
    HelixModerationAPI.prototype.getModeratorEventsPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/moderators/events',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixModeratorEvent_1.default(data, _this._client); });
    };
    return HelixModerationAPI;
}(BaseAPI_1.default));
exports.default = HelixModerationAPI;
module.exports = exports = HelixModerationAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixModerationAPI;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var HTTPStatusCodeError_1 = __webpack_require__(19);
var StreamNotLiveError_1 = __webpack_require__(57);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixPagination_1 = __webpack_require__(18);
var HelixStream_1 = __webpack_require__(58);
var HelixStreamMarker_1 = __webpack_require__(59);
var HelixStreamMarkerWithVideo_1 = __webpack_require__(133);
/**
 * The Helix API methods that deal with streams.
 *
 * Can be accessed using `client.helix.streams` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const stream = await client.helix.streams.getStreamByUserId('125328655');
 * ```
 */
var HelixStreamAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixStreamAPI, _super);
    function HelixStreamAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of streams.
     *
     * @expandParams
     */
    HelixStreamAPI.prototype.getStreams = function (filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'streams',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: tslib_1.__assign(tslib_1.__assign({}, HelixPagination_1.makePaginationQuery(filter)), { community_id: filter.community, game_id: filter.game, language: filter.language, type: filter.type, user_id: filter.userId, user_login: filter.userName })
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixStream_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for streams.
     *
     * @expandParams
     */
    HelixStreamAPI.prototype.getStreamsPaginated = function (filter) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        return new HelixPaginatedRequest_1.default({
            url: 'streams',
            query: {
                community_id: filter.community,
                game_id: filter.game,
                language: filter.language,
                type: filter.type,
                user_id: filter.userId,
                user_login: filter.userName
            }
        }, this._client, function (data) { return new HelixStream_1.default(data, _this._client); });
    };
    /**
     * Retrieves the current stream for the given user name.
     *
     * @param user The user name to retrieve the stream for.
     */
    HelixStreamAPI.prototype.getStreamByUserName = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getStreams({ userName: UserTools_1.extractUserName(user) })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.length ? result.data[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the current stream for the given user ID.
     *
     * @param user The user ID to retrieve the stream for.
     */
    HelixStreamAPI.prototype.getStreamByUserId = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getStreams({ userId: UserTools_1.extractUserId(user) })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.length ? result.data[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves a list of all stream markers for an user.
     *
     * @param user The user to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForUser = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getStreamMarkers('user_id', UserTools_1.extractUserId(user))];
            });
        });
    };
    /**
     * Creates a paginator for all stream markers for an user.
     *
     * @param user The user to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForUserPaginated = function (user) {
        return this._getStreamMarkersPaginated('user_id', UserTools_1.extractUserId(user));
    };
    /**
     * Retrieves a list of all stream markers for a video.
     *
     * @param videoId The video to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForVideo = function (videoId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getStreamMarkers('video_id', videoId)];
            });
        });
    };
    /**
     * Creates a paginator for all stream markers for a video.
     *
     * @param videoId The video to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForVideoPaginated = function (videoId) {
        return this._getStreamMarkersPaginated('video_id', videoId);
    };
    /**
     * Creates a new stream marker.
     *
     * Only works while the specified user's stream is live.
     */
    HelixStreamAPI.prototype.createStreamMarker = function (userId, description) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'streams/markers',
                                method: 'POST',
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                scope: 'user:edit:broadcast',
                                query: {
                                    user_id: userId,
                                    description: description
                                }
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new HelixStreamMarker_1.default(result.data[0], this._client)];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default && e_1.statusCode === 404) {
                            throw new StreamNotLiveError_1.default();
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    HelixStreamAPI.prototype._getStreamMarkers = function (queryType, id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'streams/markers',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: (_a = {},
                                _a[queryType] = id,
                                _a),
                            scope: 'user:read:broadcast'
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, {
                                data: shared_utils_1.flatten(result.data.map(HelixStreamAPI._mapGetStreamMarkersResult.bind(this._client))),
                                cursor: result.pagination && result.pagination.cursor
                            }];
                }
            });
        });
    };
    HelixStreamAPI.prototype._getStreamMarkersPaginated = function (queryType, id) {
        var _a;
        return new HelixPaginatedRequest_1.default({
            url: 'streams/markers',
            query: (_a = {},
                _a[queryType] = id,
                _a),
            scope: 'user:read:broadcast'
        }, this._client, HelixStreamAPI._mapGetStreamMarkersResult.bind(this._client));
    };
    HelixStreamAPI._mapGetStreamMarkersResult = function (data) {
        var _this = this;
        return data.videos.reduce(function (result, video) { return tslib_1.__spread(result, video.markers.map(function (marker) { return new HelixStreamMarkerWithVideo_1.default(marker, video.video_id, _this); })); }, []);
    };
    return HelixStreamAPI;
}(BaseAPI_1.default));
exports.default = HelixStreamAPI;
module.exports = exports = HelixStreamAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixStreamAPI;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixStreamMarker_1 = __webpack_require__(59);
var HelixStreamMarkerWithVideo = /** @class */ (function (_super) {
    tslib_1.__extends(HelixStreamMarkerWithVideo, _super);
    /** @private */
    function HelixStreamMarkerWithVideo(data, _videoId, client) {
        var _this = _super.call(this, data, client) || this;
        _this._videoId = _videoId;
        return _this;
    }
    Object.defineProperty(HelixStreamMarkerWithVideo.prototype, "url", {
        /**
         * The URL of the video, which will start playing at the position of the stream marker.
         */
        get: function () {
            return this._data.URL;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarkerWithVideo.prototype, "videoId", {
        /**
         * The ID of the video.
         */
        get: function () {
            return this._videoId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the video data of the video the marker was set in.
     */
    HelixStreamMarkerWithVideo.prototype.getVideo = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.videos.getVideoById(this._videoId)];
            });
        });
    };
    return HelixStreamMarkerWithVideo;
}(HelixStreamMarker_1.default));
exports.default = HelixStreamMarkerWithVideo;
module.exports = exports = HelixStreamMarkerWithVideo;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixStreamMarkerWithVideo;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixSubscription_1 = __webpack_require__(31);
var HelixSubscriptionEvent_1 = __webpack_require__(60);
/**
 * The Helix API methods that deal with subscriptions.
 *
 * Can be accessed using `client.helix.subscriptions` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const subscriptions = await client.helix.subscriptions.getSubscriptionsForUsers('61369223', '125328655');
 * ```
 */
var HelixSubscriptionAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixSubscriptionAPI, _super);
    function HelixSubscriptionAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of all subscriptions to a given broadcaster.
     *
     * @param broadcaster The broadcaster to list subscriptions to.
     */
    HelixSubscriptionAPI.prototype.getSubscriptions = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'subscriptions',
                            scope: 'channel:read:subscriptions',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: {
                                broadcaster_id: UserTools_1.extractUserId(broadcaster)
                            }
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixSubscription_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for all subscriptions to a given broadcaster.
     *
     * @param broadcaster The broadcaster to list subscriptions to.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionsPaginated = function (broadcaster) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'subscriptions',
            scope: 'channel:read:subscriptions',
            query: {
                broadcaster_id: UserTools_1.extractUserId(broadcaster)
            }
        }, this._client, function (data) { return new HelixSubscription_1.default(data, _this._client); });
    };
    /**
     * Retrieves the subset of the given user list that is subscribed to the given broadcaster.
     *
     * @param broadcaster The broadcaster to find subscriptions to.
     * @param users The users that should be checked for subscriptions.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionsForUsers = function (broadcaster, users) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'subscriptions',
                            scope: 'channel:read:subscriptions',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: {
                                broadcaster_id: UserTools_1.extractUserId(broadcaster),
                                user_id: users.map(UserTools_1.extractUserId)
                            }
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.map(function (data) { return new HelixSubscription_1.default(data, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for a given user to a given broadcaster.
     *
     * @param broadcaster The broadcaster to check.
     * @param user The user to check.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionForUser = function (broadcaster, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var list;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getSubscriptionsForUsers(broadcaster, [user])];
                    case 1:
                        list = _a.sent();
                        return [2 /*return*/, list.length ? list[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the most recent subscription events for a given broadcaster.
     *
     * @param broadcaster The broadcaster to retrieve subscription events for.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionEventsForBroadcaster = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getSubscriptionEvents('broadcaster_id', UserTools_1.extractUserId(broadcaster))];
            });
        });
    };
    /**
     * Creates a paginator for the recent subscription events for a given broadcaster.
     *
     * @param broadcaster The broadcaster to retrieve subscription events for.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionEventsForBroadcasterPaginated = function (broadcaster) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'subscriptions/events',
            scope: 'channel:read:subscriptions',
            query: {
                broadcaster_id: UserTools_1.extractUserId(broadcaster)
            }
        }, this._client, function (data) { return new HelixSubscriptionEvent_1.default(data, _this._client); });
    };
    /**
     * Retrieves a single subscription event by ID.
     *
     * @param id The event ID.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionEventById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getSubscriptionEvents('id', id)];
            });
        });
    };
    HelixSubscriptionAPI.prototype._getSubscriptionEvents = function (by, id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'subscriptions/events',
                            scope: 'channel:read:subscriptions',
                            query: (_a = {},
                                _a[by] = id,
                                _a)
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixSubscriptionEvent_1.default, this._client)];
                }
            });
        });
    };
    return HelixSubscriptionAPI;
}(BaseAPI_1.default));
exports.default = HelixSubscriptionAPI;
module.exports = exports = HelixSubscriptionAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixSubscriptionAPI;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HellFreezesOverError_1 = __webpack_require__(20);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequestWithTotal_1 = __webpack_require__(61);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixFollow_1 = __webpack_require__(62);
var HelixPrivilegedUser_1 = __webpack_require__(63);
var HelixUser_1 = __webpack_require__(32);
/** @private */
var UserLookupType;
(function (UserLookupType) {
    UserLookupType["Id"] = "id";
    UserLookupType["Login"] = "login";
})(UserLookupType || (UserLookupType = {}));
exports.UserLookupType = UserLookupType;
/**
 * The Helix API methods that deal with users.
 *
 * Can be accessed using `client.helix.users` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const user = await client.helix.users.getUserById('125328655');
 * ```
 */
var HelixUserAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixUserAPI, _super);
    function HelixUserAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the user data for the given list of user IDs.
     *
     * @param userIds The user IDs you want to look up.
     */
    HelixUserAPI.prototype.getUsersByIds = function (userIds) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getUsers(UserLookupType.Id, userIds.map(UserTools_1.extractUserId))];
            });
        });
    };
    /**
     * Retrieves the user data for the given list of user names.
     *
     * @param userNames The user names you want to look up.
     */
    HelixUserAPI.prototype.getUsersByNames = function (userNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getUsers(UserLookupType.Login, userNames.map(UserTools_1.extractUserName))];
            });
        });
    };
    /**
     * Retrieves the user data for the given user ID.
     *
     * @param userId The user ID you want to look up.
     */
    HelixUserAPI.prototype.getUserById = function (userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var users;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getUsers(UserLookupType.Id, UserTools_1.extractUserId(userId))];
                    case 1:
                        users = _a.sent();
                        return [2 /*return*/, users.length ? users[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user name.
     *
     * @param userName The user name you want to look up.
     */
    HelixUserAPI.prototype.getUserByName = function (userName) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var users;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getUsers(UserLookupType.Login, UserTools_1.extractUserName(userName))];
                    case 1:
                        users = _a.sent();
                        return [2 /*return*/, users.length ? users[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the user data of the currently authenticated user.
     *
     * @param withEmail Whether you need the user's email address.
     */
    HelixUserAPI.prototype.getMe = function (withEmail) {
        if (withEmail === void 0) { withEmail = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'users',
                            scope: withEmail ? 'user:read:email' : ''
                        })];
                    case 1:
                        result = _a.sent();
                        if (!result.data || !result.data.length) {
                            throw new HellFreezesOverError_1.default('Could not get authenticated user');
                        }
                        return [2 /*return*/, new HelixPrivilegedUser_1.default(result.data[0], this._client)];
                }
            });
        });
    };
    /**
     * Updates the currently authenticated user's data.
     *
     * @param data The data to update.
     */
    HelixUserAPI.prototype.updateUser = function (data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'users',
                            method: 'PUT',
                            scope: 'user:edit',
                            query: {
                                description: data.description
                            }
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new HelixPrivilegedUser_1.default(result.data[0], this._client)];
                }
            });
        });
    };
    /**
     * Retrieves a list of follow relations.
     *
     * @param filter Several filtering and pagination parameters. See the {@HelixFollowFilter} documentation.
     */
    HelixUserAPI.prototype.getFollows = function (filter) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = HelixUserAPI._makeFollowsQuery(filter);
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'users/follows',
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                query: query
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResultWithTotal(result, HelixFollow_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for follow relations.
     *
     * @param filter Several filtering and pagination parameters. See the {@HelixFollowFilter} documentation.
     */
    HelixUserAPI.prototype.getFollowsPaginated = function (filter) {
        var _this = this;
        var query = HelixUserAPI._makeFollowsQuery(filter);
        return new HelixPaginatedRequestWithTotal_1.default({
            url: 'users/follows',
            query: query
        }, this._client, function (data) { return new HelixFollow_1.default(data, _this._client); });
    };
    HelixUserAPI._makeFollowsQuery = function (filter) {
        var query = {};
        var hasUserIdParam = false;
        if (filter.user) {
            query.from_id = UserTools_1.extractUserId(filter.user);
            hasUserIdParam = true;
        }
        if (filter.followedUser) {
            query.to_id = UserTools_1.extractUserId(filter.followedUser);
            hasUserIdParam = true;
        }
        if (!hasUserIdParam) {
            throw new TypeError('At least one of user and followedUser have to be set');
        }
        return query;
    };
    HelixUserAPI.prototype._getUsers = function (lookupType, param) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, result;
            var _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        query = (_a = {}, _a[lookupType] = param, _a);
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'users',
                                query: query
                            })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, result.data.map(function (userData) { return new HelixUser_1.default(userData, _this._client); })];
                }
            });
        });
    };
    return HelixUserAPI;
}(BaseAPI_1.default));
exports.default = HelixUserAPI;
module.exports = exports = HelixUserAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserLookupType = UserLookupType;
exports.default = HelixUserAPI;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPagination_1 = __webpack_require__(18);
var HelixVideo_1 = __webpack_require__(64);
/**
 * The Helix API methods that deal with videos.
 *
 * Can be accessed using `client.helix.videos` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const videos = await client.helix.videos.getVideosByUser('125328655');
 * ```
 */
var HelixVideoAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixVideoAPI, _super);
    function HelixVideoAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the video data for the given list of video IDs.
     *
     * @param ids The video IDs you want to look up.
     */
    HelixVideoAPI.prototype.getVideosByIds = function (ids) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getVideos('id', ids)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data];
                }
            });
        });
    };
    /**
     * Retrieves the video data for the given video ID.
     *
     * @param id The video ID you want to look up.
     */
    HelixVideoAPI.prototype.getVideoById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var videos;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getVideosByIds(id)];
                    case 1:
                        videos = _a.sent();
                        return [2 /*return*/, videos.length ? videos[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the videos of the given user.
     *
     * @param user The user you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByUser = function (user, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this._getVideos('user_id', userId, filter)];
            });
        });
    };
    /**
     * Creates a paginator for videos of the given user.
     *
     * @param user The user you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByUserPaginated = function (user, filter) {
        if (filter === void 0) { filter = {}; }
        var userId = UserTools_1.extractUserId(user);
        return this._getVideosPaginated('user_id', userId, filter);
    };
    /**
     * Retrieves the videos of the given game.
     *
     * @param gameId The game you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByGame = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getVideos('game_id', gameId, filter)];
            });
        });
    };
    /**
     * Creates a paginator for videos of the given game.
     *
     * @param gameId The game you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByGamePaginated = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return this._getVideosPaginated('game_id', gameId, filter);
    };
    HelixVideoAPI.prototype._getVideos = function (filterType, filterValues, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'videos',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: tslib_1.__assign(tslib_1.__assign({}, HelixVideoAPI._makeVideosQuery(filterType, filterValues, filter)), HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, {
                                data: result.data.map(function (data) { return new HelixVideo_1.default(data, _this._client); }),
                                cursor: result.pagination && result.pagination.cursor
                            }];
                }
            });
        });
    };
    HelixVideoAPI.prototype._getVideosPaginated = function (filterType, filterValues, filter) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        return new HelixPaginatedRequest_1.default({
            url: 'videos',
            query: HelixVideoAPI._makeVideosQuery(filterType, filterValues, filter)
        }, this._client, function (data) { return new HelixVideo_1.default(data, _this._client); });
    };
    HelixVideoAPI._makeVideosQuery = function (filterType, filterValues, filter) {
        var _a;
        if (filter === void 0) { filter = {}; }
        var language = filter.language, period = filter.period, orderBy = filter.orderBy, type = filter.type;
        return _a = {},
            _a[filterType] = filterValues,
            _a.language = language,
            _a.period = period,
            _a.sort = orderBy,
            _a.type = type,
            _a;
    };
    return HelixVideoAPI;
}(BaseAPI_1.default));
exports.default = HelixVideoAPI;
module.exports = exports = HelixVideoAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixVideoAPI;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequestWithTotal_1 = __webpack_require__(61);
var HelixWebHookSubscription_1 = __webpack_require__(138);
/**
 * The API methods that deal with WebHooks.
 *
 * Can be accessed using `client.helix.webHooks` on a {@TwitchClient} instance.
 *
 * ## Before using these methods...
 *
 * All of the methods in this class assume that you are already running a working WebHook listener at the given callback URL.
 *
 * If you don't already have one, we recommend use of the `twitch-webhooks` library, which handles subscribing and unsubscribing to these topics automatically.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const accepted = await client.helix.webHooks.subscribeToUserFollowsTo('125328655', { callbackUrl: 'https://example.com' });
 * ```
 */
var HelixWebHooksAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixWebHooksAPI, _super);
    function HelixWebHooksAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the current WebHook subscriptions for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     */
    HelixWebHooksAPI.prototype.getSubscriptions = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new HelixPaginatedRequestWithTotal_1.default({
                        url: 'webhooks/subscriptions'
                    }, this._client, function (data) { return new HelixWebHookSubscription_1.default(data, _this._client); })];
            });
        });
    };
    /**
     * Sends an arbitrary request to subscribe to or unsubscribe from an event.
     *
     * @expandParams
     */
    HelixWebHooksAPI.prototype.sendHubRequest = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var mode, callbackUrl, topicUrl, _a, validityInSeconds, secret, scope;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        mode = options.mode, callbackUrl = options.callbackUrl, topicUrl = options.topicUrl, _a = options.validityInSeconds, validityInSeconds = _a === void 0 ? 3600 : _a, secret = options.secret, scope = options.scope;
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'webhooks/hub',
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                method: 'POST',
                                scope: scope,
                                jsonBody: {
                                    'hub.mode': mode,
                                    'hub.topic': topicUrl,
                                    'hub.callback': callbackUrl,
                                    'hub.lease_seconds': mode === 'subscribe' ? validityInSeconds.toString() : undefined,
                                    'hub.secret': secret
                                }
                            })];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Subscribes to events representing a user following other users.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about the users they will follow.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToUserFollowsFrom = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('subscribe', 'from', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a user being followed by other users.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about the users they will be followed by.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToUserFollowsTo = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('subscribe', 'to', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user following other users.
     *
     * @expandParams
     *
     * @param user The user for which to not get any more notifications about the users they will follow.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromUserFollowsFrom = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('unsubscribe', 'from', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user being followed by other users.
     *
     * @expandParams
     *
     * @param user The user for which to not get any more notifications about the users they will be followed by.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromUserFollowsTo = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('unsubscribe', 'to', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a stream changing, i.e. going live, offline or changing its title or category.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about their streams changing.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToStreamChanges = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendStreamChangeHubRequest('subscribe', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a stream changing.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about their streams changing.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromStreamChanges = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendStreamChangeHubRequest('unsubscribe', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a user changing a public setting or their email address.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about changing a setting.
     * @param options
     * @param withEmail Whether to subscribe to email address changes. This adds the necessary scope to read the email address to the request.
     */
    HelixWebHooksAPI.prototype.subscribeToUserChanges = function (user, options, withEmail) {
        if (withEmail === void 0) { withEmail = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserChangeHubRequest('subscribe', user, options, withEmail)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user changing a public setting or their email address.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about changing a setting.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromUserChanges = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserChangeHubRequest('unsubscribe', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing the start or end of a channel subscription.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about subscriptions to their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToSubscriptionEvents = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendSubscriptionEventsHubRequest('subscribe', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing the start or end of a channel subscription.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about subscriptions and unsubscriptions to their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromSubscriptionEvents = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendSubscriptionEventsHubRequest('unsubscribe', user, options)];
            });
        });
    };
    /**
     * Subscribes to extension transactions.
     *
     * @expandParams
     *
     * @param extensionId The extension ID for which to get notifications about transactions.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToExtensionTransactions = function (extensionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendExtensionTransactionsHubRequest('subscribe', extensionId, options)];
            });
        });
    };
    /**
     * Unsubscribes from extension transactions.
     *
     * @expandParams
     *
     * @param extensionId The extension ID for which not to get any more notifications about transactions.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromExtensionTransactions = function (extensionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendExtensionTransactionsHubRequest('unsubscribe', extensionId, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about bans or unbans in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToBanEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('subscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about bans or unbans in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromBanEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('unsubscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about bans or unbans in their channel.
     * @param user The user that is being banned or unbanned.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToBanEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('subscribe', broadcaster, options, user)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about bans or unbans in their channel.
     * @param user The user that is being banned or unbanned.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromBanEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('unsubscribe', broadcaster, options, user)];
            });
        });
    };
    /**
     * Subscribes to events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about moderator changes in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToModeratorEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('subscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about moderator changes in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromModeratorEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('unsubscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about moderator changes in their channel.
     * @param user The user that is being modded or unmodded.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToModeratorEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('subscribe', broadcaster, options, user)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about moderator changes in their channel.
     * @param user The user that is being modded or unmodded.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromModeratorEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('unsubscribe', broadcaster, options, user)];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendUserFollowsHubRequest = function (mode, direction, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/users/follows?first=1&" + direction + "_id=" + userId }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendStreamChangeHubRequest = function (mode, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/streams?user_id=" + userId }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendUserChangeHubRequest = function (mode, user, options, withEmail) {
        if (withEmail === void 0) { withEmail = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/users?id=" + userId, scope: withEmail ? 'user:read:email' : undefined }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendSubscriptionEventsHubRequest = function (mode, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/subscriptions/events?broadcaster_id=" + userId + "&first=1", scope: 'channel:read:subscriptions' }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendExtensionTransactionsHubRequest = function (mode, extensionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/extensions/transactions?extension_id=" + extensionId + "&first=1" }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendBanEventsHubRequest = function (mode, broadcaster, options, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId, topicUrl;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = UserTools_1.extractUserId(broadcaster);
                topicUrl = "https://api.twitch.tv/helix/moderation/banned/events?broadcaster_id=" + broadcasterId + "&first=1";
                if (user) {
                    topicUrl += "&user_id=" + UserTools_1.extractUserId(user);
                }
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode,
                        topicUrl: topicUrl, scope: 'moderation:read' }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendModeratorEventsHubRequest = function (mode, broadcaster, options, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId, topicUrl;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = UserTools_1.extractUserId(broadcaster);
                topicUrl = "https://api.twitch.tv/helix/moderation/moderators/events?broadcaster_id=" + broadcasterId + "&first=1";
                if (user) {
                    topicUrl += "&user_id=" + UserTools_1.extractUserId(user);
                }
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode,
                        topicUrl: topicUrl, scope: 'moderation:read' }, options))];
            });
        });
    };
    return HelixWebHooksAPI;
}(BaseAPI_1.default));
exports.default = HelixWebHooksAPI;
module.exports = exports = HelixWebHooksAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixWebHooksAPI;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A subscription to a Twitch WebHook.
 */
var HelixWebHookSubscription = /** @class */ (function () {
    /** @private */
    function HelixWebHookSubscription(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixWebHookSubscription.prototype, "topicUrl", {
        /**
         * The topic the WebHook is listening to.
         */
        get: function () {
            return this._data.topic;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixWebHookSubscription.prototype, "callbackUrl", {
        /**
         * The URL that will be called for every subscribed event.
         */
        get: function () {
            return this._data.callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixWebHookSubscription.prototype, "expiryDate", {
        /**
         * The time when the subscription will expire.
         */
        get: function () {
            return new Date(this._data.expires_at);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Unsubscribe from the WebHook.
     */
    HelixWebHookSubscription.prototype.unsubscribe = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.webHooks.sendHubRequest({
                        mode: 'unsubscribe',
                        topicUrl: this.topicUrl,
                        callbackUrl: this.callbackUrl
                    })];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixWebHookSubscription.prototype, "_client", void 0);
    return HelixWebHookSubscription;
}());
exports.default = HelixWebHookSubscription;
module.exports = exports = HelixWebHookSubscription;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixWebHookSubscription;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var rate_limiter_1 = __webpack_require__(140);
var TwitchClient_1 = __webpack_require__(4);
var HelixRateLimiter = /** @class */ (function (_super) {
    tslib_1.__extends(HelixRateLimiter, _super);
    function HelixRateLimiter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HelixRateLimiter.prototype.doRequest = function (_a) {
        var options = _a.options, clientId = _a.clientId, accessToken = _a.accessToken;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_b) {
                return [2 /*return*/, TwitchClient_1.default._callAPIRaw(options, clientId, accessToken)];
            });
        });
    };
    HelixRateLimiter.prototype.needsToRetryAfter = function (res) {
        if (res.status === 429) {
            return +res.headers.get('ratelimit-reset') * 1000 - Date.now();
        }
        return null;
    };
    HelixRateLimiter.prototype.getParametersFromResponse = function (res) {
        var headers = res.headers;
        return {
            limit: +headers.get('ratelimit-limit'),
            remaining: +headers.get('ratelimit-remaining'),
            resetsAt: +headers.get('ratelimit-reset') * 1000
        };
    };
    return HelixRateLimiter;
}(rate_limiter_1.ResponseBasedRateLimiter));
exports.default = HelixRateLimiter;
module.exports = exports = HelixRateLimiter;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixRateLimiter;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ResponseBasedRateLimiter_1 = __webpack_require__(141);
exports.ResponseBasedRateLimiter = ResponseBasedRateLimiter_1.ResponseBasedRateLimiter;
var RetryAfterError_1 = __webpack_require__(87);
exports.RetryAfterError = RetryAfterError_1.RetryAfterError;
//# sourceMappingURL=index.js.map

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(33);
var logger_1 = __webpack_require__(142);
var promise_allsettled_1 = __webpack_require__(145);
var RetryAfterError_1 = __webpack_require__(87);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var ResponseBasedRateLimiter = /** @class */ (function () {
    function ResponseBasedRateLimiter(logLevel) {
        this._queue = [];
        this._batchRunning = false;
        this._logger = new logger_1.Logger({ name: 'rate-limiter', minLevel: logLevel, emoji: true });
    }
    ResponseBasedRateLimiter.prototype.request = function (req) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var reqSpec = {
                            req: req,
                            resolve: resolve,
                            reject: reject
                        };
                        if (_this._batchRunning || _this._nextBatchTimer) {
                            _this._queue.push(reqSpec);
                        }
                        else {
                            _this._runRequestBatch([reqSpec]);
                        }
                    })];
            });
        });
    };
    ResponseBasedRateLimiter.prototype._runRequestBatch = function (reqSpecs) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var promises, settledPromises, rejectedPromises, now, retryAt, retryAfter, params, delay;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._batchRunning = true;
                        if (this._parameters) {
                            this._logger.debug1("remaining requests: " + this._parameters.remaining);
                        }
                        this._logger.debug2("doing " + reqSpecs.length + " requests, new queue length is " + this._queue.length);
                        promises = reqSpecs.map(function (reqSpec) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var req, resolve, reject, result, retry, params, e_1;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        req = reqSpec.req, resolve = reqSpec.resolve, reject = reqSpec.reject;
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, this.doRequest(req)];
                                    case 2:
                                        result = _a.sent();
                                        retry = this.needsToRetryAfter(result);
                                        if (retry !== null) {
                                            this._queue.unshift(reqSpec);
                                            this._logger.info("Retrying after " + retry + " ms");
                                            throw new RetryAfterError_1.RetryAfterError(retry);
                                        }
                                        params = this.getParametersFromResponse(result);
                                        resolve(result);
                                        return [2 /*return*/, params];
                                    case 3:
                                        e_1 = _a.sent();
                                        if (e_1 instanceof RetryAfterError_1.RetryAfterError) {
                                            throw e_1;
                                        }
                                        reject(e_1);
                                        return [2 /*return*/, undefined];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); });
                        return [4 /*yield*/, (0, promise_allsettled_1.default)(promises)];
                    case 1:
                        settledPromises = _a.sent();
                        rejectedPromises = settledPromises.filter(function (p) { return p.status === 'rejected'; });
                        now = Date.now();
                        if (rejectedPromises.length) {
                            retryAt = Math.max.apply(Math, tslib_1.__spread([now], rejectedPromises.map(function (p) { return p.reason.retryAt; })));
                            retryAfter = retryAt - now;
                            this._logger.warn("waiting for " + retryAfter + " ms because the rate limit was exceeded");
                            this._nextBatchTimer = setTimeout(function () {
                                _this._parameters = undefined;
                                _this._runNextBatch();
                            }, retryAfter);
                        }
                        else {
                            params = settledPromises
                                .map(function (p) { return p.value; })
                                .filter(function (v) { return v !== undefined; })
                                .reduce(function (carry, v) {
                                if (!carry) {
                                    return v;
                                }
                                // return v.resetsAt > carry.resetsAt ? v : carry;
                                return v.remaining < carry.remaining ? v : carry;
                            }, undefined);
                            this._batchRunning = false;
                            if (params) {
                                this._parameters = params;
                                if (params.resetsAt < now || params.remaining > 0) {
                                    this._runNextBatch();
                                }
                                else {
                                    delay = params.resetsAt - now;
                                    this._logger.warn("Waiting for " + delay + " ms because the rate limit was reached");
                                    this._nextBatchTimer = setTimeout(function () {
                                        _this._parameters = undefined;
                                        _this._runNextBatch();
                                    }, delay);
                                }
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ResponseBasedRateLimiter.prototype._runNextBatch = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var amount, reqSpecs;
            return tslib_1.__generator(this, function (_a) {
                if (this._nextBatchTimer) {
                    clearTimeout(this._nextBatchTimer);
                    this._nextBatchTimer = undefined;
                }
                amount = this._parameters ? Math.min(this._parameters.remaining, this._parameters.limit / 10) : 1;
                reqSpecs = this._queue.splice(0, amount);
                if (reqSpecs.length) {
                    this._runRequestBatch(reqSpecs);
                }
                return [2 /*return*/];
            });
        });
    };
    return ResponseBasedRateLimiter;
}());
exports.ResponseBasedRateLimiter = ResponseBasedRateLimiter;
//# sourceMappingURL=ResponseBasedRateLimiter.js.map

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable filenames/match-exported */
var isNode = __webpack_require__(14);
var NodeLogger_1 = __webpack_require__(143);
var BrowserLogger_1 = __webpack_require__(144);
var Logger = isNode ? NodeLogger_1.NodeLogger : BrowserLogger_1.BrowserLogger;
exports.Logger = Logger;
var LogLevel_1 = __webpack_require__(22);
exports.LogLevel = LogLevel_1.LogLevel;
//# sourceMappingURL=index.js.map

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(65);
var LogLevel_1 = __webpack_require__(22);
var BaseLogger_1 = __webpack_require__(66);
exports.LogLevelToEmoji = (_a = {},
    _a[LogLevel_1.LogLevel.CRITICAL] = "\uD83D\uDED1",
    _a[LogLevel_1.LogLevel.ERROR] = "\u274C",
    // these following two need extra spaces at the end because somehow they consume less space in a terminal than they should...
    _a[LogLevel_1.LogLevel.WARNING] = "\u26A0\uFE0F ",
    _a[LogLevel_1.LogLevel.INFO] = "\u2139\uFE0F ",
    _a[LogLevel_1.LogLevel.DEBUG] = "\uD83D\uDC1E",
    _a[LogLevel_1.LogLevel.TRACE] = "\uD83D\uDC3E",
    _a);
var colors = {
    black: 30,
    red: 31,
    green: 32,
    yellow: 33,
    blue: 34,
    magenta: 35,
    cyan: 36,
    white: 37,
    blackBright: 90,
    redBright: 91,
    greenBright: 92,
    yellowBright: 93,
    blueBright: 94,
    magentaBright: 95,
    cyanBright: 96,
    whiteBright: 97
};
var bgColors = {
    bgBlack: 40,
    bgRed: 41,
    bgGreen: 42,
    bgYellow: 43,
    bgBlue: 44,
    bgMagenta: 45,
    bgCyan: 46,
    bgWhite: 47,
    bgBlackBright: 100,
    bgRedBright: 101,
    bgGreenBright: 102,
    bgYellowBright: 103,
    bgBlueBright: 104,
    bgMagentaBright: 105,
    bgCyanBright: 106,
    bgWhiteBright: 107
};
function createGenericWrapper(color, ending, inner) {
    return function (str) { return "\u001B[" + color + "m" + (inner ? inner(str) : str) + "\u001B[" + ending + "m"; };
}
function createColorWrapper(color) {
    return createGenericWrapper(colors[color], 39);
}
function createBgWrapper(color, fgWrapper) {
    return createGenericWrapper(bgColors[color], 49, fgWrapper);
}
exports.LogLevelToColor = (_b = {},
    _b[LogLevel_1.LogLevel.CRITICAL] = createColorWrapper('red'),
    _b[LogLevel_1.LogLevel.ERROR] = createColorWrapper('redBright'),
    _b[LogLevel_1.LogLevel.WARNING] = createColorWrapper('yellow'),
    _b[LogLevel_1.LogLevel.INFO] = createColorWrapper('blue'),
    _b[LogLevel_1.LogLevel.DEBUG] = createColorWrapper('magenta'),
    _b[LogLevel_1.LogLevel.TRACE] = createGenericWrapper(0, 0),
    _b);
exports.LogLevelToBackgroundColor = (_c = {},
    _c[LogLevel_1.LogLevel.CRITICAL] = createBgWrapper('bgRed', createColorWrapper('white')),
    _c[LogLevel_1.LogLevel.ERROR] = createBgWrapper('bgRedBright', createColorWrapper('white')),
    _c[LogLevel_1.LogLevel.WARNING] = createBgWrapper('bgYellow', createColorWrapper('black')),
    _c[LogLevel_1.LogLevel.INFO] = createBgWrapper('bgBlue', createColorWrapper('white')),
    _c[LogLevel_1.LogLevel.DEBUG] = createBgWrapper('bgMagenta', createColorWrapper('black')),
    _c[LogLevel_1.LogLevel.TRACE] = createGenericWrapper(7, 27),
    _c);
var NodeLogger = /** @class */ (function (_super) {
    tslib_1.__extends(NodeLogger, _super);
    function NodeLogger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeLogger.prototype.log = function (level, message) {
        if (level > this._minLevel) {
            return;
        }
        var logFn = LogLevel_1.LogLevelToConsoleFunction[level];
        var builtMessage = '';
        if (this._timestamps) {
            builtMessage += "[" + new Date().toISOString() + "] ";
        }
        if (this._emoji) {
            var emoji = exports.LogLevelToEmoji[level];
            builtMessage += emoji + " ";
        }
        if (this._colors) {
            builtMessage += exports.LogLevelToBackgroundColor[level](this._name) + " " + exports.LogLevelToBackgroundColor[level](LogLevel_1.LogLevel[level]) + " " + exports.LogLevelToColor[level](message);
        }
        else {
            builtMessage += "[" + this._name + ":" + LogLevel_1.LogLevel[level].toLowerCase() + "] " + message;
        }
        logFn(builtMessage);
    };
    return NodeLogger;
}(BaseLogger_1.BaseLogger));
exports.NodeLogger = NodeLogger;
//# sourceMappingURL=NodeLogger.js.map

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(65);
var LogLevel_1 = __webpack_require__(22);
var BaseLogger_1 = __webpack_require__(66);
var BrowserLogger = /** @class */ (function (_super) {
    tslib_1.__extends(BrowserLogger, _super);
    function BrowserLogger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BrowserLogger.prototype.log = function (level, message) {
        if (level > this._minLevel) {
            return;
        }
        var logFn = LogLevel_1.LogLevelToConsoleFunction[level];
        var formattedMessage = "[" + this._name + "] " + message;
        if (this._timestamps) {
            formattedMessage = "[" + new Date().toISOString() + "] " + message;
        }
        logFn(formattedMessage);
    };
    return BrowserLogger;
}(BaseLogger_1.BaseLogger));
exports.BrowserLogger = BrowserLogger;
//# sourceMappingURL=BrowserLogger.js.map

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var callBind = __webpack_require__(34);
var define = __webpack_require__(24);

var requirePromise = __webpack_require__(25);
var implementation = __webpack_require__(69);
var getPolyfill = __webpack_require__(86);
var shim = __webpack_require__(192);

requirePromise();
var bound = callBind(getPolyfill());

var rebindable = function allSettled(iterable) {
	// eslint-disable-next-line no-invalid-this
	return bound(typeof this === 'undefined' ? Promise : this, iterable);
};

define(rebindable, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = rebindable;
module.exports.default = rebindable;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),
/* 147 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(68);

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(149);

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(68); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var callBound = __webpack_require__(8);

var $PromiseResolve = callBound('Promise.resolve', true);

// https://ecma-international.org/ecma-262/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};



/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://www.ecma-international.org/ecma-262/5.1/#sec-8

module.exports = function Type(x) {
	if (x === null) {
		return 'Null';
	}
	if (typeof x === 'undefined') {
		return 'Undefined';
	}
	if (typeof x === 'function' || typeof x === 'object') {
		return 'Object';
	}
	if (typeof x === 'number') {
		return 'Number';
	}
	if (typeof x === 'boolean') {
		return 'Boolean';
	}
	if (typeof x === 'string') {
		return 'String';
	}
};


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getIterator = __webpack_require__(153);
var $TypeError = TypeError;
var iterate = __webpack_require__(159);

module.exports = function iterateValue(iterable) {
	var iterator = getIterator(iterable);
	if (!iterator) {
		throw new $TypeError('non-iterable value provided');
	}
	if (arguments.length > 1) {
		return iterate(iterator, arguments[1]);
	}
	return iterate(iterator);
};


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/* eslint global-require: 0 */
// the code is structured this way so that bundlers can
// alias out `has-symbols` to `() => true` or `() => false` if your target
// environments' Symbol capabilities are known, and then use
// dead code elimination on the rest of this module.
//
// Similarly, `isarray` can be aliased to `Array.isArray` if
// available in all target environments.

var isArguments = __webpack_require__(155);

if (__webpack_require__(23)() || __webpack_require__(67)()) {
	var $iterator = Symbol.iterator;
	// Symbol is available natively or shammed
	// natively:
	//  - Chrome >= 38
	//  - Edge 12-14?, Edge >= 15 for sure
	//  - FF >= 36
	//  - Safari >= 9
	//  - node >= 0.12
	module.exports = function getIterator(iterable) {
		// alternatively, `iterable[$iterator]?.()`
		if (iterable != null && typeof iterable[$iterator] !== 'undefined') {
			return iterable[$iterator]();
		}
		if (isArguments(iterable)) {
			// arguments objects lack Symbol.iterator
			// - node 0.12
			return Array.prototype[$iterator].call(iterable);
		}
	};
} else {
	// Symbol is not available, native or shammed
	var isArray = __webpack_require__(156);
	var isString = __webpack_require__(70);
	var GetIntrinsic = __webpack_require__(2);
	var $Map = GetIntrinsic('%Map%', true);
	var $Set = GetIntrinsic('%Set%', true);
	var callBound = __webpack_require__(8);
	var $arrayPush = callBound('Array.prototype.push');
	var $charCodeAt = callBound('String.prototype.charCodeAt');
	var $stringSlice = callBound('String.prototype.slice');

	var advanceStringIndex = function advanceStringIndex(S, index) {
		var length = S.length;
		if ((index + 1) >= length) {
			return index + 1;
		}

		var first = $charCodeAt(S, index);
		if (first < 0xD800 || first > 0xDBFF) {
			return index + 1;
		}

		var second = $charCodeAt(S, index + 1);
		if (second < 0xDC00 || second > 0xDFFF) {
			return index + 1;
		}

		return index + 2;
	};

	var getArrayIterator = function getArrayIterator(arraylike) {
		var i = 0;
		return {
			next: function next() {
				var done = i >= arraylike.length;
				var value;
				if (!done) {
					value = arraylike[i];
					i += 1;
				}
				return {
					done: done,
					value: value
				};
			}
		};
	};

	var getNonCollectionIterator = function getNonCollectionIterator(iterable) {
		if (isArray(iterable) || isArguments(iterable)) {
			return getArrayIterator(iterable);
		}
		if (isString(iterable)) {
			var i = 0;
			return {
				next: function next() {
					var nextIndex = advanceStringIndex(iterable, i);
					var value = $stringSlice(iterable, i, nextIndex);
					i = nextIndex;
					return {
						done: nextIndex > iterable.length,
						value: value
					};
				}
			};
		}
	};

	if (!$Map && !$Set) {
		// the only language iterables are Array, String, arguments
		// - Safari <= 6.0
		// - Chrome < 38
		// - node < 0.12
		// - FF < 13
		// - IE < 11
		// - Edge < 11

		module.exports = getNonCollectionIterator;
	} else {
		// either Map or Set are available, but Symbol is not
		// - es6-shim on an ES5 browser
		// - Safari 6.2 (maybe 6.1?)
		// - FF v[13, 36)
		// - IE 11
		// - Edge 11
		// - Safari v[6, 9)

		var isMap = __webpack_require__(157);
		var isSet = __webpack_require__(158);

		// Firefox >= 27, IE 11, Safari 6.2 - 9, Edge 11, es6-shim in older envs, all have forEach
		var $mapForEach = callBound('Map.prototype.forEach', true);
		var $setForEach = callBound('Set.prototype.forEach', true);
		if (typeof process === 'undefined' || !process.versions || !process.versions.node) { // "if is not node"

			// Firefox 17 - 26 has `.iterator()`, whose iterator `.next()` either
			// returns a value, or throws a StopIteration object. These browsers
			// do not have any other mechanism for iteration.
			var $mapIterator = callBound('Map.prototype.iterator', true);
			var $setIterator = callBound('Set.prototype.iterator', true);
			var getStopIterationIterator = function (iterator) {
				var done = false;
				return {
					next: function next() {
						try {
							return {
								done: done,
								value: done ? undefined : iterator.next()
							};
						} catch (e) {
							done = true;
							return {
								done: true,
								value: undefined
							};
						}
					}
				};
			};
		}
		// Firefox 27-35, and some older es6-shim versions, use a string "@@iterator" property
		// this returns a proper iterator object, so we should use it instead of forEach.
		// newer es6-shim versions use a string "_es6-shim iterator_" property.
		var $mapAtAtIterator = callBound('Map.prototype.@@iterator', true) || callBound('Map.prototype._es6-shim iterator_', true);
		var $setAtAtIterator = callBound('Set.prototype.@@iterator', true) || callBound('Set.prototype._es6-shim iterator_', true);

		var getCollectionIterator = function getCollectionIterator(iterable) {
			if (isMap(iterable)) {
				if ($mapIterator) {
					return getStopIterationIterator($mapIterator(iterable));
				}
				if ($mapAtAtIterator) {
					return $mapAtAtIterator(iterable);
				}
				if ($mapForEach) {
					var entries = [];
					$mapForEach(iterable, function (v, k) {
						$arrayPush(entries, [k, v]);
					});
					return getArrayIterator(entries);
				}
			}
			if (isSet(iterable)) {
				if ($setIterator) {
					return getStopIterationIterator($setIterator(iterable));
				}
				if ($setAtAtIterator) {
					return $setAtAtIterator(iterable);
				}
				if ($setForEach) {
					var values = [];
					$setForEach(iterable, function (v) {
						$arrayPush(values, v);
					});
					return getArrayIterator(values);
				}
			}
		};

		module.exports = function getIterator(iterable) {
			return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
		};
	}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(154)))

/***/ }),
/* 154 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr = Object.prototype.toString;

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return toStr.call(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		toStr.call(value) !== '[object Array]' &&
		toStr.call(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),
/* 156 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

var exported;

if (!$Map) {
	// eslint-disable-next-line no-unused-vars
	exported = function isMap(x) {
		// `Map` is not present in this environment.
		return false;
	};
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$mapHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isMap(x) {
		// `Map` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isMap(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$mapHas.call(x);
		if ($setHas) {
			try {
				$setHas.call(x);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $Map; // core-js workaround, pre-v2.5.0
	} catch (e) {}
	return false;
};


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

var exported;

if (!$Set) {
	// eslint-disable-next-line no-unused-vars
	exported = function isSet(x) {
		// `Set` is not present in this environment.
		return false;
	};
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$setHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isSet(x) {
		// `Set` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isSet(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$setHas.call(x);
		if ($mapHas) {
			try {
				$mapHas.call(x);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $Set; // core-js workaround, pre-v2.5.0
	} catch (e) {}
	return false;
};


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
module.exports = function iterateIterator(iterator) {
	if (!iterator || typeof iterator.next !== 'function') {
		throw new $TypeError('iterator must be an object with a `next` method');
	}
	if (arguments.length > 1) {
		var callback = arguments[1];
		if (typeof callback !== 'function') {
			throw new $TypeError('`callback`, if provided, must be a function');
		}
	}
	var values = callback || [];
	var result;
	while ((result = iterator.next()) && !result.done) {
		if (callback) {
			callback(result.value); // eslint-disable-line callback-return
		} else {
			values.push(result.value);
		}
	}
	if (!callback) {
		return values;
	}
};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(24);
var RequireObjectCoercible = __webpack_require__(71);
var callBound = __webpack_require__(8);

var implementation = __webpack_require__(72);
var getPolyfill = __webpack_require__(85);
var polyfill = getPolyfill();
var shim = __webpack_require__(191);

var $slice = callBound('Array.prototype.slice');

// eslint-disable-next-line no-unused-vars
var boundMapShim = function map(array, callbackfn) {
	RequireObjectCoercible(array);
	return polyfill.apply(array, $slice(arguments, 1));
};
define(boundMapShim, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = boundMapShim;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.10

module.exports = function CheckObjectCoercible(value, optMessage) {
	if (value == null) {
		throw new $TypeError(optMessage || ('Cannot call method on ' + value));
	}
	return value;
};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $Array = GetIntrinsic('%Array%');
var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = GetIntrinsic('%TypeError%');

var Get = __webpack_require__(73);
var IsArray = __webpack_require__(74);
var IsConstructor = __webpack_require__(165);
var IsInteger = __webpack_require__(169);
var Type = __webpack_require__(7);

// https://ecma-international.org/ecma-262/6.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!IsInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}
	var len = length === 0 ? 0 : length;
	var C;
	var isArray = IsArray(originalArray);
	if (isArray) {
		C = Get(originalArray, 'constructor');
		// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
		// if (IsConstructor(C)) {
		// 	if C is another realm's Array, C = undefined
		// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
		// }
		if ($species && Type(C) === 'Object') {
			C = Get(C, $species);
			if (C === null) {
				C = void 0;
			}
		}
	}
	if (typeof C === 'undefined') {
		return $Array(len);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(len); // Construct(C, len);
};



/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var match = String.prototype.match;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;

var inspectCustom = __webpack_require__(164).custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean') {
        throw new TypeError('option "customInspect", if provided, must be `true` or `false`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
    }

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        return String(obj);
    }
    if (typeof obj === 'bigint') { // eslint-disable-line valid-typeof
        return String(obj) + 'n';
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function') {
        var name = nameOf(obj);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']';
    }
    if (isSymbol(obj)) {
        var symString = Symbol.prototype.toString.call(obj);
        return typeof obj === 'object' ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + xs.join(', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
            return obj[inspectSymbol]();
        } else if (typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        if (ys.length === 0) { return '{}'; }
        if (indent) {
            return '{' + indentedJoin(ys, indent) + '}';
        }
        return '{ ' + ys.join(', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]'; }
function isDate(obj) { return toStr(obj) === '[object Date]'; }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]'; }
function isError(obj) { return toStr(obj) === '[object Error]'; }
function isSymbol(obj) { return toStr(obj) === '[object Symbol]'; }
function isString(obj) { return toStr(obj) === '[object String]'; }
function isNumber(obj) { return toStr(obj) === '[object Number]'; }
function isBigInt(obj) { return toStr(obj) === '[object BigInt]'; }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]'; }

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = Array(opts.indent + 1).join(' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: Array(depth + 1).join(baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + xs.join(',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if ((/[^\w$]/).test(key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    return xs;
}


/***/ }),
/* 164 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = __webpack_require__(166);
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://www.ecma-international.org/ecma-262/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var isPropertyDescriptor = __webpack_require__(167);
var DefineOwnProperty = __webpack_require__(75);

var FromPropertyDescriptor = __webpack_require__(76);
var IsAccessorDescriptor = __webpack_require__(168);
var IsDataDescriptor = __webpack_require__(77);
var IsPropertyKey = __webpack_require__(16);
var SameValue = __webpack_require__(78);
var ToPropertyDescriptor = __webpack_require__(80);
var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}

	var Desc = isPropertyDescriptor({
		Type: Type,
		IsDataDescriptor: IsDataDescriptor,
		IsAccessorDescriptor: IsAccessorDescriptor
	}, desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor({
		Type: Type,
		IsDataDescriptor: IsDataDescriptor,
		IsAccessorDescriptor: IsAccessorDescriptor
	}, Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var has = __webpack_require__(17);
var $TypeError = GetIntrinsic('%TypeError%');

module.exports = function IsPropertyDescriptor(ES, Desc) {
	if (ES.Type(Desc) !== 'Object') {
		return false;
	}
	var allowed = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Get]]': true,
		'[[Set]]': true,
		'[[Value]]': true,
		'[[Writable]]': true
	};

	for (var key in Desc) { // eslint-disable-line no-restricted-syntax
		if (has(Desc, key) && !allowed[key]) {
			return false;
		}
	}

	if (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {
		throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
	}
	return true;
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(17);

var assertRecord = __webpack_require__(36);

var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-isaccessordescriptor

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	if (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $Math = GetIntrinsic('%Math%');

var $floor = $Math.floor;
var $abs = $Math.abs;

var $isNaN = __webpack_require__(79);
var $isFinite = __webpack_require__(170);

// https://www.ecma-international.org/ecma-262/6.0/#sec-isinteger

module.exports = function IsInteger(argument) {
	if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
		return false;
	}
	var abs = $abs(argument);
	return $floor(abs) === abs;
};


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);
var callBound = __webpack_require__(8);

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('%Function.prototype.apply%');

// https://www.ecma-international.org/ecma-262/6.0/#sec-call

module.exports = function Call(F, V) {
	var args = arguments.length > 2 ? arguments[2] : [];
	return $apply(F, V, args);
};


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var CreateDataProperty = __webpack_require__(173);
var IsPropertyKey = __webpack_require__(16);
var Type = __webpack_require__(7);

// // https://ecma-international.org/ecma-262/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var DefineOwnProperty = __webpack_require__(75);

var FromPropertyDescriptor = __webpack_require__(76);
var OrdinaryGetOwnProperty = __webpack_require__(174);
var IsDataDescriptor = __webpack_require__(77);
var IsExtensible = __webpack_require__(178);
var IsPropertyKey = __webpack_require__(16);
var SameValue = __webpack_require__(78);
var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}
	var oldDesc = OrdinaryGetOwnProperty(O, P);
	var extensible = !oldDesc || IsExtensible(O);
	var immutable = oldDesc && (!oldDesc['[[Writable]]'] || !oldDesc['[[Configurable]]']);
	if (immutable || !extensible) {
		return false;
	}
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		{
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Value]]': V,
			'[[Writable]]': true
		}
	);
};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $gOPD = __webpack_require__(175);
var $TypeError = GetIntrinsic('%TypeError%');

var callBound = __webpack_require__(8);

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var has = __webpack_require__(17);

var IsArray = __webpack_require__(74);
var IsPropertyKey = __webpack_require__(16);
var IsRegExp = __webpack_require__(176);
var ToPropertyDescriptor = __webpack_require__(80);
var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!has(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = __webpack_require__(177);

var ToBoolean = __webpack_require__(81);

// https://ecma-international.org/ecma-262/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!argument || typeof argument !== 'object') {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasSymbols = __webpack_require__(23)();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';
var hasOwnProperty;
var regexExec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag) {
	hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
	regexExec = Function.call.bind(RegExp.prototype.exec);
	isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}
}

var toStr = Object.prototype.toString;
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';

module.exports = hasToStringTag
	// eslint-disable-next-line consistent-return
	? function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		var descriptor = gOPD(value, 'lastIndex');
		var hasLastIndexDataProperty = descriptor && hasOwnProperty(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			regexExec(value, badStringifier);
		} catch (e) {
			return e === isRegexMarker;
		}
	}
	: function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return toStr.call(value) === regexClass;
	};


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $Object = GetIntrinsic('%Object%');

var isPrimitive = __webpack_require__(84);

var $preventExtensions = $Object.preventExtensions;
var $isExtensible = $Object.isExtensible;

// https://www.ecma-international.org/ecma-262/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var IsPropertyKey = __webpack_require__(16);
var Type = __webpack_require__(7);

// https://ecma-international.org/ecma-262/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ToNumber = __webpack_require__(181);

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = __webpack_require__(8);
var regexTester = __webpack_require__(182);
var isPrimitive = __webpack_require__(84);

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

// whitespace from: https://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
var ws = [
	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	'\u2029\uFEFF'
].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var $replace = callBound('String.prototype.replace');
var $trim = function (value) {
	return $replace(value, trimRegex, '');
};

var ToPrimitive = __webpack_require__(183);

// https://www.ecma-international.org/ecma-262/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		} else {
			var trimmed = $trim(value);
			if (trimmed !== value) {
				return ToNumber(trimmed);
			}
		}
	}
	return $Number(value);
};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $test = GetIntrinsic('RegExp.prototype.test');

var callBind = __webpack_require__(34);

module.exports = function regexTester(regex) {
	return callBind($test, regex);
};


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toPrimitive = __webpack_require__(184);

// https://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = __webpack_require__(185);
var isCallable = __webpack_require__(83);
var isDate = __webpack_require__(186);
var isSymbol = __webpack_require__(187);

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
	return void 0;
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (arguments[1] === String) {
			hint = 'string';
		} else if (arguments[1] === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;
var hasSymbols = __webpack_require__(23)();

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isRealSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') {
			return false;
		}
		return symStringRegex.test(symToStr.call(value));
	};

	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') {
			return true;
		}
		if (toStr.call(value) !== '[object Symbol]') {
			return false;
		}
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {

	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return  false && false;
	};
}


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $Object = GetIntrinsic('%Object%');

var RequireObjectCoercible = __webpack_require__(71);

// https://www.ecma-international.org/ecma-262/6.0/#sec-toobject

module.exports = function ToObject(value) {
	RequireObjectCoercible(value);
	return $Object(value);
};


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $String = GetIntrinsic('%String%');
var $TypeError = GetIntrinsic('%TypeError%');

// https://www.ecma-international.org/ecma-262/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};


/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports = function properlyBoxed(method) {
	// Check node 0.6.21 bug where third parameter is not boxed
	var properlyBoxesNonStrict = true;
	var properlyBoxesStrict = true;
	var threwException = false;
	if (typeof method === 'function') {
		try {
			// eslint-disable-next-line max-params
			method.call('f', function (_, __, O) {
				if (typeof O !== 'object') {
					properlyBoxesNonStrict = false;
				}
			});

			method.call(
				[null],
				function () {
					'use strict';

					properlyBoxesStrict = typeof this === 'string'; // eslint-disable-line no-invalid-this
				},
				'x'
			);
		} catch (e) {
			threwException = true;
		}
		return !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
	}
	return false;
};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(24);
var getPolyfill = __webpack_require__(85);

module.exports = function shimArrayPrototypeMap() {
	var polyfill = getPolyfill();
	define(
		Array.prototype,
		{ map: polyfill },
		{ map: function () { return Array.prototype.map !== polyfill; } }
	);
	return polyfill;
};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var requirePromise = __webpack_require__(25);

var getPolyfill = __webpack_require__(86);
var define = __webpack_require__(24);

module.exports = function shimAllSettled() {
	requirePromise();

	var polyfill = getPolyfill();
	define(Promise, { allSettled: polyfill }, {
		allSettled: function testAllSettled() {
			return Promise.allSettled !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(33);
/** @private */
var CustomError = /** @class */ (function (_super) {
    tslib_1.__extends(CustomError, _super);
    function CustomError() {
        var _newTarget = this.constructor;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var _this = _super.apply(this, tslib_1.__spread(params)) || this;
        // restore prototype chain
        var actualProto = _newTarget.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(_this, actualProto);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            _this.__proto__ = actualProto;
        }
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _newTarget.constructor);
        }
        return _this;
    }
    Object.defineProperty(CustomError.prototype, "name", {
        get: function () {
            return this.constructor.name;
        },
        enumerable: true,
        configurable: true
    });
    return CustomError;
}(Error));
exports.CustomError = CustomError;
//# sourceMappingURL=CustomError.js.map

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var BaseAPI_1 = __webpack_require__(3);
var BitsAPI_1 = __webpack_require__(195);
var ChannelAPI_1 = __webpack_require__(196);
var ChatAPI_1 = __webpack_require__(197);
var SearchAPI_1 = __webpack_require__(201);
var StreamAPI_1 = __webpack_require__(202);
var TeamAPI_1 = __webpack_require__(203);
var UserAPI_1 = __webpack_require__(205);
/**
 * Groups all API calls available in Kraken v5.
 *
 * Can be accessed using {@TwitchClient#kraken}.
 */
var KrakenAPIGroup = /** @class */ (function (_super) {
    tslib_1.__extends(KrakenAPIGroup, _super);
    function KrakenAPIGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(KrakenAPIGroup.prototype, "bits", {
        /**
         * The API methods that deal with bits.
         */
        get: function () {
            return new BitsAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "channels", {
        /**
         * The API methods that deal with channels.
         */
        get: function () {
            return new ChannelAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "chat", {
        /**
         * The API methods that deal with chat.
         */
        get: function () {
            return new ChatAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "search", {
        /**
         * The API methods that deal with searching.
         */
        get: function () {
            return new SearchAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "streams", {
        /**
         * The API methods that deal with streams.
         */
        get: function () {
            return new StreamAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "users", {
        /**
         * The API methods that deal with users.
         */
        get: function () {
            return new UserAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "teams", {
        /**
         * The API methods that deal with teams.
         */
        get: function () {
            return new TeamAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "bits", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "channels", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "chat", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "search", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "streams", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "users", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "teams", null);
    KrakenAPIGroup = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], KrakenAPIGroup);
    return KrakenAPIGroup;
}(BaseAPI_1.default));
exports.default = KrakenAPIGroup;
module.exports = exports = KrakenAPIGroup;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = KrakenAPIGroup;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var UserTools_1 = __webpack_require__(6);
var BaseAPI_1 = __webpack_require__(3);
var CheermoteList_1 = __webpack_require__(37);
/**
 * The API methods that deal with Bits/Cheermotes.
 *
 * Can be accessed using `client.kraken.bits` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const cheermotes = await client.kraken.bits.getCheermotes();
 * ```
 */
var BitsAPI = /** @class */ (function (_super) {
    tslib_1.__extends(BitsAPI, _super);
    function BitsAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves global and channel cheermotes.
     *
     * @param channel The channel you want to retrieve the available cheermotes for.
     * If not given, this method retrieves a list of globally available cheermotes.
     * @param includeSponsored Whether to include sponsored cheermotes in the list.
     */
    BitsAPI.prototype.getCheermotes = function (channel, includeSponsored) {
        if (includeSponsored === void 0) { includeSponsored = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = {};
                        if (channel) {
                            query.channel_id = UserTools_1.extractUserId(channel);
                        }
                        if (includeSponsored) {
                            query.include_sponsored = 'true';
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'bits/actions', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new CheermoteList_1.default(data.actions, this._client)];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], BitsAPI.prototype, "getCheermotes", null);
    BitsAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], BitsAPI);
    return BitsAPI;
}(BaseAPI_1.default));
exports.default = BitsAPI;
module.exports = exports = BitsAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BitsAPI;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var HTTPStatusCodeError_1 = __webpack_require__(19);
var NoSubscriptionProgramError_1 = __webpack_require__(15);
var UserTools_1 = __webpack_require__(6);
var BaseAPI_1 = __webpack_require__(3);
var User_1 = __webpack_require__(10);
var Channel_1 = __webpack_require__(13);
var ChannelFollow_1 = __webpack_require__(88);
var ChannelSubscription_1 = __webpack_require__(89);
var PrivilegedChannel_1 = __webpack_require__(90);
var Team_1 = __webpack_require__(40);
/**
 * The API methods that deal with channels.
 *
 * Can be accessed using `client.kraken.channels` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const channel = await client.kraken.channels.getMyChannel();
 * ```
 */
var ChannelAPI = /** @class */ (function (_super) {
    tslib_1.__extends(ChannelAPI, _super);
    function ChannelAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets the channel the client is logged in to.
     */
    ChannelAPI.prototype.getMyChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = PrivilegedChannel_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({ url: 'channel', scope: 'channel_read' })];
                    case 1: return [2 /*return*/, new (_a.apply(PrivilegedChannel_1.default, [void 0, _b.sent(),
                            this._client]))()];
                }
            });
        });
    };
    /**
     * Retrieves the channel for the given user.
     *
     * @param user The user you want to retrieve the channel for.
     */
    ChannelAPI.prototype.getChannel = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = Channel_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({ url: "channels/" + UserTools_1.extractUserId(user) })];
                    case 1: return [2 /*return*/, new (_a.apply(Channel_1.default, [void 0, _b.sent(), this._client]))()];
                }
            });
        });
    };
    /**
     * Updates the given channel with the given data.
     *
     * @param channel The channel you want to update.
     * @param data The updated channel data.
     */
    ChannelAPI.prototype.updateChannel = function (channel, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId,
                                method: 'PUT',
                                jsonBody: { channel: data },
                                scope: 'channel_editor'
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves the list of users that have editor rights to the given channel.
     *
     * @param channel The channel you want to retrieve the list of editors for.
     */
    ChannelAPI.prototype.getChannelEditors = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/editors",
                                scope: 'channel_read'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.users.map(function (userData) { return new User_1.default(userData, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the list of followers of the given channel.
     *
     * @param channel The channel you want to retrieve the list of followers of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    ChannelAPI.prototype.getChannelFollowers = function (channel, page, limit, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        query = { limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        if (orderDirection) {
                            query.direction = orderDirection;
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/follows",
                                query: query
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.follows.map(function (follow) { return new ChannelFollow_1.default(follow, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the list of subscribers of the given channel.
     *
     * @param channel The channel you want to retrieve the list of subscribers of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    ChannelAPI.prototype.getChannelSubscriptions = function (channel, page, limit, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getChannelSubscriptions(channel, page, limit, orderDirection)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.subscriptions.map(function (sub) { return new ChannelSubscription_1.default(sub, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the total number of subscribers for the given channel.
     *
     * @param channel The channel you want to retrieve the number of subscribers for.
     */
    ChannelAPI.prototype.getChannelSubscriptionCount = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getChannelSubscriptions(channel, 0, 1)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data._total];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for the given user to a given channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the channel. If you only have access to the user,
     * use {@UserAPI#getSubscriptionData} instead.
     *
     * @param channel The channel to check the subscription to.
     * @param byUser The user to check the subscription for.
     */
    ChannelAPI.prototype.getChannelSubscriptionByUser = function (channel, byUser) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, userId, _a, e_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        userId = UserTools_1.extractUserId(byUser);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        _a = ChannelSubscription_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/subscriptions/" + userId,
                                scope: 'channel_check_subscription'
                            })];
                    case 2: return [2 /*return*/, new (_a.apply(ChannelSubscription_1.default, [void 0, _b.sent(),
                            this._client]))()];
                    case 3:
                        e_1 = _b.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default) {
                            if (e_1.statusCode === 404) {
                                return [2 /*return*/, null];
                            }
                            else if (e_1.statusCode === 422) {
                                throw new NoSubscriptionProgramError_1.default(channelId);
                            }
                        }
                        throw e_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a list of teams of the given channel.
     *
     * @param channel The channel you want to retrieve the list of teams of.
     */
    ChannelAPI.prototype.getChannelTeams = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/teams",
                                method: 'GET'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.teams.map(function (team) { return new Team_1.default(team, _this._client); })];
                }
            });
        });
    };
    /**
     * Starts a commercial in the given channel.
     *
     * @param channel The channel to start the commercial in.
     * @param length The length of the commercial.
     */
    ChannelAPI.prototype.startChannelCommercial = function (channel, length) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId;
            return tslib_1.__generator(this, function (_a) {
                channelId = UserTools_1.extractUserId(channel);
                return [2 /*return*/, this._client.callAPI({
                        url: "channels/" + channelId + "/commercial",
                        method: 'POST',
                        jsonBody: { length: length },
                        scope: 'channel_commercial'
                    })];
            });
        });
    };
    /**
     * Resets the given channel's stream key.
     *
     * @param channel The channel to reset the stream key for.
     */
    ChannelAPI.prototype.resetChannelStreamKey = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId;
            return tslib_1.__generator(this, function (_a) {
                channelId = UserTools_1.extractUserId(channel);
                return [2 /*return*/, this._client.callAPI({
                        url: "channels/" + channelId + "/stream_key",
                        method: 'DELETE',
                        scope: 'channel_stream'
                    })];
            });
        });
    };
    ChannelAPI.prototype._getChannelSubscriptions = function (channel, page, limit, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, query, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        query = { limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        if (orderDirection) {
                            query.direction = orderDirection;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/subscriptions",
                                query: query,
                                scope: 'channel_subscriptions'
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_2 = _a.sent();
                        if (e_2 instanceof HTTPStatusCodeError_1.default && e_2.statusCode === 422) {
                            throw new NoSubscriptionProgramError_1.default(channelId);
                        }
                        throw e_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getMyChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getChannel', 1)
    ], ChannelAPI.prototype, "updateChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getChannelEditors", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelFollowers", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelSubscriptions", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelSubscriptionCount", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getChannelSubscriptionByUser", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelTeams", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getMyChannel')
    ], ChannelAPI.prototype, "resetChannelStreamKey", null);
    ChannelAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], ChannelAPI);
    return ChannelAPI;
}(BaseAPI_1.default));
exports.default = ChannelAPI;
module.exports = exports = ChannelAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChannelAPI;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var UserTools_1 = __webpack_require__(6);
var BaseAPI_1 = __webpack_require__(3);
var ChatEmoteList_1 = __webpack_require__(198);
var ChatRoom_1 = __webpack_require__(200);
/**
 * The API methods that deal with chat and chatrooms.
 *
 * Can be accessed using `client.kraken.chat` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const emotes = await client.kraken.chat.getEmotesBySets('1');
 * ```
 */
var ChatAPI = /** @class */ (function (_super) {
    tslib_1.__extends(ChatAPI, _super);
    function ChatAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of emotes for a given list of enote set IDs.
     *
     * @param emotesets The list of emote set IDs, either as array of strings or as a comma separated string.
     */
    ChatAPI.prototype.getEmotesBySets = function (emotesets) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof emotesets !== 'string') {
                            emotesets = emotesets.join(',');
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'chat/emoticon_images',
                                query: {
                                    emotesets: emotesets
                                }
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new ChatEmoteList_1.default(data.emoticons, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves a list of chat rooms for a given channel.
     *
     * @param channel The channel to retrieve the chat rooms of.
     */
    ChatAPI.prototype.getChatRoomsForChannel = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: "chat/" + UserTools_1.extractUserId(channel) + "/rooms"
                        })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.rooms.map(function (room) { return new ChatRoom_1.default(room, _this._client); })];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChatAPI.prototype, "getEmotesBySets", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChatAPI.prototype, "getChatRoomsForChannel", null);
    ChatAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], ChatAPI);
    return ChatAPI;
}(BaseAPI_1.default));
exports.default = ChatAPI;
module.exports = exports = ChatAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatAPI;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var shared_utils_1 = __webpack_require__(1);
var ChatEmote_1 = __webpack_require__(199);
/**
 * A list of emotes.
 */
var ChatEmoteList = /** @class */ (function () {
    /** @private */
    function ChatEmoteList(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatEmoteList.prototype, "emotes", {
        /**
         * A list of all emotes in the list.
         */
        get: function () {
            var _this = this;
            return this._data.map(function (emote) { return new ChatEmote_1.default(emote, _this._client); });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets all emotes from the list that are from a given emote set.
     *
     * @param setId
     */
    ChatEmoteList.prototype.getAllFromSet = function (setId) {
        var _this = this;
        return this._data
            .filter(function (emote) { return emote.emoticon_set === setId; })
            .map(function (emote) { return new ChatEmote_1.default(emote, _this._client); });
    };
    /**
     * Finds a single emote by its ID.
     *
     * @param id
     */
    ChatEmoteList.prototype.getById = function (id) {
        var data = this._data.find(function (emote) { return emote.id === id; });
        return data ? new ChatEmote_1.default(data, this._client) : null;
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatEmoteList.prototype, "_client", void 0);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], ChatEmoteList.prototype, "emotes", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached()
    ], ChatEmoteList.prototype, "getAllFromSet", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached()
    ], ChatEmoteList.prototype, "getById", null);
    ChatEmoteList = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], ChatEmoteList);
    return ChatEmoteList;
}());
exports.default = ChatEmoteList;
module.exports = exports = ChatEmoteList;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatEmoteList;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A chat emote.
 */
var ChatEmote = /** @class */ (function () {
    /** @private */
    function ChatEmote(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatEmote.prototype, "id", {
        /**
         * The emote ID.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatEmote.prototype, "code", {
        /**
         * The emote code, i.e. how you write it in chat.
         */
        get: function () {
            return this._data.code;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatEmote.prototype, "setId", {
        /**
         * The ID of the emote set.
         */
        get: function () {
            return this._data.emoticon_set;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatEmote.prototype, "_client", void 0);
    return ChatEmote;
}());
exports.default = ChatEmote;
module.exports = exports = ChatEmote;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatEmote;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/** @private */
var shared_utils_1 = __webpack_require__(1);
var ChatRoom = /** @class */ (function () {
    /** @private */
    function ChatRoom(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatRoom.prototype, "id", {
        /**
         * The ID of the chat room.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "ownerId", {
        /**
         * The user ID of the chat room owner.
         */
        get: function () {
            return this._data.owner_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the user data of the chat room owner.
     */
    ChatRoom.prototype.getOwner = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getUser(this._data.owner_id)];
            });
        });
    };
    Object.defineProperty(ChatRoom.prototype, "name", {
        /**
         * The name of the chat room.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "topic", {
        /**
         * The topic of the chat room.
         */
        get: function () {
            return this._data.topic;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "isPreviewable", {
        /**
         * Whether the chat room is previewable.
         */
        get: function () {
            return this._data.is_previewable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "minRole", {
        /**
         * The minimum role allowed to enter this chat room.
         */
        get: function () {
            return this._data.minimum_allowed_role;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "ircName", {
        /**
         * The name of the IRC channel that corresponds to this chat room.
         */
        get: function () {
            return "#chatrooms:" + this._data.owner_id + ":" + this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatRoom.prototype, "_client", void 0);
    return ChatRoom;
}());
exports.default = ChatRoom;
module.exports = exports = ChatRoom;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatRoom;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var BaseAPI_1 = __webpack_require__(3);
var Channel_1 = __webpack_require__(13);
var Stream_1 = __webpack_require__(41);
/**
 * The API methods that deal with searching.
 *
 * Can be accessed using `client.kraken.search` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const channel = await client.kraken.search.searchStreams('Hearthstone');
 * ```
 */
var SearchAPI = /** @class */ (function (_super) {
    tslib_1.__extends(SearchAPI, _super);
    function SearchAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of channels that match the given search term.
     *
     * @param term The term you want to search for.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    SearchAPI.prototype.searchChannels = function (term, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { query: term, limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'search/channels', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.channels.map(function (channelData) { return new Channel_1.default(channelData, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves a list of streams that match the given search term.
     *
     * @param term The term you want to search for.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param hls Whether you want only HLS or only non-HLS (RTMP) streams. If not set, finds both types of streams.
     */
    SearchAPI.prototype.searchStreams = function (term, page, limit, hls) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { query: term, limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        if (hls !== undefined) {
                            query.hls = hls.toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'search/streams', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.streams.map(function (streamData) { return new Stream_1.default(streamData, _this._client); })];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], SearchAPI.prototype, "searchChannels", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], SearchAPI.prototype, "searchStreams", null);
    SearchAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], SearchAPI);
    return SearchAPI;
}(BaseAPI_1.default));
exports.default = SearchAPI;
module.exports = exports = SearchAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SearchAPI;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var UserTools_1 = __webpack_require__(6);
var BaseAPI_1 = __webpack_require__(3);
var Stream_1 = __webpack_require__(41);
/**
 * The API methods that deal with streams.
 *
 * Can be accessed using `client.kraken.streams` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const stream = await client.kraken.streams.getStreamByChannel('125328655');
 * ```
 */
var StreamAPI = /** @class */ (function (_super) {
    tslib_1.__extends(StreamAPI, _super);
    function StreamAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the current stream on the given channel.
     *
     * @param channel
     */
    StreamAPI.prototype.getStreamByChannel = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({ url: "streams/" + channelId })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.stream ? new Stream_1.default(data.stream, this._client) : null];
                }
            });
        });
    };
    /**
     * Retrieves a list of streams.
     *
     * @param channels A channel ID or a list thereof.
     * @param game Show only streams playing a certain game.
     * @param languageCode Show only streams in a certain language.
     * @param type Show only streams of a certain type.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getStreams = function (channels, game, languageCode, type, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { limit: limit.toString() };
                        if (channels) {
                            query.channel = typeof channels === 'string' ? channels : channels.join(',');
                        }
                        if (game) {
                            query.game = game;
                        }
                        if (languageCode) {
                            query.language = languageCode;
                        }
                        if (type) {
                            query.stream_type = type;
                        }
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'streams', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.streams.map(function (streamData) { return new Stream_1.default(streamData, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves a list of all streams.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getAllStreams = function (page, limit) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getStreams(undefined, undefined, undefined, Stream_1.StreamType.All, page, limit)];
            });
        });
    };
    /**
     * Retrieves a list of all live streams.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getAllLiveStreams = function (page, limit) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getStreams(undefined, undefined, undefined, Stream_1.StreamType.Live, page, limit)];
            });
        });
    };
    /**
     * Retrieves a list of all streams on channels the currently authenticated user is following.
     *
     * @param type Show only streams of a certain type.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getFollowedStreams = function (type, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { limit: limit.toString() };
                        if (type) {
                            query.type = type;
                        }
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'streams/followed',
                                query: query,
                                scope: 'user_read'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.streams.map(function (streamData) { return new Stream_1.default(streamData, _this._client); })];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(60)
    ], StreamAPI.prototype, "getStreamByChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(60)
    ], StreamAPI.prototype, "getFollowedStreams", null);
    StreamAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], StreamAPI);
    return StreamAPI;
}(BaseAPI_1.default));
exports.default = StreamAPI;
module.exports = exports = StreamAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StreamAPI;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var BaseAPI_1 = __webpack_require__(3);
var Team_1 = __webpack_require__(40);
var TeamWithUsers_1 = __webpack_require__(204);
/**
 * The API methods that deal with teams.
 *
 * Can be accessed using `client.kraken.teams` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const team = await client.kraken.teams.getTeamByName('staff');
 * ```
 */
var TeamAPI = /** @class */ (function (_super) {
    tslib_1.__extends(TeamAPI, _super);
    function TeamAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get a list of teams.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    TeamAPI.prototype.getTeams = function (page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = {};
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        query.limit = limit.toString();
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'teams',
                                query: query
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.teams.map(function (team) { return new Team_1.default(team, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the team data for the given team name.
     *
     * @param team The team name you want to look up.
     */
    TeamAPI.prototype.getTeamByName = function (team) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var teamData;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({ url: "teams/" + team })];
                    case 1:
                        teamData = _a.sent();
                        return [2 /*return*/, new TeamWithUsers_1.default(teamData, this._client)];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], TeamAPI.prototype, "getTeams", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], TeamAPI.prototype, "getTeamByName", null);
    TeamAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], TeamAPI);
    return TeamAPI;
}(BaseAPI_1.default));
exports.default = TeamAPI;
module.exports = exports = TeamAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TeamAPI;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Team_1 = __webpack_require__(40);
var User_1 = __webpack_require__(10);
var TeamWithUsers = /** @class */ (function (_super) {
    tslib_1.__extends(TeamWithUsers, _super);
    function TeamWithUsers() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * The list of users in the team.
     */
    TeamWithUsers.prototype.getUsers = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._data.users.map(function (data) { return new User_1.default(data, _this._client); })];
            });
        });
    };
    return TeamWithUsers;
}(Team_1.default));
exports.default = TeamWithUsers;
module.exports = exports = TeamWithUsers;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TeamWithUsers;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var shared_utils_1 = __webpack_require__(1);
var HellFreezesOverError_1 = __webpack_require__(20);
var HTTPStatusCodeError_1 = __webpack_require__(19);
var NoSubscriptionProgramError_1 = __webpack_require__(15);
var UserTools_1 = __webpack_require__(6);
var BaseAPI_1 = __webpack_require__(3);
var EmoteSetList_1 = __webpack_require__(91);
var PrivilegedUser_1 = __webpack_require__(92);
var User_1 = __webpack_require__(10);
var UserBlock_1 = __webpack_require__(93);
var UserChatInfo_1 = __webpack_require__(206);
var UserFollow_1 = __webpack_require__(94);
var UserSubscription_1 = __webpack_require__(95);
/**
 * The API methods that deal with users.
 *
 * Can be accessed using `client.kraken.users` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const user = await client.kraken.users.getUser('125328655');
 * ```
 */
var UserAPI = /** @class */ (function (_super) {
    tslib_1.__extends(UserAPI, _super);
    function UserAPI() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._userByNameCache = new Map();
        return _this;
    }
    /**
     * Retrieves the user data of the currently authenticated user.
     */
    UserAPI.prototype.getMe = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = PrivilegedUser_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({ url: 'user', scope: 'user_read' })];
                    case 1: return [2 /*return*/, new (_a.apply(PrivilegedUser_1.default, [void 0, _b.sent(), this._client]))()];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user ID.
     *
     * @param userId The user ID you want to look up.
     */
    UserAPI.prototype.getUser = function (userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userData;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({ url: "users/" + UserTools_1.extractUserId(userId) })];
                    case 1:
                        userData = _a.sent();
                        if (!userData) {
                            throw new HellFreezesOverError_1.default('Could not get authenticated user');
                        }
                        return [2 /*return*/, new User_1.default(userData, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user name.
     *
     * @param userName The user name you want to look up.
     */
    UserAPI.prototype.getUserByName = function (userName) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var users, user;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // not using the decorator's cache here as users-by-name is slightly more complex to cache
                        this._cleanUserCache();
                        if (this._userByNameCache.has(userName)) {
                            return [2 /*return*/, this._userByNameCache.get(userName).value];
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'users', query: { login: userName } })];
                    case 1:
                        users = (_a.sent()).users;
                        if (users.length === 0) {
                            return [2 /*return*/, null];
                        }
                        user = new User_1.default(users[0], this._client);
                        this._userByNameCache.set(userName, {
                            value: user,
                            expires: Date.now() + 3600 * 1000
                        });
                        return [2 /*return*/, user];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user names.
     *
     * @param userNames The user names you want to look up.
     */
    UserAPI.prototype.getUsersByNames = function (userNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cachedEntries, cachedObject, cachedUsers, toFetch, usersData, usersArr, users;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._cleanUserCache();
                        userNames = userNames.map(function (name) { return name.toLowerCase(); });
                        cachedEntries = Array.from(this._userByNameCache.entries()).filter(function (_a) {
                            var _b = tslib_1.__read(_a, 1), key = _b[0];
                            return userNames.includes(key);
                        });
                        cachedObject = shared_utils_1.entriesToObject(cachedEntries);
                        cachedUsers = shared_utils_1.mapObject(cachedObject, function (entry) { return entry.value; });
                        toFetch = userNames.filter(function (name) { return !(name in cachedUsers); });
                        if (!toFetch.length) {
                            return [2 /*return*/, cachedUsers];
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'users', query: { login: toFetch.join(',') } })];
                    case 1:
                        usersData = _a.sent();
                        usersArr = usersData.users.map(function (data) { return new User_1.default(data, _this._client); });
                        usersArr.forEach(function (user) {
                            return _this._userByNameCache.set(user.name, {
                                value: user,
                                expires: Date.now() + 3600 * 1000
                            });
                        });
                        users = shared_utils_1.indexBy(usersArr, 'name');
                        return [2 /*return*/, tslib_1.__assign(tslib_1.__assign({}, cachedUsers), users)];
                }
            });
        });
    };
    /**
     * Retrieves information about the user's chat appearance and privileges.
     *
     * @param user The user you want to get chat info for.
     */
    UserAPI.prototype.getChatInfo = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this._client.callAPI({ url: "users/" + userId + "/chat" })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new UserChatInfo_1.default(data, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves the emotes a given user can use.
     *
     * @param user The user you want to get emotes for.
     */
    UserAPI.prototype.getUserEmotes = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this._client.callAPI({ url: "users/" + userId + "/emotes", scope: 'user_subscriptions' })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new EmoteSetList_1.default(data.emoticon_sets)];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for a given user to a given channel.
     *
     * @param user The user to retrieve the subscription data of.
     * @param toChannel The channel you want to retrieve the subscription data to.
     */
    UserAPI.prototype.getSubscriptionData = function (user, toChannel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId, _a, e_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(toChannel);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        _a = UserSubscription_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/subscriptions/" + channelId,
                                scope: 'user_subscriptions'
                            })];
                    case 2: return [2 /*return*/, new (_a.apply(UserSubscription_1.default, [void 0, _b.sent(),
                            this._client]))()];
                    case 3:
                        e_1 = _b.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default) {
                            if (e_1.statusCode === 404) {
                                return [2 /*return*/, null];
                            }
                            else if (e_1.statusCode === 422) {
                                throw new NoSubscriptionProgramError_1.default(channelId);
                            }
                        }
                        throw e_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a list of channels a given user follows.
     *
     * @param user The user you want to retrieve the follows of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderBy The field to order by.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    UserAPI.prototype.getFollowedChannels = function (user, page, limit, orderBy, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        query = {};
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        query.limit = limit.toString();
                        if (orderBy) {
                            query.sortby = orderBy;
                        }
                        if (orderDirection) {
                            query.direction = orderDirection;
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/follows/channels",
                                query: query
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.follows.map(function (follow) { return new UserFollow_1.default(follow, _this._client); })];
                }
            });
        });
    };
    /**
     * Get follow data for a given user to a given channel.
     *
     * @param user The user you want to retrieve follow data of.
     * @param channel The channel you want to retrieve follow data to.
     */
    UserAPI.prototype.getFollowedChannel = function (user, channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId, data, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(channel);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._client.callAPI({ url: "users/" + userId + "/follows/channels/" + channelId })];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, new UserFollow_1.default(data, this._client)];
                    case 3:
                        e_2 = _a.sent();
                        if (e_2 instanceof HTTPStatusCodeError_1.default) {
                            if (e_2.statusCode === 404) {
                                return [2 /*return*/, null];
                            }
                        }
                        throw e_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Follows a given channel with a given user.
     *
     * @param user The user you want to follow with.
     * @param channel The channel to follow.
     * @param notifications Whether the user will receive notifications.
     */
    UserAPI.prototype.followChannel = function (user, channel, notifications) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/follows/channels/" + channelId,
                                method: 'PUT',
                                scope: 'user_follows_edit',
                                body: { notifications: Boolean(notifications).toString() }
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new UserFollow_1.default(data, this._client)];
                }
            });
        });
    };
    /**
     * Unfollows a given channel with a given user.
     *
     * @param user The user you want to unfollow with.
     * @param channel The channel to unfollow.
     */
    UserAPI.prototype.unfollowChannel = function (user, channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/follows/channels/" + channelId,
                                scope: 'user_follows_edit',
                                method: 'DELETE'
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a list of users a given user has blocked.
     *
     * @param user The user you want to retrieve the block list of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    UserAPI.prototype.getBlockedUsers = function (user, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        query = { limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/blocks",
                                query: query,
                                scope: 'user_blocks_read'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.blocks.map(function (block) { return new UserBlock_1.default(block, _this._client); })];
                }
            });
        });
    };
    /**
     * Blocks a given user with another given user.
     *
     * @param user The user you want to block with.
     * @param userToBlock The user to block.
     */
    UserAPI.prototype.blockUser = function (user, userToBlock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, userIdToBlock, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        userIdToBlock = UserTools_1.extractUserId(userToBlock);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/blocks/" + userIdToBlock,
                                method: 'PUT',
                                scope: 'user_blocks_edit'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new UserBlock_1.default(data, this._client)];
                }
            });
        });
    };
    /**
     * Unblocks a given user with another given user.
     *
     * @param user The user you want to unblock with.
     * @param userToUnblock The user to unblock.
     */
    UserAPI.prototype.unblockUser = function (user, userToUnblock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, userIdToUnblock;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        userIdToUnblock = UserTools_1.extractUserId(userToUnblock);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/blocks/" + userIdToUnblock,
                                method: 'DELETE',
                                scope: 'user_blocks_edit'
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    UserAPI.prototype._cleanUserCache = function () {
        var _this = this;
        var now = Date.now();
        this._userByNameCache.forEach(function (val, key) {
            if (val.expires < now) {
                _this._userByNameCache.delete(key);
            }
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getMe", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getUser", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getChatInfo", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getUserEmotes", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getSubscriptionData", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], UserAPI.prototype, "getFollowedChannels", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], UserAPI.prototype, "getFollowedChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getFollowedChannels', 1),
        cache_decorators_1.ClearsCache('getFollowedChannel', 2)
    ], UserAPI.prototype, "followChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getFollowedChannels', 1),
        cache_decorators_1.ClearsCache('getFollowedChannel', 2)
    ], UserAPI.prototype, "unfollowChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getBlockedUsers", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getBlockedUsers', 1)
    ], UserAPI.prototype, "blockUser", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getBlockedUsers', 1)
    ], UserAPI.prototype, "unblockUser", null);
    UserAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], UserAPI);
    return UserAPI;
}(BaseAPI_1.default));
exports.default = UserAPI;
module.exports = exports = UserAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UserAPI;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * Information about a user's chat appearance and privileges.
 */
var UserChatInfo = /** @class */ (function () {
    /** @private */
    function UserChatInfo(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(UserChatInfo.prototype, "userId", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the user.
     */
    UserChatInfo.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getUser(this._data._id)];
            });
        });
    };
    Object.defineProperty(UserChatInfo.prototype, "userName", {
        /**
         * The name of the user.
         */
        get: function () {
            return this._data.login;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "displayName", {
        /**
         * The display name of the user.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "color", {
        /**
         * The color that the user appears in in chat.
         */
        get: function () {
            return this._data.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "isKnownBot", {
        /**
         * Whether the user is a known bot.
         */
        get: function () {
            return this._data.is_known_bot;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "isVerifiedBot", {
        /**
         * Whether the user is a verified bot.
         */
        get: function () {
            return this._data.is_verified_bot;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "isAtLeastKnownBot", {
        /**
         * Whether the user is at least a known bot (i.e. known or verified).
         */
        get: function () {
            return this._data.is_known_bot || this._data.is_verified_bot;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks whether the user has access to a given global badge.
     *
     * @param id The ID of a badge.
     */
    UserChatInfo.prototype.hasBadge = function (id) {
        return this._data.badges.some(function (badge) { return badge.id === id; });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], UserChatInfo.prototype, "_client", void 0);
    return UserChatInfo;
}());
exports.default = UserChatInfo;
module.exports = exports = UserChatInfo;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UserChatInfo;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var ChattersList_1 = __webpack_require__(97);
/**
 * Different API methods that are not officially supported by Twitch.
 *
 * Can be accessed using `client.unsupported` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const events = await client.unsupported.getEvents('125328655');
 * ```
 */
var UnsupportedAPI = /** @class */ (function (_super) {
    tslib_1.__extends(UnsupportedAPI, _super);
    function UnsupportedAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of chatters in the Twitch chat of the given channel.
     *
     * **WARNING**: In contrast to most other methods, this takes a channel *name*, not a user ID.
     *
     * @param channel The channel to retrieve the chatters for.
     */
    UnsupportedAPI.prototype.getChatters = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelName, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelName = UserTools_1.extractUserName(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "https://tmi.twitch.tv/group/user/" + channelName + "/chatters",
                                type: TwitchClient_1.TwitchAPICallType.Custom
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new ChattersList_1.default(data)];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(60)
    ], UnsupportedAPI.prototype, "getChatters", null);
    UnsupportedAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], UnsupportedAPI);
    return UnsupportedAPI;
}(BaseAPI_1.default));
exports.default = UnsupportedAPI;
module.exports = exports = UnsupportedAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UnsupportedAPI;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var TwitchClient_1 = __webpack_require__(4);
/**
 * An auth provider that retrieve tokens using client credentials.
 */
var ClientCredentialsAuthProvider = /** @class */ (function () {
    /**
     * Creates a new auth provider to receive an application token with using the client ID and secret.
     *
     * You don't usually have to create this manually. You should use `TwitchClient.withClientCredentials` instead.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     */
    function ClientCredentialsAuthProvider(clientId, clientSecret) {
        /**
         * The type of tokens this provider generates.
         *
         * This auth provider generates app tokens.
         */
        this.tokenType = 'app';
        this._clientId = clientId;
        this._clientSecret = clientSecret;
    }
    /**
     * Retrieves an access token.
     *
     * If any scopes are provided, this throws. The client credentials flow does not support scopes.
     *
     * @param scopes The requested scopes.
     */
    ClientCredentialsAuthProvider.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (scopes && scopes.length > 0) {
                    throw new Error("Scope " + (typeof scopes === 'string' ? scopes : scopes.join(',')) + " requested but the client credentials flow does not support scopes");
                }
                if (!this._token || this._token.isExpired) {
                    return [2 /*return*/, this.refresh()];
                }
                return [2 /*return*/, this._token];
            });
        });
    };
    /**
     * Retrieves a new app access token.
     */
    ClientCredentialsAuthProvider.prototype.refresh = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, TwitchClient_1.default.getAppAccessToken(this._clientId, this._clientSecret)];
                    case 1: return [2 /*return*/, (_a._token = _b.sent())];
                }
            });
        });
    };
    /** @private */
    ClientCredentialsAuthProvider.prototype.setAccessToken = function (token) {
        this._token = token;
    };
    Object.defineProperty(ClientCredentialsAuthProvider.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._clientId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientCredentialsAuthProvider.prototype, "currentScopes", {
        /**
         * The scopes that are currently available using the access token.
         */
        get: function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ClientCredentialsAuthProvider.prototype, "_clientId", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ClientCredentialsAuthProvider.prototype, "_clientSecret", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ClientCredentialsAuthProvider.prototype, "_token", void 0);
    return ClientCredentialsAuthProvider;
}());
exports.default = ClientCredentialsAuthProvider;
module.exports = exports = ClientCredentialsAuthProvider;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ClientCredentialsAuthProvider;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever a different token type (user vs. app) is expected in the method you're calling.
 */
var InvalidTokenTypeError = /** @class */ (function (_super) {
    tslib_1.__extends(InvalidTokenTypeError, _super);
    function InvalidTokenTypeError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return InvalidTokenTypeError;
}(CustomError_1.default));
exports.default = InvalidTokenTypeError;
module.exports = exports = InvalidTokenTypeError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = InvalidTokenTypeError;


/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/twitch/lib/index.js
var lib = __webpack_require__(42);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// CONCATENATED MODULE: ./src/config.ts
const defaultClientId = "59x8jyaudw3pnyi722x3e2x9awh385";
class ConfigManager {
    static setUserClientId(clientId) {
        this.userClientId = clientId;
    }
    static getClientId() {
        if (this.userClientId) {
            return this.userClientId;
        }
        return defaultClientId;
    }
}

// CONCATENATED MODULE: ./src/downloader/config.ts
// File with config values and constants
const config_clientId = "ybum1fvursno4nf3ckzx56jmhqynjk"; // Add client ID here
const defaultHeaders = {
    "Client-ID": config_clientId,
    "Accept": "application/vnd.twitchtv.v5+json",
    "Authorization": "OAuth gcu9pd0kcn6x2x3drix6esbhlrfqfv",
};
// TypeScript does not allow parametrized string to be formatted in runtime,
// so this is the best way to get a formatted URL.
function getApiUrl(videoId, nextCursor) {
    if (nextCursor) {
        return `https://api.twitch.tv/v5/videos/${videoId}/comments?cursor=${nextCursor}`;
    }
    return `https://api.twitch.tv/v5/videos/${videoId}/comments`;
}

// CONCATENATED MODULE: ./src/downloader/chat.ts

const tooManyRequests = 429; // HTTP 429 too many requests response code
async function sleep(ms) {
    return new Promise(_ => setTimeout(_, ms));
}
class chat_ChatDownloader {
    addLoopEventListener(handler) {
        this.loopHandler = handler;
    }
    // Download chat of single Twitch video
    async downloadChat(videoId) {
        var _a, _b, _c, _d;
        const comments = [];
        let turn = 0;
        let nextCursor = null;
        do {
            const response = await this.callApi(videoId, nextCursor);
            if (response.text) { // response.text is null if status is not ok.
                try {
                    const jsonContent = JSON.parse(response.text);
                    for (let newComment of jsonContent["comments"]) {
                        comments.push(newComment);
                    }
                    nextCursor = jsonContent["_next"];
                    turn += 1;
                    (_a = this.loopHandler) === null || _a === void 0 ? void 0 : _a.call(this, turn, response.status, comments.length);
                }
                catch (err) {
                    console.error(`Error when parsing JSON response: ${response.text}`);
                    (_b = this.loopHandler) === null || _b === void 0 ? void 0 : _b.call(this, turn, response.status, comments.length);
                    return null;
                }
            }
            else if (response.status == tooManyRequests) {
                (_c = this.loopHandler) === null || _c === void 0 ? void 0 : _c.call(this, turn, response.status, comments.length);
                // As of 2020-07-25, Kraken API does not seem to use 429 response code at all.
                // This sleep is here only as an additional check
                await sleep(500); // Sleep for 1 second
            }
            else {
                console.error(`API call failed with error code: ${response.status}`);
                (_d = this.loopHandler) === null || _d === void 0 ? void 0 : _d.call(this, turn, response.status, comments.length);
                return null;
            }
        } while (nextCursor);
        return comments;
    }
    // Call Twitch API one time
    async callApi(videoId, cursor) {
        const url = getApiUrl(videoId, cursor);
        const response = await fetch(url, { headers: defaultHeaders });
        if (!response.ok) {
            return { status: response.status, text: null };
        }
        const content = await response.text();
        return { status: response.status, text: content };
    }
}

// CONCATENATED MODULE: ./src/downloader.ts



let twitchClient;
function getTwitchClient() {
    if (twitchClient !== null) {
        return twitchClient;
    }
    // User not logged in
    const token = sessionStorage.getItem("twitch_chat_analyzer_access_token");
    if (!token) {
        return null;
    }
    const clientId = ConfigManager.getClientId();
    const client = lib_default.a.withCredentials(clientId, token);
    twitchClient = client;
    return client;
}
async function getStreamerInfo(username) {
    const token = sessionStorage.getItem("twitch_chat_analyzer_access_token");
    if (!token) {
        return null;
    }
    const clientId = ConfigManager.getClientId();
    const client = lib_default.a.withCredentials(clientId, token);
    const user = await client.helix.users.getUserByName(username);
    return user;
}
function addFollowerDownloaderListeners() {
    const streamerNameInputElem = document.getElementById("streamer-username-input");
    const streamerSearchButtomElem = document.getElementById("streamer-search-button");
    const streamerInfoElem = document.getElementById("streamer-info");
    const downloadButtonElem = document.getElementById("follower-list-download-button");
    streamerSearchButtomElem.addEventListener("click", async () => {
        const name = streamerNameInputElem.value;
        const client = getTwitchClient();
        client.helix.users.getUserByName(name).then((helixUser) => {
            if (!helixUser) {
                streamerInfoElem.textContent = `스트리머를 찾을 수 없습니다: ${name}`;
                return;
            }
            streamerInfoElem.textContent = `스트리머: ${helixUser.displayName}`;
            // Show download button
        });
    });
    downloadButtonElem.addEventListener("click", async () => {
        // Display download status
        // download
        // When finished downloading, download the file to local disk
    });
}
function addChatDownloaderListeners() {
    const videoIdInputElem = document.getElementById("video-id-input");
    const videoSearchButtomElem = document.getElementById("video-search-button");
    const videoInfoElem = document.getElementById("video-info");
    const downloadButtonElem = document.getElementById("video-chat-download-button");
    videoSearchButtomElem.addEventListener("click", async () => {
        const videoId = videoIdInputElem.value;
        const client = getTwitchClient();
        client.helix.videos.getVideoById(videoId).then((video) => {
            // Populate video info elem
            videoInfoElem.textContent = video.title + ", " + video.description;
        });
    });
    const loopHandler = (turn, status, downloadCount) => {
        // Display download status in some <div>
    };
    downloadButtonElem.addEventListener("click", async () => {
        const videoId = videoIdInputElem.value;
        const downloader = new chat_ChatDownloader();
        downloader.addLoopEventListener(loopHandler);
        const chats = await downloader.downloadChat(videoId);
        // Display download status
        // download
        // When finished downloading, download the file to local disk
    });
}
(function () {
    addFollowerDownloaderListeners();
    addChatDownloaderListeners();
})();
/*
function main() {

  //const input = "random filter name & Follow 1day | subscriber & aaaaa & (Bbbb)";
  //const input = "!(랜덤한 필터 이름) & 팔로우 1일 이하 | 비구독자 & 그냥 이것저것 & (아무거나 이것저것)";
  const input = "!(랜덤한 필터 이름) | 팔로우 1일 이하| (비구독자 |!그냥 이것저것) & 아무거나 이것저것";
  const f = getFilter(input);
  console.log("f: " + f);
  console.log("type f: " + Object.keys(f));
  console.log("toString: " + f.toString());

  return;

  const beforeFile = performance.now();
  const fileContent = fs.readFileSync(filePath, "utf8");
  const fileJson = JSON.parse(fileContent);
  const commentsData = fileJson["comments"] as Array<CommentData>;
  
  const repository = new CommentRepository(commentsData);
  console.log("User count: " + repository.userCount());
  console.log("Chat count: " + repository.commentCount());
  
  const group = new AndExpressionGroup();
  group.addRegex({type: "user", key: "username"}, "c");
  group.addRegex({type: "comment", key: "rawText"}, "heart");
  group.addGreaterThan({type: "comment", key: "relativeTime"}, 200);

  const beforeFilter = performance.now();
  console.log("Repository created in " + (beforeFilter - beforeFile) + " milliseconds");
  const filtered = repository.filter(group);
  //const filter = new RegexExpression({type: "comment", key: "rawText"}, "ㅋㅋㅋ");
  //const filter = new RegexExpression({type: "user", key: "username"}, "r");

  //const filtered = repository.filter(filter);
  
  const afterFilter = performance.now();
  console.log("Filtered complete in " + (afterFilter - beforeFilter) + " milliseconds");

  console.log(filtered.length);
  for(let i = 0; i < 10; i++) {
      console.log(filtered[i].toDisplayString());
  }
  for(let chat of filtered) {
      console.log(chat.toDisplayString());
  }
}


main();

*/ 


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9zaGFyZWQtdXRpbHMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9HZXRJbnRyaW5zaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0Jhc2VBUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvVHdpdGNoQ2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnMvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzL2VzL3V0aWxzL2NyZWF0ZUNhY2hlS2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnMvZXMvZGVjb3JhdG9ycy9DYWNoZWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9ycy9lcy9kZWNvcmF0b3JzL0NhY2hlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzL2VzL2RlY29yYXRvcnMvQ2FjaGVkR2V0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnMvZXMvZGVjb3JhdG9ycy9DbGVhcnNDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL1Rvb2xraXQvVXNlclRvb2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L1R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvY2FsbEJvdW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9IZWxpeFBhZ2luYXRlZFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9Vc2VyL1VzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L0hlbGl4UGFnaW5hdGVkUmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0Vycm9ycy9DdXN0b21FcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYW5uZWwvQ2hhbm5lbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV0ZWN0LW5vZGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9FcnJvcnMvTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvSXNQcm9wZXJ0eUtleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvSGVsaXhQYWdpbmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0Vycm9ycy9IVFRQU3RhdHVzQ29kZUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0Vycm9ycy9IZWxsRnJlZXplc092ZXJFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0xvZ0xldmVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3JhdGUtbGltaXRlci9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0xvZ0xldmVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcHJvbWlzZS5hbGxzZXR0bGVkL3JlcXVpcmVQcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3FzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvQWNjZXNzVG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvb2JqZWN0L2FycmF5VG9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L01vZGVyYXRpb24vSGVsaXhCYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L01vZGVyYXRpb24vSGVsaXhNb2RlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1N1YnNjcmlwdGlvbnMvSGVsaXhTdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1VzZXIvSGVsaXhVc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3JhdGUtbGltaXRlci9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2NhbGxCaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2Fzc2VydFJlY29yZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0JpdHMvQ2hlZXJtb3RlTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYW5uZWwvQ2hhbm5lbFBsYWNlaG9sZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9LcmFrZW4vU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9LcmFrZW4vVGVhbS9UZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9LcmFrZW4vU3RyZWFtL1N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0Jhc2VMb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcXMvbGliL2Zvcm1hdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvb2JqZWN0L3BpY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0JhZGdlcy9DaGF0QmFkZ2VMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9CYWRnZXMvQ2hhdEJhZGdlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9CYWRnZXMvQ2hhdEJhZGdlVmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvQml0cy9IZWxpeEJpdHNMZWFkZXJib2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvQml0cy9IZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9DbGlwL0hlbGl4Q2xpcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvRXh0ZW5zaW9ucy9IZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9HYW1lL0hlbGl4R2FtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvTW9kZXJhdGlvbi9IZWxpeEJhbkV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9Nb2RlcmF0aW9uL0hlbGl4TW9kZXJhdG9yRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvRXJyb3JzL1N0cmVhbU5vdExpdmVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvU3RyZWFtL0hlbGl4U3RyZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9TdHJlYW0vSGVsaXhTdHJlYW1NYXJrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1N1YnNjcmlwdGlvbnMvSGVsaXhTdWJzY3JpcHRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9Vc2VyL0hlbGl4Rm9sbG93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9Vc2VyL0hlbGl4UHJpdmlsZWdlZFVzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1ZpZGVvL0hlbGl4VmlkZW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcmF0ZS1saW1pdGVyL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2xvZ2dlci9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3JhdGUtbGltaXRlci9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0Jhc2VMb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9wcm9taXNlLmFsbHNldHRsZWQvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUubWFwL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0dldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9Jc0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL0RlZmluZU93blByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0Zyb21Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvSXNEYXRhRGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9TYW1lVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvaXNOYU4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvVG9Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvVG9Cb29sZWFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0lzQ2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLWNhbGxhYmxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUubWFwL3BvbHlmaWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3Byb21pc2UuYWxsc2V0dGxlZC9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXIvbGliL1JldHJ5QWZ0ZXJFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYW5uZWwvQ2hhbm5lbEZvbGxvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYW5uZWwvQ2hhbm5lbFN1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYW5uZWwvUHJpdmlsZWdlZENoYW5uZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9DaGFubmVsL0Vtb3RlU2V0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1VzZXIvUHJpdmlsZWdlZFVzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9Vc2VyL1VzZXJCbG9jay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1VzZXIvVXNlckZvbGxvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1VzZXIvVXNlclN1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvVG9rZW5JbmZvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9VbnN1cHBvcnRlZC9DaGF0dGVyc0xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQXV0aC9SZWZyZXNoYWJsZUF1dGhQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BdXRoL1N0YXRpY0F1dGhQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9FcnJvcnMvQ29uZmlnRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvRXJyb3JzL0ludmFsaWRUb2tlbkVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2Nyb3NzLWZldGNoL2Rpc3QvYnJvd3Nlci1wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2xvZ2dlci9saWIvTm9kZUxvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0Jyb3dzZXJMb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcXMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3FzL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9CYWRnZXMvQmFkZ2VzQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3NoYXJlZC11dGlscy9saWIvZGVjb3JhdG9ycy9FbnVtZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3NoYXJlZC11dGlscy9saWIvZnVuY3Rpb25zL2FycmF5L2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvY29uZmlnL3Jlc29sdmVDb25maWdWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9zaGFyZWQtdXRpbHMvbGliL2Z1bmN0aW9ucy9kZXByZWNhdGUvZGVwcmVjYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvbWF0Y2gvbWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvb2JqZWN0L2VudHJpZXNUb09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9zaGFyZWQtdXRpbHMvbGliL2Z1bmN0aW9ucy9vYmplY3QvZm9yRWFjaE9iamVjdEVudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3NoYXJlZC11dGlscy9saWIvZnVuY3Rpb25zL29iamVjdC9pbmRleEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3NoYXJlZC11dGlscy9saWIvZnVuY3Rpb25zL29iamVjdC9tYXBPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvb2JqZWN0L29taXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvcHJvbWlzZS9kZWxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9zaGFyZWQtdXRpbHMvbGliL2Z1bmN0aW9ucy9zdHJpbmcvcGFkTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9zaGFyZWQtdXRpbHMvbGliL2Z1bmN0aW9ucy9zdHJpbmcvc3BsaXRXaXRoTGltaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvc3RyaW5nL3V0ZjhMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvc3RyaW5nL3V0ZjhTdWJzdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L0hlbGl4QVBJR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L0JpdHMvSGVsaXhCaXRzQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9DbGlwL0hlbGl4Q2xpcEFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvRXh0ZW5zaW9ucy9IZWxpeEV4dGVuc2lvbnNBUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L0dhbWUvSGVsaXhHYW1lQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9Nb2RlcmF0aW9uL0hlbGl4TW9kZXJhdGlvbkFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvU3RyZWFtL0hlbGl4U3RyZWFtQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9TdHJlYW0vSGVsaXhTdHJlYW1NYXJrZXJXaXRoVmlkZW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1N1YnNjcmlwdGlvbnMvSGVsaXhTdWJzY3JpcHRpb25BUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1VzZXIvSGVsaXhVc2VyQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9WaWRlby9IZWxpeFZpZGVvQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9XZWJIb29rcy9IZWxpeFdlYkhvb2tzQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9XZWJIb29rcy9IZWxpeFdlYkhvb2tTdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L0hlbGl4UmF0ZUxpbWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcmF0ZS1saW1pdGVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXIvbGliL1Jlc3BvbnNlQmFzZWRSYXRlTGltaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXIvbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvbG9nZ2VyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXIvbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvbG9nZ2VyL2xpYi9Ob2RlTG9nZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3JhdGUtbGltaXRlci9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0Jyb3dzZXJMb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcHJvbWlzZS5hbGxzZXR0bGVkL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9Qcm9taXNlUmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvNS9UeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pdGVyYXRlLXZhbHVlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1nZXQtaXRlcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1hcmd1bWVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWdldC1pdGVyYXRvci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtbWFwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1zZXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2l0ZXJhdGUtaXRlcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzUvQ2hlY2tPYmplY3RDb2VyY2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvQXJyYXlTcGVjaWVzQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi91dGlsLmluc3BlY3QgKGlnbm9yZWQpIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0lzQ29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvRGVmaW5lUHJvcGVydHlPclRocm93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzUHJvcGVydHlEZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0lzQWNjZXNzb3JEZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0lzSW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9pc0Zpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9DYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0NyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvQ3JlYXRlRGF0YVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L09yZGluYXJ5R2V0T3duUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0lzUmVnRXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9Jc0V4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvSGFzUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvVG9VaW50MzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvVG9OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvcmVnZXhUZXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvVG9QcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLXRvLXByaW1pdGl2ZS9lczIwMTUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLXRvLXByaW1pdGl2ZS9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1kYXRlLW9iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L1RvT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L1RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hcnJheS1tZXRob2QtYm94ZXMtcHJvcGVybHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5tYXAvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9wcm9taXNlLmFsbHNldHRsZWQvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXIvbGliL0N1c3RvbUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9LcmFrZW4vS3Jha2VuQVBJR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9CaXRzL0JpdHNBUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9DaGFubmVsL0NoYW5uZWxBUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9DaGF0L0NoYXRBUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9DaGF0L0NoYXRFbW90ZUxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9DaGF0L0NoYXRFbW90ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYXQvQ2hhdFJvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9TZWFyY2gvU2VhcmNoQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9LcmFrZW4vU3RyZWFtL1N0cmVhbUFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1RlYW0vVGVhbUFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1RlYW0vVGVhbVdpdGhVc2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1VzZXIvVXNlckFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1VzZXIvVXNlckNoYXRJbmZvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9VbnN1cHBvcnRlZC9VbnN1cHBvcnRlZEFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BdXRoL0NsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0Vycm9ycy9JbnZhbGlkVG9rZW5UeXBlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG93bmxvYWRlci9jb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Rvd25sb2FkZXIvY2hhdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG93bmxvYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFB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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGlFQUFpRTtBQUMzSTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7Ozs7Ozs7O0FDOVFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csK0JBQStCLEVBQUU7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsK0JBQStCLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxjQUFjLG1CQUFPLENBQUMsQ0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7Ozs7Ozs7O0FDdkNhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLENBQU87QUFDN0IsMkJBQTJCLG1CQUFPLENBQUMsRUFBc0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtB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OztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxhQUFhO0FBQ3hGLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDs7Ozs7Ozs7QUM3RGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxjQUFjLG1CQUFPLENBQUMsQ0FBTztBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyxDQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7Ozs7Ozs7O0FDdkVhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLENBQU87QUFDN0IscUJBQXFCLG1CQUFPLENBQUMsQ0FBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FB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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVCQUF1QjtBQUNuRSxhQUFhO0FBQ2IseUNBQXlDLGNBQWMsRUFBRTtBQUN6RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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Q1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiwwQkFBMEIsZUFBZTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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SztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QVcsQ0FBQyxDQUFDO1FBQzdDLE1BQU0sS0FBSyxHQUFHLE1BQU0sVUFBVSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyRCwwQkFBMEI7UUFDMUIsV0FBVztRQUNYLDZEQUE2RDtJQUNqRSxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUM7QUFFRCxDQUFDO0lBRUQsOEJBQThCLEVBQUUsQ0FBQztJQUNqQywwQkFBMEIsRUFBRSxDQUFDO0FBSTdCLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFJTDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFrREUiLCJmaWxlIjoiZG93bmxvYWRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMDIpO1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVudW1lcmFibGVfMSA9IHJlcXVpcmUoXCIuL2RlY29yYXRvcnMvRW51bWVyYWJsZVwiKTtcbnZhciBfX2V4cG9ydF9FbnVtZXJhYmxlID0gRW51bWVyYWJsZV8xLkVudW1lcmFibGU7XG5leHBvcnRzLkVudW1lcmFibGUgPSBfX2V4cG9ydF9FbnVtZXJhYmxlO1xudmFyIF9fZXhwb3J0X05vbkVudW1lcmFibGUgPSBFbnVtZXJhYmxlXzEuTm9uRW51bWVyYWJsZTtcbmV4cG9ydHMuTm9uRW51bWVyYWJsZSA9IF9fZXhwb3J0X05vbkVudW1lcmFibGU7XG52YXIgZmxhdHRlbl8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL2FycmF5L2ZsYXR0ZW5cIik7XG52YXIgX19leHBvcnRfZmxhdHRlbiA9IGZsYXR0ZW5fMS5mbGF0dGVuO1xuZXhwb3J0cy5mbGF0dGVuID0gX19leHBvcnRfZmxhdHRlbjtcbnZhciByZXNvbHZlQ29uZmlnVmFsdWVfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9jb25maWcvcmVzb2x2ZUNvbmZpZ1ZhbHVlXCIpO1xudmFyIF9fZXhwb3J0X3Jlc29sdmVDb25maWdWYWx1ZSA9IHJlc29sdmVDb25maWdWYWx1ZV8xLnJlc29sdmVDb25maWdWYWx1ZTtcbmV4cG9ydHMucmVzb2x2ZUNvbmZpZ1ZhbHVlID0gX19leHBvcnRfcmVzb2x2ZUNvbmZpZ1ZhbHVlO1xudmFyIGRlcHJlY2F0ZUNsYXNzXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvZGVwcmVjYXRlL2RlcHJlY2F0ZUNsYXNzXCIpO1xudmFyIF9fZXhwb3J0X2RlcHJlY2F0ZUNsYXNzID0gZGVwcmVjYXRlQ2xhc3NfMS5kZXByZWNhdGVDbGFzcztcbmV4cG9ydHMuZGVwcmVjYXRlQ2xhc3MgPSBfX2V4cG9ydF9kZXByZWNhdGVDbGFzcztcbnZhciBtYXRjaF8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL21hdGNoL21hdGNoXCIpO1xudmFyIF9fZXhwb3J0X21hdGNoID0gbWF0Y2hfMS5tYXRjaDtcbmV4cG9ydHMubWF0Y2ggPSBfX2V4cG9ydF9tYXRjaDtcbnZhciBfX2V4cG9ydF9lcSA9IG1hdGNoXzEuZXE7XG5leHBvcnRzLmVxID0gX19leHBvcnRfZXE7XG52YXIgYXJyYXlUb09iamVjdF8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL29iamVjdC9hcnJheVRvT2JqZWN0XCIpO1xudmFyIF9fZXhwb3J0X2FycmF5VG9PYmplY3QgPSBhcnJheVRvT2JqZWN0XzEuYXJyYXlUb09iamVjdDtcbmV4cG9ydHMuYXJyYXlUb09iamVjdCA9IF9fZXhwb3J0X2FycmF5VG9PYmplY3Q7XG52YXIgZW50cmllc1RvT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvb2JqZWN0L2VudHJpZXNUb09iamVjdFwiKTtcbnZhciBfX2V4cG9ydF9lbnRyaWVzVG9PYmplY3QgPSBlbnRyaWVzVG9PYmplY3RfMS5lbnRyaWVzVG9PYmplY3Q7XG5leHBvcnRzLmVudHJpZXNUb09iamVjdCA9IF9fZXhwb3J0X2VudHJpZXNUb09iamVjdDtcbnZhciBmb3JFYWNoT2JqZWN0RW50cnlfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9vYmplY3QvZm9yRWFjaE9iamVjdEVudHJ5XCIpO1xudmFyIF9fZXhwb3J0X2ZvckVhY2hPYmplY3RFbnRyeSA9IGZvckVhY2hPYmplY3RFbnRyeV8xLmZvckVhY2hPYmplY3RFbnRyeTtcbmV4cG9ydHMuZm9yRWFjaE9iamVjdEVudHJ5ID0gX19leHBvcnRfZm9yRWFjaE9iamVjdEVudHJ5O1xudmFyIGluZGV4QnlfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9vYmplY3QvaW5kZXhCeVwiKTtcbnZhciBfX2V4cG9ydF9pbmRleEJ5ID0gaW5kZXhCeV8xLmluZGV4Qnk7XG5leHBvcnRzLmluZGV4QnkgPSBfX2V4cG9ydF9pbmRleEJ5O1xudmFyIG1hcE9iamVjdF8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL29iamVjdC9tYXBPYmplY3RcIik7XG52YXIgX19leHBvcnRfbWFwT2JqZWN0ID0gbWFwT2JqZWN0XzEubWFwT2JqZWN0O1xuZXhwb3J0cy5tYXBPYmplY3QgPSBfX2V4cG9ydF9tYXBPYmplY3Q7XG52YXIgb21pdF8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL29iamVjdC9vbWl0XCIpO1xudmFyIF9fZXhwb3J0X29taXQgPSBvbWl0XzEub21pdDtcbmV4cG9ydHMub21pdCA9IF9fZXhwb3J0X29taXQ7XG52YXIgcGlja18xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL29iamVjdC9waWNrXCIpO1xudmFyIF9fZXhwb3J0X3BpY2sgPSBwaWNrXzEucGljaztcbmV4cG9ydHMucGljayA9IF9fZXhwb3J0X3BpY2s7XG52YXIgZGVsYXlfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9wcm9taXNlL2RlbGF5XCIpO1xudmFyIF9fZXhwb3J0X2RlbGF5ID0gZGVsYXlfMS5kZWxheTtcbmV4cG9ydHMuZGVsYXkgPSBfX2V4cG9ydF9kZWxheTtcbnZhciBwYWRMZWZ0XzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvc3RyaW5nL3BhZExlZnRcIik7XG52YXIgX19leHBvcnRfcGFkTGVmdCA9IHBhZExlZnRfMS5wYWRMZWZ0O1xuZXhwb3J0cy5wYWRMZWZ0ID0gX19leHBvcnRfcGFkTGVmdDtcbnZhciBzcGxpdFdpdGhMaW1pdF8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL3N0cmluZy9zcGxpdFdpdGhMaW1pdFwiKTtcbnZhciBfX2V4cG9ydF9zcGxpdFdpdGhMaW1pdCA9IHNwbGl0V2l0aExpbWl0XzEuc3BsaXRXaXRoTGltaXQ7XG5leHBvcnRzLnNwbGl0V2l0aExpbWl0ID0gX19leHBvcnRfc3BsaXRXaXRoTGltaXQ7XG52YXIgdXRmOExlbmd0aF8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL3N0cmluZy91dGY4TGVuZ3RoXCIpO1xudmFyIF9fZXhwb3J0X3V0ZjhMZW5ndGggPSB1dGY4TGVuZ3RoXzEudXRmOExlbmd0aDtcbmV4cG9ydHMudXRmOExlbmd0aCA9IF9fZXhwb3J0X3V0ZjhMZW5ndGg7XG52YXIgdXRmOFN1YnN0cmluZ18xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL3N0cmluZy91dGY4U3Vic3RyaW5nXCIpO1xudmFyIF9fZXhwb3J0X3V0ZjhTdWJzdHJpbmcgPSB1dGY4U3Vic3RyaW5nXzEudXRmOFN1YnN0cmluZztcbmV4cG9ydHMudXRmOFN1YnN0cmluZyA9IF9fZXhwb3J0X3V0ZjhTdWJzdHJpbmc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVudW1lcmFibGUgPSBfX2V4cG9ydF9FbnVtZXJhYmxlO1xuZXhwb3J0cy5Ob25FbnVtZXJhYmxlID0gX19leHBvcnRfTm9uRW51bWVyYWJsZTtcbmV4cG9ydHMuZmxhdHRlbiA9IF9fZXhwb3J0X2ZsYXR0ZW47XG5leHBvcnRzLnJlc29sdmVDb25maWdWYWx1ZSA9IF9fZXhwb3J0X3Jlc29sdmVDb25maWdWYWx1ZTtcbmV4cG9ydHMuZGVwcmVjYXRlQ2xhc3MgPSBfX2V4cG9ydF9kZXByZWNhdGVDbGFzcztcbmV4cG9ydHMubWF0Y2ggPSBfX2V4cG9ydF9tYXRjaDtcbmV4cG9ydHMuZXEgPSBfX2V4cG9ydF9lcTtcbmV4cG9ydHMuYXJyYXlUb09iamVjdCA9IF9fZXhwb3J0X2FycmF5VG9PYmplY3Q7XG5leHBvcnRzLmVudHJpZXNUb09iamVjdCA9IF9fZXhwb3J0X2VudHJpZXNUb09iamVjdDtcbmV4cG9ydHMuZm9yRWFjaE9iamVjdEVudHJ5ID0gX19leHBvcnRfZm9yRWFjaE9iamVjdEVudHJ5O1xuZXhwb3J0cy5pbmRleEJ5ID0gX19leHBvcnRfaW5kZXhCeTtcbmV4cG9ydHMubWFwT2JqZWN0ID0gX19leHBvcnRfbWFwT2JqZWN0O1xuZXhwb3J0cy5vbWl0ID0gX19leHBvcnRfb21pdDtcbmV4cG9ydHMucGljayA9IF9fZXhwb3J0X3BpY2s7XG5leHBvcnRzLmRlbGF5ID0gX19leHBvcnRfZGVsYXk7XG5leHBvcnRzLnBhZExlZnQgPSBfX2V4cG9ydF9wYWRMZWZ0O1xuZXhwb3J0cy5zcGxpdFdpdGhMaW1pdCA9IF9fZXhwb3J0X3NwbGl0V2l0aExpbWl0O1xuZXhwb3J0cy51dGY4TGVuZ3RoID0gX19leHBvcnRfdXRmOExlbmd0aDtcbmV4cG9ydHMudXRmOFN1YnN0cmluZyA9IF9fZXhwb3J0X3V0ZjhTdWJzdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbHNcblx0QXRvbWljcyxcblx0U2hhcmVkQXJyYXlCdWZmZXIsXG4qL1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyAkVHlwZUVycm9yKCk7IH07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG52YXIgZ2VuZXJhdG9yOyAvLyA9IGZ1bmN0aW9uICogKCkge307XG52YXIgZ2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3IgPyBnZXRQcm90byhnZW5lcmF0b3IpIDogdW5kZWZpbmVkO1xudmFyIGFzeW5jRm47IC8vIGFzeW5jIGZ1bmN0aW9uKCkge307XG52YXIgYXN5bmNGdW5jdGlvbiA9IGFzeW5jRm4gPyBhc3luY0ZuLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkO1xudmFyIGFzeW5jR2VuOyAvLyBhc3luYyBmdW5jdGlvbiAqICgpIHt9O1xudmFyIGFzeW5jR2VuRnVuY3Rpb24gPSBhc3luY0dlbiA/IGdldFByb3RvKGFzeW5jR2VuKSA6IHVuZGVmaW5lZDtcbnZhciBhc3luY0dlbkl0ZXJhdG9yID0gYXN5bmNHZW4gPyBhc3luY0dlbigpIDogdW5kZWZpbmVkO1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLnByb3RvdHlwZSxcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IEFycmF5LnByb3RvdHlwZSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogQXJyYXkucHJvdG90eXBlLmVudHJpZXMsXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBBcnJheS5wcm90b3R5cGUua2V5cyxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBBcnJheS5wcm90b3R5cGUudmFsdWVzLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBhc3luY0Z1bmN0aW9uLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogYXN5bmNGdW5jdGlvbiA/IGFzeW5jRnVuY3Rpb24ucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IGFzeW5jR2VuID8gZ2V0UHJvdG8oYXN5bmNHZW5JdGVyYXRvcikgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBhc3luY0dlbkZ1bmN0aW9uLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IGFzeW5jR2VuRnVuY3Rpb24gPyBhc3luY0dlbkZ1bmN0aW9uLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IGFzeW5jR2VuSXRlcmF0b3IgJiYgaGFzU3ltYm9scyAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciA/IGFzeW5jR2VuSXRlcmF0b3JbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkgOiB1bmRlZmluZWQsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IEJvb2xlYW4ucHJvdG90eXBlLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcucHJvdG90eXBlLFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IERhdGUucHJvdG90eXBlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclRXJyb3JQcm90b3R5cGUlJzogRXJyb3IucHJvdG90eXBlLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogRXZhbEVycm9yLnByb3RvdHlwZSxcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LnByb3RvdHlwZSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LnByb3RvdHlwZSxcblx0JyVGdW5jdGlvbiUnOiBGdW5jdGlvbixcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBGdW5jdGlvbi5wcm90b3R5cGUsXG5cdCclR2VuZXJhdG9yJSc6IGdlbmVyYXRvciA/IGdldFByb3RvKGdlbmVyYXRvcigpKSA6IHVuZGVmaW5lZCxcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBnZW5lcmF0b3JGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogZ2VuZXJhdG9yRnVuY3Rpb24gPyBnZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheS5wcm90b3R5cGUsXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LnByb3RvdHlwZSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LnByb3RvdHlwZSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJUpTT05QYXJzZSUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OLnBhcnNlIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hcFByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcC5wcm90b3R5cGUsXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IE51bWJlci5wcm90b3R5cGUsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogT2JqZWN0LnByb3RvdHlwZSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLnByb3RvdHlwZSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLnByb3RvdHlwZS50aGVuLFxuXHQnJVByb21pc2VfYWxsJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UuYWxsLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UucmVqZWN0LFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLnJlc29sdmUsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFJhbmdlRXJyb3IucHJvdG90eXBlLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFJlZmVyZW5jZUVycm9yLnByb3RvdHlwZSxcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogUmVnRXhwLnByb3RvdHlwZSxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTZXRQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQucHJvdG90eXBlLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIucHJvdG90eXBlLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFN0cmluZy5wcm90b3R5cGUsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6IFN5bnRheEVycm9yLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFN5bnRheEVycm9yLnByb3RvdHlwZSxcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBUeXBlZEFycmF5ID8gVHlwZWRBcnJheS5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6ICRUeXBlRXJyb3IucHJvdG90eXBlLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXkucHJvdG90eXBlLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXkucHJvdG90eXBlLFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXkucHJvdG90eXBlLFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXkucHJvdG90eXBlLFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFVSSUVycm9yLnByb3RvdHlwZSxcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLnByb3RvdHlwZSxcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXQsXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0LnByb3RvdHlwZVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICghKG5hbWUgaW4gSU5UUklOU0lDUykpIHtcblx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG5cdH1cblxuXHQvLyBpc3RhbmJ1bCBpZ25vcmUgaWYgLy8gaG9wZWZ1bGx5IHRoaXMgaXMgaW1wb3NzaWJsZSB0byB0ZXN0IDotKVxuXHRpZiAodHlwZW9mIElOVFJJTlNJQ1NbbmFtZV0gPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0fVxuXG5cdHJldHVybiBJTlRSSU5TSUNTW25hbWVdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cblx0dmFyIHZhbHVlID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyAocGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJycpICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHRmb3IgKHZhciBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0c1tpXSk7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nICYmICEocGFydHNbaV0gaW4gdmFsdWUpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSBkZXNjID8gKGRlc2MuZ2V0IHx8IGRlc2MudmFsdWUpIDogdmFsdWVbcGFydHNbaV1dO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0c1tpXV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqIEBwcml2YXRlICovXG52YXIgQmFzZUFQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlQVBJKGNsaWVudCkge1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBCYXNlQVBJLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEJhc2VBUEk7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZUFQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEJhc2VBUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8vLyA8cmVmZXJlbmNlIGxpYj1cImRvbVwiIC8+XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBjcm9zc19mZXRjaF8xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY3Jvc3MtZmV0Y2hcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9sb2dnZXJcIik7XG52YXIgcXNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3FzXCIpO1xudmFyIEFjY2Vzc1Rva2VuXzEgPSByZXF1aXJlKFwiLi9BUEkvQWNjZXNzVG9rZW5cIik7XG52YXIgQmFkZ2VzQVBJXzEgPSByZXF1aXJlKFwiLi9BUEkvQmFkZ2VzL0JhZGdlc0FQSVwiKTtcbnZhciBIZWxpeEFQSUdyb3VwXzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvSGVsaXhBUElHcm91cFwiKTtcbnZhciBIZWxpeFJhdGVMaW1pdGVyXzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvSGVsaXhSYXRlTGltaXRlclwiKTtcbnZhciBDaGVlcm1vdGVMaXN0XzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL0JpdHMvQ2hlZXJtb3RlTGlzdFwiKTtcbnZhciBLcmFrZW5BUElHcm91cF8xID0gcmVxdWlyZShcIi4vQVBJL0tyYWtlbi9LcmFrZW5BUElHcm91cFwiKTtcbnZhciBUb2tlbkluZm9fMSA9IHJlcXVpcmUoXCIuL0FQSS9Ub2tlbkluZm9cIik7XG52YXIgVW5zdXBwb3J0ZWRBUElfMSA9IHJlcXVpcmUoXCIuL0FQSS9VbnN1cHBvcnRlZC9VbnN1cHBvcnRlZEFQSVwiKTtcbnZhciBDbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vQXV0aC9DbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlclwiKTtcbnZhciBSZWZyZXNoYWJsZUF1dGhQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vQXV0aC9SZWZyZXNoYWJsZUF1dGhQcm92aWRlclwiKTtcbnZhciBTdGF0aWNBdXRoUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL0F1dGgvU3RhdGljQXV0aFByb3ZpZGVyXCIpO1xudmFyIENvbmZpZ0Vycm9yXzEgPSByZXF1aXJlKFwiLi9FcnJvcnMvQ29uZmlnRXJyb3JcIik7XG52YXIgSFRUUFN0YXR1c0NvZGVFcnJvcl8xID0gcmVxdWlyZShcIi4vRXJyb3JzL0hUVFBTdGF0dXNDb2RlRXJyb3JcIik7XG52YXIgSW52YWxpZFRva2VuRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0Vycm9ycy9JbnZhbGlkVG9rZW5FcnJvclwiKTtcbi8qKlxuICogVGhlIGVuZHBvaW50IHRvIGNhbGwsIGkuZS4gL2tyYWtlbiwgL2hlbGl4IG9yIGEgY3VzdG9tIChwb3RlbnRpYWxseSB1bnN1cHBvcnRlZCkgZW5kcG9pbnQuXG4gKi9cbnZhciBUd2l0Y2hBUElDYWxsVHlwZTtcbihmdW5jdGlvbiAoVHdpdGNoQVBJQ2FsbFR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBDYWxsIGEgS3Jha2VuIEFQSSBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBUd2l0Y2hBUElDYWxsVHlwZVtUd2l0Y2hBUElDYWxsVHlwZVtcIktyYWtlblwiXSA9IDBdID0gXCJLcmFrZW5cIjtcbiAgICAvKipcbiAgICAgKiBDYWxsIGEgSGVsaXggQVBJIGVuZHBvaW50LlxuICAgICAqL1xuICAgIFR3aXRjaEFQSUNhbGxUeXBlW1R3aXRjaEFQSUNhbGxUeXBlW1wiSGVsaXhcIl0gPSAxXSA9IFwiSGVsaXhcIjtcbiAgICAvKipcbiAgICAgKiBDYWxsIGFuIGF1dGhlbnRpY2F0aW9uIGVuZHBvaW50LlxuICAgICAqL1xuICAgIFR3aXRjaEFQSUNhbGxUeXBlW1R3aXRjaEFQSUNhbGxUeXBlW1wiQXV0aFwiXSA9IDJdID0gXCJBdXRoXCI7XG4gICAgLyoqXG4gICAgICogQ2FsbCBhIGN1c3RvbSAocG90ZW50aWFsbHkgdW5zdXBwb3J0ZWQpIGVuZHBvaW50LlxuICAgICAqL1xuICAgIFR3aXRjaEFQSUNhbGxUeXBlW1R3aXRjaEFQSUNhbGxUeXBlW1wiQ3VzdG9tXCJdID0gM10gPSBcIkN1c3RvbVwiO1xufSkoVHdpdGNoQVBJQ2FsbFR5cGUgfHwgKFR3aXRjaEFQSUNhbGxUeXBlID0ge30pKTtcbmV4cG9ydHMuVHdpdGNoQVBJQ2FsbFR5cGUgPSBUd2l0Y2hBUElDYWxsVHlwZTtcbi8qKlxuICogVGhlIG1haW4gZW50cnkgcG9pbnQgb2YgdGhpcyBsaWJyYXJ5LiBNYW5hZ2VzIEFQSSBjYWxscyBhbmQgdGhlIHVzZSBvZiBhY2Nlc3MgdG9rZW5zIGluIHRoZXNlLlxuICovXG52YXIgVHdpdGNoQ2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHdpdGNoIGNsaWVudCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBmb3IgdGhlIGNsaWVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUd2l0Y2hDbGllbnQoY29uZmlnKSB7XG4gICAgICAgIHZhciBhdXRoUHJvdmlkZXIgPSBjb25maWcuYXV0aFByb3ZpZGVyLCByZXN0Q29uZmlnID0gdHNsaWJfMS5fX3Jlc3QoY29uZmlnLCBbXCJhdXRoUHJvdmlkZXJcIl0pO1xuICAgICAgICBpZiAoIWF1dGhQcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbmZpZ0Vycm9yXzEuZGVmYXVsdCgnTm8gYXV0aCBwcm92aWRlciBnaXZlbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlbGl4UmF0ZUxpbWl0ZXIgPSBuZXcgSGVsaXhSYXRlTGltaXRlcl8xLmRlZmF1bHQoY29uZmlnLmxvZ0xldmVsIHx8IGxvZ2dlcl8xLkxvZ0xldmVsLkNSSVRJQ0FMKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gdHNsaWJfMS5fX2Fzc2lnbih7IHByZUF1dGg6IGZhbHNlLCBjaGVlcm1vdGVzOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEJhY2tncm91bmQ6IENoZWVybW90ZUxpc3RfMS5DaGVlcm1vdGVCYWNrZ3JvdW5kLmRhcmssXG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlOiBDaGVlcm1vdGVMaXN0XzEuQ2hlZXJtb3RlU3RhdGUuYW5pbWF0ZWQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFNjYWxlOiBDaGVlcm1vdGVMaXN0XzEuQ2hlZXJtb3RlU2NhbGUueDFcbiAgICAgICAgICAgIH0sIGF1dGhQcm92aWRlcjogYXV0aFByb3ZpZGVyIH0sIHJlc3RDb25maWcpO1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLnByZUF1dGgpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgYXV0aFByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKHRoaXMuX2NvbmZpZy5pbml0aWFsU2NvcGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUd2l0Y2hDbGllbnRfMSA9IFR3aXRjaENsaWVudDtcbiAgICAvLyBUT0RPIDUuMDogY29uZmlnIG9iamVjdCFcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIHdpdGggZml4ZWQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiBUaGUgYWNjZXNzIHRva2VuIHRvIGNhbGwgdGhlIEFQSSB3aXRoLlxuICAgICAqXG4gICAgICogWW91IG5lZWQgdG8gb2J0YWluIG9uZSB1c2luZyBvbmUgb2YgdGhlIFtUd2l0Y2ggT0F1dGggZmxvd3NdKGh0dHBzOi8vZGV2LnR3aXRjaC50di9kb2NzL2F1dGhlbnRpY2F0aW9uL2dldHRpbmctdG9rZW5zLW9hdXRoLykuXG4gICAgICogQHBhcmFtIHNjb3BlcyBUaGUgc2NvcGVzIHlvdXIgc3VwcGxpZWQgdG9rZW4gaGFzLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIHNjb3BlcyBuZWVkIHRvIGJlIGNvcnJlY3QsIG9yIHdlaXJkIHRoaW5ncyBtaWdodCBoYXBwZW4uIElmIGl0J3Mgbm90IChpLmUuIGl0J3MgYHVuZGVmaW5lZGApLCB3ZSBmZXRjaCB0aGUgY29ycmVjdCBzY29wZXMgZm9yIHlvdS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBjYW4ndCBleGFjdGx5IHNheSB3aGljaCBzY29wZXMgeW91ciB0b2tlbiBoYXMsIGRvbid0IHVzZSB0aGlzIHBhcmFtZXRlci9zZXQgaXQgdG8gYHVuZGVmaW5lZGAuXG4gICAgICogQHBhcmFtIHJlZnJlc2hDb25maWcgQ29uZmlndXJhdGlvbiB0byBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggZXhwaXJlZCB0b2tlbnMuXG4gICAgICogQHBhcmFtIGNvbmZpZyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaWYgeW91IHByb3ZpZGUgYSBjdXN0b20gYGF1dGhQcm92aWRlcmAsIHRoaXMgbWV0aG9kIHdpbGwgb3ZlcndyaXRlIGl0LiBJbiB0aGlzIGNhc2UsIHlvdSBzaG91bGQgdXNlIHRoZSBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAgICAgKiBAcGFyYW0gdG9rZW5UeXBlIFRoZSB0eXBlIG9mIHRva2VuIHlvdSBwYXNzZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBhbG1vc3QgYWx3YXlzIGJlICd1c2VyJyAod2hpY2ggaXMgdGhlIGRlZmF1bHQpLlxuICAgICAqXG4gICAgICogSWYgeW91J3JlIHBhc3NpbmcgJ2FwcCcgaGVyZSwgcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHtAVHdpdGNoQ2xpZW50LndpdGhDbGllbnRDcmVkZW50aWFsc30gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24gKGNsaWVudElkLCBhY2Nlc3NUb2tlbiwgc2NvcGVzLCByZWZyZXNoQ29uZmlnLCBjb25maWcsIHRva2VuVHlwZSkge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgaWYgKHRva2VuVHlwZSA9PT0gdm9pZCAwKSB7IHRva2VuVHlwZSA9ICd1c2VyJzsgfVxuICAgICAgICB2YXIgYXV0aFByb3ZpZGVyID0gcmVmcmVzaENvbmZpZ1xuICAgICAgICAgICAgPyBuZXcgUmVmcmVzaGFibGVBdXRoUHJvdmlkZXJfMS5kZWZhdWx0KG5ldyBTdGF0aWNBdXRoUHJvdmlkZXJfMS5kZWZhdWx0KGNsaWVudElkLCBhY2Nlc3NUb2tlbiwgc2NvcGVzLCB0b2tlblR5cGUpLCByZWZyZXNoQ29uZmlnKVxuICAgICAgICAgICAgOiBuZXcgU3RhdGljQXV0aFByb3ZpZGVyXzEuZGVmYXVsdChjbGllbnRJZCwgYWNjZXNzVG9rZW4sIHNjb3BlcywgdG9rZW5UeXBlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgY29uZmlnKSwgeyBhdXRoUHJvdmlkZXI6IGF1dGhQcm92aWRlciB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIHdpdGggY2xpZW50IGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudElkIFRoZSBjbGllbnQgSUQgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gY2xpZW50U2VjcmV0IFRoZSBjbGllbnQgc2VjcmV0IG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIGNvbmZpZyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaWYgeW91IHByb3ZpZGUgYSBjdXN0b20gYGF1dGhQcm92aWRlcmAsIHRoaXMgbWV0aG9kIHdpbGwgb3ZlcndyaXRlIGl0LiBJbiB0aGlzIGNhc2UsIHlvdSBzaG91bGQgdXNlIHRoZSBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBUd2l0Y2hDbGllbnQud2l0aENsaWVudENyZWRlbnRpYWxzID0gZnVuY3Rpb24gKGNsaWVudElkLCBjbGllbnRTZWNyZXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgdmFyIGF1dGhQcm92aWRlciA9IGNsaWVudFNlY3JldFxuICAgICAgICAgICAgPyBuZXcgQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXJfMS5kZWZhdWx0KGNsaWVudElkLCBjbGllbnRTZWNyZXQpXG4gICAgICAgICAgICA6IG5ldyBTdGF0aWNBdXRoUHJvdmlkZXJfMS5kZWZhdWx0KGNsaWVudElkKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgY29uZmlnKSwgeyBhdXRoUHJvdmlkZXI6IGF1dGhQcm92aWRlciB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNhbGwgdG8gdGhlIFR3aXRjaCBBUEkgdXNpbmcgZ2l2ZW4gY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgY2FsbC5cbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiBUaGUgYWNjZXNzIHRva2VuIHRvIGNhbGwgdGhlIEFQSSB3aXRoLlxuICAgICAqXG4gICAgICogWW91IG5lZWQgdG8gb2J0YWluIG9uZSB1c2luZyBvbmUgb2YgdGhlIFtUd2l0Y2ggT0F1dGggZmxvd3NdKGh0dHBzOi8vZGV2LnR3aXRjaC50di9kb2NzL2F1dGhlbnRpY2F0aW9uL2dldHRpbmctdG9rZW5zLW9hdXRoLykuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBUd2l0Y2hDbGllbnQuY2FsbEFQSSA9IGZ1bmN0aW9uIChvcHRpb25zLCBjbGllbnRJZCwgYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2FsbEFQSVJhdyhvcHRpb25zLCBjbGllbnRJZCwgYWNjZXNzVG9rZW4pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fdHJhbnNmb3JtUmVzcG9uc2UocmVzcG9uc2UpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYWNjZXNzIHRva2VuIHdpdGggeW91ciBjbGllbnQgY3JlZGVudGlhbHMgYW5kIGFuIGF1dGhvcml6YXRpb24gY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnRJZCBUaGUgY2xpZW50IElEIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIGNsaWVudFNlY3JldCBUaGUgY2xpZW50IHNlY3JldCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBjb2RlIFRoZSBhdXRob3JpemF0aW9uIGNvZGUuXG4gICAgICogQHBhcmFtIHJlZGlyZWN0VXJpIFRoZSByZWRpcmVjdCBVUkkuIFRoaXMgc2VydmVzIG5vIHJlYWwgcHVycG9zZSBoZXJlLCBidXQgbXVzdCBzdGlsbCBtYXRjaCB3aXRoIHRoZSByZWRpcmVjdCBVUkkgeW91IGNvbmZpZ3VyZWQgaW4gdGhlIFR3aXRjaCBEZXZlbG9wZXIgZGFzaGJvYXJkLlxuICAgICAqL1xuICAgIFR3aXRjaENsaWVudC5nZXRBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uIChjbGllbnRJZCwgY2xpZW50U2VjcmV0LCBjb2RlLCByZWRpcmVjdFVyaSkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBBY2Nlc3NUb2tlbl8xLmRlZmF1bHQuYmluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaEFQSUNhbGxUeXBlLkF1dGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3Rva2VuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFudF90eXBlOiAnYXV0aG9yaXphdGlvbl9jb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9pZDogY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiBjbGllbnRTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RfdXJpOiByZWRpcmVjdFVyaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgKF9hLmFwcGx5KEFjY2Vzc1Rva2VuXzEuZGVmYXVsdCwgW3ZvaWQgMCwgX2Iuc2VudCgpXSkpKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhcHAgYWNjZXNzIHRva2VuIHdpdGggeW91ciBjbGllbnQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBjbGllbnRTZWNyZXQgVGhlIGNsaWVudCBzZWNyZXQgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gY2xpZW50U2VjcmV0XG4gICAgICovXG4gICAgVHdpdGNoQ2xpZW50LmdldEFwcEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKGNsaWVudElkLCBjbGllbnRTZWNyZXQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gQWNjZXNzVG9rZW5fMS5kZWZhdWx0LmJpbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hBUElDYWxsVHlwZS5BdXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICd0b2tlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ2NsaWVudF9jcmVkZW50aWFscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50X3NlY3JldDogY2xpZW50U2VjcmV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyAoX2EuYXBwbHkoQWNjZXNzVG9rZW5fMS5kZWZhdWx0LCBbdm9pZCAwLCBfYi5zZW50KCldKSkoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIGFuIGV4cGlyZWQgYWNjZXNzIHRva2VuIHdpdGggeW91ciBjbGllbnQgY3JlZGVudGlhbHMgYW5kIHRoZSByZWZyZXNoIHRva2VuIHRoYXQgd2FzIGdpdmVuIGJ5IHRoZSBpbml0aWFsIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudElkIFRoZSBjbGllbnQgSUQgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gY2xpZW50U2VjcmV0IFRoZSBjbGllbnQgc2VjcmV0IG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBUaGUgcmVmcmVzaCB0b2tlbi5cbiAgICAgKi9cbiAgICBUd2l0Y2hDbGllbnQucmVmcmVzaEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKGNsaWVudElkLCBjbGllbnRTZWNyZXQsIHJlZnJlc2hUb2tlbikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBBY2Nlc3NUb2tlbl8xLmRlZmF1bHQuYmluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaEFQSUNhbGxUeXBlLkF1dGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3Rva2VuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50X3NlY3JldDogY2xpZW50U2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyAoX2EuYXBwbHkoQWNjZXNzVG9rZW5fMS5kZWZhdWx0LCBbdm9pZCAwLCBfYi5zZW50KCldKSkoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IGFuIGFjY2VzcyB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnRJZCBUaGUgY2xpZW50IElEIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIFRoZSBhY2Nlc3MgdG9rZW4gdG8gZ2V0IHRoZSBpbmZvcm1hdGlvbiBvZi5cbiAgICAgKlxuICAgICAqIFlvdSBuZWVkIHRvIG9idGFpbiBvbmUgdXNpbmcgb25lIG9mIHRoZSBbVHdpdGNoIE9BdXRoIGZsb3dzXShodHRwczovL2Rldi50d2l0Y2gudHYvZG9jcy9hdXRoZW50aWNhdGlvbi9nZXR0aW5nLXRva2Vucy1vYXV0aC8pLlxuICAgICAqL1xuICAgIFR3aXRjaENsaWVudC5nZXRUb2tlbkluZm8gPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIGNsaWVudElkKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEsIGVfMTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2FsbEFQSSh7IHR5cGU6IFR3aXRjaEFQSUNhbGxUeXBlLkF1dGgsIHVybDogJ3ZhbGlkYXRlJyB9LCBjbGllbnRJZCwgYWNjZXNzVG9rZW4pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgVG9rZW5JbmZvXzEuZGVmYXVsdChkYXRhKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEgaW5zdGFuY2VvZiBIVFRQU3RhdHVzQ29kZUVycm9yXzEuZGVmYXVsdCAmJiBlXzEuc3RhdHVzQ29kZSA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUb2tlbkVycm9yXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aXRjaENsaWVudC5fY2FsbEFQSVJhdyA9IGZ1bmN0aW9uIChvcHRpb25zLCBjbGllbnRJZCwgYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSwgdXJsLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHksIHJlcXVlc3RPcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IG9wdGlvbnMudHlwZSA9PT0gdW5kZWZpbmVkID8gVHdpdGNoQVBJQ2FsbFR5cGUuS3Jha2VuIDogb3B0aW9ucy50eXBlO1xuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuX2dldFVybChvcHRpb25zLnVybCwgdHlwZSk7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcXNfMS5zdHJpbmdpZnkob3B0aW9ucy5xdWVyeSwgeyBhcnJheUZvcm1hdDogJ3JlcGVhdCcgfSk7XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IG5ldyBjcm9zc19mZXRjaF8xLkhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICAgICBBY2NlcHQ6IHR5cGUgPT09IFR3aXRjaEFQSUNhbGxUeXBlLktyYWtlblxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImFwcGxpY2F0aW9uL3ZuZC50d2l0Y2h0di52XCIgKyAob3B0aW9ucy52ZXJzaW9uIHx8IDUpICsgXCIranNvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHFzXzEuc3RyaW5naWZ5KG9wdGlvbnMuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuanNvbkJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbkJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudElkICYmIHR5cGUgIT09IFR3aXRjaEFQSUNhbGxUeXBlLkF1dGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoJ0NsaWVudC1JRCcsIGNsaWVudElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKCdBdXRob3JpemF0aW9uJywgKHR5cGUgPT09IFR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4ID8gJ0JlYXJlcicgOiAnT0F1dGgnKSArIFwiIFwiICsgYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNyb3NzX2ZldGNoXzEuZGVmYXVsdChwYXJhbXMgPyB1cmwgKyBcIj9cIiArIHBhcmFtcyA6IHVybCwgcmVxdWVzdE9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB5b3VyIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBUd2l0Y2hDbGllbnQucHJvdG90eXBlLmdldFRva2VuSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSwgZV8yO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsQVBJKHsgdHlwZTogVHdpdGNoQVBJQ2FsbFR5cGUuQXV0aCwgdXJsOiAndmFsaWRhdGUnIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgVG9rZW5JbmZvXzEuZGVmYXVsdChkYXRhKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzIgaW5zdGFuY2VvZiBIVFRQU3RhdHVzQ29kZUVycm9yXzEuZGVmYXVsdCAmJiBlXzIuc3RhdHVzQ29kZSA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUb2tlbkVycm9yXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8yO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYWNjZXNzIHRva2VuIGZvciB0aGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NvcGVzIFRoZSBzY29wZXMgdG8gcmVxdWVzdC5cbiAgICAgKi9cbiAgICBUd2l0Y2hDbGllbnQucHJvdG90eXBlLmdldEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKHNjb3Blcykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jb25maWcuYXV0aFByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKHNjb3BlcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciB0byByZWZyZXNoIHRoZSBhY2Nlc3MgdG9rZW4sIGlmIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIFR3aXRjaENsaWVudC5wcm90b3R5cGUucmVmcmVzaEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jb25maWcuYXV0aFByb3ZpZGVyLnJlZnJlc2ggJiYgdGhpcy5fY29uZmlnLmF1dGhQcm92aWRlci5yZWZyZXNoKCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aXRjaENsaWVudC5wcm90b3R5cGUsIFwidG9rZW5UeXBlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRva2VuIHVzZWQgYnkgdGhlIGNsaWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5hdXRoUHJvdmlkZXIudG9rZW5UeXBlIHx8ICd1c2VyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTWFrZXMgYSBjYWxsIHRvIHRoZSBUd2l0Y2ggQVBJIHVzaW5nIHlvdXIgYWNjZXNzIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGNhbGwuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBUd2l0Y2hDbGllbnQucHJvdG90eXBlLmNhbGxBUEkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhdXRoUHJvdmlkZXIsIGFjY2Vzc1Rva2VuLCByZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aFByb3ZpZGVyID0gdGhpcy5fY29uZmlnLmF1dGhQcm92aWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGF1dGhQcm92aWRlci5nZXRBY2Nlc3NUb2tlbihvcHRpb25zLnNjb3BlID8gW29wdGlvbnMuc2NvcGVdIDogdW5kZWZpbmVkKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUd2l0Y2hDbGllbnRfMS5jYWxsQVBJKG9wdGlvbnMsIGF1dGhQcm92aWRlci5jbGllbnRJZCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYWNjZXNzVG9rZW4uaXNFeHBpcmVkICYmIGF1dGhQcm92aWRlci5yZWZyZXNoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBhdXRoUHJvdmlkZXIucmVmcmVzaCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2FsbEFQSUludGVybmFsKG9wdGlvbnMsIGF1dGhQcm92aWRlci5jbGllbnRJZCwgYWNjZXNzVG9rZW4uYWNjZXNzVG9rZW4pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZS5zdGF0dXMgPT09IDQwMSAmJiBhdXRoUHJvdmlkZXIucmVmcmVzaCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYXV0aFByb3ZpZGVyLnJlZnJlc2goKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGF1dGhQcm92aWRlci5nZXRBY2Nlc3NUb2tlbihvcHRpb25zLnNjb3BlID8gW29wdGlvbnMuc2NvcGVdIDogW10pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFjY2Vzc1Rva2VuKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NhbGxBUElJbnRlcm5hbChvcHRpb25zLCBhdXRoUHJvdmlkZXIuY2xpZW50SWQsIGFjY2Vzc1Rva2VuLmFjY2Vzc1Rva2VuKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMiAvKnJldHVybiovLCBUd2l0Y2hDbGllbnRfMS5fdHJhbnNmb3JtUmVzcG9uc2UocmVzcG9uc2UpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpdGNoQ2xpZW50LnByb3RvdHlwZSwgXCJjaGVlcm1vdGVEZWZhdWx0c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBzcGVjcyBmb3IgY2hlZXJtb3Rlcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5jaGVlcm1vdGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpdGNoQ2xpZW50LnByb3RvdHlwZSwgXCJrcmFrZW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBncm91cCBvZiBLcmFrZW4gQVBJIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgS3Jha2VuQVBJR3JvdXBfMS5kZWZhdWx0KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpdGNoQ2xpZW50LnByb3RvdHlwZSwgXCJoZWxpeFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGdyb3VwIG9mIEhlbGl4IEFQSSBtZXRob2RzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlbGl4QVBJR3JvdXBfMS5kZWZhdWx0KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpdGNoQ2xpZW50LnByb3RvdHlwZSwgXCJiYWRnZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIGJhZGdlcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCYWRnZXNBUElfMS5kZWZhdWx0KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpdGNoQ2xpZW50LnByb3RvdHlwZSwgXCJ1bnN1cHBvcnRlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYXJpb3VzIEFQSSBtZXRob2RzIHRoYXQgYXJlIG5vdCBvZmZpY2lhbGx5IHN1cHBvcnRlZCBieSBUd2l0Y2guXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5zdXBwb3J0ZWRBUElfMS5kZWZhdWx0KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBUd2l0Y2hDbGllbnQucHJvdG90eXBlLl9nZXRBdXRoUHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuYXV0aFByb3ZpZGVyO1xuICAgIH07XG4gICAgVHdpdGNoQ2xpZW50LnByb3RvdHlwZS5fY2FsbEFQSUludGVybmFsID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNsaWVudElkLCBhY2Nlc3NUb2tlbikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09IFR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9oZWxpeFJhdGVMaW1pdGVyLnJlcXVlc3QoeyBvcHRpb25zOiBvcHRpb25zLCBjbGllbnRJZDogY2xpZW50SWQsIGFjY2Vzc1Rva2VuOiBhY2Nlc3NUb2tlbiB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUd2l0Y2hDbGllbnRfMS5fY2FsbEFQSVJhdyhvcHRpb25zLCBjbGllbnRJZCwgYWNjZXNzVG9rZW4pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFR3aXRjaENsaWVudC5fZ2V0VXJsID0gZnVuY3Rpb24gKHVybCwgdHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVHdpdGNoQVBJQ2FsbFR5cGUuS3Jha2VuOlxuICAgICAgICAgICAgY2FzZSBUd2l0Y2hBUElDYWxsVHlwZS5IZWxpeDpcbiAgICAgICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSB0eXBlID09PSBUd2l0Y2hBUElDYWxsVHlwZS5LcmFrZW4gPyAna3Jha2VuJyA6ICdoZWxpeCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9hcGkudHdpdGNoLnR2L1wiICsgdHlwZU5hbWUgKyBcIi9cIiArIHVybC5yZXBsYWNlKC9eXFwvLywgJycpO1xuICAgICAgICAgICAgY2FzZSBUd2l0Y2hBUElDYWxsVHlwZS5BdXRoOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi8vaWQudHdpdGNoLnR2L29hdXRoMi9cIiArIHVybC5yZXBsYWNlKC9eXFwvLywgJycpO1xuICAgICAgICAgICAgY2FzZSBUd2l0Y2hBUElDYWxsVHlwZS5DdXN0b206XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDsgLy8gd2F0XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFR3aXRjaENsaWVudC5fdHJhbnNmb3JtUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCB0ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFyZXNwb25zZS5vaykgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IEhUVFBTdGF0dXNDb2RlRXJyb3JfMS5kZWZhdWx0LmJpbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IFt2b2lkIDAsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2Uuc3RhdHVzVGV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS5qc29uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHRocm93IG5ldyAoX2EuYXBwbHkoSFRUUFN0YXR1c0NvZGVFcnJvcl8xLmRlZmF1bHQsIF9iLmNvbmNhdChbX2Muc2VudCgpXSkpKSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdOyAvLyBvb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLnRleHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdOyAvLyBtZWdhIG9vZiAtIHR3aXRjaCBkb2Vzbid0IHJldHVybiBhIHJlc3BvbnNlIHdoZW4gaXQgc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgSlNPTi5wYXJzZSh0ZXh0KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIFR3aXRjaENsaWVudF8xO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIFR3aXRjaENsaWVudC5wcm90b3R5cGUsIFwia3Jha2VuXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIFR3aXRjaENsaWVudC5wcm90b3R5cGUsIFwiaGVsaXhcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgVHdpdGNoQ2xpZW50LnByb3RvdHlwZSwgXCJiYWRnZXNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgVHdpdGNoQ2xpZW50LnByb3RvdHlwZSwgXCJ1bnN1cHBvcnRlZFwiLCBudWxsKTtcbiAgICBUd2l0Y2hDbGllbnQgPSBUd2l0Y2hDbGllbnRfMSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBUd2l0Y2hDbGllbnQpO1xuICAgIHJldHVybiBUd2l0Y2hDbGllbnQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVHdpdGNoQ2xpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVHdpdGNoQ2xpZW50O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ud2l0Y2hBUElDYWxsVHlwZSA9IFR3aXRjaEFQSUNhbGxUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gVHdpdGNoQ2xpZW50O1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY3JlYXRlQmluZGluZyhvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIiwiaW1wb3J0IHsgX19yZWFkLCBfX3NwcmVhZCB9IGZyb20gXCJ0c2xpYlwiO1xuZnVuY3Rpb24gY3JlYXRlU2luZ2xlQ2FjaGVLZXkocGFyYW0pIHtcbiAgICAvLyBub2luc3BlY3Rpb24gRmFsbFRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgc3dpdGNoICh0eXBlb2YgcGFyYW0pIHtcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzoge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgIGlmIChwYXJhbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnY2FjaGVLZXknIGluIHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLmNhY2hlS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9iaktleSA9IEpTT04uc3RyaW5naWZ5KHBhcmFtKTtcbiAgICAgICAgICAgIGlmIChvYmpLZXkgIT09ICd7fScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXkocHJvcE5hbWUsIHBhcmFtcywgcHJlZml4KSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkKFtwcm9wTmFtZV0sIHBhcmFtcy5tYXAoY3JlYXRlU2luZ2xlQ2FjaGVLZXkpKS5qb2luKCcvJykgKyAocHJlZml4ID8gJy8nIDogJycpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlQ2FjaGVLZXkuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgY3JlYXRlQ2FjaGVLZXkgZnJvbSAnLi4vdXRpbHMvY3JlYXRlQ2FjaGVLZXknO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FjaGVhYmxlKGNscykge1xuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRGcm9tQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGVLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFuQ2FjaGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXRDYWNoZSA9IGZ1bmN0aW9uIChjYWNoZUtleSwgdmFsdWUsIHRpbWVJblNlY29uZHMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cGlyZXM6IERhdGUubm93KCkgKyB0aW1lSW5TZWNvbmRzICogMTAwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnJlbW92ZUZyb21DYWNoZSA9IGZ1bmN0aW9uIChjYWNoZUtleSwgcHJlZml4KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGludGVybmFsQ2FjaGVLZXk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhY2hlS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGludGVybmFsQ2FjaGVLZXkgPSBjYWNoZUtleTtcbiAgICAgICAgICAgICAgICBpZiAoIWludGVybmFsQ2FjaGVLZXkuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbENhY2hlS2V5ICs9ICcvJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBjYWNoZUtleS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGludGVybmFsQ2FjaGVLZXkgPSBjcmVhdGVDYWNoZUtleShwcm9wTmFtZSwgY2FjaGVLZXksIHByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoaW50ZXJuYWxDYWNoZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShpbnRlcm5hbENhY2hlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuX2NsZWFuQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLmZvckVhY2goZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5leHBpcmVzIDwgbm93KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KGNscykpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGVhYmxlLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBjcmVhdGVDYWNoZUtleSBmcm9tICcuLi91dGlscy9jcmVhdGVDYWNoZUtleSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDYWNoZWQodGltZUluU2Vjb25kcywgY2FjaGVGYWlsdXJlcykge1xuICAgIGlmICh0aW1lSW5TZWNvbmRzID09PSB2b2lkIDApIHsgdGltZUluU2Vjb25kcyA9IEluZmluaXR5OyB9XG4gICAgaWYgKGNhY2hlRmFpbHVyZXMgPT09IHZvaWQgMCkgeyBjYWNoZUZhaWx1cmVzID0gZmFsc2U7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgcHJvcE5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgdmFyIG9yaWdGbiA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSwgY2FjaGVkVmFsdWUsIHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSA9IGNyZWF0ZUNhY2hlS2V5KHByb3BOYW1lLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFZhbHVlID0gdGhpcy5nZXRGcm9tQ2FjaGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2FjaGVkVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBvcmlnRm4uYXBwbHkodGhpcywgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCB8fCBjYWNoZUZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2FjaGUoY2FjaGVLZXksIHJlc3VsdCwgdGltZUluU2Vjb25kcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhY2hlZC5qcy5tYXAiLCJpbXBvcnQgY3JlYXRlQ2FjaGVLZXkgZnJvbSAnLi4vdXRpbHMvY3JlYXRlQ2FjaGVLZXknO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FjaGVkR2V0dGVyKHRpbWVJblNlY29uZHMpIHtcbiAgICBpZiAodGltZUluU2Vjb25kcyA9PT0gdm9pZCAwKSB7IHRpbWVJblNlY29uZHMgPSBJbmZpbml0eTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wTmFtZSwgZGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICAgICAgICAgIHZhciBvcmlnRm5fMSA9IGRlc2NyaXB0b3IuZ2V0O1xuICAgICAgICAgICAgZGVzY3JpcHRvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjcmVhdGVDYWNoZUtleShwcm9wTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkVmFsdWUgPSB0aGlzLmdldEZyb21DYWNoZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9yaWdGbl8xLmFwcGx5KHRoaXMsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDYWNoZShjYWNoZUtleSwgcmVzdWx0LCB0aW1lSW5TZWNvbmRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGVkR2V0dGVyLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IsIF9fcmVhZCwgX19zcHJlYWQgfSBmcm9tIFwidHNsaWJcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENsZWFyc0NhY2hlKGNhY2hlTmFtZSwgbnVtYmVyT2ZBcmd1bWVudHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgcHJvcE5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgdmFyIG9yaWdGbiA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIGFyZ3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG9yaWdGbi5hcHBseSh0aGlzLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IG51bWJlck9mQXJndW1lbnRzID09PSB1bmRlZmluZWQgPyBwYXJhbXMuc2xpY2UoKSA6IHBhcmFtcy5zbGljZSgwLCBudW1iZXJPZkFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tQ2FjaGUoX19zcHJlYWQoW2NhY2hlTmFtZV0sIGFyZ3MpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGVhcnNDYWNoZS5qcy5tYXAiLCJleHBvcnQgeyBkZWZhdWx0IGFzIENhY2hlYWJsZSB9IGZyb20gJy4vZGVjb3JhdG9ycy9DYWNoZWFibGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYWNoZWQgfSBmcm9tICcuL2RlY29yYXRvcnMvQ2FjaGVkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2FjaGVkR2V0dGVyIH0gZnJvbSAnLi9kZWNvcmF0b3JzL0NhY2hlZEdldHRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENsZWFyc0NhY2hlIH0gZnJvbSAnLi9kZWNvcmF0b3JzL0NsZWFyc0NhY2hlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3JlYXRlQ2FjaGVLZXkgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZUNhY2hlS2V5Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBFeHRyYWN0cyB0aGUgdXNlciBJRCBmcm9tIGFuIGFyZ3VtZW50IHRoYXQgaXMgcG9zc2libHkgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhhdCBJRC5cbiAqXG4gKiBAcGFyYW0gdXNlciBUaGUgdXNlciBJRCBvciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RVc2VySWQodXNlcikge1xuICAgIGlmICh0eXBlb2YgdXNlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB1c2VyID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdXNlci50b1N0cmluZygxMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdXNlci5pZDtcbiAgICB9XG59XG5leHBvcnRzLmV4dHJhY3RVc2VySWQgPSBleHRyYWN0VXNlcklkO1xuLyoqXG4gKiBFeHRyYWN0cyB0aGUgdXNlciBuYW1lIGZyb20gYW4gYXJndW1lbnQgdGhhdCBpcyBwb3NzaWJseSBhbiBvYmplY3QgY29udGFpbmluZyB0aGF0IG5hbWUuXG4gKlxuICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgbmFtZSBvciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RVc2VyTmFtZSh1c2VyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1c2VyID09PSAnc3RyaW5nJyA/IHVzZXIgOiB1c2VyLm5hbWU7XG59XG5leHBvcnRzLmV4dHJhY3RVc2VyTmFtZSA9IGV4dHJhY3RVc2VyTmFtZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVTNVR5cGUgPSByZXF1aXJlKCcuLi81L1R5cGUnKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWVjbWFzY3JpcHQtZGF0YS10eXBlcy1hbmQtdmFsdWVzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVHlwZSh4KSB7XG5cdGlmICh0eXBlb2YgeCA9PT0gJ3N5bWJvbCcpIHtcblx0XHRyZXR1cm4gJ1N5bWJvbCc7XG5cdH1cblx0cmV0dXJuIEVTNVR5cGUoeCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vY2FsbEJpbmQnKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJpbmQoR2V0SW50cmluc2ljKCdTdHJpbmcucHJvdG90eXBlLmluZGV4T2YnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKTtcblx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJlc25leHQuYXN5bmNpdGVyYWJsZVwiIC8+XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vVHdpdGNoQ2xpZW50XCIpO1xuaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoU3ltYm9sLCAnYXN5bmNJdGVyYXRvcicpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBTeW1ib2wuYXN5bmNJdGVyYXRvciA9IFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFN5bWJvbC5mb3IoJ1N5bWJvbC5hc3luY0l0ZXJhdG9yJyk7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSByZXF1ZXN0IHRvIHRoZSBuZXcgVHdpdGNoIEFQSSAoSGVsaXgpIHRoYXQgdXRpbGl6ZXMgYSBjdXJzb3IgdG8gcGFnaW5hdGUgdGhyb3VnaCBpdHMgcmVzdWx0cy5cbiAqXG4gKiBBc2lkZSBmcm9tIHRoZSBtZXRob2RzIGRlc2NyaWJlZCBiZWxvdywgeW91IGNhbiBhbHNvIHV0aWxpemUgdGhlIGFzeW5jIGl0ZXJhdG9yIHVzaW5nIGBmb3IgYXdhaXQgLi4gb2ZgOlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCByZXN1bHQgPSBjbGllbnQuaGVsaXgudmlkZW9zLmdldFZpZGVvc0J5VXNlcignMTI1MzI4NjU1Jyk7XG4gKiBmb3IgYXdhaXQgKGNvbnN0IHZpZGVvIG9mIHJlc3VsdCkge1xuICogICAgIGNvbnNvbGUubG9nKHZpZGVvLnRpdGxlKTtcbiAqIH1cbiAqIGBgYFxuICovXG52YXIgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4UGFnaW5hdGVkUmVxdWVzdChfY2FsbE9wdGlvbnMsIGNsaWVudCwgX21hcHBlcikge1xuICAgICAgICB0aGlzLl9jYWxsT3B0aW9ucyA9IF9jYWxsT3B0aW9ucztcbiAgICAgICAgdGhpcy5fbWFwcGVyID0gX21hcHBlcjtcbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0LnByb3RvdHlwZSwgXCJjdXJyZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IHJldHJpZXZlZCBwYWdlIG9mIGRhdGEgYXNzb2NpYXRlZCB0byB0aGUgcmVxdWVzdGVkIHJlc291cmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPbmx5IHdvcmtzIHdpdGgge0BIZWxpeFBhZ2luYXRlZFJlcXVlc3QjZ2V0TmV4dH0gYW5kIG5vdCB3aXRoIGFueSBvdGhlciBtZXRob2RzIG9mIGRhdGEgcmV0cmlldmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudERhdGEgPyB0aGlzLl9jdXJyZW50RGF0YS5kYXRhIDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW5kIHJldHVybnMgdGhlIG5leHQgYXZhaWxhYmxlIHBhZ2Ugb2YgZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UsIG9yIGFuIGVtcHR5IGFycmF5IGlmIHRoZXJlIGFyZSBubyBtb3JlIGF2YWlsYWJsZSBwYWdlcy5cbiAgICAgKi9cbiAgICBIZWxpeFBhZ2luYXRlZFJlcXVlc3QucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZmV0Y2hEYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fcHJvY2Vzc1Jlc3VsdChyZXN1bHQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW5kIHJldHVybnMgYWxsIGRhdGEgYXNzb2NpYXRlZCB0byB0aGUgcmVxdWVzdGVkIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCB0aGlzIG1ha2VzIG11bHRpcGxlIGNhbGxzIHRvIHRoZSBUd2l0Y2ggQVBJLiBEdWUgdG8gdGhpcywgeW91IG1pZ2h0IGJlIG1vcmUgc3VzcGVjdGlibGUgdG8gcmF0ZSBsaW1pdHMuXG4gICAgICpcbiAgICAgKiBBbHNvIGJlIGF3YXJlIHRoYXQgdGhpcyByZXNldHMgdGhlIGludGVybmFsIGN1cnNvciwgc28gYXZvaWQgdXNpbmcgdGhpcyBhbmQge0BIZWxpeFBhZ2luYXRlZFJlcXVlc3QjZ2V0TmV4dH0gdG9nZXRoZXIuXG4gICAgICovXG4gICAgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0LnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCB0c2xpYl8xLl9fc3ByZWFkKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRDdXJzb3IpIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0LnByb3RvdHlwZSwgXCJjdXJyZW50Q3Vyc29yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBjdXJzb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGlmIHlvdSB3YW50IHRvIG1ha2UgbWFudWFsIHJlcXVlc3RzIHRvIHRoZSBBUEkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q3Vyc29yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGludGVybmFsIGN1cnNvci5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBtYWtlIHtASGVsaXhQYWdpbmF0ZWRSZXF1ZXN0I2dldE5leHR9IHN0YXJ0IGZyb20gdGhlIGZpcnN0IHBhZ2UgYWdhaW4uXG4gICAgICovXG4gICAgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEN1cnNvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jdXJyZW50RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEhlbGl4UGFnaW5hdGVkUmVxdWVzdC5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gX2EoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRydWUpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHNsaWJfMS5fX2F3YWl0KHRoaXMuZ2V0TmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzUgLyp5aWVsZCoqLywgdHNsaWJfMS5fX3ZhbHVlcyh0c2xpYl8xLl9fYXN5bmNEZWxlZ2F0b3IodHNsaWJfMS5fX2FzeW5jVmFsdWVzKGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpKSkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0c2xpYl8xLl9fYXdhaXQuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0LnByb3RvdHlwZS5fZmV0Y2hEYXRhID0gZnVuY3Rpb24gKGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIGlmIChhZGRpdGlvbmFsT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGFkZGl0aW9uYWxPcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmNhbGxBUEkodHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oeyB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCB9LCB0aGlzLl9jYWxsT3B0aW9ucyksIGFkZGl0aW9uYWxPcHRpb25zKSwgeyBxdWVyeTogdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIHRoaXMuX2NhbGxPcHRpb25zLnF1ZXJ5KSwgeyBhZnRlcjogdGhpcy5fY3VycmVudEN1cnNvciwgZmlyc3Q6ICcxMDAnIH0pLCBhZGRpdGlvbmFsT3B0aW9ucy5xdWVyeSkgfSkpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIEhlbGl4UGFnaW5hdGVkUmVxdWVzdC5wcm90b3R5cGUuX3Byb2Nlc3NSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3IgPSByZXN1bHQucGFnaW5hdGlvbiA/IHJlc3VsdC5wYWdpbmF0aW9uLmN1cnNvciA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRDdXJzb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudERhdGEgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQuZGF0YS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZWxlbSkge1xuICAgICAgICAgICAgdmFyIG1hcHBlZCA9IF90aGlzLl9tYXBwZXIoZWxlbSk7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXBwZWQpID8gdHNsaWJfMS5fX3NwcmVhZChhY2MsIG1hcHBlZCkgOiB0c2xpYl8xLl9fc3ByZWFkKGFjYywgW21hcHBlZF0pO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0LnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEhlbGl4UGFnaW5hdGVkUmVxdWVzdDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFBhZ2luYXRlZFJlcXVlc3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFBhZ2luYXRlZFJlcXVlc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFBhZ2luYXRlZFJlcXVlc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRXJyb3JzL05vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXCIpO1xudmFyIENoYW5uZWxQbGFjZWhvbGRlcl8xID0gcmVxdWlyZShcIi4uL0NoYW5uZWwvQ2hhbm5lbFBsYWNlaG9sZGVyXCIpO1xuLyoqXG4gKiBBIFR3aXRjaCB1c2VyLlxuICovXG52YXIgVXNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBVc2VyKC8qKiBAcHJpdmF0ZSAqLyBfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlci5wcm90b3R5cGUsIFwiY2FjaGVLZXlcIiwge1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXIucHJvdG90eXBlLCBcImJpb1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmlvIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5iaW87XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyLnByb3RvdHlwZSwgXCJjcmVhdGlvbkRhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgd2hlbiB0aGUgdXNlciB3YXMgY3JlYXRlZCwgaS5lLiB3aGVuIHRoZXkgcmVnaXN0ZXJlZCBvbiBUd2l0Y2guXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmNyZWF0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlci5wcm90b3R5cGUsIFwidXBkYXRlRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFzdCBkYXRlIHdoZW4gdGhlIHVzZXIgY2hhbmdlZCBhbnl0aGluZyBpbiB0aGVpciBwcm9maWxlLCBlLmcuIHRoZWlyIGRlc2NyaXB0aW9uIG9yIHRoZWlyIHByb2ZpbGUgcGljdHVyZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEudXBkYXRlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1c2VyIG5hbWUgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyLnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5kaXNwbGF5X25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyLnByb3RvdHlwZSwgXCJsb2dvVXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgdG8gdGhlIHByb2ZpbGUgcGljdHVyZSBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubG9nbztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXIucHJvdG90eXBlLCBcInR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2hhbm5lbCBkYXRhIG9mIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIFVzZXIucHJvdG90eXBlLmdldENoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4uY2hhbm5lbHMuZ2V0Q2hhbm5lbCh0aGlzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgY2hhbm5lbCBwbGFjZWhvbGRlciBvYmplY3QgZm9yIHRoZSB1c2VyLCB3aGljaCBjYW4gZG8gYW55dGhpbmcgeW91IGNhbiBkbyB0byBhIGNoYW5uZWwgd2l0aCBqdXN0IHRoZSBJRC5cbiAgICAgKi9cbiAgICBVc2VyLnByb3RvdHlwZS5nZXRDaGFubmVsUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbm5lbFBsYWNlaG9sZGVyXzEuZGVmYXVsdCh0aGlzLl9kYXRhLl9pZCwgdGhpcy5fY2xpZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgc3RyZWFtIG9mIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIFVzZXIucHJvdG90eXBlLmdldFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5nZXRDaGFubmVsUGxhY2Vob2xkZXIoKS5nZXRTdHJlYW0oKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHN1YnNjcmlwdGlvbiBkYXRhIGZvciB0aGUgdXNlciB0byB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIFRocm93cyBpZiB0aGUgY2hhbm5lbCBkb2Vzbid0IGhhdmUgYSBzdWJzY3JpcHRpb24gcHJvZ3JhbSBvciB0aGUgdXNlciBpcyBub3Qgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlcXVpcmVzIGFjY2VzcyB0byB0aGUgdXNlci4gSWYgeW91IG9ubHkgaGF2ZSBhY2Nlc3MgdG8gdGhlIGNoYW5uZWwsXG4gICAgICogdXNlIHtAQ2hhbm5lbFBsYWNlaG9sZGVyI2dldFN1YnNjcmlwdGlvbkJ5fSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgeW91IHdhbnQgdG8gZ2V0IHRoZSBzdWJzY3JpcHRpb24gZGF0YSBmb3IuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9uVG8gPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLmdldFN1YnNjcmlwdGlvbkRhdGEodGhpcywgY2hhbm5lbCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgaXMgc3Vic2NyaWJlZCB0byB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHlvdSB3YW50IHRvIGNoZWNrIHRoZSBzdWJzY3JpcHRpb24gZm9yLlxuICAgICAqL1xuICAgIFVzZXIucHJvdG90eXBlLmlzU3Vic2NyaWJlZFRvID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZV8xO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRTdWJzY3JpcHRpb25UbyhjaGFubmVsKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpICE9PSBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSBpbnN0YW5jZW9mIE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXzE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgY2hhbm5lbHMgZm9sbG93ZWQgYnkgdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZSBUaGUgcmVzdWx0IHBhZ2UgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIGxpbWl0IFRoZSBudW1iZXIgb2YgcmVzdWx0cyB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gb3JkZXJCeSBUaGUgZmllbGQgdG8gb3JkZXIgYnkuXG4gICAgICogQHBhcmFtIG9yZGVyRGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdG8gb3JkZXIgaW4gLSBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZy5cbiAgICAgKi9cbiAgICBVc2VyLnByb3RvdHlwZS5nZXRGb2xsb3dzID0gZnVuY3Rpb24gKHBhZ2UsIGxpbWl0LCBvcmRlckJ5LCBvcmRlckRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLmdldEZvbGxvd2VkQ2hhbm5lbHModGhpcywgcGFnZSwgbGltaXQsIG9yZGVyQnksIG9yZGVyRGlyZWN0aW9uKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZvbGxvdyBkYXRhIG9mIHRoZSB1c2VyIHRvIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHJldHJpZXZlIHRoZSBmb2xsb3cgZGF0YSBmb3IuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuZ2V0Rm9sbG93VG8gPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLmdldEZvbGxvd2VkQ2hhbm5lbCh0aGlzLCBjaGFubmVsKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBpcyBmb2xsb3dpbmcgdGhlIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byBjaGVjayBmb3IgdGhlIHVzZXIncyBmb2xsb3cuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuZm9sbG93cyA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVfMjtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0Rm9sbG93VG8oY2hhbm5lbCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKSAhPT0gbnVsbF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9sbG93cyB0aGUgY2hhbm5lbCB3aXRoIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuZm9sbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VXNlcjtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLmdldE1lKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjdXJyZW50VXNlci5mb2xsb3dDaGFubmVsKHRoaXMpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmZvbGxvd3MgdGhlIGNoYW5uZWwgd2l0aCB0aGUgYXV0aGVudGljYXRlZCB1c2VyLlxuICAgICAqL1xuICAgIFVzZXIucHJvdG90eXBlLnVuZm9sbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VXNlcjtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLmdldE1lKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjdXJyZW50VXNlci51bmZvbGxvd0NoYW5uZWwodGhpcyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZW1vdGVzIHRoZSB1c2VyIGNhbiB1c2UuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuZ2V0RW1vdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLmdldFVzZXJFbW90ZXModGhpcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIFVzZXIucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gVXNlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVc2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVXNlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gY3JlYXRlUGFnaW5hdGVkUmVzdWx0KHJlc3BvbnNlLCB0eXBlLCBjbGllbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiAoX2IgPSAoX2EgPSByZXNwb25zZS5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgdHlwZShkYXRhLCBjbGllbnQpOyB9KSwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSksXG4gICAgICAgIGN1cnNvcjogKF9jID0gcmVzcG9uc2UucGFnaW5hdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmN1cnNvclxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZVBhZ2luYXRlZFJlc3VsdCA9IGNyZWF0ZVBhZ2luYXRlZFJlc3VsdDtcbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gY3JlYXRlUGFnaW5hdGVkUmVzdWx0V2l0aFRvdGFsKHJlc3BvbnNlLCB0eXBlLCBjbGllbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiByZXNwb25zZS5kYXRhLm1hcChmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IHR5cGUoZGF0YSwgY2xpZW50KTsgfSksXG4gICAgICAgIGN1cnNvcjogcmVzcG9uc2UucGFnaW5hdGlvbi5jdXJzb3IsXG4gICAgICAgIHRvdGFsOiByZXNwb25zZS50b3RhbFxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZVBhZ2luYXRlZFJlc3VsdFdpdGhUb3RhbCA9IGNyZWF0ZVBhZ2luYXRlZFJlc3VsdFdpdGhUb3RhbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG4vKiogQHByaXZhdGUgKi9cbnZhciBDdXN0b21FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDdXN0b21FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcigpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJhbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgdHNsaWJfMS5fX3NwcmVhZChwYXJhbXMpKSB8fCB0aGlzO1xuICAgICAgICAvLyByZXN0b3JlIHByb3RvdHlwZSBjaGFpblxuICAgICAgICB2YXIgYWN0dWFsUHJvdG8gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgX3RoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgX25ld1RhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tRXJyb3IucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDdXN0b21FcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEN1c3RvbUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ3VzdG9tRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDdXN0b21FcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQ2hhbm5lbFBsYWNlaG9sZGVyXzEgPSByZXF1aXJlKFwiLi9DaGFubmVsUGxhY2Vob2xkZXJcIik7XG4vKipcbiAqIEEgVHdpdGNoIENoYW5uZWwuXG4gKi9cbnZhciBDaGFubmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENoYW5uZWwsIF9zdXBlcik7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gQ2hhbm5lbChkYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGF0YS5faWQsIGNsaWVudCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIG92ZXJyaWRlIHBhcmVudCdzIG1ldGhvZCBzbyB3ZSBhdm9pZCB0aGUgQVBJL2NhY2hlIHJlcXVlc3QgaGVyZSBpZiBzb21lb25lIHdyb25nbHkgYXNzdW1lcyB0aGlzIGlzIGEgcGxhY2Vob2xkZXJcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBDaGFubmVsLnByb3RvdHlwZS5nZXRDaGFubmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgdGhlIHRlYW1zIG9mIHRoZSBjaGFubmVsLlxuICAgICAqL1xuICAgIENoYW5uZWwucHJvdG90eXBlLmdldFRlYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLmNoYW5uZWxzLmdldENoYW5uZWxUZWFtcyh0aGlzLl9kYXRhLl9pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2FtZSwgdGl0bGUgb3IgZGVsYXkgb2YgYSBjaGFubmVsIG9yIHRvZ2dsZXMgdGhlIGNoYW5uZWwgZmVlZC5cbiAgICAgKi9cbiAgICBDaGFubmVsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLmNoYW5uZWxzLnVwZGF0ZUNoYW5uZWwodGhpcywgZGF0YSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBjaGFubmVsLCB3aXRoIHByb3BlciBjYXBpdGFsaXphdGlvbiBvciBhcyBBc2lhbiBzY3JpcHQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmRpc3BsYXlfbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcImJyb2FkY2FzdGVyTGFuZ3VhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJyb2FkY2FzdGVyJ3MgbGFuZ3VhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJyb2FkY2FzdGVyX2xhbmd1YWdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwiYnJvYWRjYXN0ZXJUeXBlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBicm9hZGNhc3RlcidzIHR5cGUsIGkuZS4gXCJwYXJ0bmVyXCIsIFwiYWZmaWxpYXRlXCIgb3IgXCJcIiAoZW1wdHkgc3RyaW5nLCBzbyBuZWl0aGVyIG9mIHRoZW0pLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5icm9hZGNhc3Rlcl90eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwiY3JlYXRpb25EYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIHdoZW4gdGhlIGNoYW5uZWwgd2FzIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmNyZWF0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcImZvbGxvd2Vyc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHBlb3BsZSBmb2xsb3dpbmcgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmZvbGxvd2VycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcImdhbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGdhbWUgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgcGxheWVkIG9uIHRoZSBjaGFubmVsIChvciB3YXMgcGxheWVkIHdoZW4gaXQgd2FzIGxhc3Qgb25saW5lKS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2FtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcImxhbmd1YWdlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYW5ndWFnZSBvZiB0aGUgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubGFuZ3VhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJsb2dvXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgdG8gdGhlIGxvZ28gb2YgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmxvZ287XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJpc01hdHVyZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjaGFubmVsIGlzIGZsYWdnZWQgYXMgc3VpdGFibGUgZm9yIG1hdHVyZSBhdWRpZW5jZXMgb25seS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubWF0dXJlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwiaXNQYXJ0bmVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNoYW5uZWwgaXMgcGFydG5lcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5wYXJ0bmVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwicHJvZmlsZUJhbm5lclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIHRvIHRoZSBwcm9maWxlJ3MgYmFubmVyIGltYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5wcm9maWxlX2Jhbm5lcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcInByb2ZpbGVCYW5uZXJCYWNrZ3JvdW5kQ29sb3JcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIHByb2ZpbGUncyBiYW5uZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnByb2ZpbGVfYmFubmVyX2JhY2tncm91bmRfY29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJzdGF0dXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgc3RhdHVzIG1lc3NhZ2UgKGkuZS4gdGhlIHRpdGxlKSBvZiB0aGUgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc3RhdHVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwidXBkYXRlRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSB3aGVuIHRoZSBjaGFubmVsIHdhcyBsYXN0IHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLnVwZGF0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwidXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgdG8gdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcInZpZGVvQmFubmVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgdG8gdGhlIGNoYW5uZWwncyB2aWRlbyBiYW5uZXIsIGkuZS4gdGhlIG9mZmxpbmUgaW1hZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnZpZGVvX2Jhbm5lcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcInZpZXdzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2Ygdmlld3Mgb2YgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnZpZXdzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQ2hhbm5lbDtcbn0oQ2hhbm5lbFBsYWNlaG9sZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENoYW5uZWw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFubmVsO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBDdXN0b21FcnJvcl8xID0gcmVxdWlyZShcIi4vQ3VzdG9tRXJyb3JcIik7XG4vKipcbiAqIFRocm93biB3aGVuZXZlciB5b3UgdHJ5IGFjY2Vzc2luZyBhIHN1YnNjcmlwdGlvbi1yZWxhdGVkIHJlc291cmNlXG4gKiAoZm9yIGV4YW1wbGUge0BDaGFubmVsQVBJI2dldENoYW5uZWxTdWJzY3JpcHRpb25zfSlcbiAqIGFuZCB0aGUgZ2l2ZW4gY2hhbm5lbCBkb2VzIG5vdCBoYXZlIGEgc3Vic2NyaXB0aW9uIHByb2dyYW0uXG4gKi9cbnZhciBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvciwgX3N1cGVyKTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvcihjaGFubmVsSWQpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiQ2hhbm5lbCBcIiArIGNoYW5uZWxJZCArIFwiIGRvZXMgbm90IGhhdmUgYSBzdWJzY3JpcHRpb24gcHJvZ3JhbVwiKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3I7XG59KEN1c3RvbUVycm9yXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzcHJvcGVydHlrZXlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KSB7XG5cdHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N5bWJvbCc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gbWFrZVBhZ2luYXRpb25RdWVyeShfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBhZnRlciA9IF9iLmFmdGVyLCBiZWZvcmUgPSBfYi5iZWZvcmUsIGxpbWl0ID0gX2IubGltaXQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWZ0ZXI6IGFmdGVyLFxuICAgICAgICBiZWZvcmU6IGJlZm9yZSxcbiAgICAgICAgZmlyc3Q6IGxpbWl0XG4gICAgfTtcbn1cbmV4cG9ydHMubWFrZVBhZ2luYXRpb25RdWVyeSA9IG1ha2VQYWdpbmF0aW9uUXVlcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEN1c3RvbUVycm9yXzEgPSByZXF1aXJlKFwiLi9DdXN0b21FcnJvclwiKTtcbi8qKlxuICogVGhyb3duIHdoZW5ldmVyIGEgSFRUUCBlcnJvciBvY2N1cnMuIFNvbWUgSFRUUCBlcnJvcnMgYXJlIGhhbmRsZWQgaW4gdGhlIGxpYnJhcnkgd2hlbiB0aGV5J3JlIGV4cGVjdGVkLlxuICovXG52YXIgSFRUUFN0YXR1c0NvZGVFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIVFRQU3RhdHVzQ29kZUVycm9yLCBfc3VwZXIpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZnVuY3Rpb24gSFRUUFN0YXR1c0NvZGVFcnJvcihzdGF0dXNDb2RlLCBzdGF0dXNUZXh0LCBib2R5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiRW5jb3VudGVyZWQgSFRUUCBzdGF0dXMgY29kZSBcIiArIHN0YXR1c0NvZGUgKyBcIjogXCIgKyBzdGF0dXNUZXh0ICsgXCJcXG5cXG5Cb2R5OlxcblwiICsgSlNPTi5zdHJpbmdpZnkoYm9keSwgbnVsbCwgMikpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgX3RoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVFRQU3RhdHVzQ29kZUVycm9yLnByb3RvdHlwZSwgXCJzdGF0dXNDb2RlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzQ29kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUVFBTdGF0dXNDb2RlRXJyb3IucHJvdG90eXBlLCBcImJvZHlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib2R5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gSFRUUFN0YXR1c0NvZGVFcnJvcjtcbn0oQ3VzdG9tRXJyb3JfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIVFRQU3RhdHVzQ29kZUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSFRUUFN0YXR1c0NvZGVFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhUVFBTdGF0dXNDb2RlRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEN1c3RvbUVycm9yXzEgPSByZXF1aXJlKFwiLi9DdXN0b21FcnJvclwiKTtcbi8qKlxuICogVGhlc2UgYXJlIHRoZSBraW5kIG9mIGVycm9ycyB0aGF0IHNob3VsZCBuZXZlciBoYXBwZW4uXG4gKlxuICogSWYgeW91IHNlZSBvbmUgdGhyb3duLCBwbGVhc2UgZmlsZSBhIGJ1ZyBpbiB0aGUgR2l0SHViIGlzc3VlIHRyYWNrZXIuXG4gKi9cbnZhciBIZWxsRnJlZXplc092ZXJFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxsRnJlZXplc092ZXJFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxsRnJlZXplc092ZXJFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlICsgXCIgLSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIHBsZWFzZSBmaWxlIGEgYnVnIGluIHRoZSBHaXRIdWIgaXNzdWUgdHJhY2tlclwiKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSGVsbEZyZWV6ZXNPdmVyRXJyb3I7XG59KEN1c3RvbUVycm9yXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsbEZyZWV6ZXNPdmVyRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxsRnJlZXplc092ZXJFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGxGcmVlemVzT3ZlckVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNOb2RlID0gcmVxdWlyZShcImRldGVjdC1ub2RlXCIpO1xudmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiQ1JJVElDQUxcIl0gPSAwXSA9IFwiQ1JJVElDQUxcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXQVJOSU5HXCJdID0gMl0gPSBcIldBUk5JTkdcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIklORk9cIl0gPSAzXSA9IFwiSU5GT1wiO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgREVCVUcgaW5zdGVhZCAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUcxXCJdID0gNF0gPSBcIkRFQlVHMVwiO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgREVCVUcgaW5zdGVhZCAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUcyXCJdID0gNF0gPSBcIkRFQlVHMlwiO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgREVCVUcgaW5zdGVhZCAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUczXCJdID0gNF0gPSBcIkRFQlVHM1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUdcIl0gPSA0XSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlRSQUNFXCJdID0gN10gPSBcIlRSQUNFXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTG9nTGV2ZWw7XG5mdW5jdGlvbiByZXNvbHZlTG9nTGV2ZWwobGV2ZWwpIHtcbiAgICBpZiAodHlwZW9mIGxldmVsID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKExvZ0xldmVsLCBsZXZlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsZXZlbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxpZ2libGVMZXZlbHMgPSBPYmplY3Qua2V5cyhMb2dMZXZlbClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHBhcnNlSW50KGssIDEwKTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuICFpc05hTihrKSAmJiBrIDwgbGV2ZWw7IH0pO1xuICAgICAgICBpZiAoIWVsaWdpYmxlTGV2ZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9nTGV2ZWwuV0FSTklORztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgZWxpZ2libGVMZXZlbHMpO1xuICAgIH1cbiAgICB2YXIgc3RyTGV2ZWwgPSBsZXZlbC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKExvZ0xldmVsLCBzdHJMZXZlbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBsb2cgbGV2ZWwgc3RyaW5nOiBcIiArIHN0ckxldmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIExvZ0xldmVsW3N0ckxldmVsXTtcbn1cbmV4cG9ydHMucmVzb2x2ZUxvZ0xldmVsID0gcmVzb2x2ZUxvZ0xldmVsO1xuLy8gTm9kZSA4KyBkZWZpbmVzIGNvbnNvbGUuZGVidWcgYXMgbm9vcCwgYW5kIGVhcmxpZXIgdmVyc2lvbnMgZG9uJ3QgZGVmaW5lIGl0IGF0IGFsbFxudmFyIGRlYnVnRnVuY3Rpb24gPSBpc05vZGUgPyBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpIDogY29uc29sZS5kZWJ1Zy5iaW5kKGNvbnNvbGUpO1xudmFyIF9fZXhwb3J0X0xvZ0xldmVsVG9Db25zb2xlRnVuY3Rpb24gPSAoX2EgPSB7fSxcbiAgICBfYVtMb2dMZXZlbC5DUklUSUNBTF0gPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgX2FbTG9nTGV2ZWwuRVJST1JdID0gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpLFxuICAgIF9hW0xvZ0xldmVsLldBUk5JTkddID0gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSksXG4gICAgX2FbTG9nTGV2ZWwuSU5GT10gPSBjb25zb2xlLmluZm8uYmluZChjb25zb2xlKSxcbiAgICBfYVtMb2dMZXZlbC5ERUJVR10gPSBkZWJ1Z0Z1bmN0aW9uLmJpbmQoY29uc29sZSksXG4gICAgX2FbTG9nTGV2ZWwuVFJBQ0VdID0gY29uc29sZS50cmFjZS5iaW5kKGNvbnNvbGUpLFxuICAgIF9hKTtcbmV4cG9ydHMuTG9nTGV2ZWxUb0NvbnNvbGVGdW5jdGlvbiA9IF9fZXhwb3J0X0xvZ0xldmVsVG9Db25zb2xlRnVuY3Rpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBMb2dMZXZlbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IExvZ0xldmVsO1xuZXhwb3J0cy5yZXNvbHZlTG9nTGV2ZWwgPSByZXNvbHZlTG9nTGV2ZWw7XG5leHBvcnRzLkxvZ0xldmVsVG9Db25zb2xlRnVuY3Rpb24gPSBfX2V4cG9ydF9Mb2dMZXZlbFRvQ29uc29sZUZ1bmN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nTGV2ZWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNOb2RlID0gcmVxdWlyZShcImRldGVjdC1ub2RlXCIpO1xudmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiQ1JJVElDQUxcIl0gPSAwXSA9IFwiQ1JJVElDQUxcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXQVJOSU5HXCJdID0gMl0gPSBcIldBUk5JTkdcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIklORk9cIl0gPSAzXSA9IFwiSU5GT1wiO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgREVCVUcgaW5zdGVhZCAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUcxXCJdID0gNF0gPSBcIkRFQlVHMVwiO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgREVCVUcgaW5zdGVhZCAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUcyXCJdID0gNF0gPSBcIkRFQlVHMlwiO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgREVCVUcgaW5zdGVhZCAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUczXCJdID0gNF0gPSBcIkRFQlVHM1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUdcIl0gPSA0XSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlRSQUNFXCJdID0gN10gPSBcIlRSQUNFXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xuZXhwb3J0cy5Mb2dMZXZlbCA9IExvZ0xldmVsO1xuZnVuY3Rpb24gcmVzb2x2ZUxvZ0xldmVsKGxldmVsKSB7XG4gICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChMb2dMZXZlbCwgbGV2ZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsaWdpYmxlTGV2ZWxzID0gT2JqZWN0LmtleXMoTG9nTGV2ZWwpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBwYXJzZUludChrLCAxMCk7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiAhaXNOYU4oaykgJiYgayA8IGxldmVsOyB9KTtcbiAgICAgICAgaWYgKCFlbGlnaWJsZUxldmVscykge1xuICAgICAgICAgICAgcmV0dXJuIExvZ0xldmVsLldBUk5JTkc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIGVsaWdpYmxlTGV2ZWxzKTtcbiAgICB9XG4gICAgdmFyIHN0ckxldmVsID0gbGV2ZWwudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChMb2dMZXZlbCwgc3RyTGV2ZWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbG9nIGxldmVsIHN0cmluZzogXCIgKyBzdHJMZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBMb2dMZXZlbFtzdHJMZXZlbF07XG59XG5leHBvcnRzLnJlc29sdmVMb2dMZXZlbCA9IHJlc29sdmVMb2dMZXZlbDtcbi8vIE5vZGUgOCsgZGVmaW5lcyBjb25zb2xlLmRlYnVnIGFzIG5vb3AsIGFuZCBlYXJsaWVyIHZlcnNpb25zIGRvbid0IGRlZmluZSBpdCBhdCBhbGxcbnZhciBkZWJ1Z0Z1bmN0aW9uID0gaXNOb2RlID8gY29uc29sZS5sb2cuYmluZChjb25zb2xlKSA6IGNvbnNvbGUuZGVidWcuYmluZChjb25zb2xlKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnRzLkxvZ0xldmVsVG9Db25zb2xlRnVuY3Rpb24gPSAoX2EgPSB7fSxcbiAgICBfYVtMb2dMZXZlbC5DUklUSUNBTF0gPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgX2FbTG9nTGV2ZWwuRVJST1JdID0gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpLFxuICAgIF9hW0xvZ0xldmVsLldBUk5JTkddID0gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSksXG4gICAgX2FbTG9nTGV2ZWwuSU5GT10gPSBjb25zb2xlLmluZm8uYmluZChjb25zb2xlKSxcbiAgICBfYVtMb2dMZXZlbC5ERUJVR10gPSBkZWJ1Z0Z1bmN0aW9uLmJpbmQoY29uc29sZSksXG4gICAgX2FbTG9nTGV2ZWwuVFJBQ0VdID0gY29uc29sZS50cmFjZS5iaW5kKGNvbnNvbGUpLFxuICAgIF9hKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ0xldmVsLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sKCdmb28nKSA9PT0gJ3N5bWJvbCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBvcmlnRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG5cdHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgdG9TdHIuY2FsbChmbikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG9iaiA9IHt9O1xuXHR0cnkge1xuXHRcdG9yaWdEZWZpbmVQcm9wZXJ0eShvYmosICd4JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG9iaiB9KTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cdFx0Zm9yICh2YXIgXyBpbiBvYmopIHsgLy8ganNjczppZ25vcmUgZGlzYWxsb3dVbnVzZWRWYXJpYWJsZXNcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIG9iai54ID09PSBvYmo7XG5cdH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBJRSA4LiAqL1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gb3JpZ0RlZmluZVByb3BlcnR5ICYmIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQoKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuXHRpZiAobmFtZSBpbiBvYmplY3QgJiYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuXHRcdG9yaWdEZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvYmplY3RbbmFtZV0gPSB2YWx1ZTtcblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBjb25jYXQuY2FsbChwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wc1tpXSwgbWFwW3Byb3BzW2ldXSwgcHJlZGljYXRlc1twcm9wc1tpXV0pO1xuXHR9XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlUHJvbWlzZSgpIHtcblx0aWYgKHR5cGVvZiBQcm9taXNlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYFByb21pc2UuYWxsU2V0dGxlZGAgcmVxdWlyZXMgYSBnbG9iYWwgYFByb21pc2VgIGJlIGF2YWlsYWJsZS4nKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBoZXhUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICBhcnJheS5wdXNoKCclJyArICgoaSA8IDE2ID8gJzAnIDogJycpICsgaS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbn0oKSk7XG5cbnZhciBjb21wYWN0UXVldWUgPSBmdW5jdGlvbiBjb21wYWN0UXVldWUocXVldWUpIHtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICB2YXIgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFjdGVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpbal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKG9ialtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLm9ialtpdGVtLnByb3BdID0gY29tcGFjdGVkO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGFycmF5VG9PYmplY3QgPSBmdW5jdGlvbiBhcnJheVRvT2JqZWN0KHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSBvcHRpb25zICYmIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb2JqW2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiAwICovXG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICgob3B0aW9ucyAmJiAob3B0aW9ucy5wbGFpbk9iamVjdHMgfHwgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpKSB8fCAhaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtzb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbdGFyZ2V0LCBzb3VyY2VdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gW3RhcmdldF0uY29uY2F0KHNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIG1lcmdlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgIWlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBtZXJnZVRhcmdldCA9IGFycmF5VG9PYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKHRhcmdldCwgaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SXRlbSA9IHRhcmdldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SXRlbSAmJiB0eXBlb2YgdGFyZ2V0SXRlbSA9PT0gJ29iamVjdCcgJiYgaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gbWVyZ2UodGFyZ2V0SXRlbSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmIChoYXMuY2FsbChhY2MsIGtleSkpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gbWVyZ2UoYWNjW2tleV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBtZXJnZVRhcmdldCk7XG59O1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduU2luZ2xlU291cmNlKHRhcmdldCwgc291cmNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICBhY2Nba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRhcmdldCk7XG59O1xuXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gKHN0ciwgZGVjb2RlciwgY2hhcnNldCkge1xuICAgIHZhciBzdHJXaXRob3V0UGx1cyA9IHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICBpZiAoY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIC8vIHVuZXNjYXBlIG5ldmVyIHRocm93cywgbm8gdHJ5Li4uY2F0Y2ggbmVlZGVkOlxuICAgICAgICByZXR1cm4gc3RyV2l0aG91dFBsdXMucmVwbGFjZSgvJVswLTlhLWZdezJ9L2dpLCB1bmVzY2FwZSk7XG4gICAgfVxuICAgIC8vIHV0Zi04XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHJXaXRob3V0UGx1cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc3RyV2l0aG91dFBsdXM7XG4gICAgfVxufTtcblxudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShzdHIsIGRlZmF1bHRFbmNvZGVyLCBjaGFyc2V0KSB7XG4gICAgLy8gVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQnJpYW4gV2hpdGUgKG1zY2RleCkgZm9yIHRoZSBpby5qcyBjb3JlIHF1ZXJ5c3RyaW5nIGxpYnJhcnkuXG4gICAgLy8gSXQgaGFzIGJlZW4gYWRhcHRlZCBoZXJlIGZvciBzdHJpY3RlciBhZGhlcmVuY2UgdG8gUkZDIDM5ODZcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSBzdHI7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyaW5nID0gU3RyaW5nKHN0cik7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICByZXR1cm4gZXNjYXBlKHN0cmluZykucmVwbGFjZSgvJXVbMC05YS1mXXs0fS9naSwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyUyNiUyMycgKyBwYXJzZUludCgkMC5zbGljZSgyKSwgMTYpICsgJyUzQic7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuICAgICAgICAgICAgfHwgYyA9PT0gMHgyRSAvLyAuXG4gICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cbiAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgfHwgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIC8vIDAtOVxuICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxuICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICApIHtcbiAgICAgICAgICAgIG91dCArPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIGhleFRhYmxlW2NdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhDMCB8IChjID4+IDYpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPj0gMHhFMDAwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhFMCB8IChjID4+IDEyKV0gKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgICBjID0gMHgxMDAwMCArICgoKGMgJiAweDNGRikgPDwgMTApIHwgKHN0cmluZy5jaGFyQ29kZUF0KGkpICYgMHgzRkYpKTtcbiAgICAgICAgb3V0ICs9IGhleFRhYmxlWzB4RjAgfCAoYyA+PiAxOCldXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzRildXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG52YXIgY29tcGFjdCA9IGZ1bmN0aW9uIGNvbXBhY3QodmFsdWUpIHtcbiAgICB2YXIgcXVldWUgPSBbeyBvYmo6IHsgbzogdmFsdWUgfSwgcHJvcDogJ28nIH1dO1xuICAgIHZhciByZWZzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWVbaV07XG4gICAgICAgIHZhciBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgcmVmcy5pbmRleE9mKHZhbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh7IG9iajogb2JqLCBwcm9wOiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgcmVmcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wYWN0UXVldWUocXVldWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGlzUmVnRXhwID0gZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbn07XG5cbnZhciBpc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSk7XG59O1xuXG52YXIgY29tYmluZSA9IGZ1bmN0aW9uIGNvbWJpbmUoYSwgYikge1xuICAgIHJldHVybiBbXS5jb25jYXQoYSwgYik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhcnJheVRvT2JqZWN0OiBhcnJheVRvT2JqZWN0LFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGNvbWJpbmU6IGNvbWJpbmUsXG4gICAgY29tcGFjdDogY29tcGFjdCxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gICAgaXNSZWdFeHA6IGlzUmVnRXhwLFxuICAgIG1lcmdlOiBtZXJnZVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkYXRhIG9mIGFuIE9BdXRoIGFjY2VzcyB0b2tlbiByZXR1cm5lZCBieSBUd2l0Y2guXG4gKi9cbnZhciBBY2Nlc3NUb2tlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBBY2Nlc3NUb2tlbihfZGF0YSwgb2J0YWlubWVudERhdGUpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9vYnRhaW5tZW50RGF0ZSA9IG9idGFpbm1lbnREYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY2Nlc3NUb2tlbi5wcm90b3R5cGUsIFwiYWNjZXNzVG9rZW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjY2VzcyB0b2tlbiB3aGljaCBpcyBuZWNlc3NhcnkgZm9yIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIFR3aXRjaCBBUEkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmFjY2Vzc190b2tlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjY2Vzc1Rva2VuLnByb3RvdHlwZSwgXCJyZWZyZXNoVG9rZW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlZnJlc2ggdG9rZW4gd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIHJlZnJlc2ggdGhlIGFjY2VzcyB0b2tlbiBvbmNlIGl0IGV4cGlyZXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY2Nlc3NUb2tlbi5wcm90b3R5cGUsIFwiZXhwaXJ5RGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSB3aGVuIHRoZSBhY2Nlc3MgdG9rZW4gd2lsbCBleHBpcmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIE1heSBiZSBgbnVsbGAsIGluIHdoaWNoIGNhc2UgdGhlIHRva2VuIGRvZXMgbm90IGV4cGlyZS5cbiAgICAgICAgICogVGhpcyBjYW4gb25seSBiZSB0aGUgY2FzZSB3aXRoIHZlcnkgb2xkIENsaWVudCBJRHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGF0YS5leHBpcmVzX2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fb2J0YWlubWVudERhdGUuZ2V0VGltZSgpICsgdGhpcy5fZGF0YS5leHBpcmVzX2luICogMTAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY2Nlc3NUb2tlbi5wcm90b3R5cGUsIFwiaXNFeHBpcmVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RhdGEuZXhwaXJlc19pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpID4gdGhpcy5fb2J0YWlubWVudERhdGUuZ2V0VGltZSgpICsgdGhpcy5fZGF0YS5leHBpcmVzX2luICogMTAwMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjY2Vzc1Rva2VuLnByb3RvdHlwZSwgXCJzY29wZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NvcGUgdGhlIGFjY2VzcyB0b2tlbiBpcyB2YWxpZCBmb3IsIGkuZS4gd2hhdCB0aGlzIHRva2VuIGVuYWJsZXMgeW91IHRvIGRvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zY29wZSB8fCBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEFjY2Vzc1Rva2VuO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFjY2Vzc1Rva2VuO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWNjZXNzVG9rZW47XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBY2Nlc3NUb2tlbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5mdW5jdGlvbiBhcnJheVRvT2JqZWN0KGFyciwgZm4pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIHRzbGliXzEuX19zcHJlYWQoW3t9XSwgYXJyLm1hcChmbikpKTtcbn1cbmV4cG9ydHMuYXJyYXlUb09iamVjdCA9IGFycmF5VG9PYmplY3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFycmF5VG9PYmplY3QgPSBhcnJheVRvT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXlUb09iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgYmFuIG9mIGEgdXNlci5cbiAqL1xudmFyIEhlbGl4QmFuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4QmFuKF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEJhbi5wcm90b3R5cGUsIFwidXNlcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG1vcmUgZGF0YSBhYm91dCB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBIZWxpeEJhbi5wcm90b3R5cGUuZ2V0VXNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeUlkKHRoaXMuX2RhdGEudXNlcl9pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QmFuLnByb3RvdHlwZSwgXCJ1c2VyTmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCYW4ucHJvdG90eXBlLCBcImV4cGlyeURhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgd2hlbiB0aGUgYmFuIHdpbGwgZXhwaXJlOyBudWxsIGZvciBwZXJtYW5lbnQgYmFucy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZXhwaXJlc19hdCA/IG5ldyBEYXRlKHRoaXMuX2RhdGEuZXhwaXJlc19hdCkgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgSGVsaXhCYW4ucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gSGVsaXhCYW47XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhCYW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeEJhbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4QmFuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vZGVyYXRvciBzdGF0dXMgb2YgYSB1c2VyLlxuICovXG52YXIgSGVsaXhNb2RlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhNb2RlcmF0b3IoX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4TW9kZXJhdG9yLnByb3RvdHlwZSwgXCJ1c2VySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgbW9yZSBkYXRhIGFib3V0IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIEhlbGl4TW9kZXJhdG9yLnByb3RvdHlwZS5nZXRVc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy5fZGF0YS51c2VyX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhNb2RlcmF0b3IucHJvdG90eXBlLCBcInVzZXJOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeE1vZGVyYXRvci5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWxpeE1vZGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeE1vZGVyYXRvcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4TW9kZXJhdG9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhNb2RlcmF0b3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBBIChwYWlkKSBzdWJzY3JpcHRpb24gb2YgYSB1c2VyIHRvIGEgYnJvYWRjYXN0ZXIuXG4gKi9cbnZhciBIZWxpeFN1YnNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeFN1YnNjcmlwdGlvbihfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcImJyb2FkY2FzdGVySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgSUQgb2YgdGhlIGJyb2FkY2FzdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5icm9hZGNhc3Rlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJicm9hZGNhc3RlckRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIGJyb2FkY2FzdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5icm9hZGNhc3Rlcl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgbW9yZSBkYXRhIGFib3V0IHRoZSBicm9hZGNhc3Rlci5cbiAgICAgKi9cbiAgICBIZWxpeFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZ2V0QnJvYWRjYXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCh0aGlzLmJyb2FkY2FzdGVySWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwiaXNHaWZ0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHN1YnNjcmlwdGlvbiBoYXMgYmVlbiBnaWZ0ZWQgYnkgYW5vdGhlciB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pc19naWZ0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcInRpZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpZXIgb2YgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudGllcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJ1c2VySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgSUQgb2YgdGhlIHN1YnNjcmliZWQgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJ1c2VyRGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgc3Vic2NyaWJlZCB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBtb3JlIGRhdGEgYWJvdXQgdGhlIHN1YnNjcmliZWQgdXNlci5cbiAgICAgKi9cbiAgICBIZWxpeFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZ2V0VXNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeUlkKHRoaXMudXNlcklkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgSGVsaXhTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gSGVsaXhTdWJzY3JpcHRpb247XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdWJzY3JpcHRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFN1YnNjcmlwdGlvbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4U3Vic2NyaXB0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0Vycm9ycy9Ob1N1YnNjcmlwdGlvblByb2dyYW1FcnJvclwiKTtcbi8qKlxuICogVGhlIHR5cGUgb2YgYSBicm9hZGNhc3Rlci5cbiAqL1xudmFyIEhlbGl4QnJvYWRjYXN0ZXJUeXBlO1xuKGZ1bmN0aW9uIChIZWxpeEJyb2FkY2FzdGVyVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEEgVHdpdGNoIFBhcnRuZXIuXG4gICAgICovXG4gICAgSGVsaXhCcm9hZGNhc3RlclR5cGVbXCJQYXJ0bmVyXCJdID0gXCJwYXJ0bmVyXCI7XG4gICAgLyoqXG4gICAgICogQSBUd2l0Y2ggQWZmaWxpYXRlLlxuICAgICAqL1xuICAgIEhlbGl4QnJvYWRjYXN0ZXJUeXBlW1wiQWZmaWxpYXRlXCJdID0gXCJhZmZpbGlhdGVcIjtcbiAgICAvKipcbiAgICAgKiBBIHVzZXIgdGhhdCdzIG5laXRoZXIgYSBwYXJ0bmVyIG5vciBhbiBhZmZpbGlhdGUuXG4gICAgICovXG4gICAgSGVsaXhCcm9hZGNhc3RlclR5cGVbXCJOb25lXCJdID0gXCJcIjtcbn0pKEhlbGl4QnJvYWRjYXN0ZXJUeXBlIHx8IChIZWxpeEJyb2FkY2FzdGVyVHlwZSA9IHt9KSk7XG5leHBvcnRzLkhlbGl4QnJvYWRjYXN0ZXJUeXBlID0gSGVsaXhCcm9hZGNhc3RlclR5cGU7XG4vKipcbiAqIFRoZSB0eXBlIG9mIGEgdXNlci5cbiAqL1xudmFyIEhlbGl4VXNlclR5cGU7XG4oZnVuY3Rpb24gKEhlbGl4VXNlclR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBIFR3aXRjaCBzdGFmZiBtZW1iZXIuXG4gICAgICovXG4gICAgSGVsaXhVc2VyVHlwZVtcIlN0YWZmXCJdID0gXCJzdGFmZlwiO1xuICAgIC8qKlxuICAgICAqIEEgVHdpdGNoIGFkbWluaXN0cmF0b3IuXG4gICAgICovXG4gICAgSGVsaXhVc2VyVHlwZVtcIkFkbWluXCJdID0gXCJhZG1pblwiO1xuICAgIC8qKlxuICAgICAqIEEgZ2xvYmFsIG1vZGVyYXRvci5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXJUeXBlW1wiR2xvYmFsTW9kXCJdID0gXCJnbG9iYWxfbW9kXCI7XG4gICAgLyoqXG4gICAgICogQSB1c2VyIHdpdGggbm8gc3BlY2lhbCBwZXJtaXNzaW9ucyBhY3Jvc3MgVHdpdGNoLlxuICAgICAqL1xuICAgIEhlbGl4VXNlclR5cGVbXCJOb25lXCJdID0gXCJcIjtcbn0pKEhlbGl4VXNlclR5cGUgfHwgKEhlbGl4VXNlclR5cGUgPSB7fSkpO1xuZXhwb3J0cy5IZWxpeFVzZXJUeXBlID0gSGVsaXhVc2VyVHlwZTtcbi8qKlxuICogQSBUd2l0Y2ggdXNlci5cbiAqL1xudmFyIEhlbGl4VXNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeFVzZXIoLyoqIEBwcml2YXRlICovIF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFVzZXIucHJvdG90eXBlLCBcImNhY2hlS2V5XCIsIHtcbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFVzZXIucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFVzZXIucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgbmFtZSBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubG9naW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFVzZXIucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmRpc3BsYXlfbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VXNlci5wcm90b3R5cGUsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VXNlci5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VXNlci5wcm90b3R5cGUsIFwiYnJvYWRjYXN0ZXJUeXBlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5icm9hZGNhc3Rlcl90eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhVc2VyLnByb3RvdHlwZSwgXCJwcm9maWxlUGljdHVyZVVybFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIHRvIHRoZSBwcm9maWxlIHBpY3R1cmUgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnByb2ZpbGVfaW1hZ2VfdXJsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhVc2VyLnByb3RvdHlwZSwgXCJvZmZsaW5lUGxhY2Vob2xkZXJVcmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCB0byB0aGUgb2ZmbGluZSB2aWRlbyBwbGFjZWhvbGRlciBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEub2ZmbGluZV9pbWFnZV91cmw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFVzZXIucHJvdG90eXBlLCBcInZpZXdzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2Ygdmlld3Mgb2YgdGhlIHVzZXIncyBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS52aWV3X2NvdW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNoYW5uZWwncyBzdHJlYW0gZGF0YS5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXIucHJvdG90eXBlLmdldFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnN0cmVhbXMuZ2V0U3RyZWFtQnlVc2VySWQodGhpcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBicm9hZGNhc3RlcnMgdGhlIHVzZXIgZm9sbG93cy5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXIucHJvdG90eXBlLmdldEZvbGxvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRGb2xsb3dzKHsgdXNlcjogdGhpcyB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZvbGxvdyBkYXRhIG9mIHRoZSB1c2VyIHRvIHRoZSBnaXZlbiBicm9hZGNhc3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBicm9hZGNhc3RlciBUaGUgYnJvYWRjYXN0ZXIgdG8gY2hlY2sgdGhlIGZvbGxvdyB0by5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXIucHJvdG90eXBlLmdldEZvbGxvd1RvID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcywgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2xsb3dlZFVzZXI6IGJyb2FkY2FzdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldEZvbGxvd3MocGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChfYS5zZW50KCkpLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0Lmxlbmd0aCA/IHJlc3VsdFswXSA6IG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGZvbGxvd2luZyB0aGUgZ2l2ZW4gYnJvYWRjYXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIHRvIGNoZWNrIHRoZSB1c2VyJ3MgZm9sbG93IHRvLlxuICAgICAqL1xuICAgIEhlbGl4VXNlci5wcm90b3R5cGUuZm9sbG93cyA9IGZ1bmN0aW9uIChicm9hZGNhc3Rlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEZvbGxvd1RvKGJyb2FkY2FzdGVyKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpICE9PSBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2xsb3dzIHRoZSBicm9hZGNhc3Rlci5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXIucHJvdG90eXBlLmZvbGxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFVzZXI7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmtyYWtlbi51c2Vycy5nZXRNZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFVzZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY3VycmVudFVzZXIuZm9sbG93Q2hhbm5lbCh0aGlzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5mb2xsb3dzIHRoZSBicm9hZGNhc3Rlci5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXIucHJvdG90eXBlLnVuZm9sbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VXNlcjtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLmdldE1lKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjdXJyZW50VXNlci51bmZvbGxvd0NoYW5uZWwodGhpcyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc3Vic2NyaXB0aW9uIGRhdGEgZm9yIHRoZSB1c2VyIHRvIHRoZSBnaXZlbiBicm9hZGNhc3Rlciwgb3IgYG51bGxgIGlmIHRoZSB1c2VyIGlzIG5vdCBzdWJzY3JpYmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciB5b3Ugd2FudCB0byBnZXQgdGhlIHN1YnNjcmlwdGlvbiBkYXRhIGZvci5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXIucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvblRvID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC5zdWJzY3JpcHRpb25zLmdldFN1YnNjcmlwdGlvbkZvclVzZXIoYnJvYWRjYXN0ZXIsIHRoaXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIHN1YnNjcmliZWQgdG8gdGhlIGdpdmVuIGJyb2FkY2FzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciB5b3Ugd2FudCB0byBjaGVjayB0aGUgc3Vic2NyaXB0aW9uIGZvci5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXIucHJvdG90eXBlLmlzU3Vic2NyaWJlZFRvID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVfMTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0U3Vic2NyaXB0aW9uVG8oYnJvYWRjYXN0ZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSkgIT09IG51bGxdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xIGluc3RhbmNlb2YgTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIEhlbGl4VXNlci5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWxpeFVzZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhVc2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhVc2VyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IZWxpeEJyb2FkY2FzdGVyVHlwZSA9IEhlbGl4QnJvYWRjYXN0ZXJUeXBlO1xuZXhwb3J0cy5IZWxpeFVzZXJUeXBlID0gSGVsaXhVc2VyVHlwZTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4VXNlcjtcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NyZWF0ZUJpbmRpbmcobywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGNhbGwsIGFyZ3VtZW50cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xudmFyICRTeW50YXhFcnJvciA9IEdldEludHJpbnNpYygnJVN5bnRheEVycm9yJScpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG5cbnZhciBwcmVkaWNhdGVzID0ge1xuXHQvLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcHJvcGVydHktZGVzY3JpcHRvci1zcGVjaWZpY2F0aW9uLXR5cGVcblx0J1Byb3BlcnR5IERlc2NyaXB0b3InOiBmdW5jdGlvbiBpc1Byb3BlcnR5RGVzY3JpcHRvcihUeXBlLCBEZXNjKSB7XG5cdFx0aWYgKFR5cGUoRGVzYykgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciBhbGxvd2VkID0ge1xuXHRcdFx0J1tbQ29uZmlndXJhYmxlXV0nOiB0cnVlLFxuXHRcdFx0J1tbRW51bWVyYWJsZV1dJzogdHJ1ZSxcblx0XHRcdCdbW0dldF1dJzogdHJ1ZSxcblx0XHRcdCdbW1NldF1dJzogdHJ1ZSxcblx0XHRcdCdbW1ZhbHVlXV0nOiB0cnVlLFxuXHRcdFx0J1tbV3JpdGFibGVdXSc6IHRydWVcblx0XHR9O1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIERlc2MpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRcdFx0aWYgKGhhcyhEZXNjLCBrZXkpICYmICFhbGxvd2VkW2tleV0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBpc0RhdGEgPSBoYXMoRGVzYywgJ1tbVmFsdWVdXScpO1xuXHRcdHZhciBJc0FjY2Vzc29yID0gaGFzKERlc2MsICdbW0dldF1dJykgfHwgaGFzKERlc2MsICdbW1NldF1dJyk7XG5cdFx0aWYgKGlzRGF0YSAmJiBJc0FjY2Vzc29yKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignUHJvcGVydHkgRGVzY3JpcHRvcnMgbWF5IG5vdCBiZSBib3RoIGFjY2Vzc29yIGFuZCBkYXRhIGRlc2NyaXB0b3JzJyk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2VydFJlY29yZChUeXBlLCByZWNvcmRUeXBlLCBhcmd1bWVudE5hbWUsIHZhbHVlKSB7XG5cdHZhciBwcmVkaWNhdGUgPSBwcmVkaWNhdGVzW3JlY29yZFR5cGVdO1xuXHRpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Vua25vd24gcmVjb3JkIHR5cGU6ICcgKyByZWNvcmRUeXBlKTtcblx0fVxuXHRpZiAoIXByZWRpY2F0ZShUeXBlLCB2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcihhcmd1bWVudE5hbWUgKyAnIG11c3QgYmUgYSAnICsgcmVjb3JkVHlwZSk7XG5cdH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIEhlbGxGcmVlemVzT3ZlckVycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRXJyb3JzL0hlbGxGcmVlemVzT3ZlckVycm9yXCIpO1xuLyoqXG4gKiBUaGUgdHlwZSBvZiBiYWNrZ3JvdW5kIGEgY2hlZXJtb3RlIGlzIHN1cHBvc2VkIHRvIGFwcGVhciBvbi5cbiAqXG4gKiBXZSB3aWxsIHN1cHBseSBhIGZpdHRpbmcgZ3JhcGhpYyB0aGF0IGRvZXMgbm90IHNob3cgYW55IGFydGlmYWN0c1xuICogb24gdGhlIGdpdmVuIHR5cGUgb2YgYmFja2dyb3VuZC5cbiAqL1xudmFyIENoZWVybW90ZUJhY2tncm91bmQ7XG4oZnVuY3Rpb24gKENoZWVybW90ZUJhY2tncm91bmQpIHtcbiAgICAvKipcbiAgICAgKiBBIGRhcmsgYmFja2dyb3VuZC5cbiAgICAgKlxuICAgICAqIENoZWVybW90ZXMgbWlnaHQgc2hvdyBhcnRpZmFjdHMgb24gYnJpZ2h0IGJhY2tncm91bmRzLlxuICAgICAqL1xuICAgIENoZWVybW90ZUJhY2tncm91bmRbXCJkYXJrXCJdID0gXCJkYXJrXCI7XG4gICAgLyoqXG4gICAgICogQSBicmlnaHQgYmFja2dyb3VuZC5cbiAgICAgKlxuICAgICAqIENoZWVybW90ZXMgbWlnaHQgc2hvdyBhcnRpZmFjdHMgb24gZGFyayBiYWNrZ3JvdW5kcy5cbiAgICAgKi9cbiAgICBDaGVlcm1vdGVCYWNrZ3JvdW5kW1wibGlnaHRcIl0gPSBcImxpZ2h0XCI7XG59KShDaGVlcm1vdGVCYWNrZ3JvdW5kIHx8IChDaGVlcm1vdGVCYWNrZ3JvdW5kID0ge30pKTtcbmV4cG9ydHMuQ2hlZXJtb3RlQmFja2dyb3VuZCA9IENoZWVybW90ZUJhY2tncm91bmQ7XG4vKipcbiAqIFRoZSBzdGF0ZSBvZiBhIGNoZWVybW90ZSwgaS5lLiB3aGV0aGVyIGl0J3MgYW5pbWF0ZWQgb3Igbm90LlxuICovXG52YXIgQ2hlZXJtb3RlU3RhdGU7XG4oZnVuY3Rpb24gKENoZWVybW90ZVN0YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNoZWVybW90ZSBzaG91bGQgYmUgYW5pbWF0ZWQuXG4gICAgICovXG4gICAgQ2hlZXJtb3RlU3RhdGVbXCJhbmltYXRlZFwiXSA9IFwiYW5pbWF0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hlZXJtb3RlIHNob3VsZCBub3QgYmUgYW5pbWF0ZWQuXG4gICAgICovXG4gICAgQ2hlZXJtb3RlU3RhdGVbXCJzdGF0aWNcIl0gPSBcInN0YXRpY1wiO1xufSkoQ2hlZXJtb3RlU3RhdGUgfHwgKENoZWVybW90ZVN0YXRlID0ge30pKTtcbmV4cG9ydHMuQ2hlZXJtb3RlU3RhdGUgPSBDaGVlcm1vdGVTdGF0ZTtcbi8qKlxuICogVGhlIHNjYWxlIG9mIHRoZSBjaGVlcm1vdGUsIHdoaWNoIHVzdWFsbHkgcmVsYXRlcyB0byB0aGUgcGl4ZWwgZGVuc2l0eSBvZiB0aGUgZGV2aWNlIGluIHVzZS5cbiAqL1xudmFyIENoZWVybW90ZVNjYWxlO1xuKGZ1bmN0aW9uIChDaGVlcm1vdGVTY2FsZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGVlcm1vdGUgc2hvdWxkIG5vdCBiZSBzY2FsZWQuXG4gICAgICovXG4gICAgQ2hlZXJtb3RlU2NhbGVbXCJ4MVwiXSA9IFwiMVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGVlcm1vdGUgc2hvdWxkIGJlIHNjYWxlZCAxLjV4LlxuICAgICAqL1xuICAgIENoZWVybW90ZVNjYWxlW1wieDFfNVwiXSA9IFwiMS41XCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNoZWVybW90ZSBzaG91bGQgYmUgc2NhbGVkIDJ4LlxuICAgICAqL1xuICAgIENoZWVybW90ZVNjYWxlW1wieDJcIl0gPSBcIjJcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hlZXJtb3RlIHNob3VsZCBiZSBzY2FsZWQgM3guXG4gICAgICovXG4gICAgQ2hlZXJtb3RlU2NhbGVbXCJ4M1wiXSA9IFwiM1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGVlcm1vdGUgc2hvdWxkIGJlIHNjYWxlZCA0eC5cbiAgICAgKi9cbiAgICBDaGVlcm1vdGVTY2FsZVtcIng0XCJdID0gXCI0XCI7XG59KShDaGVlcm1vdGVTY2FsZSB8fCAoQ2hlZXJtb3RlU2NhbGUgPSB7fSkpO1xuZXhwb3J0cy5DaGVlcm1vdGVTY2FsZSA9IENoZWVybW90ZVNjYWxlO1xuLyoqXG4gKiBBIGxpc3Qgb2YgY2hlZXJtb3RlcyB5b3UgY2FuIHVzZSBnbG9iYWxseSBvciBpbiBhIHNwZWNpZmljIGNoYW5uZWwsIGRlcGVuZGluZyBvbiBob3cgeW91IGZldGNoZWQgdGhlIGxpc3QuXG4gKi9cbnZhciBDaGVlcm1vdGVMaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIENoZWVybW90ZUxpc3QoZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHNoYXJlZF91dGlsc18xLmluZGV4QnkoZGF0YSwgZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gYWN0aW9uLnByZWZpeC50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgVVJMIGFuZCBjb2xvciBuZWVkZWQgdG8gcHJvcGVybHkgcmVwcmVzZW50IGEgY2hlZXIgb2YgdGhlIGdpdmVuIGFtb3VudCBvZiBiaXRzIHdpdGggdGhlIGdpdmVuIHByZWZpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lL3ByZWZpeCBvZiB0aGUgY2hlZXJtb3RlLlxuICAgICAqIEBwYXJhbSBiaXRzIFRoZSBhbW91bnQgb2YgYml0cyBjaGVlcmVkLlxuICAgICAqIEBwYXJhbSBmb3JtYXQgVGhlIGZvcm1hdCBvZiB0aGUgY2hlZXJtb3RlIHlvdSB3YW50IHRvIHJlcXVlc3QuXG4gICAgICovXG4gICAgQ2hlZXJtb3RlTGlzdC5wcm90b3R5cGUuZ2V0Q2hlZXJtb3RlRGlzcGxheUluZm8gPSBmdW5jdGlvbiAobmFtZSwgYml0cywgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IHZvaWQgMCkgeyBmb3JtYXQgPSB7fTsgfVxuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgY2hlZXJtb3RlRGVmYXVsdHMgPSB0aGlzLl9jbGllbnQuY2hlZXJtb3RlRGVmYXVsdHM7XG4gICAgICAgIHZhciBmdWxsT3B0aW9ucyA9IHRzbGliXzEuX19hc3NpZ24oeyBiYWNrZ3JvdW5kOiBjaGVlcm1vdGVEZWZhdWx0cy5kZWZhdWx0QmFja2dyb3VuZCwgc3RhdGU6IGNoZWVybW90ZURlZmF1bHRzLmRlZmF1bHRTdGF0ZSwgc2NhbGU6IGNoZWVybW90ZURlZmF1bHRzLmRlZmF1bHRTY2FsZSB9LCBmb3JtYXQpO1xuICAgICAgICB2YXIgdGllcnMgPSB0aGlzLl9kYXRhW25hbWVdLnRpZXJzO1xuICAgICAgICB2YXIgY29ycmVjdFRpZXIgPSB0aWVycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLm1pbl9iaXRzIC0gYS5taW5fYml0czsgfSkuZmluZChmdW5jdGlvbiAodGllcikgeyByZXR1cm4gdGllci5taW5fYml0cyA8PSBiaXRzOyB9KTtcbiAgICAgICAgaWYgKCFjb3JyZWN0VGllcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEhlbGxGcmVlemVzT3ZlckVycm9yXzEuZGVmYXVsdChcIkNoZWVybW90ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGRvZXMgbm90IGhhdmUgYW4gYXBwbGljYWJsZSB0aWVyIGZvciBcIiArIGJpdHMgKyBcIiBiaXRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IGNvcnJlY3RUaWVyLmltYWdlc1tmdWxsT3B0aW9ucy5iYWNrZ3JvdW5kXVtmdWxsT3B0aW9ucy5zdGF0ZV1bZnVsbE9wdGlvbnMuc2NhbGVdLFxuICAgICAgICAgICAgY29sb3I6IGNvcnJlY3RUaWVyLmNvbG9yXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBwb3NzaWJsZSBjaGVlcm1vdGUgbmFtZXMuXG4gICAgICovXG4gICAgQ2hlZXJtb3RlTGlzdC5wcm90b3R5cGUuZ2V0UG9zc2libGVOYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2RhdGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFsbCB0aGUgY2hlZXJtb3RlcyBvdXQgb2YgYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgQ2hlZXJtb3RlTGlzdC5wcm90b3R5cGUucGFyc2VNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgbmFtZXMgPSB0aGlzLmdldFBvc3NpYmxlTmFtZXMoKTtcbiAgICAgICAgLy8gVE9ETyBmaXggdGhpcyByZWdleCBzbyBpdCB3b3JrcyBpbiBmaXJlZm94LCB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IGxvb2tiZWhpbmRcbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnKD88PV58XFxcXHMpKFthLXowLTldKz8pKFxcXFxkKykoPz1cXFxcc3wkKScsICdnaScpO1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKG1lc3NhZ2UpKSkge1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobmFtZXMuaW5jbHVkZXMobmFtZV8xKSkge1xuICAgICAgICAgICAgICAgIHZhciBhbW91bnQgPSBOdW1iZXIobWF0Y2hbMl0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IGFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHNoYXJlZF91dGlsc18xLnV0ZjhMZW5ndGgobWVzc2FnZS5zdWJzdHIoMCwgbWF0Y2guaW5kZXgpKSxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBtYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlJbmZvOiB0aGlzLmdldENoZWVybW90ZURpc3BsYXlJbmZvKG5hbWVfMSwgYW1vdW50KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGFsbCB0aGUgY2hlZXJtb3RlcyBpbiBhIG1lc3NhZ2UgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBtZXNzYWdlIHBhcnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybWVyIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIGEgbWVzc2FnZSBwYXJ0IGludG8gYW4gYXJiaXRyYXJ5IHN0cnVjdHVyZS5cbiAgICAgKi9cbiAgICBDaGVlcm1vdGVMaXN0LnByb3RvdHlwZS50cmFuc2Zvcm1DaGVlck1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IHRzbGliXzEuX192YWx1ZXModGhpcy5wYXJzZU1lc3NhZ2UobWVzc2FnZSkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kQ2hlZXJtb3RlID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA8IGZvdW5kQ2hlZXJtb3RlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1lc3NhZ2Uuc3Vic3RyaW5nKGN1cnJlbnRQb3NpdGlvbiwgZm91bmRDaGVlcm1vdGUucG9zaXRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godHJhbnNmb3JtZXIoZm91bmRDaGVlcm1vdGUpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gPSBmb3VuZENoZWVybW90ZS5wb3NpdGlvbiArIGZvdW5kQ2hlZXJtb3RlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50UG9zaXRpb24gPCBtZXNzYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWVzc2FnZS5zdWJzdHIoY3VycmVudFBvc2l0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBDaGVlcm1vdGVMaXN0LnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIENoZWVybW90ZUxpc3Q7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hlZXJtb3RlTGlzdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENoZWVybW90ZUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWVybW90ZUJhY2tncm91bmQgPSBDaGVlcm1vdGVCYWNrZ3JvdW5kO1xuZXhwb3J0cy5DaGVlcm1vdGVTdGF0ZSA9IENoZWVybW90ZVN0YXRlO1xuZXhwb3J0cy5DaGVlcm1vdGVTY2FsZSA9IENoZWVybW90ZVNjYWxlO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hlZXJtb3RlTGlzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FcnJvcnMvTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JcIik7XG4vKipcbiAqIEEgcGxhY2Vob2xkZXIgZm9yIGEgY2hhbm5lbC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGV4YW1wbGUgd2hlbiB5b3Ugb25seSBoYXZlIHJldHJpZXZlZCB1c2VyIGRhdGEsIGJ1dCBub3QgY2hhbm5lbCBkYXRhLlxuICogVGhpcyBjYW4gZG8gYW55dGhpbmcgeW91IGNhbiBkbyB3aXRoIG9ubHkgYSBjaGFubmVsIElELCBhcyBpdCdzIGVxdWl2YWxlbnQgdG8gdGhlIHVzZXIgSUQuXG4gKi9cbnZhciBDaGFubmVsUGxhY2Vob2xkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gQ2hhbm5lbFBsYWNlaG9sZGVyKGlkLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHsgX2lkOiBpZCB9O1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsUGxhY2Vob2xkZXIucHJvdG90eXBlLCBcImNhY2hlS2V5XCIsIHtcbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbFBsYWNlaG9sZGVyLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIGNoZWVybW90ZXMgeW91IGNhbiB1c2UgaW4gdGhlIGNoYW5uZWwuXG4gICAgICovXG4gICAgQ2hhbm5lbFBsYWNlaG9sZGVyLnByb3RvdHlwZS5nZXRDaGVlcm1vdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLmJpdHMuZ2V0Q2hlZXJtb3Rlcyh0aGlzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNoYW5uZWwgZGF0YS5cbiAgICAgKi9cbiAgICBDaGFubmVsUGxhY2Vob2xkZXIucHJvdG90eXBlLmdldENoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4uY2hhbm5lbHMuZ2V0Q2hhbm5lbCh0aGlzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNoYW5uZWwncyBzdHJlYW0gZGF0YS5cbiAgICAgKi9cbiAgICBDaGFubmVsUGxhY2Vob2xkZXIucHJvdG90eXBlLmdldFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmtyYWtlbi5zdHJlYW1zLmdldFN0cmVhbUJ5Q2hhbm5lbCh0aGlzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNoYW5uZWwncyBmb2xsb3dlcnMuXG4gICAgICovXG4gICAgQ2hhbm5lbFBsYWNlaG9sZGVyLnByb3RvdHlwZS5nZXRGb2xsb3dlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4uY2hhbm5lbHMuZ2V0Q2hhbm5lbEZvbGxvd2Vycyh0aGlzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNoYW5uZWwncyBzdWJzY3JpYmVycy5cbiAgICAgKi9cbiAgICBDaGFubmVsUGxhY2Vob2xkZXIucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4uY2hhbm5lbHMuZ2V0Q2hhbm5lbFN1YnNjcmlwdGlvbnModGhpcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBzdWJzY3JpcHRpb24gZGF0YSBmb3IgdGhlIGdpdmVuIHVzZXIgdG8gdGhlIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgaWYgdGhlIGNoYW5uZWwgZG9lc24ndCBoYXZlIGEgc3Vic2NyaXB0aW9uIHByb2dyYW0gb3IgdGhlIHVzZXIgaXMgbm90IHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCByZXF1aXJlcyBhY2Nlc3MgdG8gdGhlIGNoYW5uZWwuIElmIHlvdSBvbmx5IGhhdmUgYWNjZXNzIHRvIHRoZSB1c2VyLFxuICAgICAqIHVzZSB7QFVzZXIjZ2V0U3Vic2NyaXB0aW9uVG99IGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB5b3Ugd2FudCB0byBnZXQgdGhlIHN1YnNjcmlwdGlvbiBkYXRhIGZvci5cbiAgICAgKi9cbiAgICBDaGFubmVsUGxhY2Vob2xkZXIucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvbkJ5ID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmtyYWtlbi5jaGFubmVscy5nZXRDaGFubmVsU3Vic2NyaXB0aW9uQnlVc2VyKHRoaXMsIHVzZXIpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB1c2VyIGlzIHN1YnNjcmliZWQgdG8gdGhlIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB5b3Ugd2FudCB0byBjaGVjayB0aGUgc3Vic2NyaXB0aW9uIGZvci5cbiAgICAgKi9cbiAgICBDaGFubmVsUGxhY2Vob2xkZXIucHJvdG90eXBlLmhhc1N1YnNjcmliZXIgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFN1YnNjcmlwdGlvbkJ5KHVzZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSkgIT09IG51bGxdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xIGluc3RhbmNlb2YgTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIENoYW5uZWxQbGFjZWhvbGRlci5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBDaGFubmVsUGxhY2Vob2xkZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbFBsYWNlaG9sZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ2hhbm5lbFBsYWNlaG9sZGVyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbFBsYWNlaG9sZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogQSBzdWJzY3JpcHRpb24gdG8gYSBUd2l0Y2ggY2hhbm5lbC5cbiAqL1xudmFyIFN1YnNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24oLyoqIEBwcml2YXRlICovIF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcInN1YlBsYW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHN1YnNjcmlwdGlvbiBwbGFuLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zdWJfcGxhbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwic3ViUGxhbk5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHN1YnNjcmlwdGlvbiBwbGFuLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zdWJfcGxhbl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJzdGFydERhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHdhcyBzdGFydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS5jcmVhdGVkX2F0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBTdWJzY3JpcHRpb247XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3Vic2NyaXB0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU3Vic2NyaXB0aW9uO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3Vic2NyaXB0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogQSBUd2l0Y2ggdGVhbS5cbiAqL1xudmFyIFRlYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gVGVhbSgvKiogQHByaXZhdGUgKi8gX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlYW0ucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdGVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVhbS5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmFja2dyb3VuZCB1cmwgb2YgdGhlIHRlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJhY2tncm91bmQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZWFtLnByb3RvdHlwZSwgXCJiYW5uZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhbm5lciB1cmwgb2YgdGhlIHRlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJhbm5lcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlYW0ucHJvdG90eXBlLCBcImNyZWF0aW9uRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSB3aGVuIHRoZSB0ZWFtIHdhcyBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS5jcmVhdGVkX2F0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlYW0ucHJvdG90eXBlLCBcInVwZGF0ZURhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhc3QgZGF0ZSB3aGVuIHRoZSB0ZWFtIGNoYW5nZWQgYW55dGhpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLnVwZGF0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVhbS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdGVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlYW0ucHJvdG90eXBlLCBcImluZm9cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZm8gb2YgdGhlIHRlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmluZm87XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZWFtLnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSB0ZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5kaXNwbGF5X25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZWFtLnByb3RvdHlwZSwgXCJsb2dvVXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgdG8gdGhlIHByb2ZpbGUgcGljdHVyZSBvZiB0aGUgdGVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubG9nbztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGVhbS5wcm90b3R5cGUuZ2V0VXNlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRlYW07XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmtyYWtlbi50ZWFtcy5nZXRUZWFtQnlOYW1lKHRoaXMubmFtZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRlYW0uZ2V0VXNlcnMoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIFRlYW0ucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gVGVhbTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUZWFtO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVGVhbTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRlYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIENoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi9DaGFubmVsL0NoYW5uZWxcIik7XG4vKipcbiAqIFRoZSB0eXBlIG9mIGEgc3RyZWFtLlxuICovXG52YXIgU3RyZWFtVHlwZTtcbihmdW5jdGlvbiAoU3RyZWFtVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEEgbGl2ZSBzdHJlYW0uXG4gICAgICovXG4gICAgU3RyZWFtVHlwZVtcIkxpdmVcIl0gPSBcImxpdmVcIjtcbiAgICAvKipcbiAgICAgKiBBbiB1cGxvYWQgdG8gdGhlIGNoYW5uZWwgKFZvRCkgdGhhdCBpcyBzdHJlYW1lZCBsaXZlIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAgKi9cbiAgICBTdHJlYW1UeXBlW1wiUHJlbWllcmVcIl0gPSBcInByZW1pZXJlXCI7XG4gICAgLyoqXG4gICAgICogQSByZXJ1biBvZiBhIHBhc3QgbGl2ZSBzdHJlYW0uXG4gICAgICovXG4gICAgU3RyZWFtVHlwZVtcIlJlUnVuXCJdID0gXCJyZXJ1blwiO1xuICAgIC8qKlxuICAgICAqIEFsbCB0eXBlcyBvZiBzdHJlYW1zLiBVc2VkIGZvciBmaWx0ZXJpbmcuXG4gICAgICovXG4gICAgU3RyZWFtVHlwZVtcIkFsbFwiXSA9IFwiYWxsXCI7XG59KShTdHJlYW1UeXBlIHx8IChTdHJlYW1UeXBlID0ge30pKTtcbmV4cG9ydHMuU3RyZWFtVHlwZSA9IFN0cmVhbVR5cGU7XG4vKipcbiAqIEEgVHdpdGNoIHN0cmVhbS5cbiAqL1xudmFyIFN0cmVhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBTdHJlYW0oX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmVhbS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLl9pZC50b1N0cmluZygpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyZWFtLnByb3RvdHlwZSwgXCJnYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBnYW1lIHBsYXllZCBvbiB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyZWFtLnByb3RvdHlwZSwgXCJ2aWV3ZXJzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IG51bWJlciBvZiBjb25jdXJyZW50IHZpZXdlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnZpZXdlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW0ucHJvdG90eXBlLCBcInZpZGVvSGVpZ2h0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHN0cmVhbSB2aWRlby5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudmlkZW9faGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyZWFtLnByb3RvdHlwZSwgXCJhdmVyYWdlRlBTXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhdmVyYWdlIEZQUyAoZnJhbWVzIHBlciBzZWNvbmQpIHRoYXQgYXJlIHNob3duIG9uIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmF2ZXJhZ2VfZnBzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyZWFtLnByb3RvdHlwZSwgXCJkZWxheVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsYXkgb2YgdGhlIHN0cmVhbSwgaW4gc2Vjb25kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZGVsYXk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW0ucHJvdG90eXBlLCBcInN0YXJ0RGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSB3aGVuIHRoZSBzdHJlYW0gc3RhcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEuY3JlYXRlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW0ucHJvdG90eXBlLCBcImlzUGxheWxpc3RcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgc3RyZWFtIGlzIHJ1bm5pbmcgYSBwbGF5bGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaXNfcGxheWxpc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW0ucHJvdG90eXBlLCBcInR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc3RyZWFtX3R5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFVSTCBvZiBhIHByZXZpZXcgaW1hZ2UgZm9yIHRoZSBzdHJlYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaXplIFRoZSBzaXplIG9mIHRoZSBpbWFnZS5cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmdldFByZXZpZXdVcmwgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5wcmV2aWV3W3NpemVdO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmVhbS5wcm90b3R5cGUsIFwiY2hhbm5lbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2hhbm5lbCB3aGVyZSB0aGUgc3RyZWFtIGlzIHNob3duLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYW5uZWxfMS5kZWZhdWx0KHRoaXMuX2RhdGEuY2hhbm5lbCwgdGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIFN0cmVhbS5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBTdHJlYW07XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RyZWFtO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU3RyZWFtO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJlYW1UeXBlID0gU3RyZWFtVHlwZTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmVhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogZXNsaW50LWRpc2FibGUgZmlsZW5hbWVzL21hdGNoLWV4cG9ydGVkICovXG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi9Ud2l0Y2hDbGllbnRcIik7XG5leHBvcnRzLlR3aXRjaEFQSUNhbGxUeXBlID0gVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGU7XG5leHBvcnRzLmRlZmF1bHQgPSBUd2l0Y2hDbGllbnRfMS5kZWZhdWx0O1xudmFyIENvbmZpZ0Vycm9yXzEgPSByZXF1aXJlKFwiLi9FcnJvcnMvQ29uZmlnRXJyb3JcIik7XG5leHBvcnRzLkNvbmZpZ0Vycm9yID0gQ29uZmlnRXJyb3JfMS5kZWZhdWx0O1xudmFyIEhlbGxGcmVlemVzT3ZlckVycm9yXzEgPSByZXF1aXJlKFwiLi9FcnJvcnMvSGVsbEZyZWV6ZXNPdmVyRXJyb3JcIik7XG5leHBvcnRzLkhlbGxGcmVlemVzT3ZlckVycm9yID0gSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMS5kZWZhdWx0O1xudmFyIEhUVFBTdGF0dXNDb2RlRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0Vycm9ycy9IVFRQU3RhdHVzQ29kZUVycm9yXCIpO1xuZXhwb3J0cy5IVFRQU3RhdHVzQ29kZUVycm9yID0gSFRUUFN0YXR1c0NvZGVFcnJvcl8xLmRlZmF1bHQ7XG52YXIgSW52YWxpZFRva2VuRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0Vycm9ycy9JbnZhbGlkVG9rZW5FcnJvclwiKTtcbmV4cG9ydHMuSW52YWxpZFRva2VuRXJyb3IgPSBJbnZhbGlkVG9rZW5FcnJvcl8xLmRlZmF1bHQ7XG52YXIgSW52YWxpZFRva2VuVHlwZUVycm9yXzEgPSByZXF1aXJlKFwiLi9FcnJvcnMvSW52YWxpZFRva2VuVHlwZUVycm9yXCIpO1xuZXhwb3J0cy5JbnZhbGlkVG9rZW5UeXBlRXJyb3IgPSBJbnZhbGlkVG9rZW5UeXBlRXJyb3JfMS5kZWZhdWx0O1xudmFyIE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXzEgPSByZXF1aXJlKFwiLi9FcnJvcnMvTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JcIik7XG5leHBvcnRzLk5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yID0gTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMS5kZWZhdWx0O1xudmFyIFN0cmVhbU5vdExpdmVFcnJvcl8xID0gcmVxdWlyZShcIi4vRXJyb3JzL1N0cmVhbU5vdExpdmVFcnJvclwiKTtcbmV4cG9ydHMuU3RyZWFtTm90TGl2ZUVycm9yID0gU3RyZWFtTm90TGl2ZUVycm9yXzEuZGVmYXVsdDtcbnZhciBTdGF0aWNBdXRoUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL0F1dGgvU3RhdGljQXV0aFByb3ZpZGVyXCIpO1xuZXhwb3J0cy5TdGF0aWNBdXRoUHJvdmlkZXIgPSBTdGF0aWNBdXRoUHJvdmlkZXJfMS5kZWZhdWx0O1xudmFyIFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9BdXRoL1JlZnJlc2hhYmxlQXV0aFByb3ZpZGVyXCIpO1xuZXhwb3J0cy5SZWZyZXNoYWJsZUF1dGhQcm92aWRlciA9IFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyXzEuZGVmYXVsdDtcbnZhciBBY2Nlc3NUb2tlbl8xID0gcmVxdWlyZShcIi4vQVBJL0FjY2Vzc1Rva2VuXCIpO1xuZXhwb3J0cy5BY2Nlc3NUb2tlbiA9IEFjY2Vzc1Rva2VuXzEuZGVmYXVsdDtcbnZhciBUb2tlbkluZm9fMSA9IHJlcXVpcmUoXCIuL0FQSS9Ub2tlbkluZm9cIik7XG5leHBvcnRzLlRva2VuSW5mbyA9IFRva2VuSW5mb18xLmRlZmF1bHQ7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL1N1YnNjcmlwdGlvblwiKTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uXzEuZGVmYXVsdDtcbnZhciBDaGVlcm1vdGVMaXN0XzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL0JpdHMvQ2hlZXJtb3RlTGlzdFwiKTtcbmV4cG9ydHMuQ2hlZXJtb3RlTGlzdCA9IENoZWVybW90ZUxpc3RfMS5kZWZhdWx0O1xuZXhwb3J0cy5DaGVlcm1vdGVCYWNrZ3JvdW5kID0gQ2hlZXJtb3RlTGlzdF8xLkNoZWVybW90ZUJhY2tncm91bmQ7XG5leHBvcnRzLkNoZWVybW90ZVNjYWxlID0gQ2hlZXJtb3RlTGlzdF8xLkNoZWVybW90ZVNjYWxlO1xuZXhwb3J0cy5DaGVlcm1vdGVTdGF0ZSA9IENoZWVybW90ZUxpc3RfMS5DaGVlcm1vdGVTdGF0ZTtcbnZhciBDaGFubmVsXzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL0NoYW5uZWwvQ2hhbm5lbFwiKTtcbmV4cG9ydHMuQ2hhbm5lbCA9IENoYW5uZWxfMS5kZWZhdWx0O1xudmFyIENoYW5uZWxGb2xsb3dfMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vQ2hhbm5lbC9DaGFubmVsRm9sbG93XCIpO1xuZXhwb3J0cy5DaGFubmVsRm9sbG93ID0gQ2hhbm5lbEZvbGxvd18xLmRlZmF1bHQ7XG52YXIgQ2hhbm5lbFBsYWNlaG9sZGVyXzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL0NoYW5uZWwvQ2hhbm5lbFBsYWNlaG9sZGVyXCIpO1xuZXhwb3J0cy5DaGFubmVsUGxhY2Vob2xkZXIgPSBDaGFubmVsUGxhY2Vob2xkZXJfMS5kZWZhdWx0O1xudmFyIENoYW5uZWxTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vQ2hhbm5lbC9DaGFubmVsU3Vic2NyaXB0aW9uXCIpO1xuZXhwb3J0cy5DaGFubmVsU3Vic2NyaXB0aW9uID0gQ2hhbm5lbFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQ7XG52YXIgRW1vdGVTZXRMaXN0XzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL0NoYW5uZWwvRW1vdGVTZXRMaXN0XCIpO1xuZXhwb3J0cy5FbW90ZVNldExpc3QgPSBFbW90ZVNldExpc3RfMS5kZWZhdWx0O1xudmFyIFByaXZpbGVnZWRDaGFubmVsXzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL0NoYW5uZWwvUHJpdmlsZWdlZENoYW5uZWxcIik7XG5leHBvcnRzLlByaXZpbGVnZWRDaGFubmVsID0gUHJpdmlsZWdlZENoYW5uZWxfMS5kZWZhdWx0O1xudmFyIFN0cmVhbV8xID0gcmVxdWlyZShcIi4vQVBJL0tyYWtlbi9TdHJlYW0vU3RyZWFtXCIpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW1fMS5kZWZhdWx0O1xuZXhwb3J0cy5TdHJlYW1UeXBlID0gU3RyZWFtXzEuU3RyZWFtVHlwZTtcbnZhciBDaGF0dGVyc0xpc3RfMSA9IHJlcXVpcmUoXCIuL0FQSS9VbnN1cHBvcnRlZC9DaGF0dGVyc0xpc3RcIik7XG5leHBvcnRzLkNoYXR0ZXJzTGlzdCA9IENoYXR0ZXJzTGlzdF8xLmRlZmF1bHQ7XG52YXIgUHJpdmlsZWdlZFVzZXJfMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vVXNlci9Qcml2aWxlZ2VkVXNlclwiKTtcbmV4cG9ydHMuUHJpdmlsZWdlZFVzZXIgPSBQcml2aWxlZ2VkVXNlcl8xLmRlZmF1bHQ7XG52YXIgVXNlcl8xID0gcmVxdWlyZShcIi4vQVBJL0tyYWtlbi9Vc2VyL1VzZXJcIik7XG5leHBvcnRzLlVzZXIgPSBVc2VyXzEuZGVmYXVsdDtcbnZhciBVc2VyQmxvY2tfMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vVXNlci9Vc2VyQmxvY2tcIik7XG5leHBvcnRzLlVzZXJCbG9jayA9IFVzZXJCbG9ja18xLmRlZmF1bHQ7XG52YXIgVXNlckZvbGxvd18xID0gcmVxdWlyZShcIi4vQVBJL0tyYWtlbi9Vc2VyL1VzZXJGb2xsb3dcIik7XG5leHBvcnRzLlVzZXJGb2xsb3cgPSBVc2VyRm9sbG93XzEuZGVmYXVsdDtcbnZhciBVc2VyU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL1VzZXIvVXNlclN1YnNjcmlwdGlvblwiKTtcbmV4cG9ydHMuVXNlclN1YnNjcmlwdGlvbiA9IFVzZXJTdWJzY3JpcHRpb25fMS5kZWZhdWx0O1xudmFyIEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L0hlbGl4UGFnaW5hdGVkUmVxdWVzdFwiKTtcbmV4cG9ydHMuSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0ID0gSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdDtcbnZhciBIZWxpeEJpdHNMZWFkZXJib2FyZF8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L0JpdHMvSGVsaXhCaXRzTGVhZGVyYm9hcmRcIik7XG5leHBvcnRzLkhlbGl4Qml0c0xlYWRlcmJvYXJkID0gSGVsaXhCaXRzTGVhZGVyYm9hcmRfMS5kZWZhdWx0O1xudmFyIEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnlfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9CaXRzL0hlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnlcIik7XG5leHBvcnRzLkhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnkgPSBIZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5XzEuZGVmYXVsdDtcbnZhciBIZWxpeENsaXBfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9DbGlwL0hlbGl4Q2xpcFwiKTtcbmV4cG9ydHMuSGVsaXhDbGlwID0gSGVsaXhDbGlwXzEuZGVmYXVsdDtcbnZhciBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvRXh0ZW5zaW9ucy9IZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uXCIpO1xuZXhwb3J0cy5IZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uID0gSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbl8xLmRlZmF1bHQ7XG52YXIgSGVsaXhHYW1lXzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvR2FtZS9IZWxpeEdhbWVcIik7XG5leHBvcnRzLkhlbGl4R2FtZSA9IEhlbGl4R2FtZV8xLmRlZmF1bHQ7XG52YXIgSGVsaXhCYW5fMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9Nb2RlcmF0aW9uL0hlbGl4QmFuXCIpO1xuZXhwb3J0cy5IZWxpeEJhbiA9IEhlbGl4QmFuXzEuZGVmYXVsdDtcbnZhciBIZWxpeEJhbkV2ZW50XzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvTW9kZXJhdGlvbi9IZWxpeEJhbkV2ZW50XCIpO1xuZXhwb3J0cy5IZWxpeEJhbkV2ZW50ID0gSGVsaXhCYW5FdmVudF8xLmRlZmF1bHQ7XG52YXIgSGVsaXhNb2RlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9Nb2RlcmF0aW9uL0hlbGl4TW9kZXJhdG9yXCIpO1xuZXhwb3J0cy5IZWxpeE1vZGVyYXRvciA9IEhlbGl4TW9kZXJhdG9yXzEuZGVmYXVsdDtcbnZhciBIZWxpeE1vZGVyYXRvckV2ZW50XzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvTW9kZXJhdGlvbi9IZWxpeE1vZGVyYXRvckV2ZW50XCIpO1xuZXhwb3J0cy5IZWxpeE1vZGVyYXRvckV2ZW50ID0gSGVsaXhNb2RlcmF0b3JFdmVudF8xLmRlZmF1bHQ7XG52YXIgSGVsaXhTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9TdHJlYW0vSGVsaXhTdHJlYW1cIik7XG5leHBvcnRzLkhlbGl4U3RyZWFtID0gSGVsaXhTdHJlYW1fMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeFN0cmVhbVR5cGUgPSBIZWxpeFN0cmVhbV8xLkhlbGl4U3RyZWFtVHlwZTtcbnZhciBIZWxpeEZvbGxvd18xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L1VzZXIvSGVsaXhGb2xsb3dcIik7XG5leHBvcnRzLkhlbGl4Rm9sbG93ID0gSGVsaXhGb2xsb3dfMS5kZWZhdWx0O1xudmFyIEhlbGl4UHJpdmlsZWdlZFVzZXJfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9Vc2VyL0hlbGl4UHJpdmlsZWdlZFVzZXJcIik7XG5leHBvcnRzLkhlbGl4UHJpdmlsZWdlZFVzZXIgPSBIZWxpeFByaXZpbGVnZWRVc2VyXzEuZGVmYXVsdDtcbnZhciBIZWxpeFVzZXJfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9Vc2VyL0hlbGl4VXNlclwiKTtcbmV4cG9ydHMuSGVsaXhVc2VyID0gSGVsaXhVc2VyXzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhCcm9hZGNhc3RlclR5cGUgPSBIZWxpeFVzZXJfMS5IZWxpeEJyb2FkY2FzdGVyVHlwZTtcbmV4cG9ydHMuSGVsaXhVc2VyVHlwZSA9IEhlbGl4VXNlcl8xLkhlbGl4VXNlclR5cGU7XG52YXIgSGVsaXhWaWRlb18xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L1ZpZGVvL0hlbGl4VmlkZW9cIik7XG5leHBvcnRzLkhlbGl4VmlkZW8gPSBIZWxpeFZpZGVvXzEuZGVmYXVsdDtcbnZhciBIZWxpeFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L1N1YnNjcmlwdGlvbnMvSGVsaXhTdWJzY3JpcHRpb25cIik7XG5leHBvcnRzLkhlbGl4U3Vic2NyaXB0aW9uID0gSGVsaXhTdWJzY3JpcHRpb25fMS5kZWZhdWx0O1xudmFyIEhlbGl4U3Vic2NyaXB0aW9uRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9TdWJzY3JpcHRpb25zL0hlbGl4U3Vic2NyaXB0aW9uRXZlbnRcIik7XG5leHBvcnRzLkhlbGl4U3Vic2NyaXB0aW9uRXZlbnQgPSBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50XzEuZGVmYXVsdDtcbnZhciBDaGF0QmFkZ2VMaXN0XzEgPSByZXF1aXJlKFwiLi9BUEkvQmFkZ2VzL0NoYXRCYWRnZUxpc3RcIik7XG5leHBvcnRzLkNoYXRCYWRnZUxpc3QgPSBDaGF0QmFkZ2VMaXN0XzEuZGVmYXVsdDtcbnZhciBDaGF0QmFkZ2VTZXRfMSA9IHJlcXVpcmUoXCIuL0FQSS9CYWRnZXMvQ2hhdEJhZGdlU2V0XCIpO1xuZXhwb3J0cy5DaGF0QmFkZ2VTZXQgPSBDaGF0QmFkZ2VTZXRfMS5kZWZhdWx0O1xudmFyIENoYXRCYWRnZVZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL0FQSS9CYWRnZXMvQ2hhdEJhZGdlVmVyc2lvblwiKTtcbmV4cG9ydHMuQ2hhdEJhZGdlVmVyc2lvbiA9IENoYXRCYWRnZVZlcnNpb25fMS5kZWZhdWx0O1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4vVG9vbGtpdC9Vc2VyVG9vbHNcIik7XG5leHBvcnRzLmV4dHJhY3RVc2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkO1xuZXhwb3J0cy5leHRyYWN0VXNlck5hbWUgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlck5hbWU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBUd2l0Y2hDbGllbnRfMS5kZWZhdWx0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ud2l0Y2hBUElDYWxsVHlwZSA9IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gVHdpdGNoQ2xpZW50XzEuZGVmYXVsdDtcbmV4cG9ydHMuQ29uZmlnRXJyb3IgPSBDb25maWdFcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGxGcmVlemVzT3ZlckVycm9yID0gSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMS5kZWZhdWx0O1xuZXhwb3J0cy5IVFRQU3RhdHVzQ29kZUVycm9yID0gSFRUUFN0YXR1c0NvZGVFcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLkludmFsaWRUb2tlbkVycm9yID0gSW52YWxpZFRva2VuRXJyb3JfMS5kZWZhdWx0O1xuZXhwb3J0cy5JbnZhbGlkVG9rZW5UeXBlRXJyb3IgPSBJbnZhbGlkVG9rZW5UeXBlRXJyb3JfMS5kZWZhdWx0O1xuZXhwb3J0cy5Ob1N1YnNjcmlwdGlvblByb2dyYW1FcnJvciA9IE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXzEuZGVmYXVsdDtcbmV4cG9ydHMuU3RyZWFtTm90TGl2ZUVycm9yID0gU3RyZWFtTm90TGl2ZUVycm9yXzEuZGVmYXVsdDtcbmV4cG9ydHMuU3RhdGljQXV0aFByb3ZpZGVyID0gU3RhdGljQXV0aFByb3ZpZGVyXzEuZGVmYXVsdDtcbmV4cG9ydHMuUmVmcmVzaGFibGVBdXRoUHJvdmlkZXIgPSBSZWZyZXNoYWJsZUF1dGhQcm92aWRlcl8xLmRlZmF1bHQ7XG5leHBvcnRzLkFjY2Vzc1Rva2VuID0gQWNjZXNzVG9rZW5fMS5kZWZhdWx0O1xuZXhwb3J0cy5Ub2tlbkluZm8gPSBUb2tlbkluZm9fMS5kZWZhdWx0O1xuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb25fMS5kZWZhdWx0O1xuZXhwb3J0cy5DaGVlcm1vdGVMaXN0ID0gQ2hlZXJtb3RlTGlzdF8xLmRlZmF1bHQ7XG5leHBvcnRzLkNoZWVybW90ZUJhY2tncm91bmQgPSBDaGVlcm1vdGVMaXN0XzEuQ2hlZXJtb3RlQmFja2dyb3VuZDtcbmV4cG9ydHMuQ2hlZXJtb3RlU2NhbGUgPSBDaGVlcm1vdGVMaXN0XzEuQ2hlZXJtb3RlU2NhbGU7XG5leHBvcnRzLkNoZWVybW90ZVN0YXRlID0gQ2hlZXJtb3RlTGlzdF8xLkNoZWVybW90ZVN0YXRlO1xuZXhwb3J0cy5DaGFubmVsID0gQ2hhbm5lbF8xLmRlZmF1bHQ7XG5leHBvcnRzLkNoYW5uZWxGb2xsb3cgPSBDaGFubmVsRm9sbG93XzEuZGVmYXVsdDtcbmV4cG9ydHMuQ2hhbm5lbFBsYWNlaG9sZGVyID0gQ2hhbm5lbFBsYWNlaG9sZGVyXzEuZGVmYXVsdDtcbmV4cG9ydHMuQ2hhbm5lbFN1YnNjcmlwdGlvbiA9IENoYW5uZWxTdWJzY3JpcHRpb25fMS5kZWZhdWx0O1xuZXhwb3J0cy5FbW90ZVNldExpc3QgPSBFbW90ZVNldExpc3RfMS5kZWZhdWx0O1xuZXhwb3J0cy5Qcml2aWxlZ2VkQ2hhbm5lbCA9IFByaXZpbGVnZWRDaGFubmVsXzEuZGVmYXVsdDtcbmV4cG9ydHMuU3RyZWFtID0gU3RyZWFtXzEuZGVmYXVsdDtcbmV4cG9ydHMuU3RyZWFtVHlwZSA9IFN0cmVhbV8xLlN0cmVhbVR5cGU7XG5leHBvcnRzLkNoYXR0ZXJzTGlzdCA9IENoYXR0ZXJzTGlzdF8xLmRlZmF1bHQ7XG5leHBvcnRzLlByaXZpbGVnZWRVc2VyID0gUHJpdmlsZWdlZFVzZXJfMS5kZWZhdWx0O1xuZXhwb3J0cy5Vc2VyID0gVXNlcl8xLmRlZmF1bHQ7XG5leHBvcnRzLlVzZXJCbG9jayA9IFVzZXJCbG9ja18xLmRlZmF1bHQ7XG5leHBvcnRzLlVzZXJGb2xsb3cgPSBVc2VyRm9sbG93XzEuZGVmYXVsdDtcbmV4cG9ydHMuVXNlclN1YnNjcmlwdGlvbiA9IFVzZXJTdWJzY3JpcHRpb25fMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeFBhZ2luYXRlZFJlcXVlc3QgPSBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeEJpdHNMZWFkZXJib2FyZCA9IEhlbGl4Qml0c0xlYWRlcmJvYXJkXzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeSA9IEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnlfMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeENsaXAgPSBIZWxpeENsaXBfMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uID0gSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbl8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4R2FtZSA9IEhlbGl4R2FtZV8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4QmFuID0gSGVsaXhCYW5fMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeEJhbkV2ZW50ID0gSGVsaXhCYW5FdmVudF8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4TW9kZXJhdG9yID0gSGVsaXhNb2RlcmF0b3JfMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeE1vZGVyYXRvckV2ZW50ID0gSGVsaXhNb2RlcmF0b3JFdmVudF8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4U3RyZWFtID0gSGVsaXhTdHJlYW1fMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeFN0cmVhbVR5cGUgPSBIZWxpeFN0cmVhbV8xLkhlbGl4U3RyZWFtVHlwZTtcbmV4cG9ydHMuSGVsaXhGb2xsb3cgPSBIZWxpeEZvbGxvd18xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4UHJpdmlsZWdlZFVzZXIgPSBIZWxpeFByaXZpbGVnZWRVc2VyXzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhVc2VyID0gSGVsaXhVc2VyXzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhCcm9hZGNhc3RlclR5cGUgPSBIZWxpeFVzZXJfMS5IZWxpeEJyb2FkY2FzdGVyVHlwZTtcbmV4cG9ydHMuSGVsaXhVc2VyVHlwZSA9IEhlbGl4VXNlcl8xLkhlbGl4VXNlclR5cGU7XG5leHBvcnRzLkhlbGl4VmlkZW8gPSBIZWxpeFZpZGVvXzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhTdWJzY3JpcHRpb24gPSBIZWxpeFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4U3Vic2NyaXB0aW9uRXZlbnQgPSBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50XzEuZGVmYXVsdDtcbmV4cG9ydHMuQ2hhdEJhZGdlTGlzdCA9IENoYXRCYWRnZUxpc3RfMS5kZWZhdWx0O1xuZXhwb3J0cy5DaGF0QmFkZ2VTZXQgPSBDaGF0QmFkZ2VTZXRfMS5kZWZhdWx0O1xuZXhwb3J0cy5DaGF0QmFkZ2VWZXJzaW9uID0gQ2hhdEJhZGdlVmVyc2lvbl8xLmRlZmF1bHQ7XG5leHBvcnRzLmV4dHJhY3RVc2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkO1xuZXhwb3J0cy5leHRyYWN0VXNlck5hbWUgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlck5hbWU7XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMb2dMZXZlbF8xID0gcmVxdWlyZShcIi4vTG9nTGV2ZWxcIik7XG52YXIgaXNOb2RlID0gcmVxdWlyZShcImRldGVjdC1ub2RlXCIpO1xudmFyIEJhc2VMb2dnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZUxvZ2dlcihfYSkge1xuICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIF9iID0gX2EubWluTGV2ZWwsIG1pbkxldmVsID0gX2IgPT09IHZvaWQgMCA/IExvZ0xldmVsXzEuZGVmYXVsdC5XQVJOSU5HIDogX2IsIF9jID0gX2EuZW1vamksIGVtb2ppID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2EuY29sb3JzLCBjb2xvcnMgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBfZSA9IF9hLnRpbWVzdGFtcHMsIHRpbWVzdGFtcHMgPSBfZSA9PT0gdm9pZCAwID8gaXNOb2RlIDogX2U7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9taW5MZXZlbCA9IExvZ0xldmVsXzEucmVzb2x2ZUxvZ0xldmVsKG1pbkxldmVsKTtcbiAgICAgICAgdGhpcy5fZW1vamkgPSBlbW9qaTtcbiAgICAgICAgdGhpcy5fY29sb3JzID0gY29sb3JzO1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBzID0gdGltZXN0YW1wcztcbiAgICB9XG4gICAgLy8gcmVnaW9uIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5jcml0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5kZWZhdWx0LkNSSVRJQ0FMLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmNyaXRpY2FsID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5kZWZhdWx0LkNSSVRJQ0FMLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmVyciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuZGVmYXVsdC5FUlJPUiwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuZGVmYXVsdC5FUlJPUiwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5kZWZhdWx0LldBUk5JTkcsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUud2FybmluZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuZGVmYXVsdC5XQVJOSU5HLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLmRlZmF1bHQuSU5GTywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuZGVmYXVsdC5ERUJVRywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGRlYnVnIGluc3RlYWQgKi9cbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZzEgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLmRlZmF1bHQuREVCVUcsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBkZWJ1ZyBpbnN0ZWFkICovXG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUuZGVidWcyID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5kZWZhdWx0LkRFQlVHLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgZGVidWcgaW5zdGVhZCAqL1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmRlYnVnMyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuZGVmYXVsdC5ERUJVRywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS50cmFjZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuZGVmYXVsdC5UUkFDRSwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZUxvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlTG9nZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQmFzZUxvZ2dlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlTG9nZ2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGVyY2VudFR3ZW50aWVzID0gLyUyMC9nO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIEZvcm1hdCA9IHtcbiAgICBSRkMxNzM4OiAnUkZDMTczOCcsXG4gICAgUkZDMzk4NjogJ1JGQzM5ODYnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWwuYXNzaWduKFxuICAgIHtcbiAgICAgICAgJ2RlZmF1bHQnOiBGb3JtYXQuUkZDMzk4NixcbiAgICAgICAgZm9ybWF0dGVyczoge1xuICAgICAgICAgICAgUkZDMTczODogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2UuY2FsbCh2YWx1ZSwgcGVyY2VudFR3ZW50aWVzLCAnKycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFJGQzM5ODY6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBGb3JtYXRcbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIHRzbGliXzEuX19zcHJlYWQoW3t9XSwgT2JqZWN0LmVudHJpZXMob2JqKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChfYSwgMSksIGtleSA9IF9iWzBdO1xuICAgICAgICByZXR1cm4ga2V5cy5pbmNsdWRlcyhrZXkpO1xuICAgIH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIF9jID0gdHNsaWJfMS5fX3JlYWQoX2EsIDIpLCBrZXkgPSBfY1swXSwgdmFsdWUgPSBfY1sxXTtcbiAgICAgICAgcmV0dXJuIChfYiA9IHt9LCBfYltrZXldID0gdmFsdWUsIF9iKTtcbiAgICB9KSkpO1xufVxuZXhwb3J0cy5waWNrID0gcGljaztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGljayA9IHBpY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgQ2hhdEJhZGdlU2V0XzEgPSByZXF1aXJlKFwiLi9DaGF0QmFkZ2VTZXRcIik7XG4vKipcbiAqIEEgbGlzdCBvZiBiYWRnZSBzZXRzLlxuICovXG52YXIgQ2hhdEJhZGdlTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBDaGF0QmFkZ2VMaXN0KF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0QmFkZ2VMaXN0LnByb3RvdHlwZSwgXCJiYWRnZVNldE5hbWVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWVzIG9mIGFsbCBiYWRnZSBzZXRzIGluIHRoZSBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEdldHMgYSBzcGVjaWZpYyBiYWRnZSBzZXQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBiYWRnZSBzZXQuXG4gICAgICovXG4gICAgQ2hhdEJhZGdlTGlzdC5wcm90b3R5cGUuZ2V0QmFkZ2VTZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IENoYXRCYWRnZVNldF8xLmRlZmF1bHQodGhpcy5fZGF0YVtuYW1lXSwgdGhpcy5fY2xpZW50KTtcbiAgICB9O1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIENoYXRCYWRnZUxpc3QucHJvdG90eXBlLl9tZXJnZSA9IGZ1bmN0aW9uIChhZGRpdGlvbmFsRGF0YSkge1xuICAgICAgICBpZiAoYWRkaXRpb25hbERhdGEgaW5zdGFuY2VvZiBDaGF0QmFkZ2VMaXN0KSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsRGF0YSA9IGFkZGl0aW9uYWxEYXRhLl9kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdEJhZGdlTGlzdCh0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIHRoaXMuX2RhdGEpLCBhZGRpdGlvbmFsRGF0YSksIHRoaXMuX2NsaWVudCk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgQ2hhdEJhZGdlTGlzdC5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBDaGF0QmFkZ2VMaXN0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYXRCYWRnZUxpc3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDaGF0QmFkZ2VMaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEJhZGdlTGlzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgQ2hhdEJhZGdlVmVyc2lvbl8xID0gcmVxdWlyZShcIi4vQ2hhdEJhZGdlVmVyc2lvblwiKTtcbi8qKlxuICogQSBzZXQgb2YgYmFkZ2VzLlxuICovXG52YXIgQ2hhdEJhZGdlU2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIENoYXRCYWRnZVNldChfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdEJhZGdlU2V0LnByb3RvdHlwZSwgXCJ2ZXJzaW9uTmFtZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZXMgb2YgYWxsIHZlcnNpb25zIG9mIHRoZSBiYWRnZSBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9kYXRhLnZlcnNpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHNwZWNpZmljIHZlcnNpb24gb2YgYSBiYWRnZSBieSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZlcnNpb24uXG4gICAgICovXG4gICAgQ2hhdEJhZGdlU2V0LnByb3RvdHlwZS5nZXRWZXJzaW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0QmFkZ2VWZXJzaW9uXzEuZGVmYXVsdCh0aGlzLl9kYXRhLnZlcnNpb25zW25hbWVdLCB0aGlzLl9jbGllbnQpO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIENoYXRCYWRnZVNldC5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBDaGF0QmFkZ2VTZXQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEJhZGdlU2V0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ2hhdEJhZGdlU2V0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEJhZGdlU2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogQSB2ZXJzaW9uIG9mIGEgYmFkZ2UuXG4gKi9cbnZhciBDaGF0QmFkZ2VWZXJzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIENoYXRCYWRnZVZlcnNpb24oX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRCYWRnZVZlcnNpb24ucHJvdG90eXBlLCBcImNsaWNrQWN0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBiYWRnZSBpcyBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5jbGlja19hY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0QmFkZ2VWZXJzaW9uLnByb3RvdHlwZSwgXCJjbGlja1VybFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIHRvIHZpc2l0IHdoZW4gdGhlIGJhZGdlIGlzIGNsaWNrZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgYXBwbGllcyBpZiBjbGlja0FjdGlvbiA9PT0gJ3Zpc2l0X3VybCcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmNsaWNrX3VybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRCYWRnZVZlcnNpb24ucHJvdG90eXBlLCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYmFkZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmRlc2NyaXB0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGFuIGltYWdlIFVSTCBmb3IgdGhlIGdpdmVuIHNjYWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjYWxlIFRoZSBzY2FsZSBvZiB0aGUgYmFkZ2UgaW1hZ2UuXG4gICAgICovXG4gICAgQ2hhdEJhZGdlVmVyc2lvbi5wcm90b3R5cGUuZ2V0SW1hZ2VVcmwgPSBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbXCJpbWFnZV91cmxfXCIgKyBzY2FsZSArIFwieFwiXTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0QmFkZ2VWZXJzaW9uLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGl0bGUgb2YgdGhlIGJhZGdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50aXRsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIENoYXRCYWRnZVZlcnNpb24ucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQ2hhdEJhZGdlVmVyc2lvbjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGF0QmFkZ2VWZXJzaW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ2hhdEJhZGdlVmVyc2lvbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYXRCYWRnZVZlcnNpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNhY2hlX2RlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnNcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeV8xID0gcmVxdWlyZShcIi4vSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeVwiKTtcbi8qKlxuICogQSBsZWFkZXJib2FyZCB3aGVyZSB0aGUgdXNlcnMgd2hvIHVzZWQgdGhlIG1vc3QgYml0cyB0byBhIGJyb2FkY2FzdGVyIGFyZSBsaXN0ZWQuXG4gKi9cbnZhciBIZWxpeEJpdHNMZWFkZXJib2FyZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeEJpdHNMZWFkZXJib2FyZChfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCaXRzTGVhZGVyYm9hcmQucHJvdG90eXBlLCBcImVudHJpZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVudHJpZXMgb2YgdGhlIGxlYWRlcmJvYXJkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBuZXcgSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeV8xLmRlZmF1bHQoZW50cnksIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Qml0c0xlYWRlcmJvYXJkLnByb3RvdHlwZSwgXCJ0b3RhbENvdW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3RhbCBhbW91bnQgb2YgcGVvcGxlIG9uIHRoZSByZXF1ZXN0ZWQgbGVhZGVyYm9hcmQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnRvdGFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgSGVsaXhCaXRzTGVhZGVyYm9hcmQucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBIZWxpeEJpdHNMZWFkZXJib2FyZC5wcm90b3R5cGUsIFwiZW50cmllc1wiLCBudWxsKTtcbiAgICBIZWxpeEJpdHNMZWFkZXJib2FyZCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBIZWxpeEJpdHNMZWFkZXJib2FyZCk7XG4gICAgcmV0dXJuIEhlbGl4Qml0c0xlYWRlcmJvYXJkO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4Qml0c0xlYWRlcmJvYXJkO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhCaXRzTGVhZGVyYm9hcmQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEJpdHNMZWFkZXJib2FyZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG4vKipcbiAqIEEgQml0cyBsZWFkZXJib2FyZCBlbnRyeS5cbiAqL1xudmFyIEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeShfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeS5wcm90b3R5cGUsIFwidXNlcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdXNlciBvbiB0aGUgbGVhZGVyYm9hcmQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVzZXJfaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5LnByb3RvdHlwZSwgXCJ1c2VyRGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgdXNlciBvbiB0aGUgbGVhZGVyYm9hcmQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVzZXJfbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnkucHJvdG90eXBlLCBcInJhbmtcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSB1c2VyIG9uIHRoZSBsZWFkZXJib2FyZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEucmFuaztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnkucHJvdG90eXBlLCBcImFtb3VudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIGJpdHMgdXNlZCBpbiB0aGUgZ2l2ZW4gcGVyaW9kIG9mIHRpbWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnNjb3JlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHVzZXIgdGhhdCdzIG9uIHRoaXMgcGxhY2Ugb24gdGhlIGxlYWRlcmJvYXJkLlxuICAgICAqL1xuICAgIEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnkucHJvdG90eXBlLmdldFVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCh0aGlzLl9kYXRhLnVzZXJfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5LnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnk7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBIZWxpeENsaXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhDbGlwKF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeENsaXAucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGlwIElELlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwidXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgb2YgdGhlIGNsaXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwiZW1iZWRVcmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVtYmVkIFVSTCBvZiB0aGUgY2xpcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZW1iZWRfdXJsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJicm9hZGNhc3RlcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1c2VyIElEIG9mIHRoZSBicm9hZGNhc3RlciBvZiB0aGUgc3RyZWFtIHdoZXJlIHRoZSBjbGlwIHdhcyBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5icm9hZGNhc3Rlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwiYnJvYWRjYXN0ZXJEaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBicm9hZGNhc3RlciBvZiB0aGUgc3RyZWFtIHdoZXJlIHRoZSBjbGlwIHdhcyBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5icm9hZGNhc3Rlcl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGJyb2FkY2FzdGVyIG9mIHRoZSBzdHJlYW0gd2hlcmUgdGhlIGNsaXAgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgSGVsaXhDbGlwLnByb3RvdHlwZS5nZXRCcm9hZGNhc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeUlkKHRoaXMuX2RhdGEuYnJvYWRjYXN0ZXJfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeENsaXAucHJvdG90eXBlLCBcImNyZWF0b3JJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlciBJRCBvZiB0aGUgY3JlYXRvciBvZiB0aGUgY2xpcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuY3JlYXRvcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwiY3JlYXRvckRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIGNyZWF0b3Igb2YgdGhlIGNsaXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmNyZWF0b3JfbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjcmVhdG9yIG9mIHRoZSBjbGlwLlxuICAgICAqL1xuICAgIEhlbGl4Q2xpcC5wcm90b3R5cGUuZ2V0Q3JlYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeUlkKHRoaXMuX2RhdGEuY3JlYXRvcl9pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwidmlkZW9JZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIHZpZGVvIHRoZSBjbGlwIGlzIHRha2VuIGZyb20uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnZpZGVvX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZpZGVvIHRoZSBjbGlwIGlzIHRha2VuIGZyb20uXG4gICAgICovXG4gICAgSGVsaXhDbGlwLnByb3RvdHlwZS5nZXRWaWRlbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnZpZGVvcy5nZXRWaWRlb0J5SWQodGhpcy5fZGF0YS52aWRlb19pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwiZ2FtZUlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgZ2FtZSB0aGF0IHdhcyBiZWluZyBwbGF5ZWQgd2hlbiB0aGUgY2xpcCB3YXMgY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2FtZV9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBnYW1lIHRoYXQgd2FzIGJlaW5nIHBsYXllZCB3aGVuIHRoZSBjbGlwIHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIEhlbGl4Q2xpcC5wcm90b3R5cGUuZ2V0R2FtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LmdhbWVzLmdldEdhbWVCeUlkKHRoaXMuX2RhdGEuZ2FtZV9pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwibGFuZ3VhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhbmd1YWdlIG9mIHRoZSBzdHJlYW0gd2hlcmUgdGhlIGNsaXAgd2FzIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmxhbmd1YWdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGl0bGUgb2YgdGhlIGNsaXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnRpdGxlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJ2aWV3c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHZpZXdzIG9mIHRoZSBjbGlwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS52aWV3X2NvdW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJjcmVhdGlvbkRhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgd2hlbiB0aGUgY2xpcCB3YXMgY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEuY3JlYXRlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeENsaXAucHJvdG90eXBlLCBcInRodW1ibmFpbFVybFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSB0aHVtYm5haWwgb2YgdGhlIGNsaXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnRodW1ibmFpbF91cmw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeENsaXAucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gSGVsaXhDbGlwO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4Q2xpcDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4Q2xpcDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4Q2xpcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG4vKipcbiAqIEEgYml0cyB0cmFuc2FjdGlvbiBtYWRlIGluc2lkZSBhbiBleHRlbnNpb24uXG4gKi9cbnZhciBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb24oX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwidHJhbnNhY3Rpb25EYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHdoZW4gdGhlIHRyYW5zYWN0aW9uIHdhcyBtYWRlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS50aW1lc3RhbXApO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwiYnJvYWRjYXN0ZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIGJyb2FkY2FzdGVyIHRoYXQgcnVucyB0aGUgZXh0ZW5zaW9uIG9uIHRoZWlyIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJyb2FkY2FzdGVyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwiYnJvYWRjYXN0ZXJEaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBicm9hZGNhc3RlciB0aGF0IHJ1bnMgdGhlIGV4dGVuc2lvbiBvbiB0aGVpciBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5icm9hZGNhc3Rlcl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGJyb2FkY2FzdGVyIHRoYXQgcnVucyB0aGUgZXh0ZW5zaW9uIG9uIHRoZWlyIGNoYW5uZWwuXG4gICAgICovXG4gICAgSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0QnJvYWRjYXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCh0aGlzLl9kYXRhLmJyb2FkY2FzdGVyX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwidXNlcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdXNlciB0aGF0IG1hZGUgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwidXNlckRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHVzZXIgdGhhdCBtYWRlIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHVzZXIgdGhhdCBtYWRlIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZS5nZXRVc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy5fZGF0YS51c2VyX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwicHJvZHVjdFR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb2R1Y3QgdHlwZS4gQ3VycmVudGx5IGFsd2F5cyBCSVRTX0lOX0VYVEVOU0lPTi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEucHJvZHVjdF90eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwicHJvZHVjdFNLVVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcHJvZHVjdCBTS1UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnByb2R1Y3RfZGF0YS5za3U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJwcm9kdWN0Q29zdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29zdCBvZiB0aGUgcHJvZHVjdCwgaW4gYml0cy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEucHJvZHVjdF9kYXRhLmNvc3QuYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwicHJvZHVjdERpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHByb2R1Y3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnByb2R1Y3RfZGF0YS5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcInByb2R1Y3RJbkRldmVsb3BtZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHByb2R1Y3QgaXMgaW4gZGV2ZWxvcG1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnByb2R1Y3RfZGF0YS5pbkRldmVsb3BtZW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG4vKipcbiAqIEEgZ2FtZSBhcyBkaXNwbGF5ZWQgb24gVHdpdGNoLlxuICovXG52YXIgSGVsaXhHYW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4R2FtZShfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhHYW1lLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIGdhbWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhHYW1lLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBnYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhHYW1lLnByb3RvdHlwZSwgXCJib3hBcnRVcmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgYm94IGFydCBvZiB0aGUgZ2FtZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuYm94X2FydF91cmw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeEdhbWUucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gSGVsaXhHYW1lO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4R2FtZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4R2FtZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4R2FtZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgSGVsaXhCYW5fMSA9IHJlcXVpcmUoXCIuL0hlbGl4QmFuXCIpO1xuLyoqXG4gKiBUaGUgZGlmZmVyZW50IHR5cGVzIGEgYmFuIGV2ZW50IGNhbiBoYXZlLlxuICovXG52YXIgSGVsaXhCYW5FdmVudFR5cGU7XG4oZnVuY3Rpb24gKEhlbGl4QmFuRXZlbnRUeXBlKSB7XG4gICAgLyoqXG4gICAgICogU2VudCB3aGVuIGEgdXNlciBnZXRzIGJhbm5lZC5cbiAgICAgKi9cbiAgICBIZWxpeEJhbkV2ZW50VHlwZVtcIkJhblwiXSA9IFwibW9kZXJhdGlvbi51c2VyLmJhblwiO1xuICAgIC8qKlxuICAgICAqIFNlbnQgd2hlbiBhIHVzZXIgZ2V0cyB1bmJhbm5lZC5cbiAgICAgKi9cbiAgICBIZWxpeEJhbkV2ZW50VHlwZVtcIlVuYmFuXCJdID0gXCJtb2RlcmF0aW9uLnVzZXIudW5iYW5cIjtcbn0pKEhlbGl4QmFuRXZlbnRUeXBlIHx8IChIZWxpeEJhbkV2ZW50VHlwZSA9IHt9KSk7XG5leHBvcnRzLkhlbGl4QmFuRXZlbnRUeXBlID0gSGVsaXhCYW5FdmVudFR5cGU7XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaW5kaWNhdGVzIHRoZSBjaGFuZ2Ugb2YgYSBiYW4gc3RhdHVzLCBpLmUuIGJhbm5pbmcgb3IgdW5iYW5uaW5nIGEgdXNlci5cbiAqL1xudmFyIEhlbGl4QmFuRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGVsaXhCYW5FdmVudCwgX3N1cGVyKTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeEJhbkV2ZW50KF9ldmVudERhdGEsIGNsaWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfZXZlbnREYXRhLmV2ZW50X2RhdGEsIGNsaWVudCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2V2ZW50RGF0YSA9IF9ldmVudERhdGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QmFuRXZlbnQucHJvdG90eXBlLCBcImV2ZW50SWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgYmFuIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnREYXRhLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCYW5FdmVudC5wcm90b3R5cGUsIFwiZXZlbnRUeXBlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBiYW4gZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudERhdGEuZXZlbnRfdHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QmFuRXZlbnQucHJvdG90eXBlLCBcImV2ZW50RGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSBvZiB0aGUgYmFuIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZXZlbnREYXRhLmV2ZW50X3RpbWVzdGFtcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEJhbkV2ZW50LnByb3RvdHlwZSwgXCJldmVudFZlcnNpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZlcnNpb24gb2YgdGhlIGJhbiBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RGF0YS52ZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCYW5FdmVudC5wcm90b3R5cGUsIFwiYnJvYWRjYXN0ZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWQgb2YgdGhlIGJyb2FkY2FzdGVyIGZyb20gd2hvc2UgY2hhdCB0aGUgdXNlciB3YXMgYmFubmVkL3VuYmFubmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnREYXRhLmV2ZW50X2RhdGEuYnJvYWRjYXN0ZXJfaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBtb3JlIGRhdGEgYWJvdXQgdGhlIGJyb2FkY2FzdGVyLlxuICAgICAqL1xuICAgIEhlbGl4QmFuRXZlbnQucHJvdG90eXBlLmdldEJyb2FkY2FzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy5fZXZlbnREYXRhLmV2ZW50X2RhdGEuYnJvYWRjYXN0ZXJfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEJhbkV2ZW50LnByb3RvdHlwZSwgXCJicm9hZGNhc3Rlck5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGJyb2FkY2FzdGVyIGZyb20gd2hvc2UgY2hhdCB0aGUgdXNlciB3YXMgYmFubmVkL3VuYmFubmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnREYXRhLmV2ZW50X2RhdGEuYnJvYWRjYXN0ZXJfaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBIZWxpeEJhbkV2ZW50O1xufShIZWxpeEJhbl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4QmFuRXZlbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeEJhbkV2ZW50O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IZWxpeEJhbkV2ZW50VHlwZSA9IEhlbGl4QmFuRXZlbnRUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhCYW5FdmVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgSGVsaXhNb2RlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL0hlbGl4TW9kZXJhdG9yXCIpO1xuLyoqXG4gKiBUaGUgZGlmZmVyZW50IHR5cGVzIGEgbW9kZXJhdG9yIGV2ZW50IGNhbiBoYXZlLlxuICovXG52YXIgSGVsaXhNb2RlcmF0b3JFdmVudFR5cGU7XG4oZnVuY3Rpb24gKEhlbGl4TW9kZXJhdG9yRXZlbnRUeXBlKSB7XG4gICAgLyoqXG4gICAgICogU2VudCB3aGVuIGEgdXNlciBnYWlucyBtb2RlcmF0aW9uIHByaXZpbGVnZXMuXG4gICAgICovXG4gICAgSGVsaXhNb2RlcmF0b3JFdmVudFR5cGVbXCJBZGRcIl0gPSBcIm1vZGVyYXRpb24ubW9kZXJhdG9yLmFkZFwiO1xuICAgIC8qKlxuICAgICAqIFNlbnQgd2hlbiBhIHVzZXIgbG9zZXMgbW9kZXJhdGlvbiBwcml2aWxlZ2VzLlxuICAgICAqL1xuICAgIEhlbGl4TW9kZXJhdG9yRXZlbnRUeXBlW1wiUmVtb3ZlXCJdID0gXCJtb2RlcmF0aW9uLm1vZGVyYXRvci5yZW1vdmVcIjtcbn0pKEhlbGl4TW9kZXJhdG9yRXZlbnRUeXBlIHx8IChIZWxpeE1vZGVyYXRvckV2ZW50VHlwZSA9IHt9KSk7XG5leHBvcnRzLkhlbGl4TW9kZXJhdG9yRXZlbnRUeXBlID0gSGVsaXhNb2RlcmF0b3JFdmVudFR5cGU7XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaW5kaWNhdGVzIHRoZSBjaGFuZ2Ugb2YgYSBtb2RlcmF0b3Igc3RhdHVzLCBpLmUuIGdhaW5pbmcgb3IgbG9zaW5nIG1vZGVyYXRpb24gcHJpdmlsZWdlcy5cbiAqL1xudmFyIEhlbGl4TW9kZXJhdG9yRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGVsaXhNb2RlcmF0b3JFdmVudCwgX3N1cGVyKTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeE1vZGVyYXRvckV2ZW50KF9ldmVudERhdGEsIGNsaWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfZXZlbnREYXRhLmV2ZW50X2RhdGEsIGNsaWVudCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2V2ZW50RGF0YSA9IF9ldmVudERhdGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4TW9kZXJhdG9yRXZlbnQucHJvdG90eXBlLCBcImV2ZW50SWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgbW9kZXJhdG9yIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnREYXRhLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhNb2RlcmF0b3JFdmVudC5wcm90b3R5cGUsIFwiZXZlbnRUeXBlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBtb2RlcmF0b3IgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudERhdGEuZXZlbnRfdHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4TW9kZXJhdG9yRXZlbnQucHJvdG90eXBlLCBcImV2ZW50RGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSBvZiB0aGUgbW9kZXJhdG9yIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZXZlbnREYXRhLmV2ZW50X3RpbWVzdGFtcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeE1vZGVyYXRvckV2ZW50LnByb3RvdHlwZSwgXCJldmVudFZlcnNpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZlcnNpb24gb2YgdGhlIG1vZGVyYXRvciBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RGF0YS52ZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhNb2RlcmF0b3JFdmVudC5wcm90b3R5cGUsIFwiYnJvYWRjYXN0ZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWQgb2YgdGhlIGJyb2FkY2FzdGVyIHdoZXJlIHRoZSB1c2VyIGdhaW5lZC9sb3N0IG1vZGVyYXRpb24gcHJpdmlsZWdlcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RGF0YS5ldmVudF9kYXRhLmJyb2FkY2FzdGVyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgbW9yZSBkYXRhIGFib3V0IHRoZSBicm9hZGNhc3Rlci5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRvckV2ZW50LnByb3RvdHlwZS5nZXRCcm9hZGNhc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeUlkKHRoaXMuX2V2ZW50RGF0YS5ldmVudF9kYXRhLmJyb2FkY2FzdGVyX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhNb2RlcmF0b3JFdmVudC5wcm90b3R5cGUsIFwiYnJvYWRjYXN0ZXJOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBicm9hZGNhc3RlciB3aGVyZSB0aGUgdXNlciBnYWluZWQvbG9zdCBtb2RlcmF0aW9uIHByaXZpbGVnZXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudERhdGEuZXZlbnRfZGF0YS5icm9hZGNhc3Rlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEhlbGl4TW9kZXJhdG9yRXZlbnQ7XG59KEhlbGl4TW9kZXJhdG9yXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhNb2RlcmF0b3JFdmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4TW9kZXJhdG9yRXZlbnQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhlbGl4TW9kZXJhdG9yRXZlbnRUeXBlID0gSGVsaXhNb2RlcmF0b3JFdmVudFR5cGU7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeE1vZGVyYXRvckV2ZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBDdXN0b21FcnJvcl8xID0gcmVxdWlyZShcIi4vQ3VzdG9tRXJyb3JcIik7XG4vKipcbiAqIFRocm93biB3aGVuZXZlciB5b3UgdHJ5IHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHlvdXIgb3duIHN0cmVhbSB0byBiZSBsaXZlLlxuICovXG52YXIgU3RyZWFtTm90TGl2ZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFN0cmVhbU5vdExpdmVFcnJvciwgX3N1cGVyKTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBTdHJlYW1Ob3RMaXZlRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnWW91ciBzdHJlYW0gbmVlZHMgdG8gYmUgbGl2ZSB0byBkbyB0aGlzJykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmVhbU5vdExpdmVFcnJvcjtcbn0oQ3VzdG9tRXJyb3JfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdHJlYW1Ob3RMaXZlRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTdHJlYW1Ob3RMaXZlRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdHJlYW1Ob3RMaXZlRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBUaGUgdHlwZSBvZiBhIHN0cmVhbS5cbiAqL1xudmFyIEhlbGl4U3RyZWFtVHlwZTtcbihmdW5jdGlvbiAoSGVsaXhTdHJlYW1UeXBlKSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgYnkgVHdpdGNoIGluIGNhc2Ugb2YgYW4gZXJyb3IuXG4gICAgICovXG4gICAgSGVsaXhTdHJlYW1UeXBlW1wiTm9uZVwiXSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQSBsaXZlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbVR5cGVbXCJMaXZlXCJdID0gXCJsaXZlXCI7XG4gICAgLyoqXG4gICAgICogQSB2b2RjYXN0LlxuICAgICAqXG4gICAgICogQ3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgYnkgVHdpdGNoIC0gYnV0IG9uZSBjYW4gb25seSBob3BlIGFuZCBsZWF2ZSBpdCBpbiBoZXJlLlxuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtVHlwZVtcIlZvZGNhc3RcIl0gPSBcInZvZGNhc3RcIjtcbn0pKEhlbGl4U3RyZWFtVHlwZSB8fCAoSGVsaXhTdHJlYW1UeXBlID0ge30pKTtcbmV4cG9ydHMuSGVsaXhTdHJlYW1UeXBlID0gSGVsaXhTdHJlYW1UeXBlO1xuLyoqXG4gKiBBIFR3aXRjaCBzdHJlYW0uXG4gKi9cbnZhciBIZWxpeFN0cmVhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeFN0cmVhbShfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdHJlYW0ucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdHJlYW0gSUQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdHJlYW0ucHJvdG90eXBlLCBcInVzZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlciBJRC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtLnByb3RvdHlwZSwgXCJ1c2VyRGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIncyBkaXNwbGF5IG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVzZXJfbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSB1c2VyIGJyb2FkY2FzdGluZyB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtLnByb3RvdHlwZS5nZXRVc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy5fZGF0YS51c2VyX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdHJlYW0ucHJvdG90eXBlLCBcImdhbWVJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZ2FtZSBJRC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2FtZV9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBnYW1lIHRoYXQgaXMgYmVpbmcgcGxheWVkIG9uIHRoaXMgc3RyZWFtLlxuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtLnByb3RvdHlwZS5nZXRHYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXguZ2FtZXMuZ2V0R2FtZUJ5SWQodGhpcy5fZGF0YS5nYW1lX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdHJlYW0ucHJvdG90eXBlLCBcInR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGl0bGUgb2YgdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudGl0bGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbS5wcm90b3R5cGUsIFwidmlld2Vyc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHZpZXdlcnMgdGhlIHN0cmVhbSBjdXJyZW50bHkgaGFzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS52aWV3ZXJfY291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbS5wcm90b3R5cGUsIFwic3RhcnREYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHdoZW4gdGhlIHN0cmVhbSBzdGFydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS5zdGFydGVkX2F0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtLnByb3RvdHlwZSwgXCJsYW5ndWFnZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFuZ3VhZ2Ugb2YgdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubGFuZ3VhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbS5wcm90b3R5cGUsIFwidGh1bWJuYWlsVXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgb2YgdGhlIHRodW1ibmFpbCBvZiB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50aHVtYm5haWxfdXJsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgSGVsaXhTdHJlYW0ucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gSGVsaXhTdHJlYW07XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdHJlYW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFN0cmVhbTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGVsaXhTdHJlYW1UeXBlID0gSGVsaXhTdHJlYW1UeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdHJlYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIEhlbGl4U3RyZWFtTWFya2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4U3RyZWFtTWFya2VyKC8qKiBAcHJpdmF0ZSAqLyBfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdHJlYW1NYXJrZXIucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgbWFya2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtTWFya2VyLnByb3RvdHlwZSwgXCJjcmVhdGlvbkRhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgYW5kIHRpbWUgd2hlbiB0aGUgbWFya2VyIHdhcyBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS5jcmVhdGVkX2F0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtTWFya2VyLnByb3RvdHlwZSwgXCJkZXNjcmlwdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIG1hcmtlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZGVzY3JpcHRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbU1hcmtlci5wcm90b3R5cGUsIFwicG9zaXRpb25JblNlY29uZHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBvc2l0aW9uIGluIHRoZSBzdHJlYW0gd2hlbiB0aGUgbWFya2VyIHdhcyBjcmVhdGVkLCBpbiBzZWNvbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5wb3NpdGlvbl9zZWNvbmRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgSGVsaXhTdHJlYW1NYXJrZXIucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gSGVsaXhTdHJlYW1NYXJrZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdHJlYW1NYXJrZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFN0cmVhbU1hcmtlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4U3RyZWFtTWFya2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBIZWxpeFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vSGVsaXhTdWJzY3JpcHRpb25cIik7XG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgdHlwZXMgYSBzdWJzY3JpcHRpb24gZXZlbnQgY2FuIGhhdmUuXG4gKi9cbnZhciBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50VHlwZTtcbihmdW5jdGlvbiAoSGVsaXhTdWJzY3JpcHRpb25FdmVudFR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBTZW50IHdoZW4gYSBuZXcgdXNlciBzdWJzY3JpYmVzLlxuICAgICAqL1xuICAgIEhlbGl4U3Vic2NyaXB0aW9uRXZlbnRUeXBlW1wiU3Vic2NyaWJlXCJdID0gXCJzdWJzY3JpcHRpb25zLnN1YnNjcmliZVwiO1xuICAgIC8qKlxuICAgICAqIFNlbnQgd2hlbiBhIHByZXZpb3VzIHN1YnNjcmliZXIgc3RvcHMgc3Vic2NyaWJpbmcuXG4gICAgICovXG4gICAgSGVsaXhTdWJzY3JpcHRpb25FdmVudFR5cGVbXCJVbnN1YnNjcmliZVwiXSA9IFwic3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZVwiO1xuICAgIC8qKlxuICAgICAqIFNlbnQgd2hlbiBhIG5ldyBvciByZWN1cnJpbmcgc3Vic2NyaWJlciBzZW5kcyB0aGVpciBtb250aGx5IG5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50VHlwZVtcIk5vdGlmaWNhdGlvblwiXSA9IFwic3Vic2NyaXB0aW9ucy5ub3RpZmljYXRpb25cIjtcbn0pKEhlbGl4U3Vic2NyaXB0aW9uRXZlbnRUeXBlIHx8IChIZWxpeFN1YnNjcmlwdGlvbkV2ZW50VHlwZSA9IHt9KSk7XG5leHBvcnRzLkhlbGl4U3Vic2NyaXB0aW9uRXZlbnRUeXBlID0gSGVsaXhTdWJzY3JpcHRpb25FdmVudFR5cGU7XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaW5kaWNhdGVzIHRoZSBjaGFuZ2Ugb2YgYSBzdWJzY3JpcHRpb24gc3RhdHVzLCBpLmUuIHN1YnNjcmliaW5nLCB1bnN1YnNjcmliaW5nIG9yIHNlbmRpbmcgdGhlIG1vbnRobHkgbm90aWZpY2F0aW9uLlxuICovXG52YXIgSGVsaXhTdWJzY3JpcHRpb25FdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeFN1YnNjcmlwdGlvbkV2ZW50LCBfc3VwZXIpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4U3Vic2NyaXB0aW9uRXZlbnQoX2V2ZW50RGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9ldmVudERhdGEuZXZlbnRfZGF0YSwgY2xpZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZXZlbnREYXRhID0gX2V2ZW50RGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdWJzY3JpcHRpb25FdmVudC5wcm90b3R5cGUsIFwiZXZlbnRJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzdWJzY3JpcHRpb24gZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudERhdGEuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN1YnNjcmlwdGlvbkV2ZW50LnByb3RvdHlwZSwgXCJldmVudFR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHN1YnNjcmlwdGlvbiBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RGF0YS5ldmVudF90eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdWJzY3JpcHRpb25FdmVudC5wcm90b3R5cGUsIFwiZXZlbnREYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIG9mIHRoZSBzdWJzY3JpcHRpb24gZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9ldmVudERhdGEuZXZlbnRfdGltZXN0YW1wKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3Vic2NyaXB0aW9uRXZlbnQucHJvdG90eXBlLCBcImV2ZW50VmVyc2lvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc3Vic2NyaXB0aW9uIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnREYXRhLnZlcnNpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN1YnNjcmlwdGlvbkV2ZW50LnByb3RvdHlwZSwgXCJldmVudE1lc3NhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1lc3NhZ2Ugc2VudCB3aXRoIHRoZSBzdWJzY3JpcHRpb24gZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudERhdGEuZXZlbnRfZGF0YS5tZXNzYWdlIHx8ICcnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gSGVsaXhTdWJzY3JpcHRpb25FdmVudDtcbn0oSGVsaXhTdWJzY3JpcHRpb25fMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhTdWJzY3JpcHRpb25FdmVudDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGVsaXhTdWJzY3JpcHRpb25FdmVudFR5cGUgPSBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50VHlwZTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4U3Vic2NyaXB0aW9uRXZlbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xID0gcmVxdWlyZShcIi4vSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XCIpO1xuLyoqXG4gKiBBIHNwZWNpYWwgY2FzZSBvZiB7QEhlbGl4UGFnaW5hdGVkUmVxdWVzdH0gd2l0aCBzdXBwb3J0IGZvciBmZXRjaGluZyB0aGUgdG90YWwgbnVtYmVyIG9mIGVudGl0aWVzLCB3aGVuZXZlciBhbiBlbmRwb2ludCBzdXBwb3J0cyBpdC5cbiAqL1xudmFyIEhlbGl4UGFnaW5hdGVkUmVxdWVzdFdpdGhUb3RhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeFBhZ2luYXRlZFJlcXVlc3RXaXRoVG90YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbmQgcmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGVudGl0aWVzIGV4aXN0aW5nIGluIHRoZSBxdWVyaWVkIHJlc3VsdCBzZXQuXG4gICAgICovXG4gICAgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsLnByb3RvdHlwZS5nZXRUb3RhbENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBfYTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLl9jdXJyZW50RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9mZXRjaERhdGEoeyBxdWVyeTogeyBhZnRlcjogdW5kZWZpbmVkIH0gfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IChfYi5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YS50b3RhbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEhlbGl4UGFnaW5hdGVkUmVxdWVzdFdpdGhUb3RhbDtcbn0oSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogQSByZWxhdGlvbiBvZiBhIHVzZXIgZm9sbG93aW5nIGEgYnJvYWRjYXN0ZXIuXG4gKi9cbnZhciBIZWxpeEZvbGxvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeEZvbGxvdygvKiogQHByaXZhdGUgKi8gX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Rm9sbG93LnByb3RvdHlwZSwgXCJ1c2VySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgSUQgb2YgdGhlIGZvbGxvd2luZyB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5mcm9tX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhGb2xsb3cucHJvdG90eXBlLCBcInVzZXJEaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBmb2xsb3dpbmcgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZnJvbV9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGRhdGEgb2YgdGhlIGZvbGxvd2luZyB1c2VyLlxuICAgICAqL1xuICAgIEhlbGl4Rm9sbG93LnByb3RvdHlwZS5nZXRVc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy5fZGF0YS5mcm9tX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhGb2xsb3cucHJvdG90eXBlLCBcImZvbGxvd2VkVXNlcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1c2VyIElEIG9mIHRoZSBmb2xsb3dlZCBicm9hZGNhc3Rlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudG9faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEZvbGxvdy5wcm90b3R5cGUsIFwiZm9sbG93ZWRVc2VyRGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgZm9sbG93ZWQgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudG9fbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBkYXRhIG9mIHRoZSBmb2xsb3dlZCBicm9hZGNhc3Rlci5cbiAgICAgKi9cbiAgICBIZWxpeEZvbGxvdy5wcm90b3R5cGUuZ2V0Rm9sbG93ZWRVc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy5fZGF0YS50b19pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Rm9sbG93LnByb3RvdHlwZSwgXCJmb2xsb3dEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIHdoZW4gdGhlIHVzZXIgZm9sbG93ZWQgdGhlIGJyb2FkY2FzdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS5mb2xsb3dlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeEZvbGxvdy5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWxpeEZvbGxvdztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEZvbGxvdztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4Rm9sbG93O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhGb2xsb3c7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEhlbGl4VXNlcl8xID0gcmVxdWlyZShcIi4vSGVsaXhVc2VyXCIpO1xuLyoqXG4gKiBBIHVzZXIgeW91IGhhdmUgZXh0ZW5kZWQgcHJpdmlsZ2VzIGZvciwgaS5lLiB5b3Vyc2VsZi5cbiAqXG4gKiBAaW5oZXJpdERvY1xuICovXG52YXIgSGVsaXhQcml2aWxlZ2VkVXNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeFByaXZpbGVnZWRVc2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlbGl4UHJpdmlsZWdlZFVzZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4UHJpdmlsZWdlZFVzZXIucHJvdG90eXBlLCBcImVtYWlsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5lbWFpbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gVGhlIG5ldyBkZXNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBIZWxpeFByaXZpbGVnZWRVc2VyLnByb3RvdHlwZS5zZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMudXBkYXRlVXNlcih7IGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVsaXhQcml2aWxlZ2VkVXNlcjtcbn0oSGVsaXhVc2VyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhQcml2aWxlZ2VkVXNlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4UHJpdmlsZWdlZFVzZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFByaXZpbGVnZWRVc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjYWNoZV9kZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIEhlbGxGcmVlemVzT3ZlckVycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRXJyb3JzL0hlbGxGcmVlemVzT3ZlckVycm9yXCIpO1xuLyoqXG4gKiBBIHZpZGVvIG9uIFR3aXRjaC5cbiAqL1xudmFyIEhlbGl4VmlkZW8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhWaWRlbyhfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhWaWRlby5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB2aWRlby5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJ1c2VySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB1c2VyIHdobyBjcmVhdGVkIHRoZSB2aWRlby5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcInVzZXJEaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSB1c2VyIHdobyBjcmVhdGVkIHRoZSB2aWRlby5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHVzZXIgd2hvIGNyZWF0ZWQgdGhlIHZpZGVvLlxuICAgICAqL1xuICAgIEhlbGl4VmlkZW8ucHJvdG90eXBlLmdldFVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCh0aGlzLl9kYXRhLnVzZXJfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGl0bGUgb2YgdGhlIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50aXRsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgdmlkZW8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmRlc2NyaXB0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhWaWRlby5wcm90b3R5cGUsIFwiY3JlYXRpb25EYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIHdoZW4gdGhlIHZpZGVvIHdhcyBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS5jcmVhdGVkX2F0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcInB1Ymxpc2hEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIHdoZW4gdGhlIHZpZGVvIHdhcyBwdWJsaXNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLnB1Ymxpc2hlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgdmlkZW8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcInRodW1ibmFpbFVybFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSB0aHVtYm5haWwgb2YgdGhlIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50aHVtYm5haWxfdXJsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhWaWRlby5wcm90b3R5cGUsIFwiaXNQdWJsaWNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdmlkZW8gaXMgcHVibGljIG9yIG5vdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudmlld2FibGUgPT09ICdwdWJsaWMnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhWaWRlby5wcm90b3R5cGUsIFwidmlld3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiB2aWV3cyBvZiB0aGUgdmlkZW8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnZpZXdfY291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJsYW5ndWFnZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFuZ3VhZ2Ugb2YgdGhlIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sYW5ndWFnZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcInR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhWaWRlby5wcm90b3R5cGUsIFwiZHVyYXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlbywgYXMgZm9ybWF0dGVkIGJ5IFR3aXRjaC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZHVyYXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJkdXJhdGlvbkluU2Vjb25kc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvLCBpbiBzZWNvbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSB0aGlzLl9kYXRhLmR1cmF0aW9uLm1hdGNoKC9cXGQrW2htc10vZyk7XG4gICAgICAgICAgICBpZiAoIXBhcnRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEhlbGxGcmVlemVzT3ZlckVycm9yXzEuZGVmYXVsdChcIkNvdWxkIG5vdCBwYXJzZSBkdXJhdGlvbiBzdHJpbmc6IFwiICsgdGhpcy5fZGF0YS5kdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFydHNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxNYXRjaCA9IHBhcnQubWF0Y2goLyhcXGQrKShbaG1zXSkvKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnRpYWxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMS5kZWZhdWx0KFwiQ291bGQgbm90IHBhcnNlIHBhcnRpYWwgZHVyYXRpb24gc3RyaW5nOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0c2xpYl8xLl9fcmVhZChwYXJ0aWFsTWF0Y2gsIDMpLCBudW0gPSBfYVsxXSwgdW5pdCA9IF9hWzJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW0sIDEwKSAqIHsgaDogMzYwMCwgbTogNjAsIHM6IDEgfVt1bml0XTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgSGVsaXhWaWRlby5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcImR1cmF0aW9uSW5TZWNvbmRzXCIsIG51bGwpO1xuICAgIEhlbGl4VmlkZW8gPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVhYmxlXG4gICAgXSwgSGVsaXhWaWRlbyk7XG4gICAgcmV0dXJuIEhlbGl4VmlkZW87XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhWaWRlbztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4VmlkZW87XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFZpZGVvO1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ0xldmVsXzEgPSByZXF1aXJlKFwiLi9Mb2dMZXZlbFwiKTtcbnZhciBpc05vZGUgPSByZXF1aXJlKFwiZGV0ZWN0LW5vZGVcIik7XG52YXIgQmFzZUxvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlTG9nZ2VyKF9hKSB7XG4gICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgX2IgPSBfYS5taW5MZXZlbCwgbWluTGV2ZWwgPSBfYiA9PT0gdm9pZCAwID8gTG9nTGV2ZWxfMS5Mb2dMZXZlbC5XQVJOSU5HIDogX2IsIF9jID0gX2EuZW1vamksIGVtb2ppID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2EuY29sb3JzLCBjb2xvcnMgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBfZSA9IF9hLnRpbWVzdGFtcHMsIHRpbWVzdGFtcHMgPSBfZSA9PT0gdm9pZCAwID8gaXNOb2RlIDogX2U7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9taW5MZXZlbCA9IExvZ0xldmVsXzEucmVzb2x2ZUxvZ0xldmVsKG1pbkxldmVsKTtcbiAgICAgICAgdGhpcy5fZW1vamkgPSBlbW9qaTtcbiAgICAgICAgdGhpcy5fY29sb3JzID0gY29sb3JzO1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBzID0gdGltZXN0YW1wcztcbiAgICB9XG4gICAgLy8gcmVnaW9uIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5jcml0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5Mb2dMZXZlbC5DUklUSUNBTCwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5jcml0aWNhbCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuTG9nTGV2ZWwuQ1JJVElDQUwsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUuZXJyID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5Mb2dMZXZlbC5FUlJPUiwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuTG9nTGV2ZWwuRVJST1IsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuTG9nTGV2ZWwuV0FSTklORywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS53YXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5Mb2dMZXZlbC5XQVJOSU5HLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLkxvZ0xldmVsLklORk8sIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLkxvZ0xldmVsLkRFQlVHLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgZGVidWcgaW5zdGVhZCAqL1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmRlYnVnMSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuTG9nTGV2ZWwuREVCVUcsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBkZWJ1ZyBpbnN0ZWFkICovXG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUuZGVidWcyID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5Mb2dMZXZlbC5ERUJVRywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGRlYnVnIGluc3RlYWQgKi9cbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZzMgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLkxvZ0xldmVsLkRFQlVHLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5Mb2dMZXZlbC5UUkFDRSwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZUxvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLkJhc2VMb2dnZXIgPSBCYXNlTG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUxvZ2dlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZVByb21pc2UgPSByZXF1aXJlKCcuL3JlcXVpcmVQcm9taXNlJyk7XG5cbnJlcXVpcmVQcm9taXNlKCk7XG5cbnZhciBQcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMTkvUHJvbWlzZVJlc29sdmUnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9UeXBlJyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJ2l0ZXJhdGUtdmFsdWUnKTtcbnZhciBtYXAgPSByZXF1aXJlKCdhcnJheS5wcm90b3R5cGUubWFwJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9jYWxsQm91bmQnKTtcblxudmFyIGFsbCA9IGNhbGxCb3VuZCgnUHJvbWlzZS5hbGwnKTtcbnZhciByZWplY3QgPSBjYWxsQm91bmQoJ1Byb21pc2UucmVqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWxsU2V0dGxlZChpdGVyYWJsZSkge1xuXHR2YXIgQyA9IHRoaXM7XG5cdGlmIChUeXBlKEMpICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2B0aGlzYCB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXHR9XG5cdHZhciB2YWx1ZXMgPSBpdGVyYXRlKGl0ZXJhYmxlKTtcblx0cmV0dXJuIGFsbChDLCBtYXAodmFsdWVzLCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciBvbkZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHJldHVybiB7IHN0YXR1czogJ2Z1bGZpbGxlZCcsIHZhbHVlOiB2YWx1ZSB9O1xuXHRcdH07XG5cdFx0dmFyIG9uUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0cmV0dXJuIHsgc3RhdHVzOiAncmVqZWN0ZWQnLCByZWFzb246IHJlYXNvbiB9O1xuXHRcdH07XG5cdFx0dmFyIGl0ZW1Qcm9taXNlID0gUHJvbWlzZVJlc29sdmUoQywgaXRlbSk7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBpdGVtUHJvbWlzZS50aGVuKG9uRnVsZmlsbCwgb25SZWplY3QpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiByZWplY3QoQywgZSk7XG5cdFx0fVxuXHR9KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyVmFsdWUgPSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgdHJ5U3RyaW5nT2JqZWN0ID0gZnVuY3Rpb24gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0c3RyVmFsdWUuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHN0ckNsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSBzdHJDbGFzcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vNS9DaGVja09iamVjdENvZXJjaWJsZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9BcnJheVNwZWNpZXNDcmVhdGUnKTtcbnZhciBDYWxsID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9DYWxsJyk7XG52YXIgQ3JlYXRlRGF0YVByb3BlcnR5T3JUaHJvdyA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMTkvQ3JlYXRlRGF0YVByb3BlcnR5T3JUaHJvdycpO1xudmFyIEdldCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMTkvR2V0Jyk7XG52YXIgSGFzUHJvcGVydHkgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDE5L0hhc1Byb3BlcnR5Jyk7XG52YXIgSXNDYWxsYWJsZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMTkvSXNDYWxsYWJsZScpO1xudmFyIFRvVWludDMyID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9Ub1VpbnQzMicpO1xudmFyIFRvT2JqZWN0ID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9Ub09iamVjdCcpO1xudmFyIFRvU3RyaW5nID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9Ub1N0cmluZycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvY2FsbEJvdW5kJyk7XG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdpcy1zdHJpbmcnKTtcblxuLy8gQ2hlY2sgZmFpbHVyZSBvZiBieS1pbmRleCBhY2Nlc3Mgb2Ygc3RyaW5nIGNoYXJhY3RlcnMgKElFIDwgOSkgYW5kIGZhaWx1cmUgb2YgYDAgaW4gYm94ZWRTdHJpbmdgIChSaGlubylcbnZhciBib3hlZFN0cmluZyA9IE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgc3RyU3BsaXQgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc3BsaXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbikge1xuXHR2YXIgTyA9IFRvT2JqZWN0KHRoaXMpO1xuXHR2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKE8pID8gc3RyU3BsaXQoTywgJycpIDogTztcblx0dmFyIGxlbiA9IFRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuXHQvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuXHRpZiAoIUlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUubWFwIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHR9XG5cblx0dmFyIFQ7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFQgPSBhcmd1bWVudHNbMV07XG5cdH1cblxuXHR2YXIgQSA9IEFycmF5U3BlY2llc0NyZWF0ZShPLCBsZW4pO1xuXHR2YXIgayA9IDA7XG5cdHdoaWxlIChrIDwgbGVuKSB7XG5cdFx0dmFyIFBrID0gVG9TdHJpbmcoayk7XG5cdFx0dmFyIGtQcmVzZW50ID0gSGFzUHJvcGVydHkoTywgUGspO1xuXHRcdGlmIChrUHJlc2VudCkge1xuXHRcdFx0dmFyIGtWYWx1ZSA9IEdldChPLCBQayk7XG5cdFx0XHR2YXIgbWFwcGVkVmFsdWUgPSBDYWxsKGNhbGxiYWNrZm4sIFQsIFtrVmFsdWUsIGssIE9dKTtcblx0XHRcdENyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3coQSwgUGssIG1hcHBlZFZhbHVlKTtcblx0XHR9XG5cdFx0ayArPSAxO1xuXHR9XG5cblx0cmV0dXJuIEE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG5cbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vKipcbiAqIDcuMy4xIEdldCAoTywgUCkgLSBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZ2V0LW8tcFxuICogMS4gQXNzZXJ0OiBUeXBlKE8pIGlzIE9iamVjdC5cbiAqIDIuIEFzc2VydDogSXNQcm9wZXJ0eUtleShQKSBpcyB0cnVlLlxuICogMy4gUmV0dXJuIE8uW1tHZXRdXShQLCBPKS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldChPLCBQKSB7XG5cdC8vIDcuMy4xLjFcblx0aWYgKFR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFR5cGUoTykgaXMgbm90IE9iamVjdCcpO1xuXHR9XG5cdC8vIDcuMy4xLjJcblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IElzUHJvcGVydHlLZXkoUCkgaXMgbm90IHRydWUsIGdvdCAnICsgaW5zcGVjdChQKSk7XG5cdH1cblx0Ly8gNy4zLjEuM1xuXHRyZXR1cm4gT1tQXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRBcnJheSA9IEdldEludHJpbnNpYygnJUFycmF5JScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcbnZhciB0b1N0ciA9ICEkQXJyYXkuaXNBcnJheSAmJiByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGxCb3VuZCcpKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNhcnJheVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIElzQXJyYXkoYXJndW1lbnQpIHtcblx0cmV0dXJuIHRvU3RyKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHQkZGVmaW5lUHJvcGVydHkgPSBudWxsO1xuXHR9XG59XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGxCb3VuZCcpO1xuXG52YXIgJGlzRW51bWVyYWJsZSA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEZWZpbmVPd25Qcm9wZXJ0eShJc0RhdGFEZXNjcmlwdG9yLCBTYW1lVmFsdWUsIEZyb21Qcm9wZXJ0eURlc2NyaXB0b3IsIE8sIFAsIGRlc2MpIHtcblx0aWYgKCEkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRpZiAoIUlzRGF0YURlc2NyaXB0b3IoZGVzYykpIHtcblx0XHRcdC8vIEVTMyBkb2VzIG5vdCBzdXBwb3J0IGdldHRlcnMvc2V0dGVyc1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoIWRlc2NbJ1tbQ29uZmlndXJhYmxlXV0nXSB8fCAhZGVzY1snW1tXcml0YWJsZV1dJ10pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBmYWxsYmFjayBmb3IgRVMzXG5cdFx0aWYgKFAgaW4gTyAmJiAkaXNFbnVtZXJhYmxlKE8sIFApICE9PSAhIWRlc2NbJ1tbRW51bWVyYWJsZV1dJ10pIHtcblx0XHRcdC8vIGEgbm9uLWVudW1lcmFibGUgZXhpc3RpbmcgcHJvcGVydHlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdCBhdCBhbGwsIG9yIGV4aXN0cyBidXQgaXMgZW51bWVyYWJsZVxuXHRcdHZhciBWID0gZGVzY1snW1tWYWx1ZV1dJ107XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0T1tQXSA9IFY7IC8vIHdpbGwgdXNlIFtbRGVmaW5lXV1cblx0XHRyZXR1cm4gU2FtZVZhbHVlKE9bUF0sIFYpO1xuXHR9XG5cdCRkZWZpbmVQcm9wZXJ0eShPLCBQLCBGcm9tUHJvcGVydHlEZXNjcmlwdG9yKGRlc2MpKTtcblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0UmVjb3JkID0gcmVxdWlyZSgnLi4vaGVscGVycy9hc3NlcnRSZWNvcmQnKTtcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1mcm9tcHJvcGVydHlkZXNjcmlwdG9yXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRnJvbVByb3BlcnR5RGVzY3JpcHRvcihEZXNjKSB7XG5cdGlmICh0eXBlb2YgRGVzYyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gRGVzYztcblx0fVxuXG5cdGFzc2VydFJlY29yZChUeXBlLCAnUHJvcGVydHkgRGVzY3JpcHRvcicsICdEZXNjJywgRGVzYyk7XG5cblx0dmFyIG9iaiA9IHt9O1xuXHRpZiAoJ1tbVmFsdWVdXScgaW4gRGVzYykge1xuXHRcdG9iai52YWx1ZSA9IERlc2NbJ1tbVmFsdWVdXSddO1xuXHR9XG5cdGlmICgnW1tXcml0YWJsZV1dJyBpbiBEZXNjKSB7XG5cdFx0b2JqLndyaXRhYmxlID0gRGVzY1snW1tXcml0YWJsZV1dJ107XG5cdH1cblx0aWYgKCdbW0dldF1dJyBpbiBEZXNjKSB7XG5cdFx0b2JqLmdldCA9IERlc2NbJ1tbR2V0XV0nXTtcblx0fVxuXHRpZiAoJ1tbU2V0XV0nIGluIERlc2MpIHtcblx0XHRvYmouc2V0ID0gRGVzY1snW1tTZXRdXSddO1xuXHR9XG5cdGlmICgnW1tFbnVtZXJhYmxlXV0nIGluIERlc2MpIHtcblx0XHRvYmouZW51bWVyYWJsZSA9IERlc2NbJ1tbRW51bWVyYWJsZV1dJ107XG5cdH1cblx0aWYgKCdbW0NvbmZpZ3VyYWJsZV1dJyBpbiBEZXNjKSB7XG5cdFx0b2JqLmNvbmZpZ3VyYWJsZSA9IERlc2NbJ1tbQ29uZmlndXJhYmxlXV0nXTtcblx0fVxuXHRyZXR1cm4gb2JqO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcycpO1xuXG52YXIgYXNzZXJ0UmVjb3JkID0gcmVxdWlyZSgnLi4vaGVscGVycy9hc3NlcnRSZWNvcmQnKTtcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pc2RhdGFkZXNjcmlwdG9yXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSXNEYXRhRGVzY3JpcHRvcihEZXNjKSB7XG5cdGlmICh0eXBlb2YgRGVzYyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRhc3NlcnRSZWNvcmQoVHlwZSwgJ1Byb3BlcnR5IERlc2NyaXB0b3InLCAnRGVzYycsIERlc2MpO1xuXG5cdGlmICghaGFzKERlc2MsICdbW1ZhbHVlXV0nKSAmJiAhaGFzKERlc2MsICdbW1dyaXRhYmxlXV0nKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRpc05hTiA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNOYU4nKTtcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTkuMTJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTYW1lVmFsdWUoeCwgeSkge1xuXHRpZiAoeCA9PT0geSkgeyAvLyAwID09PSAtMCwgYnV0IHRoZXkgYXJlIG5vdCBpZGVudGljYWwuXG5cdFx0aWYgKHggPT09IDApIHsgcmV0dXJuIDEgLyB4ID09PSAxIC8geTsgfVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiAkaXNOYU4oeCkgJiYgJGlzTmFOKHkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gaXNOYU4oYSkge1xuXHRyZXR1cm4gYSAhPT0gYTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcbnZhciBUb0Jvb2xlYW4gPSByZXF1aXJlKCcuL1RvQm9vbGVhbicpO1xudmFyIElzQ2FsbGFibGUgPSByZXF1aXJlKCcuL0lzQ2FsbGFibGUnKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTguMTAuNVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJvcGVydHlEZXNjcmlwdG9yKE9iaikge1xuXHRpZiAoVHlwZShPYmopICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdUb1Byb3BlcnR5RGVzY3JpcHRvciByZXF1aXJlcyBhbiBvYmplY3QnKTtcblx0fVxuXG5cdHZhciBkZXNjID0ge307XG5cdGlmIChoYXMoT2JqLCAnZW51bWVyYWJsZScpKSB7XG5cdFx0ZGVzY1snW1tFbnVtZXJhYmxlXV0nXSA9IFRvQm9vbGVhbihPYmouZW51bWVyYWJsZSk7XG5cdH1cblx0aWYgKGhhcyhPYmosICdjb25maWd1cmFibGUnKSkge1xuXHRcdGRlc2NbJ1tbQ29uZmlndXJhYmxlXV0nXSA9IFRvQm9vbGVhbihPYmouY29uZmlndXJhYmxlKTtcblx0fVxuXHRpZiAoaGFzKE9iaiwgJ3ZhbHVlJykpIHtcblx0XHRkZXNjWydbW1ZhbHVlXV0nXSA9IE9iai52YWx1ZTtcblx0fVxuXHRpZiAoaGFzKE9iaiwgJ3dyaXRhYmxlJykpIHtcblx0XHRkZXNjWydbW1dyaXRhYmxlXV0nXSA9IFRvQm9vbGVhbihPYmoud3JpdGFibGUpO1xuXHR9XG5cdGlmIChoYXMoT2JqLCAnZ2V0JykpIHtcblx0XHR2YXIgZ2V0dGVyID0gT2JqLmdldDtcblx0XHRpZiAodHlwZW9mIGdldHRlciAhPT0gJ3VuZGVmaW5lZCcgJiYgIUlzQ2FsbGFibGUoZ2V0dGVyKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdH1cblx0XHRkZXNjWydbW0dldF1dJ10gPSBnZXR0ZXI7XG5cdH1cblx0aWYgKGhhcyhPYmosICdzZXQnKSkge1xuXHRcdHZhciBzZXR0ZXIgPSBPYmouc2V0O1xuXHRcdGlmICh0eXBlb2Ygc2V0dGVyICE9PSAndW5kZWZpbmVkJyAmJiAhSXNDYWxsYWJsZShzZXR0ZXIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignc2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdH1cblx0XHRkZXNjWydbW1NldF1dJ10gPSBzZXR0ZXI7XG5cdH1cblxuXHRpZiAoKGhhcyhkZXNjLCAnW1tHZXRdXScpIHx8IGhhcyhkZXNjLCAnW1tTZXRdXScpKSAmJiAoaGFzKGRlc2MsICdbW1ZhbHVlXV0nKSB8fCBoYXMoZGVzYywgJ1tbV3JpdGFibGVdXScpKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdJbnZhbGlkIHByb3BlcnR5IGRlc2NyaXB0b3IuIENhbm5vdCBib3RoIHNwZWNpZnkgYWNjZXNzb3JzIGFuZCBhIHZhbHVlIG9yIHdyaXRhYmxlIGF0dHJpYnV0ZScpO1xuXHR9XG5cdHJldHVybiBkZXNjO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTkuMlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvQm9vbGVhbih2YWx1ZSkgeyByZXR1cm4gISF2YWx1ZTsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTkuMTFcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdpcy1jYWxsYWJsZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWZsZWN0QXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xudmFyIGJhZEFycmF5TGlrZTtcbnZhciBpc0NhbGxhYmxlTWFya2VyO1xuaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHR0cnkge1xuXHRcdGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2xlbmd0aCcsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBpc0NhbGxhYmxlTWFya2VyO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlzQ2FsbGFibGVNYXJrZXIgPSB7fTtcblx0fSBjYXRjaCAoXykge1xuXHRcdHJlZmxlY3RBcHBseSA9IG51bGw7XG5cdH1cbn0gZWxzZSB7XG5cdHJlZmxlY3RBcHBseSA9IG51bGw7XG59XG5cbnZhciBjb25zdHJ1Y3RvclJlZ2V4ID0gL15cXHMqY2xhc3NcXGIvO1xudmFyIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGdW5jdGlvbih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdHZhciBmblN0ciA9IGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChmblN0cik7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7IC8vIG5vdCBhIGZ1bmN0aW9uXG5cdH1cbn07XG5cbnZhciB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uVG9TdHIodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RBcHBseVxuXHQ/IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmICF2YWx1ZS5wcm90b3R5cGUpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR0cnkge1xuXHRcdFx0cmVmbGVjdEFwcGx5KHZhbHVlLCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmIChlICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gIWlzRVM2Q2xhc3NGbih2YWx1ZSk7XG5cdH1cblx0OiBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdmFsdWUucHJvdG90eXBlKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKGhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7IH1cblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gc3RyQ2xhc3MgPT09IGZuQ2xhc3MgfHwgc3RyQ2xhc3MgPT09IGdlbkNsYXNzO1xuXHR9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5TWV0aG9kQm94ZXNQcm9wZXJseSA9IHJlcXVpcmUoJ2VzLWFycmF5LW1ldGhvZC1ib3hlcy1wcm9wZXJseScpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHZhciBtZXRob2QgPSBBcnJheS5wcm90b3R5cGUubWFwO1xuXHRyZXR1cm4gYXJyYXlNZXRob2RCb3hlc1Byb3Blcmx5KG1ldGhvZCkgPyBtZXRob2QgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlUHJvbWlzZSA9IHJlcXVpcmUoJy4vcmVxdWlyZVByb21pc2UnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXF1aXJlUHJvbWlzZSgpO1xuXHRyZXR1cm4gdHlwZW9mIFByb21pc2UuYWxsU2V0dGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IFByb21pc2UuYWxsU2V0dGxlZCA6IGltcGxlbWVudGF0aW9uO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQ3VzdG9tRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0N1c3RvbUVycm9yXCIpO1xudmFyIFJldHJ5QWZ0ZXJFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZXRyeUFmdGVyRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmV0cnlBZnRlckVycm9yKGFmdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiTmVlZCB0byByZXRyeSBhZnRlciBcIiArIGFmdGVyICsgXCIgbXNcIikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3JldHJ5QXQgPSBEYXRlLm5vdygpICsgYWZ0ZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJldHJ5QWZ0ZXJFcnJvci5wcm90b3R5cGUsIFwicmV0cnlBdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHJ5QXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBSZXRyeUFmdGVyRXJyb3I7XG59KEN1c3RvbUVycm9yXzEuQ3VzdG9tRXJyb3IpKTtcbmV4cG9ydHMuUmV0cnlBZnRlckVycm9yID0gUmV0cnlBZnRlckVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmV0cnlBZnRlckVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgVXNlcl8xID0gcmVxdWlyZShcIi4uL1VzZXIvVXNlclwiKTtcbi8qKlxuICogQSByZWxhdGlvbiBvZiBhIHVzZXIgZm9sbG93aW5nIGEgcHJldmlvdXNseSBnaXZlbiBjaGFubmVsLlxuICovXG52YXIgQ2hhbm5lbEZvbGxvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBDaGFubmVsRm9sbG93KF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsRm9sbG93LnByb3RvdHlwZSwgXCJ1c2VyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1c2VyIGZvbGxvd2luZyB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVc2VyXzEuZGVmYXVsdCh0aGlzLl9kYXRhLnVzZXIsIHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsRm9sbG93LnByb3RvdHlwZSwgXCJoYXNOb3RpZmljYXRpb25zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgaGFzIG5vdGlmaWNhdGlvbnMgZW5hYmxlZCBmb3IgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLm5vdGlmaWNhdGlvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsRm9sbG93LnByb3RvdHlwZSwgXCJmb2xsb3dEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIHdoZW4gdGhlIHVzZXIgZm9sbG93ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmNyZWF0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgQ2hhbm5lbEZvbGxvdy5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBDaGFubmVsRm9sbG93O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYW5uZWxGb2xsb3c7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDaGFubmVsRm9sbG93O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbEZvbGxvdztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vU3Vic2NyaXB0aW9uXCIpO1xudmFyIFVzZXJfMSA9IHJlcXVpcmUoXCIuLi9Vc2VyL1VzZXJcIik7XG4vKipcbiAqIEEgcmVsYXRpb24gb2YgYSB1c2VyIHN1YnNjcmliaW5nIHRvIGEgcHJldmlvdXNseSBnaXZlbiBjaGFubmVsLlxuICovXG52YXIgQ2hhbm5lbFN1YnNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDaGFubmVsU3Vic2NyaXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoYW5uZWxTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWxTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcInVzZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgc3Vic2NyaWJpbmcgdG8gdGhlIGdpdmVuIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXNlcl8xLmRlZmF1bHQodGhpcy5fZGF0YS51c2VyLCB0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQ2hhbm5lbFN1YnNjcmlwdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbFN1YnNjcmlwdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENoYW5uZWxTdWJzY3JpcHRpb247XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFubmVsU3Vic2NyaXB0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBDaGFubmVsXzEgPSByZXF1aXJlKFwiLi9DaGFubmVsXCIpO1xuLyoqXG4gKiBBIGNoYW5uZWwgeW91IGhhdmUgZXh0ZW5kZWQgcHJpdmlsZWdlcyBmb3IsIGkuZS4gdGhlIGNoYW5uZWwgb2YgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gKi9cbnZhciBQcml2aWxlZ2VkQ2hhbm5lbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQcml2aWxlZ2VkQ2hhbm5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcml2aWxlZ2VkQ2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpdmlsZWdlZENoYW5uZWwucHJvdG90eXBlLCBcInN0cmVhbUtleVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2hhbm5lbCdzIHN0cmVhbSBrZXkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnN0cmVhbV9rZXk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcml2aWxlZ2VkQ2hhbm5lbC5wcm90b3R5cGUsIFwiZW1haWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNoYW5uZWwncyBlbWFpbCBhZGRyZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5lbWFpbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIGVkaXRvcnMgb2YgdGhlIGNoYW5uZWwuXG4gICAgICovXG4gICAgUHJpdmlsZWdlZENoYW5uZWwucHJvdG90eXBlLmdldEVkaXRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4uY2hhbm5lbHMuZ2V0Q2hhbm5lbEVkaXRvcnModGhpcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgY29tbWVyY2lhbCBpbiB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgY29tbWVyY2lhbC5cbiAgICAgKi9cbiAgICBQcml2aWxlZ2VkQ2hhbm5lbC5wcm90b3R5cGUuc3RhcnRDb21tZXJjaWFsID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLmNoYW5uZWxzLnN0YXJ0Q2hhbm5lbENvbW1lcmNpYWwodGhpcywgbGVuZ3RoKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGdpdmVuIGNoYW5uZWwncyBzdHJlYW0ga2V5LlxuICAgICAqL1xuICAgIFByaXZpbGVnZWRDaGFubmVsLnByb3RvdHlwZS5yZXNldFN0cmVhbUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbERhdGEsIHN0cmVhbUtleTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQua3Jha2VuLmNoYW5uZWxzLnJlc2V0Q2hhbm5lbFN0cmVhbUtleSh0aGlzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxEYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtS2V5ID0gY2hhbm5lbERhdGEuc3RyZWFtX2tleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEuc3RyZWFtX2tleSA9IHN0cmVhbUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBzdHJlYW1LZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQcml2aWxlZ2VkQ2hhbm5lbDtcbn0oQ2hhbm5lbF8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByaXZpbGVnZWRDaGFubmVsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gUHJpdmlsZWdlZENoYW5uZWw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQcml2aWxlZ2VkQ2hhbm5lbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbi8qKlxuICogQSBsaXN0IG9mIGVtb3RlcywgZ3JvdXBlZCBpbnRvIGVtb3RlIHNldHMsIHRoYXQgYSB1c2VyIGNhbiB1c2UuXG4gKi9cbnZhciBFbW90ZVNldExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gRW1vdGVTZXRMaXN0KF9kYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVtb3RlIElEIGZvciB0aGUgZ2l2ZW4gZW1vdGUgY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbW90ZUNvZGUgVGhlIGVtb3RlIGNvZGUgdG8gY2hlY2sgZm9yLlxuICAgICAqL1xuICAgIEVtb3RlU2V0TGlzdC5wcm90b3R5cGUuZmluZEVtb3RlSWQgPSBmdW5jdGlvbiAoZW1vdGVDb2RlKSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSB0c2xpYl8xLl9fdmFsdWVzKE9iamVjdC52YWx1ZXModGhpcy5fZGF0YSkpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVtb3RlU2V0ID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZW1vdGVTZXRfMSA9IChlXzIgPSB2b2lkIDAsIHRzbGliXzEuX192YWx1ZXMoZW1vdGVTZXQpKSwgZW1vdGVTZXRfMV8xID0gZW1vdGVTZXRfMS5uZXh0KCk7ICFlbW90ZVNldF8xXzEuZG9uZTsgZW1vdGVTZXRfMV8xID0gZW1vdGVTZXRfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbW90ZSA9IGVtb3RlU2V0XzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXcgUmVnRXhwKGVtb3RlLmNvZGUpLnRlc3QoZW1vdGVDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbW90ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtb3RlU2V0XzFfMSAmJiAhZW1vdGVTZXRfMV8xLmRvbmUgJiYgKF9iID0gZW1vdGVTZXRfMS5yZXR1cm4pKSBfYi5jYWxsKGVtb3RlU2V0XzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZChJbmZpbml0eSwgdHJ1ZSlcbiAgICBdLCBFbW90ZVNldExpc3QucHJvdG90eXBlLCBcImZpbmRFbW90ZUlkXCIsIG51bGwpO1xuICAgIEVtb3RlU2V0TGlzdCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBFbW90ZVNldExpc3QpO1xuICAgIHJldHVybiBFbW90ZVNldExpc3Q7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRW1vdGVTZXRMaXN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gRW1vdGVTZXRMaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gRW1vdGVTZXRMaXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBVc2VyXzEgPSByZXF1aXJlKFwiLi9Vc2VyXCIpO1xuLyoqXG4gKiBBIHVzZXIgeW91IGhhdmUgZXh0ZW5kZWQgcHJpdmlsZWdlcyBmb3IsIGkuZS4gdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gKlxuICogQGluaGVyaXREb2NcbiAqL1xudmFyIFByaXZpbGVnZWRVc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFByaXZpbGVnZWRVc2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByaXZpbGVnZWRVc2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcml2aWxlZ2VkVXNlci5wcm90b3R5cGUsIFwiZW1haWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5lbWFpbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXZpbGVnZWRVc2VyLnByb3RvdHlwZSwgXCJpc0VtYWlsVmVyaWZpZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MgaXMgdmVyaWZpZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmVtYWlsX3ZlcmlmaWVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpdmlsZWdlZFVzZXIucHJvdG90eXBlLCBcImhhc0VtYWlsTm90aWZpY2F0aW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIGhhcyBlbWFpbCBub3RpZmljYXRpb25zIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLm5vdGlmaWNhdGlvbnMuZW1haWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcml2aWxlZ2VkVXNlci5wcm90b3R5cGUsIFwiaGFzUHVzaE5vdGlmaWNhdGlvbnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdXNlciBoYXMgcHVzaCBub3RpZmljYXRpb25zIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLm5vdGlmaWNhdGlvbnMucHVzaDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXZpbGVnZWRVc2VyLnByb3RvdHlwZSwgXCJpc1BhcnRuZXJlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIGlzIHBhcnRuZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEucGFydG5lcmVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpdmlsZWdlZFVzZXIucHJvdG90eXBlLCBcImhhc1R3aXR0ZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdXNlciBoYXMgYSBUd2l0dGVyIGFjY291bnQgY29ubmVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50d2l0dGVyX2Nvbm5lY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRm9sbG93cyBhIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byBmb2xsb3cuXG4gICAgICogQHBhcmFtIG5vdGlmaWNhdGlvbnMgV2hldGhlciB0aGUgdXNlciB3aWxsIHJlY2VpdmUgbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBQcml2aWxlZ2VkVXNlci5wcm90b3R5cGUuZm9sbG93Q2hhbm5lbCA9IGZ1bmN0aW9uIChjaGFubmVsLCBub3RpZmljYXRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuZm9sbG93Q2hhbm5lbCh0aGlzLCBjaGFubmVsLCBub3RpZmljYXRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmZvbGxvd3MgYSBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gdW5mb2xsb3cuXG4gICAgICovXG4gICAgUHJpdmlsZWdlZFVzZXIucHJvdG90eXBlLnVuZm9sbG93Q2hhbm5lbCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMudW5mb2xsb3dDaGFubmVsKHRoaXMsIGNoYW5uZWwpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlclRvQmxvY2sgVGhlIHVzZXIgdG8gYmxvY2suXG4gICAgICovXG4gICAgUHJpdmlsZWdlZFVzZXIucHJvdG90eXBlLmJsb2NrVXNlciA9IGZ1bmN0aW9uICh1c2VyVG9CbG9jaykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLmJsb2NrVXNlcih0aGlzLCB1c2VyVG9CbG9jayldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5ibG9ja3MgYSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJUb1VuYmxvY2sgVGhlIHVzZXIgdG8gdW5ibG9jay5cbiAgICAgKi9cbiAgICBQcml2aWxlZ2VkVXNlci5wcm90b3R5cGUudW5ibG9ja1VzZXIgPSBmdW5jdGlvbiAodXNlclRvVW5ibG9jaykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLnVuYmxvY2tVc2VyKHRoaXMsIHVzZXJUb1VuYmxvY2spXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQcml2aWxlZ2VkVXNlcjtcbn0oVXNlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByaXZpbGVnZWRVc2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gUHJpdmlsZWdlZFVzZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQcml2aWxlZ2VkVXNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgVXNlcl8xID0gcmVxdWlyZShcIi4vVXNlclwiKTtcbi8qKlxuICogQSByZWxhdGlvbiBvZiBhIHByZXZpb3VzbHkgZ2l2biB1c2VyIGJsb2NraW5nIGFub3RoZXIgdXNlci5cbiAqL1xudmFyIFVzZXJCbG9jayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBVc2VyQmxvY2soX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJCbG9jay5wcm90b3R5cGUsIFwiYmxvY2tlZFVzZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJsb2NrZWQgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVc2VyXzEuZGVmYXVsdCh0aGlzLl9kYXRhLnVzZXIsIHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBVc2VyQmxvY2sucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gVXNlckJsb2NrO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVzZXJCbG9jaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFVzZXJCbG9jaztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVzZXJCbG9jaztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgQ2hhbm5lbF8xID0gcmVxdWlyZShcIi4uL0NoYW5uZWwvQ2hhbm5lbFwiKTtcbi8qKlxuICogQSByZWxhdGlvbiBvZiBhIHByZXZpb3VzbHkgZ2l2ZW4gdXNlciBmb2xsb3dpbmcgYSBjaGFubmVsLlxuICovXG52YXIgVXNlckZvbGxvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBVc2VyRm9sbG93KF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyRm9sbG93LnByb3RvdHlwZSwgXCJmb2xsb3dEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIHdoZW4gdGhlIHVzZXIgZm9sbG93ZWQgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmNyZWF0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckZvbGxvdy5wcm90b3R5cGUsIFwiaGFzTm90aWZpY2F0aW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIGhhcyBub3RpZmljYXRpb25zIGVuYWJsZWQgZm9yIHRoZSBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5ub3RpZmljYXRpb25zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckZvbGxvdy5wcm90b3R5cGUsIFwiY2hhbm5lbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9sbG93ZWQgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFubmVsXzEuZGVmYXVsdCh0aGlzLl9kYXRhLmNoYW5uZWwsIHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBVc2VyRm9sbG93LnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFVzZXJGb2xsb3c7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVXNlckZvbGxvdztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFVzZXJGb2xsb3c7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVc2VyRm9sbG93O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9TdWJzY3JpcHRpb25cIik7XG52YXIgQ2hhbm5lbF8xID0gcmVxdWlyZShcIi4uL0NoYW5uZWwvQ2hhbm5lbFwiKTtcbi8qKlxuICogQSByZWxhdGlvbiBvZiBhIHByZXZpb3VzbHkgZ2l2ZW4gdXNlciBzdWJzY3JpYmluZyB0byBhIGNoYW5uZWwuXG4gKi9cbnZhciBVc2VyU3Vic2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFVzZXJTdWJzY3JpcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVXNlclN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlclN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwiY2hhbm5lbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3Vic2NyaWJlZCBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYW5uZWxfMS5kZWZhdWx0KHRoaXMuX2RhdGEuY2hhbm5lbCwgdGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFVzZXJTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVzZXJTdWJzY3JpcHRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBVc2VyU3Vic2NyaXB0aW9uO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gVXNlclN1YnNjcmlwdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCBhbiBhY2Nlc3MgdG9rZW4uXG4gKi9cbnZhciBUb2tlbkluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gVG9rZW5JbmZvKF9kYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fb2J0YWlubWVudERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9rZW5JbmZvLnByb3RvdHlwZSwgXCJjbGllbnRJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IElELlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5jbGllbnRfaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb2tlbkluZm8ucHJvdG90eXBlLCBcInVzZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIGF1dGhlbnRpY2F0ZWQgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRva2VuSW5mby5wcm90b3R5cGUsIFwidXNlck5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgbmFtZSBvZiB0aGUgYXV0aGVudGljYXRlZCB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sb2dpbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRva2VuSW5mby5wcm90b3R5cGUsIFwic2NvcGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY29wZXMgZm9yIHdoaWNoIHRoaXMgdG9rZW4gaXMgdmFsaWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnNjb3BlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRva2VuSW5mby5wcm90b3R5cGUsIFwiZXhwaXJ5RGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSB3aGVuIHRoZSB0b2tlbiB3aWxsIGV4cGlyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhpcyByZXR1cm5zIG51bGwsIGl0IG1lYW5zIHRoYXQgdGhlIHRva2VuIGlzIGVpdGhlciBpbnZhbGlkIG9yIG5ldmVyIGV4cGlyZXMgKGhhcHBlbnMgd2l0aCBvbGQgY2xpZW50IElEcykuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGF0YS5leHBpcmVzX2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fb2J0YWlubWVudERhdGUuZ2V0VGltZSgpICsgdGhpcy5fZGF0YS5leHBpcmVzX2luICogMTAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUb2tlbkluZm87XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5JbmZvO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVG9rZW5JbmZvO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5JbmZvO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogQSBsaXN0IG9mIGNoYXR0ZXJzIGluIGEgVHdpdGNoIGNoYXQuXG4gKi9cbnZhciBDaGF0dGVyc0xpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gQ2hhdHRlcnNMaXN0KF9kYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXR0ZXJzTGlzdC5wcm90b3R5cGUsIFwiYWxsQ2hhdHRlcnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHVzZXIgbmFtZXMgb2YgYWxsIGNoYXR0ZXJzIGluIHRoZSBjaGF0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhcmVkX3V0aWxzXzEuZmxhdHRlbihPYmplY3QudmFsdWVzKHRoaXMuX2RhdGEuY2hhdHRlcnMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXR0ZXJzTGlzdC5wcm90b3R5cGUsIFwiYWxsQ2hhdHRlcnNXaXRoU3RhdHVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHVzZXIgbmFtZXMgb2YgYWxsIGNoYXR0ZXJzIGluIHRoZSBjaGF0LCBtYXBwZWQgdG8gdGhlaXIgc3RhdHVzIGluIHRoZSBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcChzaGFyZWRfdXRpbHNfMS5mbGF0dGVuKE9iamVjdC5lbnRyaWVzKHRoaXMuX2RhdGEuY2hhdHRlcnMpLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChfYSwgMiksIHN0YXR1cyA9IF9iWzBdLCBuYW1lcyA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtuYW1lLCBzdGF0dXNdOyB9KTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDaGF0dGVyc0xpc3Q7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdHRlcnNMaXN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ2hhdHRlcnNMaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdHRlcnNMaXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi9Ud2l0Y2hDbGllbnRcIik7XG4vKipcbiAqIEVuaGFuY2VzIGFub3RoZXIgYXV0aCBwcm92aWRlciB3aXRoIHRoZSBhYmlsaXR5IHRvIG1ha2UgdXNlIG9mIHJlZnJlc2hcbiAqIHRva2VucywgYXV0b21hdGljYWxseSByZWZyZXNoaW5nIHRoZSBhY2Nlc3MgdG9rZW4gd2hlbmV2ZXIgbmVjZXNzYXJ5LlxuICovXG52YXIgUmVmcmVzaGFibGVBdXRoUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhdXRoIHByb3ZpZGVyIGJhc2VkIG9uIHRoZSBnaXZlbiBvbmUgdGhhdCBjYW4gYXV0b21hdGljYWxseVxuICAgICAqIHJlZnJlc2ggYWNjZXNzIHRva2Vucy5cbiAgICAgKlxuICAgICAqIFlvdSBkb24ndCB1c3VhbGx5IGhhdmUgdG8gY3JlYXRlIHRoaXMgbWFudWFsbHkuIFlvdSBzaG91bGQgdXNlIGBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzYFxuICAgICAqIHdpdGggdGhlIGByZWZyZXNoQ29uZmlnYCBwYXJhbWV0ZXIgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGlsZFByb3ZpZGVyIFRoZSBiYXNlIGF1dGggcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIHJlZnJlc2hDb25maWcgVGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggYW4gYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyKGNoaWxkUHJvdmlkZXIsIHJlZnJlc2hDb25maWcpIHtcbiAgICAgICAgdGhpcy5fY2xpZW50U2VjcmV0ID0gcmVmcmVzaENvbmZpZy5jbGllbnRTZWNyZXQ7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hUb2tlbiA9IHJlZnJlc2hDb25maWcucmVmcmVzaFRva2VuO1xuICAgICAgICB0aGlzLl9jaGlsZFByb3ZpZGVyID0gY2hpbGRQcm92aWRlcjtcbiAgICAgICAgdGhpcy5faW5pdGlhbEV4cGlyeSA9IHJlZnJlc2hDb25maWcuZXhwaXJ5O1xuICAgICAgICB0aGlzLl9vblJlZnJlc2ggPSByZWZyZXNoQ29uZmlnLm9uUmVmcmVzaDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyLnByb3RvdHlwZSwgXCJ0b2tlblR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdG9rZW5zIHRoaXMgcHJvdmlkZXIgZ2VuZXJhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCBpcyB0aGUgc2FtZSBhcyB0aGUgdW5kZXJseWluZyBiYXNlIGF1dGggcHJvdmlkZXIncyB0b2tlbiB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRQcm92aWRlci50b2tlblR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhY2Nlc3MgdG9rZW4uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgY3VycmVudCBhY2Nlc3MgdG9rZW4gZG9lcyBub3QgaGF2ZSB0aGUgcmVxdWVzdGVkIHNjb3BlcywgdGhlIGJhc2UgYXV0aFxuICAgICAqIHByb3ZpZGVyIGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjdXJyZW50IGFjY2VzcyB0b2tlbiBpcyBleHBpcmVkLCBhdXRvbWF0aWNhbGx5IHJlbmV3IGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjb3BlcyBUaGUgcmVxdWVzdGVkIHNjb3Blcy5cbiAgICAgKi9cbiAgICBSZWZyZXNoYWJsZUF1dGhQcm92aWRlci5wcm90b3R5cGUuZ2V0QWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAoc2NvcGVzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9sZFRva2VuLCBuZXdUb2tlbiwgbm93LCByZWZyZXNoZWRUb2tlbjtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NvcGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlcyA9IHNjb3Blcy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2hpbGRQcm92aWRlci5nZXRBY2Nlc3NUb2tlbigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVG9rZW4gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShvbGRUb2tlbiAmJiBzY29wZXMgJiYgc2NvcGVzLnNvbWUoZnVuY3Rpb24gKHNjb3BlKSB7IHJldHVybiAhX3RoaXMuY3VycmVudFNjb3Blcy5pbmNsdWRlcyhzY29wZSk7IH0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jaGlsZFByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKHNjb3BlcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUb2tlbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmJ1dCBpZiB0aGUgdG9rZW4gZG9lc24ndCBjaGFuZ2UsIGNhcnJ5IG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VG9rZW4gIT09IG9sZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ld1Rva2VuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhIGN1cnJlbnQgdG9rZW4sIHdlIGp1c3QgcGFzcyB0aGlzIGFuZCByZWZyZXNoIHJpZ2h0IGF3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbml0aWFsRXhwaXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3cgPCB0aGlzLl9pbml0aWFsRXhwaXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgb2xkVG9rZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFvbGRUb2tlbi5pc0V4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG9sZFRva2VuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlZnJlc2goKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hlZFRva2VuID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlZnJlc2hlZFRva2VuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgYWdhaW4gZm9yIHNjb3BlcyBhZnRlciByZWZyZXNoaW5nLCBpbiBjYXNlIGEgcmVmcmVzaCB0b2tlbiB3YXMgcGFzc2VkIHdpdGhvdXQgYW4gYWNjZXNzIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2hpbGRQcm92aWRlci5nZXRBY2Nlc3NUb2tlbihzY29wZXMpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JjZSBhIHJlZnJlc2ggb2YgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBSZWZyZXNoYWJsZUF1dGhQcm92aWRlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5EYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIFR3aXRjaENsaWVudF8xLmRlZmF1bHQucmVmcmVzaEFjY2Vzc1Rva2VuKHRoaXMuY2xpZW50SWQsIHRoaXMuX2NsaWVudFNlY3JldCwgdGhpcy5fcmVmcmVzaFRva2VuKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuRGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QWNjZXNzVG9rZW4odG9rZW5EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hUb2tlbiA9IHRva2VuRGF0YS5yZWZyZXNoVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsRXhwaXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVmcmVzaCh0b2tlbkRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRva2VuRGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgUmVmcmVzaGFibGVBdXRoUHJvdmlkZXIucHJvdG90eXBlLnNldEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkUHJvdmlkZXIuc2V0QWNjZXNzVG9rZW4odG9rZW4pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyLnByb3RvdHlwZSwgXCJjbGllbnRJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IElELlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRQcm92aWRlci5jbGllbnRJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyLnByb3RvdHlwZSwgXCJjdXJyZW50U2NvcGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY29wZXMgdGhhdCBhcmUgY3VycmVudGx5IGF2YWlsYWJsZSB1c2luZyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRQcm92aWRlci5jdXJyZW50U2NvcGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgUmVmcmVzaGFibGVBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcIl9jbGllbnRTZWNyZXRcIiwgdm9pZCAwKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgUmVmcmVzaGFibGVBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcIl9yZWZyZXNoVG9rZW5cIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gUmVmcmVzaGFibGVBdXRoUHJvdmlkZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVmcmVzaGFibGVBdXRoUHJvdmlkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBSZWZyZXNoYWJsZUF1dGhQcm92aWRlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBBY2Nlc3NUb2tlbl8xID0gcmVxdWlyZShcIi4uL0FQSS9BY2Nlc3NUb2tlblwiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi9Ud2l0Y2hDbGllbnRcIik7XG4vKipcbiAqIEFuIGF1dGggcHJvdmlkZXIgdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBpbml0aWFsbHkgZ2l2ZW4gY3JlZGVudGlhbHMuXG4gKlxuICogWW91IGFyZSBhZHZpc2VkIHRvIHJvbGwgeW91ciBvd24gYXV0aCBwcm92aWRlciB0aGF0IGNhbiBoYW5kbGUgc2NvcGUgdXBncmFkZXMsXG4gKiBvciB0byBwbGFuIGFoZWFkIGFuZCBzdXBwbHkgb25seSBhY2Nlc3MgdG9rZW5zIHRoYXQgYWNjb3VudCBmb3IgYWxsIHNjb3Blc1xuICogeW91IHdpbGwgZXZlciBuZWVkLlxuICovXG52YXIgU3RhdGljQXV0aFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXV0aCBwcm92aWRlciB3aXRoIHN0YXRpYyBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIFlvdSBkb24ndCB1c3VhbGx5IGhhdmUgdG8gY3JlYXRlIHRoaXMgbWFudWFsbHkuIFlvdSBzaG91bGQgdXNlIGBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudElkIFRoZSBjbGllbnQgSUQuXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIFRoZSBhY2Nlc3MgdG9rZW4gdG8gcHJvdmlkZS5cbiAgICAgKlxuICAgICAqIFlvdSBuZWVkIHRvIG9idGFpbiBvbmUgdXNpbmcgb25lIG9mIHRoZSBbVHdpdGNoIE9BdXRoIGZsb3dzXShodHRwczovL2Rldi50d2l0Y2gudHYvZG9jcy9hdXRoZW50aWNhdGlvbi9nZXR0aW5nLXRva2Vucy1vYXV0aC8pLlxuICAgICAqIEBwYXJhbSBzY29wZXMgVGhlIHNjb3BlcyB0aGlzIHRva2VuIGhhcy5cbiAgICAgKiBAcGFyYW0gdG9rZW5UeXBlIFRoZSB0eXBlIG9mIHRoZSBzdXBwbGllZCB0b2tlbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0aWNBdXRoUHJvdmlkZXIoY2xpZW50SWQsIGFjY2Vzc1Rva2VuLCBzY29wZXMsIHRva2VuVHlwZSkge1xuICAgICAgICBpZiAodG9rZW5UeXBlID09PSB2b2lkIDApIHsgdG9rZW5UeXBlID0gJ3VzZXInOyB9XG4gICAgICAgIHRoaXMuX2NsaWVudElkID0gY2xpZW50SWQgfHwgJyc7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2Vzc1Rva2VuID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgYWNjZXNzVG9rZW4gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEFjY2Vzc1Rva2VuXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHNjb3BlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46ICcnXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDogYWNjZXNzVG9rZW47XG4gICAgICAgICAgICB0aGlzLl9zY29wZXMgPSBzY29wZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFjY2VzcyB0b2tlbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjdXJyZW50IGFjY2VzcyB0b2tlbiBkb2VzIG5vdCBoYXZlIHRoZSByZXF1ZXN0ZWQgc2NvcGVzLCB0aGlzIG1ldGhvZCB0aHJvd3MuXG4gICAgICogVGhpcyBtYWtlcyBzdXBwbHlpbmcgYW4gYWNjZXNzIHRva2VuIHdpdGggdGhlIGNvcnJlY3Qgc2NvcGVzIGZyb20gdGhlIGJlZ2lubmluZyBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NvcGVzIFRoZSByZXF1ZXN0ZWQgc2NvcGVzLlxuICAgICAqL1xuICAgIFN0YXRpY0F1dGhQcm92aWRlci5wcm90b3R5cGUuZ2V0QWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAoc2NvcGVzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRva2VuSW5mbztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHNjb3BlcyAmJiBzY29wZXMubGVuZ3RoID4gMCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhdGhpcy5fc2NvcGVzKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGggcHJvdmlkZXIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiB5ZXQgYW5kIGlzIHJlcXVlc3Rpbmcgc2NvcGVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBUd2l0Y2hDbGllbnRfMS5kZWZhdWx0LmdldFRva2VuSW5mbyh0aGlzLl9hY2Nlc3NUb2tlbi5hY2Nlc3NUb2tlbiwgdGhpcy5fY2xpZW50SWQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5JbmZvID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NvcGVzID0gdG9rZW5JbmZvLnNjb3BlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY29wZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVzID0gc2NvcGVzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGVzLnNvbWUoZnVuY3Rpb24gKHNjb3BlKSB7IHJldHVybiAhX3RoaXMuX3Njb3Blcy5pbmNsdWRlcyhzY29wZSk7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyB0b2tlbiBkb2VzIG5vdCBoYXZlIHRoZSByZXF1ZXN0ZWQgc2NvcGVzIChcIiArIHNjb3Blcy5qb2luKCcsICcpICsgXCIpIGFuZCBjYW4gbm90IGJlIHVwZ3JhZGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9hY2Nlc3NUb2tlbiB8fCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBTdGF0aWNBdXRoUHJvdmlkZXIucHJvdG90eXBlLnNldEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHRoaXMuX2FjY2Vzc1Rva2VuID0gdG9rZW47XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGljQXV0aFByb3ZpZGVyLnByb3RvdHlwZSwgXCJjbGllbnRJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IElELlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50SWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0aWNBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcImN1cnJlbnRTY29wZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjb3BlcyB0aGF0IGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlIHVzaW5nIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY29wZXMgfHwgW107XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBTdGF0aWNBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcIl9jbGllbnRJZFwiLCB2b2lkIDApO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBTdGF0aWNBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcIl9hY2Nlc3NUb2tlblwiLCB2b2lkIDApO1xuICAgIHJldHVybiBTdGF0aWNBdXRoUHJvdmlkZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RhdGljQXV0aFByb3ZpZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU3RhdGljQXV0aFByb3ZpZGVyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RhdGljQXV0aFByb3ZpZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBDdXN0b21FcnJvcl8xID0gcmVxdWlyZShcIi4vQ3VzdG9tRXJyb3JcIik7XG4vKipcbiAqIFRocm93biB3aGVuZXZlciB5b3UgdHJ5IHVzaW5nIGludmFsaWQgdmFsdWVzIGluIHRoZSBjbGllbnQgY29uZmlndXJhdGlvbi5cbiAqL1xudmFyIENvbmZpZ0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENvbmZpZ0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmZpZ0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb25maWdFcnJvcjtcbn0oQ3VzdG9tRXJyb3JfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb25maWdFcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENvbmZpZ0Vycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZmlnRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEN1c3RvbUVycm9yXzEgPSByZXF1aXJlKFwiLi9DdXN0b21FcnJvclwiKTtcbi8qKlxuICogVGhyb3duIHdoZW5ldmVyIGFuIGludmFsaWQgdG9rZW4gaXMgc3VwcGxpZWQuXG4gKi9cbnZhciBJbnZhbGlkVG9rZW5FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnZhbGlkVG9rZW5FcnJvciwgX3N1cGVyKTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBJbnZhbGlkVG9rZW5FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdJbnZhbGlkIHRva2VuIHN1cHBsaWVkJykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEludmFsaWRUb2tlbkVycm9yO1xufShDdXN0b21FcnJvcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEludmFsaWRUb2tlbkVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSW52YWxpZFRva2VuRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbnZhbGlkVG9rZW5FcnJvcjtcbiIsInZhciBfX3NlbGZfXyA9IChmdW5jdGlvbiAocm9vdCkge1xuZnVuY3Rpb24gRigpIHtcbnRoaXMuZmV0Y2ggPSBmYWxzZTtcbnRoaXMuRE9NRXhjZXB0aW9uID0gcm9vdC5ET01FeGNlcHRpb25cbn1cbkYucHJvdG90eXBlID0gcm9vdDtcbnJldHVybiBuZXcgRigpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuKGZ1bmN0aW9uKHNlbGYpIHtcblxudmFyIGlycmVsZXZhbnQgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snO1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KHt9KSk7XG59KShfX3NlbGZfXyk7XG5kZWxldGUgX19zZWxmX18uZmV0Y2gucG9seWZpbGxcbmV4cG9ydHMgPSBfX3NlbGZfXy5mZXRjaCAvLyBUbyBlbmFibGU6IGltcG9ydCBmZXRjaCBmcm9tICdjcm9zcy1mZXRjaCdcbmV4cG9ydHMuZGVmYXVsdCA9IF9fc2VsZl9fLmZldGNoIC8vIEZvciBUeXBlU2NyaXB0IGNvbnN1bWVycyB3aXRob3V0IGVzTW9kdWxlSW50ZXJvcC5cbmV4cG9ydHMuZmV0Y2ggPSBfX3NlbGZfXy5mZXRjaCAvLyBUbyBlbmFibGU6IGltcG9ydCB7ZmV0Y2h9IGZyb20gJ2Nyb3NzLWZldGNoJ1xuZXhwb3J0cy5IZWFkZXJzID0gX19zZWxmX18uSGVhZGVyc1xuZXhwb3J0cy5SZXF1ZXN0ID0gX19zZWxmX18uUmVxdWVzdFxuZXhwb3J0cy5SZXNwb25zZSA9IF9fc2VsZl9fLlJlc3BvbnNlXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogZXNsaW50LWRpc2FibGUgZmlsZW5hbWVzL21hdGNoLWV4cG9ydGVkICovXG52YXIgaXNOb2RlID0gcmVxdWlyZShcImRldGVjdC1ub2RlXCIpO1xudmFyIE5vZGVMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL05vZGVMb2dnZXJcIik7XG52YXIgQnJvd3NlckxvZ2dlcl8xID0gcmVxdWlyZShcIi4vQnJvd3NlckxvZ2dlclwiKTtcbnZhciBMb2dnZXIgPSBpc05vZGUgPyBOb2RlTG9nZ2VyXzEuZGVmYXVsdCA6IEJyb3dzZXJMb2dnZXJfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0gTG9nZ2VyO1xudmFyIExvZ0xldmVsXzEgPSByZXF1aXJlKFwiLi9Mb2dMZXZlbFwiKTtcbnZhciBfX2V4cG9ydF9Mb2dMZXZlbCA9IExvZ0xldmVsXzEuZGVmYXVsdDtcbmV4cG9ydHMuTG9nTGV2ZWwgPSBfX2V4cG9ydF9Mb2dMZXZlbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IExvZ2dlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IExvZ2dlcjtcbmV4cG9ydHMuTG9nTGV2ZWwgPSBfX2V4cG9ydF9Mb2dMZXZlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9hLCBfYiwgX2M7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBMb2dMZXZlbF8xID0gcmVxdWlyZShcIi4vTG9nTGV2ZWxcIik7XG52YXIgQmFzZUxvZ2dlcl8xID0gcmVxdWlyZShcIi4vQmFzZUxvZ2dlclwiKTtcbnZhciBfX2V4cG9ydF9Mb2dMZXZlbFRvRW1vamkgPSAoX2EgPSB7fSxcbiAgICBfYVtMb2dMZXZlbF8xLmRlZmF1bHQuQ1JJVElDQUxdID0gXCJcXHVEODNEXFx1REVEMVwiLFxuICAgIF9hW0xvZ0xldmVsXzEuZGVmYXVsdC5FUlJPUl0gPSBcIlxcdTI3NENcIixcbiAgICAvLyB0aGVzZSBmb2xsb3dpbmcgdHdvIG5lZWQgZXh0cmEgc3BhY2VzIGF0IHRoZSBlbmQgYmVjYXVzZSBzb21laG93IHRoZXkgY29uc3VtZSBsZXNzIHNwYWNlIGluIGEgdGVybWluYWwgdGhhbiB0aGV5IHNob3VsZC4uLlxuICAgIF9hW0xvZ0xldmVsXzEuZGVmYXVsdC5XQVJOSU5HXSA9IFwiXFx1MjZBMFxcdUZFMEYgXCIsXG4gICAgX2FbTG9nTGV2ZWxfMS5kZWZhdWx0LklORk9dID0gXCJcXHUyMTM5XFx1RkUwRiBcIixcbiAgICBfYVtMb2dMZXZlbF8xLmRlZmF1bHQuREVCVUddID0gXCJcXHVEODNEXFx1REMxRVwiLFxuICAgIF9hW0xvZ0xldmVsXzEuZGVmYXVsdC5UUkFDRV0gPSBcIlxcdUQ4M0RcXHVEQzNFXCIsXG4gICAgX2EpO1xuZXhwb3J0cy5Mb2dMZXZlbFRvRW1vamkgPSBfX2V4cG9ydF9Mb2dMZXZlbFRvRW1vamk7XG52YXIgY29sb3JzID0ge1xuICAgIGJsYWNrOiAzMCxcbiAgICByZWQ6IDMxLFxuICAgIGdyZWVuOiAzMixcbiAgICB5ZWxsb3c6IDMzLFxuICAgIGJsdWU6IDM0LFxuICAgIG1hZ2VudGE6IDM1LFxuICAgIGN5YW46IDM2LFxuICAgIHdoaXRlOiAzNyxcbiAgICBibGFja0JyaWdodDogOTAsXG4gICAgcmVkQnJpZ2h0OiA5MSxcbiAgICBncmVlbkJyaWdodDogOTIsXG4gICAgeWVsbG93QnJpZ2h0OiA5MyxcbiAgICBibHVlQnJpZ2h0OiA5NCxcbiAgICBtYWdlbnRhQnJpZ2h0OiA5NSxcbiAgICBjeWFuQnJpZ2h0OiA5NixcbiAgICB3aGl0ZUJyaWdodDogOTdcbn07XG52YXIgYmdDb2xvcnMgPSB7XG4gICAgYmdCbGFjazogNDAsXG4gICAgYmdSZWQ6IDQxLFxuICAgIGJnR3JlZW46IDQyLFxuICAgIGJnWWVsbG93OiA0MyxcbiAgICBiZ0JsdWU6IDQ0LFxuICAgIGJnTWFnZW50YTogNDUsXG4gICAgYmdDeWFuOiA0NixcbiAgICBiZ1doaXRlOiA0NyxcbiAgICBiZ0JsYWNrQnJpZ2h0OiAxMDAsXG4gICAgYmdSZWRCcmlnaHQ6IDEwMSxcbiAgICBiZ0dyZWVuQnJpZ2h0OiAxMDIsXG4gICAgYmdZZWxsb3dCcmlnaHQ6IDEwMyxcbiAgICBiZ0JsdWVCcmlnaHQ6IDEwNCxcbiAgICBiZ01hZ2VudGFCcmlnaHQ6IDEwNSxcbiAgICBiZ0N5YW5CcmlnaHQ6IDEwNixcbiAgICBiZ1doaXRlQnJpZ2h0OiAxMDdcbn07XG5mdW5jdGlvbiBjcmVhdGVHZW5lcmljV3JhcHBlcihjb2xvciwgZW5kaW5nLCBpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBcIlxcdTAwMUJbXCIgKyBjb2xvciArIFwibVwiICsgKGlubmVyID8gaW5uZXIoc3RyKSA6IHN0cikgKyBcIlxcdTAwMUJbXCIgKyBlbmRpbmcgKyBcIm1cIjsgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yV3JhcHBlcihjb2xvcikge1xuICAgIHJldHVybiBjcmVhdGVHZW5lcmljV3JhcHBlcihjb2xvcnNbY29sb3JdLCAzOSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCZ1dyYXBwZXIoY29sb3IsIGZnV3JhcHBlcikge1xuICAgIHJldHVybiBjcmVhdGVHZW5lcmljV3JhcHBlcihiZ0NvbG9yc1tjb2xvcl0sIDQ5LCBmZ1dyYXBwZXIpO1xufVxudmFyIF9fZXhwb3J0X0xvZ0xldmVsVG9Db2xvciA9IChfYiA9IHt9LFxuICAgIF9iW0xvZ0xldmVsXzEuZGVmYXVsdC5DUklUSUNBTF0gPSBjcmVhdGVDb2xvcldyYXBwZXIoJ3JlZCcpLFxuICAgIF9iW0xvZ0xldmVsXzEuZGVmYXVsdC5FUlJPUl0gPSBjcmVhdGVDb2xvcldyYXBwZXIoJ3JlZEJyaWdodCcpLFxuICAgIF9iW0xvZ0xldmVsXzEuZGVmYXVsdC5XQVJOSU5HXSA9IGNyZWF0ZUNvbG9yV3JhcHBlcigneWVsbG93JyksXG4gICAgX2JbTG9nTGV2ZWxfMS5kZWZhdWx0LklORk9dID0gY3JlYXRlQ29sb3JXcmFwcGVyKCdibHVlJyksXG4gICAgX2JbTG9nTGV2ZWxfMS5kZWZhdWx0LkRFQlVHXSA9IGNyZWF0ZUNvbG9yV3JhcHBlcignbWFnZW50YScpLFxuICAgIF9iW0xvZ0xldmVsXzEuZGVmYXVsdC5UUkFDRV0gPSBjcmVhdGVHZW5lcmljV3JhcHBlcigwLCAwKSxcbiAgICBfYik7XG5leHBvcnRzLkxvZ0xldmVsVG9Db2xvciA9IF9fZXhwb3J0X0xvZ0xldmVsVG9Db2xvcjtcbnZhciBfX2V4cG9ydF9Mb2dMZXZlbFRvQmFja2dyb3VuZENvbG9yID0gKF9jID0ge30sXG4gICAgX2NbTG9nTGV2ZWxfMS5kZWZhdWx0LkNSSVRJQ0FMXSA9IGNyZWF0ZUJnV3JhcHBlcignYmdSZWQnLCBjcmVhdGVDb2xvcldyYXBwZXIoJ3doaXRlJykpLFxuICAgIF9jW0xvZ0xldmVsXzEuZGVmYXVsdC5FUlJPUl0gPSBjcmVhdGVCZ1dyYXBwZXIoJ2JnUmVkQnJpZ2h0JywgY3JlYXRlQ29sb3JXcmFwcGVyKCd3aGl0ZScpKSxcbiAgICBfY1tMb2dMZXZlbF8xLmRlZmF1bHQuV0FSTklOR10gPSBjcmVhdGVCZ1dyYXBwZXIoJ2JnWWVsbG93JywgY3JlYXRlQ29sb3JXcmFwcGVyKCdibGFjaycpKSxcbiAgICBfY1tMb2dMZXZlbF8xLmRlZmF1bHQuSU5GT10gPSBjcmVhdGVCZ1dyYXBwZXIoJ2JnQmx1ZScsIGNyZWF0ZUNvbG9yV3JhcHBlcignd2hpdGUnKSksXG4gICAgX2NbTG9nTGV2ZWxfMS5kZWZhdWx0LkRFQlVHXSA9IGNyZWF0ZUJnV3JhcHBlcignYmdNYWdlbnRhJywgY3JlYXRlQ29sb3JXcmFwcGVyKCdibGFjaycpKSxcbiAgICBfY1tMb2dMZXZlbF8xLmRlZmF1bHQuVFJBQ0VdID0gY3JlYXRlR2VuZXJpY1dyYXBwZXIoNywgMjcpLFxuICAgIF9jKTtcbmV4cG9ydHMuTG9nTGV2ZWxUb0JhY2tncm91bmRDb2xvciA9IF9fZXhwb3J0X0xvZ0xldmVsVG9CYWNrZ3JvdW5kQ29sb3I7XG52YXIgTm9kZUxvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhOb2RlTG9nZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vZGVMb2dnZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTm9kZUxvZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChsZXZlbCA+IHRoaXMuX21pbkxldmVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ0ZuID0gTG9nTGV2ZWxfMS5Mb2dMZXZlbFRvQ29uc29sZUZ1bmN0aW9uW2xldmVsXTtcbiAgICAgICAgdmFyIGJ1aWx0TWVzc2FnZSA9ICcnO1xuICAgICAgICBpZiAodGhpcy5fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgYnVpbHRNZXNzYWdlICs9IFwiW1wiICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCJdIFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbW9qaSkge1xuICAgICAgICAgICAgdmFyIGVtb2ppID0gZXhwb3J0cy5Mb2dMZXZlbFRvRW1vamlbbGV2ZWxdO1xuICAgICAgICAgICAgYnVpbHRNZXNzYWdlICs9IGVtb2ppICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbG9ycykge1xuICAgICAgICAgICAgYnVpbHRNZXNzYWdlICs9IGV4cG9ydHMuTG9nTGV2ZWxUb0JhY2tncm91bmRDb2xvcltsZXZlbF0odGhpcy5fbmFtZSkgKyBcIiBcIiArIGV4cG9ydHMuTG9nTGV2ZWxUb0JhY2tncm91bmRDb2xvcltsZXZlbF0oTG9nTGV2ZWxfMS5kZWZhdWx0W2xldmVsXSkgKyBcIiBcIiArIGV4cG9ydHMuTG9nTGV2ZWxUb0NvbG9yW2xldmVsXShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1aWx0TWVzc2FnZSArPSBcIltcIiArIHRoaXMuX25hbWUgKyBcIjpcIiArIExvZ0xldmVsXzEuZGVmYXVsdFtsZXZlbF0udG9Mb3dlckNhc2UoKSArIFwiXSBcIiArIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgbG9nRm4oYnVpbHRNZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlTG9nZ2VyO1xufShCYXNlTG9nZ2VyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm9kZUxvZ2dlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IE5vZGVMb2dnZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvZ0xldmVsVG9FbW9qaSA9IF9fZXhwb3J0X0xvZ0xldmVsVG9FbW9qaTtcbmV4cG9ydHMuTG9nTGV2ZWxUb0NvbG9yID0gX19leHBvcnRfTG9nTGV2ZWxUb0NvbG9yO1xuZXhwb3J0cy5Mb2dMZXZlbFRvQmFja2dyb3VuZENvbG9yID0gX19leHBvcnRfTG9nTGV2ZWxUb0JhY2tncm91bmRDb2xvcjtcbmV4cG9ydHMuZGVmYXVsdCA9IE5vZGVMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob2RlTG9nZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgTG9nTGV2ZWxfMSA9IHJlcXVpcmUoXCIuL0xvZ0xldmVsXCIpO1xudmFyIEJhc2VMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VMb2dnZXJcIik7XG52YXIgQnJvd3NlckxvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCcm93c2VyTG9nZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJMb2dnZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQnJvd3NlckxvZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChsZXZlbCA+IHRoaXMuX21pbkxldmVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ0ZuID0gTG9nTGV2ZWxfMS5Mb2dMZXZlbFRvQ29uc29sZUZ1bmN0aW9uW2xldmVsXTtcbiAgICAgICAgdmFyIGZvcm1hdHRlZE1lc3NhZ2UgPSBcIltcIiArIHRoaXMuX25hbWUgKyBcIl0gXCIgKyBtZXNzYWdlO1xuICAgICAgICBpZiAodGhpcy5fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgZm9ybWF0dGVkTWVzc2FnZSA9IFwiW1wiICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCJdIFwiICsgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBsb2dGbihmb3JtYXR0ZWRNZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyTG9nZ2VyO1xufShCYXNlTG9nZ2VyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQnJvd3NlckxvZ2dlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEJyb3dzZXJMb2dnZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCcm93c2VyTG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlckxvZ2dlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0czogZm9ybWF0cyxcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGFycmF5UHJlZml4R2VuZXJhdG9ycyA9IHtcbiAgICBicmFja2V0czogZnVuY3Rpb24gYnJhY2tldHMocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnW10nO1xuICAgIH0sXG4gICAgY29tbWE6ICdjb21tYScsXG4gICAgaW5kaWNlczogZnVuY3Rpb24gaW5kaWNlcyhwcmVmaXgsIGtleSkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1snICsga2V5ICsgJ10nO1xuICAgIH0sXG4gICAgcmVwZWF0OiBmdW5jdGlvbiByZXBlYXQocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfVxufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbnZhciBwdXNoVG9BcnJheSA9IGZ1bmN0aW9uIChhcnIsIHZhbHVlT3JBcnJheSkge1xuICAgIHB1c2guYXBwbHkoYXJyLCBpc0FycmF5KHZhbHVlT3JBcnJheSkgPyB2YWx1ZU9yQXJyYXkgOiBbdmFsdWVPckFycmF5XSk7XG59O1xuXG52YXIgdG9JU08gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGRlZmF1bHRGb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWRkUXVlcnlQcmVmaXg6IGZhbHNlLFxuICAgIGFsbG93RG90czogZmFsc2UsXG4gICAgY2hhcnNldDogJ3V0Zi04JyxcbiAgICBjaGFyc2V0U2VudGluZWw6IGZhbHNlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGVuY29kZTogdHJ1ZSxcbiAgICBlbmNvZGVyOiB1dGlscy5lbmNvZGUsXG4gICAgZW5jb2RlVmFsdWVzT25seTogZmFsc2UsXG4gICAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0LFxuICAgIGZvcm1hdHRlcjogZm9ybWF0cy5mb3JtYXR0ZXJzW2RlZmF1bHRGb3JtYXRdLFxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBpbmRpY2VzOiBmYWxzZSxcbiAgICBzZXJpYWxpemVEYXRlOiBmdW5jdGlvbiBzZXJpYWxpemVEYXRlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoZGF0ZSk7XG4gICAgfSxcbiAgICBza2lwTnVsbHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBpc05vbk51bGxpc2hQcmltaXRpdmUgPSBmdW5jdGlvbiBpc05vbk51bGxpc2hQcmltaXRpdmUodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZydcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnYm9vbGVhbidcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdzeW1ib2wnXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnYmlnaW50Jztcbn07XG5cbnZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoXG4gICAgb2JqZWN0LFxuICAgIHByZWZpeCxcbiAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICBza2lwTnVsbHMsXG4gICAgZW5jb2RlcixcbiAgICBmaWx0ZXIsXG4gICAgc29ydCxcbiAgICBhbGxvd0RvdHMsXG4gICAgc2VyaWFsaXplRGF0ZSxcbiAgICBmb3JtYXR0ZXIsXG4gICAgZW5jb2RlVmFsdWVzT25seSxcbiAgICBjaGFyc2V0XG4pIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9iaiA9IGZpbHRlcihwcmVmaXgsIG9iaik7XG4gICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG9iaiA9IHNlcmlhbGl6ZURhdGUob2JqKTtcbiAgICB9IGVsc2UgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iaiA9IG9iai5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc3RyaWN0TnVsbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlciAmJiAhZW5jb2RlVmFsdWVzT25seSA/IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JykgOiBwcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSAnJztcbiAgICB9XG5cbiAgICBpZiAoaXNOb25OdWxsaXNoUHJpbWl0aXZlKG9iaikgfHwgdXRpbHMuaXNCdWZmZXIob2JqKSkge1xuICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gZW5jb2RlVmFsdWVzT25seSA/IHByZWZpeCA6IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5Jyk7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihrZXlWYWx1ZSkgKyAnPScgKyBmb3JtYXR0ZXIoZW5jb2RlcihvYmosIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICd2YWx1ZScpKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIocHJlZml4KSArICc9JyArIGZvcm1hdHRlcihTdHJpbmcob2JqKSldO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIHZhciBvYmpLZXlzO1xuICAgIGlmIChpc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIG9iaktleXMgPSBzb3J0ID8ga2V5cy5zb3J0KHNvcnQpIDoga2V5cztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBwdXNoVG9BcnJheSh2YWx1ZXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgICAgICB0eXBlb2YgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2Z1bmN0aW9uJyA/IGdlbmVyYXRlQXJyYXlQcmVmaXgocHJlZml4LCBrZXkpIDogcHJlZml4LFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgICAgIHNraXBOdWxscyxcbiAgICAgICAgICAgICAgICBlbmNvZGVyLFxuICAgICAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgICAgICBzb3J0LFxuICAgICAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVEYXRlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcixcbiAgICAgICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgICAgIGNoYXJzZXRcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHVzaFRvQXJyYXkodmFsdWVzLCBzdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICAgICAgcHJlZml4ICsgKGFsbG93RG90cyA/ICcuJyArIGtleSA6ICdbJyArIGtleSArICddJyksXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgICAgIGVuY29kZXIsXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHksXG4gICAgICAgICAgICAgICAgY2hhcnNldFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxudmFyIG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmVuY29kZXIgIT09IG51bGwgJiYgb3B0cy5lbmNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdHMuZW5jb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBjaGFyc2V0ID0gb3B0cy5jaGFyc2V0IHx8IGRlZmF1bHRzLmNoYXJzZXQ7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNoYXJzZXQgIT09ICd1bmRlZmluZWQnICYmIG9wdHMuY2hhcnNldCAhPT0gJ3V0Zi04JyAmJiBvcHRzLmNoYXJzZXQgIT09ICdpc28tODg1OS0xJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2hhcnNldCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgdXRmLTgsIGlzby04ODU5LTEsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG4gICAgaWYgKHR5cGVvZiBvcHRzLmZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFoYXMuY2FsbChmb3JtYXRzLmZvcm1hdHRlcnMsIG9wdHMuZm9ybWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBmb3JtYXQgb3B0aW9uIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdCA9IG9wdHMuZm9ybWF0O1xuICAgIH1cbiAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICB2YXIgZmlsdGVyID0gZGVmYXVsdHMuZmlsdGVyO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgaXNBcnJheShvcHRzLmZpbHRlcikpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0cy5maWx0ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkUXVlcnlQcmVmaXg6IHR5cGVvZiBvcHRzLmFkZFF1ZXJ5UHJlZml4ID09PSAnYm9vbGVhbicgPyBvcHRzLmFkZFF1ZXJ5UHJlZml4IDogZGVmYXVsdHMuYWRkUXVlcnlQcmVmaXgsXG4gICAgICAgIGFsbG93RG90czogdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHMsXG4gICAgICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgICAgIGNoYXJzZXRTZW50aW5lbDogdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcbiAgICAgICAgZGVsaW1pdGVyOiB0eXBlb2Ygb3B0cy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuZGVsaW1pdGVyIDogb3B0cy5kZWxpbWl0ZXIsXG4gICAgICAgIGVuY29kZTogdHlwZW9mIG9wdHMuZW5jb2RlID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZSA6IGRlZmF1bHRzLmVuY29kZSxcbiAgICAgICAgZW5jb2RlcjogdHlwZW9mIG9wdHMuZW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZW5jb2RlciA6IGRlZmF1bHRzLmVuY29kZXIsXG4gICAgICAgIGVuY29kZVZhbHVlc09ubHk6IHR5cGVvZiBvcHRzLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzLmVuY29kZVZhbHVlc09ubHksXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgICAgICAgc2VyaWFsaXplRGF0ZTogdHlwZW9mIG9wdHMuc2VyaWFsaXplRGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuc2VyaWFsaXplRGF0ZSA6IGRlZmF1bHRzLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgIHNraXBOdWxsczogdHlwZW9mIG9wdHMuc2tpcE51bGxzID09PSAnYm9vbGVhbicgPyBvcHRzLnNraXBOdWxscyA6IGRlZmF1bHRzLnNraXBOdWxscyxcbiAgICAgICAgc29ydDogdHlwZW9mIG9wdHMuc29ydCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuc29ydCA6IG51bGwsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdHMpIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuICAgIHZhciBvcHRpb25zID0gbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyhvcHRzKTtcblxuICAgIHZhciBvYmpLZXlzO1xuICAgIHZhciBmaWx0ZXI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmogPSBmaWx0ZXIoJycsIG9iaik7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9wdGlvbnMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIGFycmF5Rm9ybWF0O1xuICAgIGlmIChvcHRzICYmIG9wdHMuYXJyYXlGb3JtYXQgaW4gYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5hcnJheUZvcm1hdDtcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgJ2luZGljZXMnIGluIG9wdHMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmluZGljZXMgPyAnaW5kaWNlcycgOiAncmVwZWF0JztcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheUZvcm1hdCA9ICdpbmRpY2VzJztcbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGFycmF5UHJlZml4R2VuZXJhdG9yc1thcnJheUZvcm1hdF07XG5cbiAgICBpZiAoIW9iaktleXMpIHtcbiAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcE51bGxzICYmIG9ialtrZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoVG9BcnJheShrZXlzLCBzdHJpbmdpZnkoXG4gICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgIG9wdGlvbnMuc2tpcE51bGxzLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGUgPyBvcHRpb25zLmVuY29kZXIgOiBudWxsLFxuICAgICAgICAgICAgb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgICAgICBvcHRpb25zLnNvcnQsXG4gICAgICAgICAgICBvcHRpb25zLmFsbG93RG90cyxcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgb3B0aW9ucy5jaGFyc2V0XG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBrZXlzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLmFkZFF1ZXJ5UHJlZml4ID09PSB0cnVlID8gJz8nIDogJyc7XG5cbiAgICBpZiAob3B0aW9ucy5jaGFyc2V0U2VudGluZWwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JyksIHRoZSBcIm51bWVyaWMgZW50aXR5XCIgcmVwcmVzZW50YXRpb24gb2YgYSBjaGVja21hcmtcbiAgICAgICAgICAgIHByZWZpeCArPSAndXRmOD0lMjYlMjMxMDAwMyUzQiYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSVFMiU5QyU5MyYnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGpvaW5lZC5sZW5ndGggPiAwID8gcHJlZml4ICsgam9pbmVkIDogJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBhbGxvd1Byb3RvdHlwZXM6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBjb21tYTogZmFsc2UsXG4gICAgZGVjb2RlcjogdXRpbHMuZGVjb2RlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGRlcHRoOiA1LFxuICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IGZhbHNlLFxuICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwLFxuICAgIHBhcnNlQXJyYXlzOiB0cnVlLFxuICAgIHBsYWluT2JqZWN0czogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIGludGVycHJldE51bWVyaWNFbnRpdGllcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjKFxcZCspOy9nLCBmdW5jdGlvbiAoJDAsIG51bWJlclN0cikge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChudW1iZXJTdHIsIDEwKSk7XG4gICAgfSk7XG59O1xuXG52YXIgcGFyc2VBcnJheVZhbHVlID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5jb21tYSAmJiB2YWwuaW5kZXhPZignLCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zcGxpdCgnLCcpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG59O1xuXG52YXIgbWF5YmVNYXAgPSBmdW5jdGlvbiBtYXliZU1hcCh2YWwsIGZuKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YXIgbWFwcGVkID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBtYXBwZWQucHVzaChmbih2YWxbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH1cbiAgICByZXR1cm4gZm4odmFsKTtcbn07XG5cbi8vIFRoaXMgaXMgd2hhdCBicm93c2VycyB3aWxsIHN1Ym1pdCB3aGVuIHRoZSDinJMgY2hhcmFjdGVyIG9jY3VycyBpbiBhblxuLy8gYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIGJvZHkgYW5kIHRoZSBlbmNvZGluZyBvZiB0aGUgcGFnZSBjb250YWluaW5nXG4vLyB0aGUgZm9ybSBpcyBpc28tODg1OS0xLCBvciB3aGVuIHRoZSBzdWJtaXR0ZWQgZm9ybSBoYXMgYW4gYWNjZXB0LWNoYXJzZXRcbi8vIGF0dHJpYnV0ZSBvZiBpc28tODg1OS0xLiBQcmVzdW1hYmx5IGFsc28gd2l0aCBvdGhlciBjaGFyc2V0cyB0aGF0IGRvIG5vdCBjb250YWluXG4vLyB0aGUg4pyTIGNoYXJhY3Rlciwgc3VjaCBhcyB1cy1hc2NpaS5cbnZhciBpc29TZW50aW5lbCA9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpXG5cbi8vIFRoZXNlIGFyZSB0aGUgcGVyY2VudC1lbmNvZGVkIHV0Zi04IG9jdGV0cyByZXByZXNlbnRpbmcgYSBjaGVja21hcmssIGluZGljYXRpbmcgdGhhdCB0aGUgcmVxdWVzdCBhY3R1YWxseSBpcyB1dGYtOCBlbmNvZGVkLlxudmFyIGNoYXJzZXRTZW50aW5lbCA9ICd1dGY4PSVFMiU5QyU5Myc7IC8vIGVuY29kZVVSSUNvbXBvbmVudCgn4pyTJylcblxudmFyIHBhcnNlVmFsdWVzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ1ZhbHVlcyhzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIGNsZWFuU3RyID0gb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA/IHN0ci5yZXBsYWNlKC9eXFw/LywgJycpIDogc3RyO1xuICAgIHZhciBsaW1pdCA9IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdDtcbiAgICB2YXIgcGFydHMgPSBjbGVhblN0ci5zcGxpdChvcHRpb25zLmRlbGltaXRlciwgbGltaXQpO1xuICAgIHZhciBza2lwSW5kZXggPSAtMTsgLy8gS2VlcCB0cmFjayBvZiB3aGVyZSB0aGUgdXRmOCBzZW50aW5lbCB3YXMgZm91bmRcbiAgICB2YXIgaTtcblxuICAgIHZhciBjaGFyc2V0ID0gb3B0aW9ucy5jaGFyc2V0O1xuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1tpXS5pbmRleE9mKCd1dGY4PScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzW2ldID09PSBjaGFyc2V0U2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9ICd1dGYtOCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXSA9PT0gaXNvU2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9ICdpc28tODg1OS0xJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBpID0gcGFydHMubGVuZ3RoOyAvLyBUaGUgZXNsaW50IHNldHRpbmdzIGRvIG5vdCBhbGxvdyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoaSA9PT0gc2tpcEluZGV4KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICAgIHZhciBicmFja2V0RXF1YWxzUG9zID0gcGFydC5pbmRleE9mKCddPScpO1xuICAgICAgICB2YXIgcG9zID0gYnJhY2tldEVxdWFsc1BvcyA9PT0gLTEgPyBwYXJ0LmluZGV4T2YoJz0nKSA6IGJyYWNrZXRFcXVhbHNQb3MgKyAxO1xuXG4gICAgICAgIHZhciBrZXksIHZhbDtcbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAna2V5Jyk7XG4gICAgICAgICAgICB2YWwgPSBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA/IG51bGwgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LnNsaWNlKDAsIHBvcyksIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHZhbCA9IG1heWJlTWFwKFxuICAgICAgICAgICAgICAgIHBhcnNlQXJyYXlWYWx1ZShwYXJ0LnNsaWNlKHBvcyArIDEpLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZW5jb2RlZFZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kZWNvZGVyKGVuY29kZWRWYWwsIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICd2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsICYmIG9wdGlvbnMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzICYmIGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAgICAgdmFsID0gaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzKHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydC5pbmRleE9mKCdbXT0nKSA+IC0xKSB7XG4gICAgICAgICAgICB2YWwgPSBpc0FycmF5KHZhbCkgPyBbdmFsXSA6IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdXRpbHMuY29tYmluZShvYmpba2V5XSwgdmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uIChjaGFpbiwgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpIHtcbiAgICB2YXIgbGVhZiA9IHZhbHVlc1BhcnNlZCA/IHZhbCA6IHBhcnNlQXJyYXlWYWx1ZSh2YWwsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgaSA9IGNoYWluLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBvYmo7XG4gICAgICAgIHZhciByb290ID0gY2hhaW5baV07XG5cbiAgICAgICAgaWYgKHJvb3QgPT09ICdbXScgJiYgb3B0aW9ucy5wYXJzZUFycmF5cykge1xuICAgICAgICAgICAgb2JqID0gW10uY29uY2F0KGxlYWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdC5jaGFyQXQoMCkgPT09ICdbJyAmJiByb290LmNoYXJBdChyb290Lmxlbmd0aCAtIDEpID09PSAnXScgPyByb290LnNsaWNlKDEsIC0xKSA6IHJvb3Q7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjbGVhblJvb3QsIDEwKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wYXJzZUFycmF5cyAmJiBjbGVhblJvb3QgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgb2JqID0geyAwOiBsZWFmIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICFpc05hTihpbmRleClcbiAgICAgICAgICAgICAgICAmJiByb290ICE9PSBjbGVhblJvb3RcbiAgICAgICAgICAgICAgICAmJiBTdHJpbmcoaW5kZXgpID09PSBjbGVhblJvb3RcbiAgICAgICAgICAgICAgICAmJiBpbmRleCA+PSAwXG4gICAgICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICAgICAgb2JqW2luZGV4XSA9IGxlYWY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gbGVhZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWYgPSBvYmo7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB9XG5cbiAgICByZXR1cm4gbGVhZjtcbn07XG5cbnZhciBwYXJzZUtleXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nS2V5cyhnaXZlbktleSwgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpIHtcbiAgICBpZiAoIWdpdmVuS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gZG90IG5vdGF0aW9uIHRvIGJyYWNrZXQgbm90YXRpb25cbiAgICB2YXIga2V5ID0gb3B0aW9ucy5hbGxvd0RvdHMgPyBnaXZlbktleS5yZXBsYWNlKC9cXC4oW14uW10rKS9nLCAnWyQxXScpIDogZ2l2ZW5LZXk7XG5cbiAgICAvLyBUaGUgcmVnZXggY2h1bmtzXG5cbiAgICB2YXIgYnJhY2tldHMgPSAvKFxcW1teW1xcXV0qXSkvO1xuICAgIHZhciBjaGlsZCA9IC8oXFxbW15bXFxdXSpdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gb3B0aW9ucy5kZXB0aCA+IDAgJiYgYnJhY2tldHMuZXhlYyhrZXkpO1xuICAgIHZhciBwYXJlbnQgPSBzZWdtZW50ID8ga2V5LnNsaWNlKDAsIHNlZ21lbnQuaW5kZXgpIDoga2V5O1xuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgcGxhaW4gb2JqZWN0cywgb3B0aW9uYWxseSBwcmVmaXgga2V5cyB0aGF0IHdvdWxkIG92ZXJ3cml0ZSBvYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFwcGVuZGluZyB0byB0aGUgYXJyYXkgdW50aWwgd2UgaGl0IGRlcHRoXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKG9wdGlvbnMuZGVwdGggPiAwICYmIChzZWdtZW50ID0gY2hpbGQuZXhlYyhrZXkpKSAhPT0gbnVsbCAmJiBpIDwgb3B0aW9ucy5kZXB0aCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc2VnbWVudFsxXS5zbGljZSgxLCAtMSkpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBqdXN0IGFkZCB3aGF0ZXZlciBpcyBsZWZ0XG5cbiAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBrZXlzLnB1c2goJ1snICsga2V5LnNsaWNlKHNlZ21lbnQuaW5kZXgpICsgJ10nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpO1xufTtcblxudmFyIG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5kZWNvZGVyICE9PSBudWxsICYmIG9wdHMuZGVjb2RlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRzLmRlY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGVjb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjaGFyc2V0IG9wdGlvbiBtdXN0IGJlIGVpdGhlciB1dGYtOCwgaXNvLTg4NTktMSwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIHZhciBjaGFyc2V0ID0gdHlwZW9mIG9wdHMuY2hhcnNldCA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5jaGFyc2V0IDogb3B0cy5jaGFyc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxsb3dEb3RzOiB0eXBlb2Ygb3B0cy5hbGxvd0RvdHMgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuYWxsb3dEb3RzIDogISFvcHRzLmFsbG93RG90cyxcbiAgICAgICAgYWxsb3dQcm90b3R5cGVzOiB0eXBlb2Ygb3B0cy5hbGxvd1Byb3RvdHlwZXMgPT09ICdib29sZWFuJyA/IG9wdHMuYWxsb3dQcm90b3R5cGVzIDogZGVmYXVsdHMuYWxsb3dQcm90b3R5cGVzLFxuICAgICAgICBhcnJheUxpbWl0OiB0eXBlb2Ygb3B0cy5hcnJheUxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMuYXJyYXlMaW1pdCA6IGRlZmF1bHRzLmFycmF5TGltaXQsXG4gICAgICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgICAgIGNoYXJzZXRTZW50aW5lbDogdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcbiAgICAgICAgY29tbWE6IHR5cGVvZiBvcHRzLmNvbW1hID09PSAnYm9vbGVhbicgPyBvcHRzLmNvbW1hIDogZGVmYXVsdHMuY29tbWEsXG4gICAgICAgIGRlY29kZXI6IHR5cGVvZiBvcHRzLmRlY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmRlY29kZXIgOiBkZWZhdWx0cy5kZWNvZGVyLFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3N0cmluZycgfHwgdXRpbHMuaXNSZWdFeHAob3B0cy5kZWxpbWl0ZXIpID8gb3B0cy5kZWxpbWl0ZXIgOiBkZWZhdWx0cy5kZWxpbWl0ZXIsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvbiwgbm8tZXh0cmEtcGFyZW5zXG4gICAgICAgIGRlcHRoOiAodHlwZW9mIG9wdHMuZGVwdGggPT09ICdudW1iZXInIHx8IG9wdHMuZGVwdGggPT09IGZhbHNlKSA/ICtvcHRzLmRlcHRoIDogZGVmYXVsdHMuZGVwdGgsXG4gICAgICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBvcHRzLmlnbm9yZVF1ZXJ5UHJlZml4ID09PSB0cnVlLFxuICAgICAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IHR5cGVvZiBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgOiBkZWZhdWx0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMsXG4gICAgICAgIHBhcmFtZXRlckxpbWl0OiB0eXBlb2Ygb3B0cy5wYXJhbWV0ZXJMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLnBhcmFtZXRlckxpbWl0IDogZGVmYXVsdHMucGFyYW1ldGVyTGltaXQsXG4gICAgICAgIHBhcnNlQXJyYXlzOiBvcHRzLnBhcnNlQXJyYXlzICE9PSBmYWxzZSxcbiAgICAgICAgcGxhaW5PYmplY3RzOiB0eXBlb2Ygb3B0cy5wbGFpbk9iamVjdHMgPT09ICdib29sZWFuJyA/IG9wdHMucGxhaW5PYmplY3RzIDogZGVmYXVsdHMucGxhaW5PYmplY3RzLFxuICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IHR5cGVvZiBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmdcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cyk7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH1cblxuICAgIHZhciB0ZW1wT2JqID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zLCB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyk7XG4gICAgICAgIG9iaiA9IHV0aWxzLm1lcmdlKG9iaiwgbmV3T2JqLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMuY29tcGFjdChvYmopO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBVc2VyVG9vbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9Ub29sa2l0L1VzZXJUb29sc1wiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9Ud2l0Y2hDbGllbnRcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uL0Jhc2VBUElcIik7XG52YXIgQ2hhdEJhZGdlTGlzdF8xID0gcmVxdWlyZShcIi4vQ2hhdEJhZGdlTGlzdFwiKTtcbi8qKlxuICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIGJhZGdlcy5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcgYGNsaWVudC5iYWRnZXNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBjaGVlcm1vdGVzID0gYXdhaXQgY2xpZW50LmJhZGdlcy5nZXRHbG9iYWxCYWRnZXMoKTtcbiAqIGBgYFxuICovXG52YXIgQmFkZ2VzQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEJhZGdlc0FQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYWRnZXNBUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBnbG9iYWxseSBhcHBsaWNhYmxlIGNoYXQgYmFkZ2VzLlxuICAgICAqL1xuICAgIEJhZGdlc0FQSS5wcm90b3R5cGUuZ2V0R2xvYmFsQmFkZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2JhZGdlcy50d2l0Y2gudHYvdjEvYmFkZ2VzL2dsb2JhbC9kaXNwbGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5DdXN0b21cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgQ2hhdEJhZGdlTGlzdF8xLmRlZmF1bHQoZGF0YS5iYWRnZV9zZXRzLCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGFwcGxpY2FibGUgY2hhdCBiYWRnZXMgZm9yIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHJldHJpZXZlIHRoZSBjaGF0IGJhZGdlcyBmb3IuXG4gICAgICogQHBhcmFtIGluY2x1ZGVHbG9iYWwgV2hldGhlciB0byBpbmNsdWRlIGdsb2JhbCBiYWRnZXMgaW4gdGhlIHJlc3VsdCBsaXN0LlxuICAgICAqL1xuICAgIEJhZGdlc0FQSS5wcm90b3R5cGUuZ2V0Q2hhbm5lbEJhZGdlcyA9IGZ1bmN0aW9uIChjaGFubmVsLCBpbmNsdWRlR2xvYmFsKSB7XG4gICAgICAgIGlmIChpbmNsdWRlR2xvYmFsID09PSB2b2lkIDApIHsgaW5jbHVkZUdsb2JhbCA9IHRydWU7IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSwgY2hhbm5lbEJhZGdlcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImh0dHBzOi8vYmFkZ2VzLnR3aXRjaC50di92MS9iYWRnZXMvY2hhbm5lbHMvXCIgKyBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpICsgXCIvZGlzcGxheVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkN1c3RvbVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEJhZGdlcyA9IG5ldyBDaGF0QmFkZ2VMaXN0XzEuZGVmYXVsdChkYXRhLmJhZGdlX3NldHMsIHRoaXMuX2NsaWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVHbG9iYWwpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRHbG9iYWxCYWRnZXMoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpLl9tZXJnZShjaGFubmVsQmFkZ2VzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNoYW5uZWxCYWRnZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBCYWRnZXNBUEkucHJvdG90eXBlLCBcImdldEdsb2JhbEJhZGdlc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgQmFkZ2VzQVBJLnByb3RvdHlwZSwgXCJnZXRDaGFubmVsQmFkZ2VzXCIsIG51bGwpO1xuICAgIEJhZGdlc0FQSSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBCYWRnZXNBUEkpO1xuICAgIHJldHVybiBCYWRnZXNBUEk7XG59KEJhc2VBUElfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYWRnZXNBUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBCYWRnZXNBUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYWRnZXNBUEk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuZnVuY3Rpb24gRW51bWVyYWJsZShlbnVtZXJhYmxlKSB7XG4gICAgaWYgKGVudW1lcmFibGUgPT09IHZvaWQgMCkgeyBlbnVtZXJhYmxlID0gdHJ1ZTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgLy8gZmlyc3QgcHJvcGVydHkgZGVmaW5lZCBpbiBwcm90b3R5cGUsIHRoYXQncyB3aHkgd2UgdXNlIGdldHRlcnMvc2V0dGVyc1xuICAgICAgICAvLyAob3RoZXJ3aXNlIGFzc2lnbm1lbnQgaW4gb2JqZWN0IHdpbGwgb3ZlcnJpZGUgcHJvcGVydHkgaW4gcHJvdG90eXBlKVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gaGVyZSB3ZSBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBhbmQgY2FuIHNldCBwcm9wZXJ0eSBkaXJlY3RseSB0byBpdFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBlbnVtZXJhYmxlXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLkVudW1lcmFibGUgPSBFbnVtZXJhYmxlO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBFbnVtZXJhYmxlKGZhbHNlKSBpbnN0ZWFkICovXG5mdW5jdGlvbiBOb25FbnVtZXJhYmxlKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIEVudW1lcmFibGUoZmFsc2UpKHRhcmdldCwga2V5KTtcbn1cbmV4cG9ydHMuTm9uRW51bWVyYWJsZSA9IE5vbkVudW1lcmFibGU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVudW1lcmFibGUgPSBFbnVtZXJhYmxlO1xuZXhwb3J0cy5Ob25FbnVtZXJhYmxlID0gTm9uRW51bWVyYWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVudW1lcmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBbXSkuY29uY2F0LmFwcGx5KF9hLCB0c2xpYl8xLl9fc3ByZWFkKGFycikpO1xufVxuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mbGF0dGVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5mdW5jdGlvbiByZXNvbHZlQ29uZmlnVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHVlKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHVlXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlc29sdmVDb25maWdWYWx1ZSA9IHJlc29sdmVDb25maWdWYWx1ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZUNvbmZpZ1ZhbHVlID0gcmVzb2x2ZUNvbmZpZ1ZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZUNvbmZpZ1ZhbHVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmZ1bmN0aW9uIGRlcHJlY2F0ZUNsYXNzKEJhc2UsIG1zZykge1xuICAgIHZhciBkZXByZWNhdGVOb3RpY2VTaG93biA9IGZhbHNlO1xuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIHRzbGliXzEuX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFkZXByZWNhdGVOb3RpY2VTaG93bikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW2RlcHJlY2F0ZWRdIFwiICsgbXNnKTtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVOb3RpY2VTaG93biA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCB0c2xpYl8xLl9fc3ByZWFkKGFyZ3MpKSB8fCB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5kZXByZWNhdGVDbGFzcyA9IGRlcHJlY2F0ZUNsYXNzO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXByZWNhdGVDbGFzcyA9IGRlcHJlY2F0ZUNsYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwcmVjYXRlQ2xhc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWF0Y2hlZCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoe1xuICAgIG90aGVyd2lzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSxcbiAgICBvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0Y2hlZCh4KTsgfVxufSk7IH07XG52YXIgbWF0Y2ggPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gKHtcbiAgICBvbjogZnVuY3Rpb24gKHByZWRpY2F0ZSwgZm4pIHsgcmV0dXJuIChwcmVkaWNhdGUoeCkgPyBtYXRjaGVkKGZuKHgpKSA6IG1hdGNoKHgpKTsgfSxcbiAgICBvdGhlcndpc2U6IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oeCk7IH1cbn0pOyB9O1xuZXhwb3J0cy5tYXRjaCA9IG1hdGNoO1xudmFyIF9fZXhwb3J0X2VxID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGZ1bmN0aW9uICh5KSB7IHJldHVybiB4ID09PSB5OyB9OyB9O1xuZXhwb3J0cy5lcSA9IF9fZXhwb3J0X2VxO1xubWF0Y2guZXEgPSBleHBvcnRzLmVxO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXRjaCA9IG1hdGNoO1xuZXhwb3J0cy5lcSA9IF9fZXhwb3J0X2VxO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBhcnJheVRvT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9hcnJheVRvT2JqZWN0XCIpO1xuZnVuY3Rpb24gZW50cmllc1RvT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBhcnJheVRvT2JqZWN0XzEuYXJyYXlUb09iamVjdChvYmosIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBfYyA9IHRzbGliXzEuX19yZWFkKF9hLCAyKSwga2V5ID0gX2NbMF0sIHZhbCA9IF9jWzFdO1xuICAgICAgICByZXR1cm4gKF9iID0ge30sIF9iW2tleV0gPSB2YWwsIF9iKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZW50cmllc1RvT2JqZWN0ID0gZW50cmllc1RvT2JqZWN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnRyaWVzVG9PYmplY3QgPSBlbnRyaWVzVG9PYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnRyaWVzVG9PYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmZ1bmN0aW9uIGZvckVhY2hPYmplY3RFbnRyeShvYmosIGZuKSB7XG4gICAgT2JqZWN0LmVudHJpZXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChfYSwgMiksIGtleSA9IF9iWzBdLCB2YWx1ZSA9IF9iWzFdO1xuICAgICAgICByZXR1cm4gZm4odmFsdWUsIGtleSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmZvckVhY2hPYmplY3RFbnRyeSA9IGZvckVhY2hPYmplY3RFbnRyeTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9yRWFjaE9iamVjdEVudHJ5ID0gZm9yRWFjaE9iamVjdEVudHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9yRWFjaE9iamVjdEVudHJ5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFycmF5VG9PYmplY3RfMSA9IHJlcXVpcmUoXCIuL2FycmF5VG9PYmplY3RcIik7XG5mdW5jdGlvbiBpbmRleEJ5KGFyciwga2V5Rm4pIHtcbiAgICBpZiAodHlwZW9mIGtleUZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlfMSA9IGtleUZuO1xuICAgICAgICBrZXlGbiA9IChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlW2tleV8xXS50b1N0cmluZygpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5VG9PYmplY3RfMS5hcnJheVRvT2JqZWN0KGFyciwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB7fSwgX2Fba2V5Rm4odmFsKV0gPSB2YWwsIF9hKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuaW5kZXhCeSA9IGluZGV4Qnk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluZGV4QnkgPSBpbmRleEJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXhCeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuZnVuY3Rpb24gbWFwT2JqZWN0KG9iaiwgZm4pIHtcbiAgICB2YXIgbWFwcGVkID0gT2JqZWN0LmVudHJpZXMob2JqKS5tYXAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtYXNzZXJ0aW9uc1xuICAgIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBfYyA9IHRzbGliXzEuX19yZWFkKF9hLCAyKSwga2V5ID0gX2NbMF0sIHZhbHVlID0gX2NbMV07XG4gICAgICAgIHJldHVybiAoX2IgPSB7fSwgX2Jba2V5XSA9IGZuKHZhbHVlLCBrZXkpLCBfYik7XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCB0c2xpYl8xLl9fc3ByZWFkKFt7fV0sIG1hcHBlZCkpO1xufVxuZXhwb3J0cy5tYXBPYmplY3QgPSBtYXBPYmplY3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcE9iamVjdCA9IG1hcE9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcE9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwaWNrXzEgPSByZXF1aXJlKFwiLi9waWNrXCIpO1xuZnVuY3Rpb24gb21pdChvYmosIGtleXMpIHtcbiAgICByZXR1cm4gcGlja18xLnBpY2sob2JqLCBPYmplY3Qua2V5cyhvYmopLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAha2V5cy5pbmNsdWRlcyhrZXkpOyB9KSk7XG59XG5leHBvcnRzLm9taXQgPSBvbWl0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vbWl0ID0gb21pdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9taXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmZ1bmN0aW9uIGRlbGF5KG1zKSB7XG4gICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTsgfSldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gcGFkTGVmdChzdHIsIGxlbmd0aCwgcGFkZGluZykge1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdHIgPSBzdHIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgbGVuZ3RoID0gbGVuZ3RoIC0gc3RyLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgaWYgKHBhZGRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYWRkaW5nID0gJyAnO1xuICAgIH1cbiAgICB2YXIgcGFkZGluZ1N0ciA9ICcnO1xuICAgIGRvIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgICAgICBpZiAoKGxlbmd0aCAmIDEpID09PSAxKSB7XG4gICAgICAgICAgICBwYWRkaW5nU3RyICs9IHBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID4+PSAxO1xuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBwYWRkaW5nICs9IHBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG4gICAgfSB3aGlsZSAobGVuZ3RoKTtcbiAgICByZXR1cm4gcGFkZGluZ1N0ciArIHN0cjtcbn1cbmV4cG9ydHMucGFkTGVmdCA9IHBhZExlZnQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhZExlZnQgPSBwYWRMZWZ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkTGVmdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuZnVuY3Rpb24gc3BsaXRXaXRoTGltaXQoc3RyLCBkZWxpbSwgY291bnQpIHtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoZGVsaW0pO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPD0gY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICByZXR1cm4gdHNsaWJfMS5fX3NwcmVhZChwYXJ0cy5zbGljZSgwLCBjb3VudCAtIDEpLCBbcGFydHMuc2xpY2UoY291bnQgLSAxKS5qb2luKGRlbGltKV0pO1xufVxuZXhwb3J0cy5zcGxpdFdpdGhMaW1pdCA9IHNwbGl0V2l0aExpbWl0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zcGxpdFdpdGhMaW1pdCA9IHNwbGl0V2l0aExpbWl0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BsaXRXaXRoTGltaXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmZ1bmN0aW9uIHV0ZjhMZW5ndGgoc3RyKSB7XG4gICAgcmV0dXJuIHRzbGliXzEuX19zcHJlYWQoc3RyKS5sZW5ndGg7XG59XG5leHBvcnRzLnV0ZjhMZW5ndGggPSB1dGY4TGVuZ3RoO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51dGY4TGVuZ3RoID0gdXRmOExlbmd0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjhMZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmZ1bmN0aW9uIHV0ZjhTdWJzdHJpbmcoc3RyLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHRzbGliXzEuX19zcHJlYWQoc3RyKS5zbGljZShzdGFydCwgZW5kKS5qb2luKCcnKTtcbn1cbmV4cG9ydHMudXRmOFN1YnN0cmluZyA9IHV0ZjhTdWJzdHJpbmc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV0ZjhTdWJzdHJpbmcgPSB1dGY4U3Vic3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOFN1YnN0cmluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNhY2hlX2RlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnNcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uL0Jhc2VBUElcIik7XG52YXIgSGVsaXhCaXRzQVBJXzEgPSByZXF1aXJlKFwiLi9CaXRzL0hlbGl4Qml0c0FQSVwiKTtcbnZhciBIZWxpeENsaXBBUElfMSA9IHJlcXVpcmUoXCIuL0NsaXAvSGVsaXhDbGlwQVBJXCIpO1xudmFyIEhlbGl4RXh0ZW5zaW9uc0FQSV8xID0gcmVxdWlyZShcIi4vRXh0ZW5zaW9ucy9IZWxpeEV4dGVuc2lvbnNBUElcIik7XG52YXIgSGVsaXhHYW1lQVBJXzEgPSByZXF1aXJlKFwiLi9HYW1lL0hlbGl4R2FtZUFQSVwiKTtcbnZhciBIZWxpeE1vZGVyYXRpb25BUElfMSA9IHJlcXVpcmUoXCIuL01vZGVyYXRpb24vSGVsaXhNb2RlcmF0aW9uQVBJXCIpO1xudmFyIEhlbGl4U3RyZWFtQVBJXzEgPSByZXF1aXJlKFwiLi9TdHJlYW0vSGVsaXhTdHJlYW1BUElcIik7XG52YXIgSGVsaXhTdWJzY3JpcHRpb25BUElfMSA9IHJlcXVpcmUoXCIuL1N1YnNjcmlwdGlvbnMvSGVsaXhTdWJzY3JpcHRpb25BUElcIik7XG52YXIgSGVsaXhVc2VyQVBJXzEgPSByZXF1aXJlKFwiLi9Vc2VyL0hlbGl4VXNlckFQSVwiKTtcbnZhciBIZWxpeFZpZGVvQVBJXzEgPSByZXF1aXJlKFwiLi9WaWRlby9IZWxpeFZpZGVvQVBJXCIpO1xudmFyIEhlbGl4V2ViSG9va3NBUElfMSA9IHJlcXVpcmUoXCIuL1dlYkhvb2tzL0hlbGl4V2ViSG9va3NBUElcIik7XG4vKipcbiAqIEdyb3VwcyBhbGwgQVBJIGNhbGxzIGF2YWlsYWJsZSBpbiBIZWxpeCBhLmsuYS4gdGhlIFwiTmV3IFR3aXRjaCBBUElcIi5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcge0BUd2l0Y2hDbGllbnQjaGVsaXh9LlxuICovXG52YXIgSGVsaXhBUElHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeEFQSUdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlbGl4QVBJR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcImJpdHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhlbGl4IGJpdHMgQVBJIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVsaXhCaXRzQVBJXzEuZGVmYXVsdCh0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwiY2xpcHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhlbGl4IGNsaXBzIEFQSSBtZXRob2RzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlbGl4Q2xpcEFQSV8xLmRlZmF1bHQodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcImV4dGVuc2lvbnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhlbGl4IGV4dGVuc2lvbnMgQVBJIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVsaXhFeHRlbnNpb25zQVBJXzEuZGVmYXVsdCh0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwiZ2FtZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhlbGl4IGdhbWUgQVBJIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVsaXhHYW1lQVBJXzEuZGVmYXVsdCh0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwibW9kZXJhdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSGVsaXggbW9kZXJhdGlvbiBBUEkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxpeE1vZGVyYXRpb25BUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJzdHJlYW1zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIZWxpeCBzdHJlYW0gQVBJIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVsaXhTdHJlYW1BUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJzdWJzY3JpcHRpb25zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIZWxpeCBzdWJzY3JpcHRpb24gQVBJIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVsaXhTdWJzY3JpcHRpb25BUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJ1c2Vyc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSGVsaXggdXNlciBBUEkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFVzZXJBUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJ3ZWJIb29rc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSGVsaXggV2ViSG9vayBBUEkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFdlYkhvb2tzQVBJXzEuZGVmYXVsdCh0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwidmlkZW9zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIZWxpeCB2aWRlbyBBUEkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFZpZGVvQVBJXzEuZGVmYXVsdCh0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJiaXRzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcImNsaXBzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcImV4dGVuc2lvbnNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwiZ2FtZXNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwibW9kZXJhdGlvblwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJzdHJlYW1zXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcInN1YnNjcmlwdGlvbnNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwidXNlcnNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwid2ViSG9va3NcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwidmlkZW9zXCIsIG51bGwpO1xuICAgIEhlbGl4QVBJR3JvdXAgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVhYmxlXG4gICAgXSwgSGVsaXhBUElHcm91cCk7XG4gICAgcmV0dXJuIEhlbGl4QVBJR3JvdXA7XG59KEJhc2VBUElfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEFQSUdyb3VwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhBUElHcm91cDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4QVBJR3JvdXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL1R3aXRjaENsaWVudFwiKTtcbnZhciBIZWxpeEJpdHNMZWFkZXJib2FyZF8xID0gcmVxdWlyZShcIi4vSGVsaXhCaXRzTGVhZGVyYm9hcmRcIik7XG4vKipcbiAqIFRoZSBIZWxpeCBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBiaXRzLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmhlbGl4LmJpdHNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBsZWFkZXJib2FyZCA9IGF3YWl0IGNsaWVudC5oZWxpeC5iaXRzLmdldExlYWRlcmJvYXJkKHsgcGVyaW9kOiAnZGF5JyB9KTtcbiAqIGBgYFxuICovXG52YXIgSGVsaXhCaXRzQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4Qml0c0FQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxpeEJpdHNBUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJpdHMgbGVhZGVyYm9hcmQgb2YgeW91ciBjaGFubmVsLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqL1xuICAgIEhlbGl4Qml0c0FQSS5wcm90b3R5cGUuZ2V0TGVhZGVyYm9hcmQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgY291bnQsIF9iLCBwZXJpb2QsIHN0YXJ0RGF0ZSwgY29udGV4dFVzZXJJZCwgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHBhcmFtcy5jb3VudCwgY291bnQgPSBfYSA9PT0gdm9pZCAwID8gMTAgOiBfYSwgX2IgPSBwYXJhbXMucGVyaW9kLCBwZXJpb2QgPSBfYiA9PT0gdm9pZCAwID8gJ2FsbCcgOiBfYiwgc3RhcnREYXRlID0gcGFyYW1zLnN0YXJ0RGF0ZSwgY29udGV4dFVzZXJJZCA9IHBhcmFtcy5jb250ZXh0VXNlcklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnYml0cy9sZWFkZXJib2FyZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnYml0czpyZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyaW9kOiBwZXJpb2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydGVkX2F0OiBzdGFydERhdGUgPyBzdGFydERhdGUudG9JU09TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJfaWQ6IGNvbnRleHRVc2VySWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBIZWxpeEJpdHNMZWFkZXJib2FyZF8xLmRlZmF1bHQocmVzdWx0LCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVsaXhCaXRzQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhCaXRzQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhCaXRzQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhCaXRzQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ud2l0Y2hDbGllbnRcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uLy4uL0Jhc2VBUElcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXN1bHRcIik7XG52YXIgSGVsaXhDbGlwXzEgPSByZXF1aXJlKFwiLi9IZWxpeENsaXBcIik7XG4vKipcbiAqIFRoZSBIZWxpeCBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBjbGlwcy5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcgYGNsaWVudC5oZWxpeC5jbGlwc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IGNsaXBJZCA9IGF3YWl0IGNsaWVudC5oZWxpeC5jbGlwcy5jcmVhdGVDbGlwKHsgY2hhbm5lbElkOiAnMTI1MzI4NjU1JyB9KTtcbiAqIGBgYFxuICovXG52YXIgSGVsaXhDbGlwQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4Q2xpcEFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxpeENsaXBBUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsYXRlc3QgY2xpcHMgZm9yIHRoZSBzcGVjaWZpZWQgYnJvYWRjYXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcklkIFRoZSBicm9hZGNhc3RlcidzIHVzZXIgSUQuXG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqL1xuICAgIEhlbGl4Q2xpcEFQSS5wcm90b3R5cGUuZ2V0Q2xpcHNGb3JCcm9hZGNhc3RlciA9IGZ1bmN0aW9uICh1c2VySWQsIGZpbHRlcikge1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0Q2xpcHModHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBmaWx0ZXIpLCB7IGZpbHRlclR5cGU6ICdicm9hZGNhc3Rlcl9pZCcsIGlkczogdXNlcklkIH0pKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciB0aGUgbGF0ZXN0IGNsaXBzIGZvciB0aGUgc3BlY2lmaWVkIGJyb2FkY2FzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJJZCBUaGUgYnJvYWRjYXN0ZXIncyB1c2VyIElELlxuICAgICAqIEBwYXJhbSBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKi9cbiAgICBIZWxpeENsaXBBUEkucHJvdG90eXBlLmdldENsaXBzRm9yQnJvYWRjYXN0ZXJQYWdpbmF0ZWQgPSBmdW5jdGlvbiAodXNlcklkLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7IGZpbHRlciA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDbGlwc1BhZ2luYXRlZCh0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIGZpbHRlciksIHsgZmlsdGVyVHlwZTogJ2Jyb2FkY2FzdGVyX2lkJywgaWRzOiB1c2VySWQgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsYXRlc3QgY2xpcHMgZm9yIHRoZSBzcGVjaWZpZWQgZ2FtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBnYW1lSWQgVGhlIGdhbWUgSUQuXG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqL1xuICAgIEhlbGl4Q2xpcEFQSS5wcm90b3R5cGUuZ2V0Q2xpcHNGb3JHYW1lID0gZnVuY3Rpb24gKGdhbWVJZCwgZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9nZXRDbGlwcyh0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIGZpbHRlciksIHsgZmlsdGVyVHlwZTogJ2dhbWVfaWQnLCBpZHM6IGdhbWVJZCB9KSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgdGhlIGxhdGVzdCBjbGlwcyBmb3IgdGhlIHNwZWNpZmllZCBnYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdhbWVJZCBUaGUgZ2FtZSBJRC5cbiAgICAgKiBAcGFyYW0gZmlsdGVyXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICovXG4gICAgSGVsaXhDbGlwQVBJLnByb3RvdHlwZS5nZXRDbGlwc0ZvckdhbWVQYWdpbmF0ZWQgPSBmdW5jdGlvbiAoZ2FtZUlkLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7IGZpbHRlciA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDbGlwc1BhZ2luYXRlZCh0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIGZpbHRlciksIHsgZmlsdGVyVHlwZTogJ2dhbWVfaWQnLCBpZHM6IGdhbWVJZCB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNsaXBzIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElEcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZHMgVGhlIGNsaXAgSURzLlxuICAgICAqL1xuICAgIEhlbGl4Q2xpcEFQSS5wcm90b3R5cGUuZ2V0Q2xpcHNCeUlkcyA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldENsaXBzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkczogaWRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQuZGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjbGlwIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSBjbGlwIElELlxuICAgICAqL1xuICAgIEhlbGl4Q2xpcEFQSS5wcm90b3R5cGUuZ2V0Q2xpcEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xpcHM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRDbGlwc0J5SWRzKFtpZF0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2xpcHMubGVuZ3RoID8gY2xpcHNbMF0gOiBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xpcCBvZiBhIHJ1bm5pbmcgc3RyZWFtLlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIGNsaXAuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICovXG4gICAgSGVsaXhDbGlwQVBJLnByb3RvdHlwZS5jcmVhdGVDbGlwID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsSWQsIF9hLCBjcmVhdGVBZnRlckRlbGF5LCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZCA9IHBhcmFtcy5jaGFubmVsSWQsIF9hID0gcGFyYW1zLmNyZWF0ZUFmdGVyRGVsYXksIGNyZWF0ZUFmdGVyRGVsYXkgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2NsaXBzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnY2xpcHM6ZWRpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3Rlcl9pZDogY2hhbm5lbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzX2RlbGF5OiBjcmVhdGVBZnRlckRlbGF5LnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhWzBdLmlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeENsaXBBUEkucHJvdG90eXBlLl9nZXRDbGlwcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyVHlwZSwgaWRzLCBzdGFydERhdGUsIGVuZERhdGUsIF9hLCBsaW1pdCwgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlID0gcGFyYW1zLmZpbHRlclR5cGUsIGlkcyA9IHBhcmFtcy5pZHMsIHN0YXJ0RGF0ZSA9IHBhcmFtcy5zdGFydERhdGUsIGVuZERhdGUgPSBwYXJhbXMuZW5kRGF0ZSwgX2EgPSBwYXJhbXMubGltaXQsIGxpbWl0ID0gX2EgPT09IHZvaWQgMCA/IDIwIDogX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdjbGlwcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoX2IgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iW2ZpbHRlclR5cGVdID0gaWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc3RhcnRlZF9hdCA9IHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmVuZGVkX2F0ID0gZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmZpcnN0ID0gbGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEuY3JlYXRlUGFnaW5hdGVkUmVzdWx0KHJlc3VsdCwgSGVsaXhDbGlwXzEuZGVmYXVsdCwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVsaXhDbGlwQVBJLnByb3RvdHlwZS5fZ2V0Q2xpcHNQYWdpbmF0ZWQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbHRlclR5cGUgPSBwYXJhbXMuZmlsdGVyVHlwZSwgaWRzID0gcGFyYW1zLmlkcywgc3RhcnREYXRlID0gcGFyYW1zLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IHBhcmFtcy5lbmREYXRlO1xuICAgICAgICByZXR1cm4gbmV3IEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgdXJsOiAnY2xpcHMnLFxuICAgICAgICAgICAgcXVlcnk6IChfYSA9IHt9LFxuICAgICAgICAgICAgICAgIF9hW2ZpbHRlclR5cGVdID0gaWRzLFxuICAgICAgICAgICAgICAgIF9hLnN0YXJ0ZWRfYXQgPSBzdGFydERhdGUsXG4gICAgICAgICAgICAgICAgX2EuZW5kZWRfYXQgPSBlbmREYXRlLFxuICAgICAgICAgICAgICAgIF9hKVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhDbGlwXzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVsaXhDbGlwQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhDbGlwQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhDbGlwQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhDbGlwQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ud2l0Y2hDbGllbnRcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uLy4uL0Jhc2VBUElcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXN1bHRcIik7XG52YXIgSGVsaXhQYWdpbmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0aW9uXCIpO1xudmFyIEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL0hlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb25cIik7XG4vKipcbiAqIFRoZSBIZWxpeCBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBleHRlbnNpb25zLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmhlbGl4LmV4dGVuc2lvbnNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCB0cmFuc2FjdGlvbnMgPSBhd2FpdCBjbGllbnQuaGVsaXguZXh0aW9uc2lvbnMuZ2V0RXh0ZW5zaW9uVHJhbnNhY3Rpb25zKCdhYmNkJyk7XG4gKiBgYGBcbiAqL1xudmFyIEhlbGl4RXh0ZW5zaW9uc0FQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeEV4dGVuc2lvbnNBUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhFeHRlbnNpb25zQVBJKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIGZvciB0aGUgZ2l2ZW4gZXh0ZW5zaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV4dGVuc2lvbklkIFRoZSBJRCBvZiB0aGUgZXh0ZW5zaW9uIHRvIHJldHJpZXZlIHRyYW5zYWN0aW9ucyBmb3IuXG4gICAgICogQHBhcmFtIGZpbHRlciBBZGRpdGlvbmFsIGZpbHRlcnMuXG4gICAgICovXG4gICAgSGVsaXhFeHRlbnNpb25zQVBJLnByb3RvdHlwZS5nZXRFeHRlbnNpb25UcmFuc2FjdGlvbnMgPSBmdW5jdGlvbiAoZXh0ZW5zaW9uSWQsIGZpbHRlcikge1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdleHRlbnNpb25zL3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHRzbGliXzEuX19hc3NpZ24oeyBleHRlbnNpb25faWQ6IGV4dGVuc2lvbklkLCBpZDogZmlsdGVyLnRyYW5zYWN0aW9uSWRzIH0sIEhlbGl4UGFnaW5hdGlvbl8xLm1ha2VQYWdpbmF0aW9uUXVlcnkoZmlsdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEuY3JlYXRlUGFnaW5hdGVkUmVzdWx0KHJlc3VsdCwgSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbl8xLmRlZmF1bHQsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYWdpbmF0b3IgZm9yIHRyYW5zYWN0aW9ucyBmb3IgdGhlIGdpdmVuIGV4dGVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHRlbnNpb25JZCBUaGUgSUQgb2YgdGhlIGV4dGVuc2lvbiB0byByZXRyaWV2ZSB0cmFuc2FjdGlvbnMgZm9yLlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgQWRkaXRpb25hbCBmaWx0ZXJzLlxuICAgICAqL1xuICAgIEhlbGl4RXh0ZW5zaW9uc0FQSS5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uVHJhbnNhY3Rpb25zUGFnaW5hdGVkID0gZnVuY3Rpb24gKGV4dGVuc2lvbklkLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7IGZpbHRlciA9IHt9OyB9XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICdleHRlbnNpb25zL3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbl9pZDogZXh0ZW5zaW9uSWQsXG4gICAgICAgICAgICAgICAgaWQ6IGZpbHRlci50cmFuc2FjdGlvbklkc1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbl8xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEhlbGl4RXh0ZW5zaW9uc0FQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4RXh0ZW5zaW9uc0FQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4RXh0ZW5zaW9uc0FQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4RXh0ZW5zaW9uc0FQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVHdpdGNoQ2xpZW50XCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGVkUmVxdWVzdFwiKTtcbnZhciBIZWxpeFBhZ2luYXRlZFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGVkUmVzdWx0XCIpO1xudmFyIEhlbGl4UGFnaW5hdGlvbl8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGlvblwiKTtcbnZhciBIZWxpeEdhbWVfMSA9IHJlcXVpcmUoXCIuL0hlbGl4R2FtZVwiKTtcbi8qKlxuICogVGhlIEhlbGl4IEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIGdhbWVzLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmhlbGl4LmdhbWVzYCBvbiBhIHtAVHdpdGNoQ2xpZW50fSBpbnN0YW5jZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgY2xpZW50ID0gVHdpdGNoQ2xpZW50LndpdGhDcmVkZW50aWFscyhjbGllbnRJZCwgYWNjZXNzVG9rZW4pO1xuICogY29uc3QgZ2FtZSA9IGF3YWl0IGNsaWVudC5oZWxpeC5nYW1lcy5nZXRHYW1lQnlOYW1lKCdIZWFydGhzdG9uZScpO1xuICogYGBgXG4gKi9cbnZhciBIZWxpeEdhbWVBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGVsaXhHYW1lQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlbGl4R2FtZUFQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGdhbWUgZGF0YSBmb3IgdGhlIGdpdmVuIGxpc3Qgb2YgZ2FtZSBJRHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWRzIFRoZSBnYW1lIElEcyB5b3Ugd2FudCB0byBsb29rIHVwLlxuICAgICAqL1xuICAgIEhlbGl4R2FtZUFQSS5wcm90b3R5cGUuZ2V0R2FtZXNCeUlkcyA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0R2FtZXMoJ2lkJywgaWRzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGdhbWUgZGF0YSBmb3IgdGhlIGdpdmVuIGxpc3Qgb2YgZ2FtZSBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lcyBUaGUgZ2FtZSBuYW1lcyB5b3Ugd2FudCB0byBsb29rIHVwLlxuICAgICAqL1xuICAgIEhlbGl4R2FtZUFQSS5wcm90b3R5cGUuZ2V0R2FtZXNCeU5hbWVzID0gZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2dldEdhbWVzKCduYW1lJywgbmFtZXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZ2FtZSBkYXRhIGZvciB0aGUgZ2l2ZW4gZ2FtZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgZ2FtZSBJRCB5b3Ugd2FudCB0byBsb29rIHVwLlxuICAgICAqL1xuICAgIEhlbGl4R2FtZUFQSS5wcm90b3R5cGUuZ2V0R2FtZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ2FtZXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0R2FtZXMoJ2lkJywgaWQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2FtZXMubGVuZ3RoID8gZ2FtZXNbMF0gOiBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGdhbWUgZGF0YSBmb3IgdGhlIGdpdmVuIGdhbWUgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBnYW1lIG5hbWUgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKi9cbiAgICBIZWxpeEdhbWVBUEkucHJvdG90eXBlLmdldEdhbWVCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBnYW1lcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRHYW1lcygnbmFtZScsIG5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2FtZXMubGVuZ3RoID8gZ2FtZXNbMF0gOiBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIHRoZSBtb3N0IHZpZXdlZCBnYW1lcyBhdCB0aGUgbW9tZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhZ2luYXRpb24gUGFnaW5hdGlvbiBpbmZvLlxuICAgICAqL1xuICAgIEhlbGl4R2FtZUFQSS5wcm90b3R5cGUuZ2V0VG9wR2FtZXMgPSBmdW5jdGlvbiAocGFnaW5hdGlvbikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2dhbWVzL3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IEhlbGl4UGFnaW5hdGlvbl8xLm1ha2VQYWdpbmF0aW9uUXVlcnkocGFnaW5hdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEuY3JlYXRlUGFnaW5hdGVkUmVzdWx0KHJlc3VsdCwgSGVsaXhHYW1lXzEuZGVmYXVsdCwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgdGhlIG1vc3Qgdmlld2VkIGdhbWVzIGF0IHRoZSBtb21lbnQuXG4gICAgICovXG4gICAgSGVsaXhHYW1lQVBJLnByb3RvdHlwZS5nZXRUb3BHYW1lc1BhZ2luYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHVybDogJ2dhbWVzL3RvcCdcbiAgICAgICAgfSwgdGhpcy5fY2xpZW50LCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IEhlbGl4R2FtZV8xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pO1xuICAgIH07XG4gICAgSGVsaXhHYW1lQVBJLnByb3RvdHlwZS5fZ2V0R2FtZXMgPSBmdW5jdGlvbiAoZmlsdGVyVHlwZSwgZmlsdGVyVmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2dhbWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogKF9hID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hW2ZpbHRlclR5cGVdID0gZmlsdGVyVmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIG5ldyBIZWxpeEdhbWVfMS5kZWZhdWx0KGVudHJ5LCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIZWxpeEdhbWVBUEk7XG59KEJhc2VBUElfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEdhbWVBUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeEdhbWVBUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEdhbWVBUEk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1Rvb2xraXQvVXNlclRvb2xzXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL1R3aXRjaENsaWVudFwiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlcXVlc3RcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlc3VsdFwiKTtcbnZhciBIZWxpeFBhZ2luYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRpb25cIik7XG52YXIgSGVsaXhCYW5fMSA9IHJlcXVpcmUoXCIuL0hlbGl4QmFuXCIpO1xudmFyIEhlbGl4QmFuRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0hlbGl4QmFuRXZlbnRcIik7XG52YXIgSGVsaXhNb2RlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL0hlbGl4TW9kZXJhdG9yXCIpO1xudmFyIEhlbGl4TW9kZXJhdG9yRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0hlbGl4TW9kZXJhdG9yRXZlbnRcIik7XG4vKipcbiAqIFRoZSBIZWxpeCBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBtb2RlcmF0aW9uLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmhlbGl4Lm1vZGVyYXRpb25gIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBnYW1lID0gYXdhaXQgY2xpZW50LmhlbGl4Lm1vZGVyYXRpb24uZ2V0QmFubmVkVXNlcnMoJzYxMzY5MjIzJyk7XG4gKiBgYGBcbiAqL1xudmFyIEhlbGl4TW9kZXJhdGlvbkFQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeE1vZGVyYXRpb25BUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhNb2RlcmF0aW9uQVBJKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgYmFubmVkIHVzZXJzIGluIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHJldHJpZXZlIHRoZSBiYW5uZWQgdXNlcnMgZnJvbS5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIEFkZGl0aW9uYWwgZmlsdGVycyBmb3IgdGhlIHJlc3VsdCBzZXQuXG4gICAgICovXG4gICAgSGVsaXhNb2RlcmF0aW9uQVBJLnByb3RvdHlwZS5nZXRCYW5uZWRVc2VycyA9IGZ1bmN0aW9uIChjaGFubmVsLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ21vZGVyYXRpb24vYmFubmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ21vZGVyYXRpb246cmVhZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHRzbGliXzEuX19hc3NpZ24oeyBicm9hZGNhc3Rlcl9pZDogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKSwgdXNlcl9pZDogKF9hID0gZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlcklkIH0sIEhlbGl4UGFnaW5hdGlvbl8xLm1ha2VQYWdpbmF0aW9uUXVlcnkoZmlsdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEuY3JlYXRlUGFnaW5hdGVkUmVzdWx0KHJlc3VsdCwgSGVsaXhCYW5fMS5kZWZhdWx0LCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciBiYW5uZWQgdXNlcnMgaW4gYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gcmV0cmlldmUgdGhlIGJhbm5lZCB1c2VycyBmcm9tLlxuICAgICAqL1xuICAgIEhlbGl4TW9kZXJhdGlvbkFQSS5wcm90b3R5cGUuZ2V0QmFubmVkVXNlcnNQYWdpbmF0ZWQgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgdXJsOiAnbW9kZXJhdGlvbi9iYW5uZWQnLFxuICAgICAgICAgICAgc2NvcGU6ICdtb2RlcmF0aW9uOnJlYWQnLFxuICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3Rlcl9pZDogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhCYW5fMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gdXNlciBpcyBiYW5uZWQgaW4gYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gY2hlY2sgZm9yIGEgYmFuIG9mIHRoZSBnaXZlbiB1c2VyLlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHRvIGNoZWNrIGZvciBhIGJhbiBpbiB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRpb25BUEkucHJvdG90eXBlLmNoZWNrVXNlckJhbiA9IGZ1bmN0aW9uIChjaGFubmVsLCB1c2VyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZCwgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRCYW5uZWRVc2VycyhjaGFubmVsLCB7IHVzZXJJZDogdXNlcklkIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhLnNvbWUoZnVuY3Rpb24gKGJhbikgeyByZXR1cm4gYmFuLnVzZXJJZCA9PT0gdXNlcklkOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBiYW4gZXZlbnRzIGZvciBhIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byByZXRyaWV2ZSB0aGUgYmFuIGV2ZW50cyBmcm9tLlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgQWRkaXRpb25hbCBmaWx0ZXJzIGZvciB0aGUgcmVzdWx0IHNldC5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRpb25BUEkucHJvdG90eXBlLmdldEJhbkV2ZW50cyA9IGZ1bmN0aW9uIChjaGFubmVsLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnbW9kZXJhdGlvbi9iYW5uZWQvZXZlbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ21vZGVyYXRpb246cmVhZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHRzbGliXzEuX19hc3NpZ24oeyBicm9hZGNhc3Rlcl9pZDogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKSwgdXNlcl9pZDogKF9hID0gZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlcklkIH0sIEhlbGl4UGFnaW5hdGlvbl8xLm1ha2VQYWdpbmF0aW9uUXVlcnkoZmlsdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEubWFwKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhCYW5FdmVudF8xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IChfYiA9IHJlc3VsdC5wYWdpbmF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY3Vyc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgYmFuIGV2ZW50cyBmb3IgYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gcmV0cmlldmUgdGhlIGJhbiBldmVudHMgZnJvbS5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRpb25BUEkucHJvdG90eXBlLmdldEJhbkV2ZW50c1BhZ2luYXRlZCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICdtb2RlcmF0aW9uL2Jhbm5lZC9ldmVudHMnLFxuICAgICAgICAgICAgc2NvcGU6ICdtb2RlcmF0aW9uOnJlYWQnLFxuICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3Rlcl9pZDogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhCYW5FdmVudF8xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBtb2RlcmF0b3JzIGluIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHJldHJpZXZlIG1vZGVyYXRvcnMgZnJvbS5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIEFkZGl0aW9uYWwgZmlsdGVycyBmb3IgdGhlIHJlc3VsdCBzZXQuXG4gICAgICovXG4gICAgSGVsaXhNb2RlcmF0aW9uQVBJLnByb3RvdHlwZS5nZXRNb2RlcmF0b3JzID0gZnVuY3Rpb24gKGNoYW5uZWwsIGZpbHRlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnbW9kZXJhdGlvbi9tb2RlcmF0b3JzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ21vZGVyYXRpb246cmVhZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHRzbGliXzEuX19hc3NpZ24oeyBicm9hZGNhc3Rlcl9pZDogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKSwgdXNlcl9pZDogKF9hID0gZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlcklkIH0sIEhlbGl4UGFnaW5hdGlvbl8xLm1ha2VQYWdpbmF0aW9uUXVlcnkoZmlsdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEuY3JlYXRlUGFnaW5hdGVkUmVzdWx0KHJlc3VsdCwgSGVsaXhNb2RlcmF0b3JfMS5kZWZhdWx0LCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciBtb2RlcmF0b3JzIGluIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHJldHJpZXZlIG1vZGVyYXRvcnMgZnJvbS5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRpb25BUEkucHJvdG90eXBlLmdldE1vZGVyYXRvcnNQYWdpbmF0ZWQgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgdXJsOiAnbW9kZXJhdGlvbi9tb2RlcmF0b3JzJyxcbiAgICAgICAgICAgIHNjb3BlOiAnbW9kZXJhdGlvbjpyZWFkJyxcbiAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0ZXJfaWQ6IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fY2xpZW50LCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IEhlbGl4TW9kZXJhdG9yXzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIHVzZXIgaXMgYSBtb2RlcmF0b3Igb2YgYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgdG8gY2hlY2suXG4gICAgICovXG4gICAgSGVsaXhNb2RlcmF0aW9uQVBJLnByb3RvdHlwZS5jaGVja1VzZXJNb2QgPSBmdW5jdGlvbiAoY2hhbm5lbCwgdXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQsIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TW9kZXJhdG9ycyhjaGFubmVsLCB7IHVzZXJJZDogdXNlcklkIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhLnNvbWUoZnVuY3Rpb24gKG1vZCkgeyByZXR1cm4gbW9kLnVzZXJJZCA9PT0gdXNlcklkOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBtb2RlcmF0b3IgZXZlbnRzIGZvciBhIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byByZXRyaWV2ZSB0aGUgbW9kZXJhdG9yIGV2ZW50cyBmcm9tLlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgQWRkaXRpb25hbCBmaWx0ZXJzIGZvciB0aGUgcmVzdWx0IHNldC5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRpb25BUEkucHJvdG90eXBlLmdldE1vZGVyYXRvckV2ZW50cyA9IGZ1bmN0aW9uIChjaGFubmVsLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ21vZGVyYXRpb24vbW9kZXJhdG9ycy9ldmVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnbW9kZXJhdGlvbjpyZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogdHNsaWJfMS5fX2Fzc2lnbih7IGJyb2FkY2FzdGVyX2lkOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpLCB1c2VyX2lkOiAoX2EgPSBmaWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VySWQgfSwgSGVsaXhQYWdpbmF0aW9uXzEubWFrZVBhZ2luYXRpb25RdWVyeShmaWx0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMS5jcmVhdGVQYWdpbmF0ZWRSZXN1bHQocmVzdWx0LCBIZWxpeE1vZGVyYXRvckV2ZW50XzEuZGVmYXVsdCwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgbW9kZXJhdG9yIGV2ZW50cyBmb3IgYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gcmV0cmlldmUgdGhlIG1vZGVyYXRvciBldmVudHMgZnJvbS5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRpb25BUEkucHJvdG90eXBlLmdldE1vZGVyYXRvckV2ZW50c1BhZ2luYXRlZCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICdtb2RlcmF0aW9uL21vZGVyYXRvcnMvZXZlbnRzJyxcbiAgICAgICAgICAgIHNjb3BlOiAnbW9kZXJhdGlvbjpyZWFkJyxcbiAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0ZXJfaWQ6IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fY2xpZW50LCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IEhlbGl4TW9kZXJhdG9yRXZlbnRfMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIZWxpeE1vZGVyYXRpb25BUEk7XG59KEJhc2VBUElfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeE1vZGVyYXRpb25BUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeE1vZGVyYXRpb25BUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeE1vZGVyYXRpb25BUEk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIEhUVFBTdGF0dXNDb2RlRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FcnJvcnMvSFRUUFN0YXR1c0NvZGVFcnJvclwiKTtcbnZhciBTdHJlYW1Ob3RMaXZlRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FcnJvcnMvU3RyZWFtTm90TGl2ZUVycm9yXCIpO1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1Rvb2xraXQvVXNlclRvb2xzXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL1R3aXRjaENsaWVudFwiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlcXVlc3RcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlc3VsdFwiKTtcbnZhciBIZWxpeFBhZ2luYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRpb25cIik7XG52YXIgSGVsaXhTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL0hlbGl4U3RyZWFtXCIpO1xudmFyIEhlbGl4U3RyZWFtTWFya2VyXzEgPSByZXF1aXJlKFwiLi9IZWxpeFN0cmVhbU1hcmtlclwiKTtcbnZhciBIZWxpeFN0cmVhbU1hcmtlcldpdGhWaWRlb18xID0gcmVxdWlyZShcIi4vSGVsaXhTdHJlYW1NYXJrZXJXaXRoVmlkZW9cIik7XG4vKipcbiAqIFRoZSBIZWxpeCBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBzdHJlYW1zLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmhlbGl4LnN0cmVhbXNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBzdHJlYW0gPSBhd2FpdCBjbGllbnQuaGVsaXguc3RyZWFtcy5nZXRTdHJlYW1CeVVzZXJJZCgnMTI1MzI4NjU1Jyk7XG4gKiBgYGBcbiAqL1xudmFyIEhlbGl4U3RyZWFtQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4U3RyZWFtQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlbGl4U3RyZWFtQVBJKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2Ygc3RyZWFtcy5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbUFQSS5wcm90b3R5cGUuZ2V0U3RyZWFtcyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7IGZpbHRlciA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnc3RyZWFtcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgSGVsaXhQYWdpbmF0aW9uXzEubWFrZVBhZ2luYXRpb25RdWVyeShmaWx0ZXIpKSwgeyBjb21tdW5pdHlfaWQ6IGZpbHRlci5jb21tdW5pdHksIGdhbWVfaWQ6IGZpbHRlci5nYW1lLCBsYW5ndWFnZTogZmlsdGVyLmxhbmd1YWdlLCB0eXBlOiBmaWx0ZXIudHlwZSwgdXNlcl9pZDogZmlsdGVyLnVzZXJJZCwgdXNlcl9sb2dpbjogZmlsdGVyLnVzZXJOYW1lIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBIZWxpeFBhZ2luYXRlZFJlc3VsdF8xLmNyZWF0ZVBhZ2luYXRlZFJlc3VsdChyZXN1bHQsIEhlbGl4U3RyZWFtXzEuZGVmYXVsdCwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3Igc3RyZWFtcy5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbUFQSS5wcm90b3R5cGUuZ2V0U3RyZWFtc1BhZ2luYXRlZCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7IGZpbHRlciA9IHt9OyB9XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICdzdHJlYW1zJyxcbiAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgY29tbXVuaXR5X2lkOiBmaWx0ZXIuY29tbXVuaXR5LFxuICAgICAgICAgICAgICAgIGdhbWVfaWQ6IGZpbHRlci5nYW1lLFxuICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBmaWx0ZXIubGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgdHlwZTogZmlsdGVyLnR5cGUsXG4gICAgICAgICAgICAgICAgdXNlcl9pZDogZmlsdGVyLnVzZXJJZCxcbiAgICAgICAgICAgICAgICB1c2VyX2xvZ2luOiBmaWx0ZXIudXNlck5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fY2xpZW50LCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IEhlbGl4U3RyZWFtXzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc3RyZWFtIGZvciB0aGUgZ2l2ZW4gdXNlciBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgbmFtZSB0byByZXRyaWV2ZSB0aGUgc3RyZWFtIGZvci5cbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbUFQSS5wcm90b3R5cGUuZ2V0U3RyZWFtQnlVc2VyTmFtZSA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFN0cmVhbXMoeyB1c2VyTmFtZTogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJOYW1lKHVzZXIpIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhLmxlbmd0aCA/IHJlc3VsdC5kYXRhWzBdIDogbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHN0cmVhbSBmb3IgdGhlIGdpdmVuIHVzZXIgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciBJRCB0byByZXRyaWV2ZSB0aGUgc3RyZWFtIGZvci5cbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbUFQSS5wcm90b3R5cGUuZ2V0U3RyZWFtQnlVc2VySWQgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRTdHJlYW1zKHsgdXNlcklkOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhLmxlbmd0aCA/IHJlc3VsdC5kYXRhWzBdIDogbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgc3RyZWFtIG1hcmtlcnMgZm9yIGFuIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB0byBsaXN0IHRoZSBzdHJlYW0gbWFya2VycyBmb3IuXG4gICAgICovXG4gICAgSGVsaXhTdHJlYW1BUEkucHJvdG90eXBlLmdldFN0cmVhbU1hcmtlcnNGb3JVc2VyID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0U3RyZWFtTWFya2VycygndXNlcl9pZCcsIFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcikpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYWdpbmF0b3IgZm9yIGFsbCBzdHJlYW0gbWFya2VycyBmb3IgYW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHRvIGxpc3QgdGhlIHN0cmVhbSBtYXJrZXJzIGZvci5cbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbUFQSS5wcm90b3R5cGUuZ2V0U3RyZWFtTWFya2Vyc0ZvclVzZXJQYWdpbmF0ZWQgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3RyZWFtTWFya2Vyc1BhZ2luYXRlZCgndXNlcl9pZCcsIFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgc3RyZWFtIG1hcmtlcnMgZm9yIGEgdmlkZW8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlkZW9JZCBUaGUgdmlkZW8gdG8gbGlzdCB0aGUgc3RyZWFtIG1hcmtlcnMgZm9yLlxuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtQVBJLnByb3RvdHlwZS5nZXRTdHJlYW1NYXJrZXJzRm9yVmlkZW8gPSBmdW5jdGlvbiAodmlkZW9JZCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9nZXRTdHJlYW1NYXJrZXJzKCd2aWRlb19pZCcsIHZpZGVvSWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYWdpbmF0b3IgZm9yIGFsbCBzdHJlYW0gbWFya2VycyBmb3IgYSB2aWRlby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aWRlb0lkIFRoZSB2aWRlbyB0byBsaXN0IHRoZSBzdHJlYW0gbWFya2VycyBmb3IuXG4gICAgICovXG4gICAgSGVsaXhTdHJlYW1BUEkucHJvdG90eXBlLmdldFN0cmVhbU1hcmtlcnNGb3JWaWRlb1BhZ2luYXRlZCA9IGZ1bmN0aW9uICh2aWRlb0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTdHJlYW1NYXJrZXJzUGFnaW5hdGVkKCd2aWRlb19pZCcsIHZpZGVvSWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzdHJlYW0gbWFya2VyLlxuICAgICAqXG4gICAgICogT25seSB3b3JrcyB3aGlsZSB0aGUgc3BlY2lmaWVkIHVzZXIncyBzdHJlYW0gaXMgbGl2ZS5cbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbUFQSS5wcm90b3R5cGUuY3JlYXRlU3RyZWFtTWFya2VyID0gZnVuY3Rpb24gKHVzZXJJZCwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBlXzE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3N0cmVhbXMvbWFya2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICd1c2VyOmVkaXQ6YnJvYWRjYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEhlbGl4U3RyZWFtTWFya2VyXzEuZGVmYXVsdChyZXN1bHQuZGF0YVswXSwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEgaW5zdGFuY2VvZiBIVFRQU3RhdHVzQ29kZUVycm9yXzEuZGVmYXVsdCAmJiBlXzEuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0cmVhbU5vdExpdmVFcnJvcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVsaXhTdHJlYW1BUEkucHJvdG90eXBlLl9nZXRTdHJlYW1NYXJrZXJzID0gZnVuY3Rpb24gKHF1ZXJ5VHlwZSwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdzdHJlYW1zL21hcmtlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FbcXVlcnlUeXBlXSA9IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICd1c2VyOnJlYWQ6YnJvYWRjYXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzaGFyZWRfdXRpbHNfMS5mbGF0dGVuKHJlc3VsdC5kYXRhLm1hcChIZWxpeFN0cmVhbUFQSS5fbWFwR2V0U3RyZWFtTWFya2Vyc1Jlc3VsdC5iaW5kKHRoaXMuX2NsaWVudCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiByZXN1bHQucGFnaW5hdGlvbiAmJiByZXN1bHQucGFnaW5hdGlvbi5jdXJzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFN0cmVhbUFQSS5wcm90b3R5cGUuX2dldFN0cmVhbU1hcmtlcnNQYWdpbmF0ZWQgPSBmdW5jdGlvbiAocXVlcnlUeXBlLCBpZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICdzdHJlYW1zL21hcmtlcnMnLFxuICAgICAgICAgICAgcXVlcnk6IChfYSA9IHt9LFxuICAgICAgICAgICAgICAgIF9hW3F1ZXJ5VHlwZV0gPSBpZCxcbiAgICAgICAgICAgICAgICBfYSksXG4gICAgICAgICAgICBzY29wZTogJ3VzZXI6cmVhZDpicm9hZGNhc3QnXG4gICAgICAgIH0sIHRoaXMuX2NsaWVudCwgSGVsaXhTdHJlYW1BUEkuX21hcEdldFN0cmVhbU1hcmtlcnNSZXN1bHQuYmluZCh0aGlzLl9jbGllbnQpKTtcbiAgICB9O1xuICAgIEhlbGl4U3RyZWFtQVBJLl9tYXBHZXRTdHJlYW1NYXJrZXJzUmVzdWx0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGRhdGEudmlkZW9zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB2aWRlbykgeyByZXR1cm4gdHNsaWJfMS5fX3NwcmVhZChyZXN1bHQsIHZpZGVvLm1hcmtlcnMubWFwKGZ1bmN0aW9uIChtYXJrZXIpIHsgcmV0dXJuIG5ldyBIZWxpeFN0cmVhbU1hcmtlcldpdGhWaWRlb18xLmRlZmF1bHQobWFya2VyLCB2aWRlby52aWRlb19pZCwgX3RoaXMpOyB9KSk7IH0sIFtdKTtcbiAgICB9O1xuICAgIHJldHVybiBIZWxpeFN0cmVhbUFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4U3RyZWFtQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhTdHJlYW1BUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFN0cmVhbUFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgSGVsaXhTdHJlYW1NYXJrZXJfMSA9IHJlcXVpcmUoXCIuL0hlbGl4U3RyZWFtTWFya2VyXCIpO1xudmFyIEhlbGl4U3RyZWFtTWFya2VyV2l0aFZpZGVvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4U3RyZWFtTWFya2VyV2l0aFZpZGVvLCBfc3VwZXIpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4U3RyZWFtTWFya2VyV2l0aFZpZGVvKGRhdGEsIF92aWRlb0lkLCBjbGllbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGF0YSwgY2xpZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdmlkZW9JZCA9IF92aWRlb0lkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbU1hcmtlcldpdGhWaWRlby5wcm90b3R5cGUsIFwidXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgb2YgdGhlIHZpZGVvLCB3aGljaCB3aWxsIHN0YXJ0IHBsYXlpbmcgYXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzdHJlYW0gbWFya2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5VUkw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbU1hcmtlcldpdGhWaWRlby5wcm90b3R5cGUsIFwidmlkZW9JZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlkZW9JZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2aWRlbyBkYXRhIG9mIHRoZSB2aWRlbyB0aGUgbWFya2VyIHdhcyBzZXQgaW4uXG4gICAgICovXG4gICAgSGVsaXhTdHJlYW1NYXJrZXJXaXRoVmlkZW8ucHJvdG90eXBlLmdldFZpZGVvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudmlkZW9zLmdldFZpZGVvQnlJZCh0aGlzLl92aWRlb0lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVsaXhTdHJlYW1NYXJrZXJXaXRoVmlkZW87XG59KEhlbGl4U3RyZWFtTWFya2VyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdHJlYW1NYXJrZXJXaXRoVmlkZW87XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFN0cmVhbU1hcmtlcldpdGhWaWRlbztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4U3RyZWFtTWFya2VyV2l0aFZpZGVvO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBVc2VyVG9vbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ub29sa2l0L1VzZXJUb29sc1wiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ud2l0Y2hDbGllbnRcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uLy4uL0Jhc2VBUElcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXN1bHRcIik7XG52YXIgSGVsaXhTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuL0hlbGl4U3Vic2NyaXB0aW9uXCIpO1xudmFyIEhlbGl4U3Vic2NyaXB0aW9uRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0hlbGl4U3Vic2NyaXB0aW9uRXZlbnRcIik7XG4vKipcbiAqIFRoZSBIZWxpeCBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBzdWJzY3JpcHRpb25zLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmhlbGl4LnN1YnNjcmlwdGlvbnNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBzdWJzY3JpcHRpb25zID0gYXdhaXQgY2xpZW50LmhlbGl4LnN1YnNjcmlwdGlvbnMuZ2V0U3Vic2NyaXB0aW9uc0ZvclVzZXJzKCc2MTM2OTIyMycsICcxMjUzMjg2NTUnKTtcbiAqIGBgYFxuICovXG52YXIgSGVsaXhTdWJzY3JpcHRpb25BUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGVsaXhTdWJzY3JpcHRpb25BUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhTdWJzY3JpcHRpb25BUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgc3Vic2NyaXB0aW9ucyB0byBhIGdpdmVuIGJyb2FkY2FzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciB0byBsaXN0IHN1YnNjcmlwdGlvbnMgdG8uXG4gICAgICovXG4gICAgSGVsaXhTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoYnJvYWRjYXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdzdWJzY3JpcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ2NoYW5uZWw6cmVhZDpzdWJzY3JpcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3Rlcl9pZDogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChicm9hZGNhc3RlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBIZWxpeFBhZ2luYXRlZFJlc3VsdF8xLmNyZWF0ZVBhZ2luYXRlZFJlc3VsdChyZXN1bHQsIEhlbGl4U3Vic2NyaXB0aW9uXzEuZGVmYXVsdCwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgYWxsIHN1YnNjcmlwdGlvbnMgdG8gYSBnaXZlbiBicm9hZGNhc3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBicm9hZGNhc3RlciBUaGUgYnJvYWRjYXN0ZXIgdG8gbGlzdCBzdWJzY3JpcHRpb25zIHRvLlxuICAgICAqL1xuICAgIEhlbGl4U3Vic2NyaXB0aW9uQVBJLnByb3RvdHlwZS5nZXRTdWJzY3JpcHRpb25zUGFnaW5hdGVkID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICdzdWJzY3JpcHRpb25zJyxcbiAgICAgICAgICAgIHNjb3BlOiAnY2hhbm5lbDpyZWFkOnN1YnNjcmlwdGlvbnMnLFxuICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3Rlcl9pZDogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChicm9hZGNhc3RlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fY2xpZW50LCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IEhlbGl4U3Vic2NyaXB0aW9uXzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHN1YnNldCBvZiB0aGUgZ2l2ZW4gdXNlciBsaXN0IHRoYXQgaXMgc3Vic2NyaWJlZCB0byB0aGUgZ2l2ZW4gYnJvYWRjYXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIHRvIGZpbmQgc3Vic2NyaXB0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0gdXNlcnMgVGhlIHVzZXJzIHRoYXQgc2hvdWxkIGJlIGNoZWNrZWQgZm9yIHN1YnNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgSGVsaXhTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvbnNGb3JVc2VycyA9IGZ1bmN0aW9uIChicm9hZGNhc3RlciwgdXNlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnc3Vic2NyaXB0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdjaGFubmVsOnJlYWQ6c3Vic2NyaXB0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0ZXJfaWQ6IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoYnJvYWRjYXN0ZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyX2lkOiB1c2Vycy5tYXAoVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQuZGF0YS5tYXAoZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBIZWxpeFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHN1YnNjcmlwdGlvbiBkYXRhIGZvciBhIGdpdmVuIHVzZXIgdG8gYSBnaXZlbiBicm9hZGNhc3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBicm9hZGNhc3RlciBUaGUgYnJvYWRjYXN0ZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgdG8gY2hlY2suXG4gICAgICovXG4gICAgSGVsaXhTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvbkZvclVzZXIgPSBmdW5jdGlvbiAoYnJvYWRjYXN0ZXIsIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGlzdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFN1YnNjcmlwdGlvbnNGb3JVc2Vycyhicm9hZGNhc3RlciwgW3VzZXJdKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGlzdC5sZW5ndGggPyBsaXN0WzBdIDogbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBtb3N0IHJlY2VudCBzdWJzY3JpcHRpb24gZXZlbnRzIGZvciBhIGdpdmVuIGJyb2FkY2FzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciB0byByZXRyaWV2ZSBzdWJzY3JpcHRpb24gZXZlbnRzIGZvci5cbiAgICAgKi9cbiAgICBIZWxpeFN1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9uRXZlbnRzRm9yQnJvYWRjYXN0ZXIgPSBmdW5jdGlvbiAoYnJvYWRjYXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0U3Vic2NyaXB0aW9uRXZlbnRzKCdicm9hZGNhc3Rlcl9pZCcsIFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoYnJvYWRjYXN0ZXIpKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciB0aGUgcmVjZW50IHN1YnNjcmlwdGlvbiBldmVudHMgZm9yIGEgZ2l2ZW4gYnJvYWRjYXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIHRvIHJldHJpZXZlIHN1YnNjcmlwdGlvbiBldmVudHMgZm9yLlxuICAgICAqL1xuICAgIEhlbGl4U3Vic2NyaXB0aW9uQVBJLnByb3RvdHlwZS5nZXRTdWJzY3JpcHRpb25FdmVudHNGb3JCcm9hZGNhc3RlclBhZ2luYXRlZCA9IGZ1bmN0aW9uIChicm9hZGNhc3Rlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgdXJsOiAnc3Vic2NyaXB0aW9ucy9ldmVudHMnLFxuICAgICAgICAgICAgc2NvcGU6ICdjaGFubmVsOnJlYWQ6c3Vic2NyaXB0aW9ucycsXG4gICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdGVyX2lkOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGJyb2FkY2FzdGVyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhTdWJzY3JpcHRpb25FdmVudF8xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiBldmVudCBieSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgZXZlbnQgSUQuXG4gICAgICovXG4gICAgSGVsaXhTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvbkV2ZW50QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9nZXRTdWJzY3JpcHRpb25FdmVudHMoJ2lkJywgaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhlbGl4U3Vic2NyaXB0aW9uQVBJLnByb3RvdHlwZS5fZ2V0U3Vic2NyaXB0aW9uRXZlbnRzID0gZnVuY3Rpb24gKGJ5LCBpZCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3N1YnNjcmlwdGlvbnMvZXZlbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ2NoYW5uZWw6cmVhZDpzdWJzY3JpcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogKF9hID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hW2J5XSA9IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEuY3JlYXRlUGFnaW5hdGVkUmVzdWx0KHJlc3VsdCwgSGVsaXhTdWJzY3JpcHRpb25FdmVudF8xLmRlZmF1bHQsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIZWxpeFN1YnNjcmlwdGlvbkFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4U3Vic2NyaXB0aW9uQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhTdWJzY3JpcHRpb25BUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFN1YnNjcmlwdGlvbkFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FcnJvcnMvSGVsbEZyZWV6ZXNPdmVyRXJyb3JcIik7XG52YXIgVXNlclRvb2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVG9vbGtpdC9Vc2VyVG9vbHNcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVHdpdGNoQ2xpZW50XCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVxdWVzdFdpdGhUb3RhbF8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGVkUmVxdWVzdFdpdGhUb3RhbFwiKTtcbnZhciBIZWxpeFBhZ2luYXRlZFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGVkUmVzdWx0XCIpO1xudmFyIEhlbGl4Rm9sbG93XzEgPSByZXF1aXJlKFwiLi9IZWxpeEZvbGxvd1wiKTtcbnZhciBIZWxpeFByaXZpbGVnZWRVc2VyXzEgPSByZXF1aXJlKFwiLi9IZWxpeFByaXZpbGVnZWRVc2VyXCIpO1xudmFyIEhlbGl4VXNlcl8xID0gcmVxdWlyZShcIi4vSGVsaXhVc2VyXCIpO1xuLyoqIEBwcml2YXRlICovXG52YXIgVXNlckxvb2t1cFR5cGU7XG4oZnVuY3Rpb24gKFVzZXJMb29rdXBUeXBlKSB7XG4gICAgVXNlckxvb2t1cFR5cGVbXCJJZFwiXSA9IFwiaWRcIjtcbiAgICBVc2VyTG9va3VwVHlwZVtcIkxvZ2luXCJdID0gXCJsb2dpblwiO1xufSkoVXNlckxvb2t1cFR5cGUgfHwgKFVzZXJMb29rdXBUeXBlID0ge30pKTtcbmV4cG9ydHMuVXNlckxvb2t1cFR5cGUgPSBVc2VyTG9va3VwVHlwZTtcbi8qKlxuICogVGhlIEhlbGl4IEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIHVzZXJzLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmhlbGl4LnVzZXJzYCBvbiBhIHtAVHdpdGNoQ2xpZW50fSBpbnN0YW5jZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgY2xpZW50ID0gVHdpdGNoQ2xpZW50LndpdGhDcmVkZW50aWFscyhjbGllbnRJZCwgYWNjZXNzVG9rZW4pO1xuICogY29uc3QgdXNlciA9IGF3YWl0IGNsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCgnMTI1MzI4NjU1Jyk7XG4gKiBgYGBcbiAqL1xudmFyIEhlbGl4VXNlckFQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeFVzZXJBUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhVc2VyQVBJKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdXNlciBkYXRhIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiB1c2VyIElEcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VySWRzIFRoZSB1c2VyIElEcyB5b3Ugd2FudCB0byBsb29rIHVwLlxuICAgICAqL1xuICAgIEhlbGl4VXNlckFQSS5wcm90b3R5cGUuZ2V0VXNlcnNCeUlkcyA9IGZ1bmN0aW9uICh1c2VySWRzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2dldFVzZXJzKFVzZXJMb29rdXBUeXBlLklkLCB1c2VySWRzLm1hcChVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgZm9yIHRoZSBnaXZlbiBsaXN0IG9mIHVzZXIgbmFtZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlck5hbWVzIFRoZSB1c2VyIG5hbWVzIHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICovXG4gICAgSGVsaXhVc2VyQVBJLnByb3RvdHlwZS5nZXRVc2Vyc0J5TmFtZXMgPSBmdW5jdGlvbiAodXNlck5hbWVzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2dldFVzZXJzKFVzZXJMb29rdXBUeXBlLkxvZ2luLCB1c2VyTmFtZXMubWFwKFVzZXJUb29sc18xLmV4dHJhY3RVc2VyTmFtZSkpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdXNlciBkYXRhIGZvciB0aGUgZ2l2ZW4gdXNlciBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VySWQgVGhlIHVzZXIgSUQgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXJBUEkucHJvdG90eXBlLmdldFVzZXJCeUlkID0gZnVuY3Rpb24gKHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VycztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRVc2VycyhVc2VyTG9va3VwVHlwZS5JZCwgVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VySWQpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVzZXJzLmxlbmd0aCA/IHVzZXJzWzBdIDogbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgZm9yIHRoZSBnaXZlbiB1c2VyIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlck5hbWUgVGhlIHVzZXIgbmFtZSB5b3Ugd2FudCB0byBsb29rIHVwLlxuICAgICAqL1xuICAgIEhlbGl4VXNlckFQSS5wcm90b3R5cGUuZ2V0VXNlckJ5TmFtZSA9IGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VycztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRVc2VycyhVc2VyTG9va3VwVHlwZS5Mb2dpbiwgVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJOYW1lKHVzZXJOYW1lKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VycyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1c2Vycy5sZW5ndGggPyB1c2Vyc1swXSA6IG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdXNlciBkYXRhIG9mIHRoZSBjdXJyZW50bHkgYXV0aGVudGljYXRlZCB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpdGhFbWFpbCBXaGV0aGVyIHlvdSBuZWVkIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXJBUEkucHJvdG90eXBlLmdldE1lID0gZnVuY3Rpb24gKHdpdGhFbWFpbCkge1xuICAgICAgICBpZiAod2l0aEVtYWlsID09PSB2b2lkIDApIHsgd2l0aEVtYWlsID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICd1c2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHdpdGhFbWFpbCA/ICd1c2VyOnJlYWQ6ZW1haWwnIDogJydcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZGF0YSB8fCAhcmVzdWx0LmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEhlbGxGcmVlemVzT3ZlckVycm9yXzEuZGVmYXVsdCgnQ291bGQgbm90IGdldCBhdXRoZW50aWNhdGVkIHVzZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgSGVsaXhQcml2aWxlZ2VkVXNlcl8xLmRlZmF1bHQocmVzdWx0LmRhdGFbMF0sIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIncyBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gdXBkYXRlLlxuICAgICAqL1xuICAgIEhlbGl4VXNlckFQSS5wcm90b3R5cGUudXBkYXRlVXNlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAndXNlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICd1c2VyOmVkaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkYXRhLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEhlbGl4UHJpdmlsZWdlZFVzZXJfMS5kZWZhdWx0KHJlc3VsdC5kYXRhWzBdLCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGZvbGxvdyByZWxhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyIFNldmVyYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uIHBhcmFtZXRlcnMuIFNlZSB0aGUge0BIZWxpeEZvbGxvd0ZpbHRlcn0gZG9jdW1lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXJBUEkucHJvdG90eXBlLmdldEZvbGxvd3MgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5LCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gSGVsaXhVc2VyQVBJLl9tYWtlRm9sbG93c1F1ZXJ5KGZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3VzZXJzL2ZvbGxvd3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMS5jcmVhdGVQYWdpbmF0ZWRSZXN1bHRXaXRoVG90YWwocmVzdWx0LCBIZWxpeEZvbGxvd18xLmRlZmF1bHQsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYWdpbmF0b3IgZm9yIGZvbGxvdyByZWxhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyIFNldmVyYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uIHBhcmFtZXRlcnMuIFNlZSB0aGUge0BIZWxpeEZvbGxvd0ZpbHRlcn0gZG9jdW1lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXJBUEkucHJvdG90eXBlLmdldEZvbGxvd3NQYWdpbmF0ZWQgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeSA9IEhlbGl4VXNlckFQSS5fbWFrZUZvbGxvd3NRdWVyeShmaWx0ZXIpO1xuICAgICAgICByZXR1cm4gbmV3IEhlbGl4UGFnaW5hdGVkUmVxdWVzdFdpdGhUb3RhbF8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgdXJsOiAndXNlcnMvZm9sbG93cycsXG4gICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgfSwgdGhpcy5fY2xpZW50LCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IEhlbGl4Rm9sbG93XzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICBIZWxpeFVzZXJBUEkuX21ha2VGb2xsb3dzUXVlcnkgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IHt9O1xuICAgICAgICB2YXIgaGFzVXNlcklkUGFyYW0gPSBmYWxzZTtcbiAgICAgICAgaWYgKGZpbHRlci51c2VyKSB7XG4gICAgICAgICAgICBxdWVyeS5mcm9tX2lkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChmaWx0ZXIudXNlcik7XG4gICAgICAgICAgICBoYXNVc2VySWRQYXJhbSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlci5mb2xsb3dlZFVzZXIpIHtcbiAgICAgICAgICAgIHF1ZXJ5LnRvX2lkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChmaWx0ZXIuZm9sbG93ZWRVc2VyKTtcbiAgICAgICAgICAgIGhhc1VzZXJJZFBhcmFtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc1VzZXJJZFBhcmFtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdCBsZWFzdCBvbmUgb2YgdXNlciBhbmQgZm9sbG93ZWRVc2VyIGhhdmUgdG8gYmUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH07XG4gICAgSGVsaXhVc2VyQVBJLnByb3RvdHlwZS5fZ2V0VXNlcnMgPSBmdW5jdGlvbiAobG9va3VwVHlwZSwgcGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnksIHJlc3VsdDtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gKF9hID0ge30sIF9hW2xvb2t1cFR5cGVdID0gcGFyYW0sIF9hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3VzZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LmRhdGEubWFwKGZ1bmN0aW9uICh1c2VyRGF0YSkgeyByZXR1cm4gbmV3IEhlbGl4VXNlcl8xLmRlZmF1bHQodXNlckRhdGEsIF90aGlzLl9jbGllbnQpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEhlbGl4VXNlckFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4VXNlckFQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4VXNlckFQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXNlckxvb2t1cFR5cGUgPSBVc2VyTG9va3VwVHlwZTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4VXNlckFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgVXNlclRvb2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVG9vbGtpdC9Vc2VyVG9vbHNcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVHdpdGNoQ2xpZW50XCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGVkUmVxdWVzdFwiKTtcbnZhciBIZWxpeFBhZ2luYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRpb25cIik7XG52YXIgSGVsaXhWaWRlb18xID0gcmVxdWlyZShcIi4vSGVsaXhWaWRlb1wiKTtcbi8qKlxuICogVGhlIEhlbGl4IEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIHZpZGVvcy5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcgYGNsaWVudC5oZWxpeC52aWRlb3NgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCB2aWRlb3MgPSBhd2FpdCBjbGllbnQuaGVsaXgudmlkZW9zLmdldFZpZGVvc0J5VXNlcignMTI1MzI4NjU1Jyk7XG4gKiBgYGBcbiAqL1xudmFyIEhlbGl4VmlkZW9BUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGVsaXhWaWRlb0FQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxpeFZpZGVvQVBJKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmlkZW8gZGF0YSBmb3IgdGhlIGdpdmVuIGxpc3Qgb2YgdmlkZW8gSURzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkcyBUaGUgdmlkZW8gSURzIHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICovXG4gICAgSGVsaXhWaWRlb0FQSS5wcm90b3R5cGUuZ2V0VmlkZW9zQnlJZHMgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRWaWRlb3MoJ2lkJywgaWRzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQuZGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2aWRlbyBkYXRhIGZvciB0aGUgZ2l2ZW4gdmlkZW8gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIHZpZGVvIElEIHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICovXG4gICAgSGVsaXhWaWRlb0FQSS5wcm90b3R5cGUuZ2V0VmlkZW9CeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZpZGVvcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFZpZGVvc0J5SWRzKGlkKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB2aWRlb3MubGVuZ3RoID8gdmlkZW9zWzBdIDogbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2aWRlb3Mgb2YgdGhlIGdpdmVuIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB5b3Ugd2FudCB0byByZXRyaWV2ZSB2aWRlb3MgZnJvbS5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIEFkZGl0aW9uYWwgZmlsdGVycyBmb3IgdGhlIHJlc3VsdCBzZXQuXG4gICAgICovXG4gICAgSGVsaXhWaWRlb0FQSS5wcm90b3R5cGUuZ2V0VmlkZW9zQnlVc2VyID0gZnVuY3Rpb24gKHVzZXIsIGZpbHRlcikge1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0VmlkZW9zKCd1c2VyX2lkJywgdXNlcklkLCBmaWx0ZXIpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYWdpbmF0b3IgZm9yIHZpZGVvcyBvZiB0aGUgZ2l2ZW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIHJldHJpZXZlIHZpZGVvcyBmcm9tLlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgQWRkaXRpb25hbCBmaWx0ZXJzIGZvciB0aGUgcmVzdWx0IHNldC5cbiAgICAgKi9cbiAgICBIZWxpeFZpZGVvQVBJLnByb3RvdHlwZS5nZXRWaWRlb3NCeVVzZXJQYWdpbmF0ZWQgPSBmdW5jdGlvbiAodXNlciwgZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSB7fTsgfVxuICAgICAgICB2YXIgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFZpZGVvc1BhZ2luYXRlZCgndXNlcl9pZCcsIHVzZXJJZCwgZmlsdGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmlkZW9zIG9mIHRoZSBnaXZlbiBnYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdhbWVJZCBUaGUgZ2FtZSB5b3Ugd2FudCB0byByZXRyaWV2ZSB2aWRlb3MgZnJvbS5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIEFkZGl0aW9uYWwgZmlsdGVycyBmb3IgdGhlIHJlc3VsdCBzZXQuXG4gICAgICovXG4gICAgSGVsaXhWaWRlb0FQSS5wcm90b3R5cGUuZ2V0VmlkZW9zQnlHYW1lID0gZnVuY3Rpb24gKGdhbWVJZCwgZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9nZXRWaWRlb3MoJ2dhbWVfaWQnLCBnYW1lSWQsIGZpbHRlcildO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgdmlkZW9zIG9mIHRoZSBnaXZlbiBnYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdhbWVJZCBUaGUgZ2FtZSB5b3Ugd2FudCB0byByZXRyaWV2ZSB2aWRlb3MgZnJvbS5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIEFkZGl0aW9uYWwgZmlsdGVycyBmb3IgdGhlIHJlc3VsdCBzZXQuXG4gICAgICovXG4gICAgSGVsaXhWaWRlb0FQSS5wcm90b3R5cGUuZ2V0VmlkZW9zQnlHYW1lUGFnaW5hdGVkID0gZnVuY3Rpb24gKGdhbWVJZCwgZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VmlkZW9zUGFnaW5hdGVkKCdnYW1lX2lkJywgZ2FtZUlkLCBmaWx0ZXIpO1xuICAgIH07XG4gICAgSGVsaXhWaWRlb0FQSS5wcm90b3R5cGUuX2dldFZpZGVvcyA9IGZ1bmN0aW9uIChmaWx0ZXJUeXBlLCBmaWx0ZXJWYWx1ZXMsIGZpbHRlcikge1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAndmlkZW9zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBIZWxpeFZpZGVvQVBJLl9tYWtlVmlkZW9zUXVlcnkoZmlsdGVyVHlwZSwgZmlsdGVyVmFsdWVzLCBmaWx0ZXIpKSwgSGVsaXhQYWdpbmF0aW9uXzEubWFrZVBhZ2luYXRpb25RdWVyeShmaWx0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHQuZGF0YS5tYXAoZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBIZWxpeFZpZGVvXzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogcmVzdWx0LnBhZ2luYXRpb24gJiYgcmVzdWx0LnBhZ2luYXRpb24uY3Vyc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVsaXhWaWRlb0FQSS5wcm90b3R5cGUuX2dldFZpZGVvc1BhZ2luYXRlZCA9IGZ1bmN0aW9uIChmaWx0ZXJUeXBlLCBmaWx0ZXJWYWx1ZXMsIGZpbHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHVybDogJ3ZpZGVvcycsXG4gICAgICAgICAgICBxdWVyeTogSGVsaXhWaWRlb0FQSS5fbWFrZVZpZGVvc1F1ZXJ5KGZpbHRlclR5cGUsIGZpbHRlclZhbHVlcywgZmlsdGVyKVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhWaWRlb18xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pO1xuICAgIH07XG4gICAgSGVsaXhWaWRlb0FQSS5fbWFrZVZpZGVvc1F1ZXJ5ID0gZnVuY3Rpb24gKGZpbHRlclR5cGUsIGZpbHRlclZhbHVlcywgZmlsdGVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7IGZpbHRlciA9IHt9OyB9XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IGZpbHRlci5sYW5ndWFnZSwgcGVyaW9kID0gZmlsdGVyLnBlcmlvZCwgb3JkZXJCeSA9IGZpbHRlci5vcmRlckJ5LCB0eXBlID0gZmlsdGVyLnR5cGU7XG4gICAgICAgIHJldHVybiBfYSA9IHt9LFxuICAgICAgICAgICAgX2FbZmlsdGVyVHlwZV0gPSBmaWx0ZXJWYWx1ZXMsXG4gICAgICAgICAgICBfYS5sYW5ndWFnZSA9IGxhbmd1YWdlLFxuICAgICAgICAgICAgX2EucGVyaW9kID0gcGVyaW9kLFxuICAgICAgICAgICAgX2Euc29ydCA9IG9yZGVyQnksXG4gICAgICAgICAgICBfYS50eXBlID0gdHlwZSxcbiAgICAgICAgICAgIF9hO1xuICAgIH07XG4gICAgcmV0dXJuIEhlbGl4VmlkZW9BUEk7XG59KEJhc2VBUElfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFZpZGVvQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhWaWRlb0FQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4VmlkZW9BUEk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1Rvb2xraXQvVXNlclRvb2xzXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL1R3aXRjaENsaWVudFwiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBIZWxpeFBhZ2luYXRlZFJlcXVlc3RXaXRoVG90YWxfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlcXVlc3RXaXRoVG90YWxcIik7XG52YXIgSGVsaXhXZWJIb29rU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9IZWxpeFdlYkhvb2tTdWJzY3JpcHRpb25cIik7XG4vKipcbiAqIFRoZSBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBXZWJIb29rcy5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcgYGNsaWVudC5oZWxpeC53ZWJIb29rc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgQmVmb3JlIHVzaW5nIHRoZXNlIG1ldGhvZHMuLi5cbiAqXG4gKiBBbGwgb2YgdGhlIG1ldGhvZHMgaW4gdGhpcyBjbGFzcyBhc3N1bWUgdGhhdCB5b3UgYXJlIGFscmVhZHkgcnVubmluZyBhIHdvcmtpbmcgV2ViSG9vayBsaXN0ZW5lciBhdCB0aGUgZ2l2ZW4gY2FsbGJhY2sgVVJMLlxuICpcbiAqIElmIHlvdSBkb24ndCBhbHJlYWR5IGhhdmUgb25lLCB3ZSByZWNvbW1lbmQgdXNlIG9mIHRoZSBgdHdpdGNoLXdlYmhvb2tzYCBsaWJyYXJ5LCB3aGljaCBoYW5kbGVzIHN1YnNjcmliaW5nIGFuZCB1bnN1YnNjcmliaW5nIHRvIHRoZXNlIHRvcGljcyBhdXRvbWF0aWNhbGx5LlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBhY2NlcHRlZCA9IGF3YWl0IGNsaWVudC5oZWxpeC53ZWJIb29rcy5zdWJzY3JpYmVUb1VzZXJGb2xsb3dzVG8oJzEyNTMyODY1NScsIHsgY2FsbGJhY2tVcmw6ICdodHRwczovL2V4YW1wbGUuY29tJyB9KTtcbiAqIGBgYFxuICovXG52YXIgSGVsaXhXZWJIb29rc0FQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeFdlYkhvb2tzQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlbGl4V2ViSG9va3NBUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IFdlYkhvb2sgc3Vic2NyaXB0aW9ucyBmb3IgdGhlIGN1cnJlbnQgY2xpZW50LlxuICAgICAqXG4gICAgICogUmVxdWlyZXMgYW4gYXBwIGFjY2VzcyB0b2tlbiB0byB3b3JrOyBkb2VzIG5vdCB3b3JrIHdpdGggdXNlciB0b2tlbnMuXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBIZWxpeFBhZ2luYXRlZFJlcXVlc3RXaXRoVG90YWxfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3dlYmhvb2tzL3N1YnNjcmlwdGlvbnMnXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuX2NsaWVudCwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBIZWxpeFdlYkhvb2tTdWJzY3JpcHRpb25fMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBhcmJpdHJhcnkgcmVxdWVzdCB0byBzdWJzY3JpYmUgdG8gb3IgdW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5zZW5kSHViUmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1vZGUsIGNhbGxiYWNrVXJsLCB0b3BpY1VybCwgX2EsIHZhbGlkaXR5SW5TZWNvbmRzLCBzZWNyZXQsIHNjb3BlO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gb3B0aW9ucy5tb2RlLCBjYWxsYmFja1VybCA9IG9wdGlvbnMuY2FsbGJhY2tVcmwsIHRvcGljVXJsID0gb3B0aW9ucy50b3BpY1VybCwgX2EgPSBvcHRpb25zLnZhbGlkaXR5SW5TZWNvbmRzLCB2YWxpZGl0eUluU2Vjb25kcyA9IF9hID09PSB2b2lkIDAgPyAzNjAwIDogX2EsIHNlY3JldCA9IG9wdGlvbnMuc2VjcmV0LCBzY29wZSA9IG9wdGlvbnMuc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3dlYmhvb2tzL2h1YicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uQm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h1Yi5tb2RlJzogbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdodWIudG9waWMnOiB0b3BpY1VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdodWIuY2FsbGJhY2snOiBjYWxsYmFja1VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdodWIubGVhc2Vfc2Vjb25kcyc6IG1vZGUgPT09ICdzdWJzY3JpYmUnID8gdmFsaWRpdHlJblNlY29uZHMudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdodWIuc2VjcmV0Jzogc2VjcmV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGV2ZW50cyByZXByZXNlbnRpbmcgYSB1c2VyIGZvbGxvd2luZyBvdGhlciB1c2Vycy5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIGZvciB3aGljaCB0byBnZXQgbm90aWZpY2F0aW9ucyBhYm91dCB0aGUgdXNlcnMgdGhleSB3aWxsIGZvbGxvdy5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnN1YnNjcmliZVRvVXNlckZvbGxvd3NGcm9tID0gZnVuY3Rpb24gKHVzZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fc2VuZFVzZXJGb2xsb3dzSHViUmVxdWVzdCgnc3Vic2NyaWJlJywgJ2Zyb20nLCB1c2VyLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGV2ZW50cyByZXByZXNlbnRpbmcgYSB1c2VyIGJlaW5nIGZvbGxvd2VkIGJ5IG90aGVyIHVzZXJzLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgZm9yIHdoaWNoIHRvIGdldCBub3RpZmljYXRpb25zIGFib3V0IHRoZSB1c2VycyB0aGV5IHdpbGwgYmUgZm9sbG93ZWQgYnkuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5zdWJzY3JpYmVUb1VzZXJGb2xsb3dzVG8gPSBmdW5jdGlvbiAodXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kVXNlckZvbGxvd3NIdWJSZXF1ZXN0KCdzdWJzY3JpYmUnLCAndG8nLCB1c2VyLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBldmVudHMgcmVwcmVzZW50aW5nIGEgdXNlciBmb2xsb3dpbmcgb3RoZXIgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciBmb3Igd2hpY2ggdG8gbm90IGdldCBhbnkgbW9yZSBub3RpZmljYXRpb25zIGFib3V0IHRoZSB1c2VycyB0aGV5IHdpbGwgZm9sbG93LlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUudW5zdWJzY3JpYmVGcm9tVXNlckZvbGxvd3NGcm9tID0gZnVuY3Rpb24gKHVzZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fc2VuZFVzZXJGb2xsb3dzSHViUmVxdWVzdCgndW5zdWJzY3JpYmUnLCAnZnJvbScsIHVzZXIsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGV2ZW50cyByZXByZXNlbnRpbmcgYSB1c2VyIGJlaW5nIGZvbGxvd2VkIGJ5IG90aGVyIHVzZXJzLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgZm9yIHdoaWNoIHRvIG5vdCBnZXQgYW55IG1vcmUgbm90aWZpY2F0aW9ucyBhYm91dCB0aGUgdXNlcnMgdGhleSB3aWxsIGJlIGZvbGxvd2VkIGJ5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUudW5zdWJzY3JpYmVGcm9tVXNlckZvbGxvd3NUbyA9IGZ1bmN0aW9uICh1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRVc2VyRm9sbG93c0h1YlJlcXVlc3QoJ3Vuc3Vic2NyaWJlJywgJ3RvJywgdXNlciwgb3B0aW9ucyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBldmVudHMgcmVwcmVzZW50aW5nIGEgc3RyZWFtIGNoYW5naW5nLCBpLmUuIGdvaW5nIGxpdmUsIG9mZmxpbmUgb3IgY2hhbmdpbmcgaXRzIHRpdGxlIG9yIGNhdGVnb3J5LlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgZm9yIHdoaWNoIHRvIGdldCBub3RpZmljYXRpb25zIGFib3V0IHRoZWlyIHN0cmVhbXMgY2hhbmdpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5zdWJzY3JpYmVUb1N0cmVhbUNoYW5nZXMgPSBmdW5jdGlvbiAodXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kU3RyZWFtQ2hhbmdlSHViUmVxdWVzdCgnc3Vic2NyaWJlJywgdXNlciwgb3B0aW9ucyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gZXZlbnRzIHJlcHJlc2VudGluZyBhIHN0cmVhbSBjaGFuZ2luZy5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIGZvciB3aGljaCBub3QgdG8gZ2V0IGFueSBtb3JlIG5vdGlmaWNhdGlvbnMgYWJvdXQgdGhlaXIgc3RyZWFtcyBjaGFuZ2luZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnVuc3Vic2NyaWJlRnJvbVN0cmVhbUNoYW5nZXMgPSBmdW5jdGlvbiAodXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kU3RyZWFtQ2hhbmdlSHViUmVxdWVzdCgndW5zdWJzY3JpYmUnLCB1c2VyLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGV2ZW50cyByZXByZXNlbnRpbmcgYSB1c2VyIGNoYW5naW5nIGEgcHVibGljIHNldHRpbmcgb3IgdGhlaXIgZW1haWwgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIGZvciB3aGljaCB0byBnZXQgbm90aWZpY2F0aW9ucyBhYm91dCBjaGFuZ2luZyBhIHNldHRpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gd2l0aEVtYWlsIFdoZXRoZXIgdG8gc3Vic2NyaWJlIHRvIGVtYWlsIGFkZHJlc3MgY2hhbmdlcy4gVGhpcyBhZGRzIHRoZSBuZWNlc3Nhcnkgc2NvcGUgdG8gcmVhZCB0aGUgZW1haWwgYWRkcmVzcyB0byB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5zdWJzY3JpYmVUb1VzZXJDaGFuZ2VzID0gZnVuY3Rpb24gKHVzZXIsIG9wdGlvbnMsIHdpdGhFbWFpbCkge1xuICAgICAgICBpZiAod2l0aEVtYWlsID09PSB2b2lkIDApIHsgd2l0aEVtYWlsID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fc2VuZFVzZXJDaGFuZ2VIdWJSZXF1ZXN0KCdzdWJzY3JpYmUnLCB1c2VyLCBvcHRpb25zLCB3aXRoRW1haWwpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGV2ZW50cyByZXByZXNlbnRpbmcgYSB1c2VyIGNoYW5naW5nIGEgcHVibGljIHNldHRpbmcgb3IgdGhlaXIgZW1haWwgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIGZvciB3aGljaCBub3QgdG8gZ2V0IGFueSBtb3JlIG5vdGlmaWNhdGlvbnMgYWJvdXQgY2hhbmdpbmcgYSBzZXR0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUudW5zdWJzY3JpYmVGcm9tVXNlckNoYW5nZXMgPSBmdW5jdGlvbiAodXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kVXNlckNoYW5nZUh1YlJlcXVlc3QoJ3Vuc3Vic2NyaWJlJywgdXNlciwgb3B0aW9ucyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBldmVudHMgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBvciBlbmQgb2YgYSBjaGFubmVsIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIGZvciB3aGljaCB0byBnZXQgbm90aWZpY2F0aW9ucyBhYm91dCBzdWJzY3JpcHRpb25zIHRvIHRoZWlyIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5zdWJzY3JpYmVUb1N1YnNjcmlwdGlvbkV2ZW50cyA9IGZ1bmN0aW9uICh1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRTdWJzY3JpcHRpb25FdmVudHNIdWJSZXF1ZXN0KCdzdWJzY3JpYmUnLCB1c2VyLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBldmVudHMgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBvciBlbmQgb2YgYSBjaGFubmVsIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIGZvciB3aGljaCBub3QgdG8gZ2V0IGFueSBtb3JlIG5vdGlmaWNhdGlvbnMgYWJvdXQgc3Vic2NyaXB0aW9ucyBhbmQgdW5zdWJzY3JpcHRpb25zIHRvIHRoZWlyIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS51bnN1YnNjcmliZUZyb21TdWJzY3JpcHRpb25FdmVudHMgPSBmdW5jdGlvbiAodXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kU3Vic2NyaXB0aW9uRXZlbnRzSHViUmVxdWVzdCgndW5zdWJzY3JpYmUnLCB1c2VyLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGV4dGVuc2lvbiB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9uSWQgVGhlIGV4dGVuc2lvbiBJRCBmb3Igd2hpY2ggdG8gZ2V0IG5vdGlmaWNhdGlvbnMgYWJvdXQgdHJhbnNhY3Rpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUuc3Vic2NyaWJlVG9FeHRlbnNpb25UcmFuc2FjdGlvbnMgPSBmdW5jdGlvbiAoZXh0ZW5zaW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fc2VuZEV4dGVuc2lvblRyYW5zYWN0aW9uc0h1YlJlcXVlc3QoJ3N1YnNjcmliZScsIGV4dGVuc2lvbklkLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBleHRlbnNpb24gdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIGV4dGVuc2lvbklkIFRoZSBleHRlbnNpb24gSUQgZm9yIHdoaWNoIG5vdCB0byBnZXQgYW55IG1vcmUgbm90aWZpY2F0aW9ucyBhYm91dCB0cmFuc2FjdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS51bnN1YnNjcmliZUZyb21FeHRlbnNpb25UcmFuc2FjdGlvbnMgPSBmdW5jdGlvbiAoZXh0ZW5zaW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fc2VuZEV4dGVuc2lvblRyYW5zYWN0aW9uc0h1YlJlcXVlc3QoJ3Vuc3Vic2NyaWJlJywgZXh0ZW5zaW9uSWQsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gZXZlbnRzIHJlcHJlc2VudGluZyBhIGJhbiBvciB1bmJhbi5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBicm9hZGNhc3RlciBUaGUgYnJvYWRjYXN0ZXIgZm9yIHdoaWNoIHRvIGdldCBub3RpZmljYXRpb25zIGFib3V0IGJhbnMgb3IgdW5iYW5zIGluIHRoZWlyIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5zdWJzY3JpYmVUb0JhbkV2ZW50cyA9IGZ1bmN0aW9uIChicm9hZGNhc3Rlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kQmFuRXZlbnRzSHViUmVxdWVzdCgnc3Vic2NyaWJlJywgYnJvYWRjYXN0ZXIsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGV2ZW50cyByZXByZXNlbnRpbmcgYSBiYW4gb3IgdW5iYW4uXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIGZvciB3aGljaCBub3QgdG8gZ2V0IGFueSBtb3JlIG5vdGlmaWNhdGlvbnMgYWJvdXQgYmFucyBvciB1bmJhbnMgaW4gdGhlaXIgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnVuc3Vic2NyaWJlRnJvbUJhbkV2ZW50cyA9IGZ1bmN0aW9uIChicm9hZGNhc3Rlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kQmFuRXZlbnRzSHViUmVxdWVzdCgndW5zdWJzY3JpYmUnLCBicm9hZGNhc3Rlciwgb3B0aW9ucyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBldmVudHMgcmVwcmVzZW50aW5nIGEgYmFuIG9yIHVuYmFuLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciBmb3Igd2hpY2ggdG8gZ2V0IG5vdGlmaWNhdGlvbnMgYWJvdXQgYmFucyBvciB1bmJhbnMgaW4gdGhlaXIgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB0aGF0IGlzIGJlaW5nIGJhbm5lZCBvciB1bmJhbm5lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnN1YnNjcmliZVRvQmFuRXZlbnRzRm9yVXNlciA9IGZ1bmN0aW9uIChicm9hZGNhc3RlciwgdXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kQmFuRXZlbnRzSHViUmVxdWVzdCgnc3Vic2NyaWJlJywgYnJvYWRjYXN0ZXIsIG9wdGlvbnMsIHVzZXIpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGV2ZW50cyByZXByZXNlbnRpbmcgYSBiYW4gb3IgdW5iYW4uXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIGZvciB3aGljaCBub3QgdG8gZ2V0IGFueSBtb3JlIG5vdGlmaWNhdGlvbnMgYWJvdXQgYmFucyBvciB1bmJhbnMgaW4gdGhlaXIgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB0aGF0IGlzIGJlaW5nIGJhbm5lZCBvciB1bmJhbm5lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnVuc3Vic2NyaWJlRnJvbUJhbkV2ZW50c0ZvclVzZXIgPSBmdW5jdGlvbiAoYnJvYWRjYXN0ZXIsIHVzZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fc2VuZEJhbkV2ZW50c0h1YlJlcXVlc3QoJ3Vuc3Vic2NyaWJlJywgYnJvYWRjYXN0ZXIsIG9wdGlvbnMsIHVzZXIpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gZXZlbnRzIHJlcHJlc2VudGluZyBhIHVzZXIgZ2FpbmluZyBvciBsb3NpbmcgbW9kZXJhdG9yIHByaXZpbGVnZXMgaW4gYSBjaGFubmVsLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciBmb3Igd2hpY2ggdG8gZ2V0IG5vdGlmaWNhdGlvbnMgYWJvdXQgbW9kZXJhdG9yIGNoYW5nZXMgaW4gdGhlaXIgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnN1YnNjcmliZVRvTW9kZXJhdG9yRXZlbnRzID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRNb2RlcmF0b3JFdmVudHNIdWJSZXF1ZXN0KCdzdWJzY3JpYmUnLCBicm9hZGNhc3Rlciwgb3B0aW9ucyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gZXZlbnRzIHJlcHJlc2VudGluZyBhIHVzZXIgZ2FpbmluZyBvciBsb3NpbmcgbW9kZXJhdG9yIHByaXZpbGVnZXMgaW4gYSBjaGFubmVsLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciBmb3Igd2hpY2ggbm90IHRvIGdldCBhbnkgbW9yZSBub3RpZmljYXRpb25zIGFib3V0IG1vZGVyYXRvciBjaGFuZ2VzIGluIHRoZWlyIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS51bnN1YnNjcmliZUZyb21Nb2RlcmF0b3JFdmVudHMgPSBmdW5jdGlvbiAoYnJvYWRjYXN0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fc2VuZE1vZGVyYXRvckV2ZW50c0h1YlJlcXVlc3QoJ3Vuc3Vic2NyaWJlJywgYnJvYWRjYXN0ZXIsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gZXZlbnRzIHJlcHJlc2VudGluZyBhIHVzZXIgZ2FpbmluZyBvciBsb3NpbmcgbW9kZXJhdG9yIHByaXZpbGVnZXMgaW4gYSBjaGFubmVsLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciBmb3Igd2hpY2ggdG8gZ2V0IG5vdGlmaWNhdGlvbnMgYWJvdXQgbW9kZXJhdG9yIGNoYW5nZXMgaW4gdGhlaXIgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB0aGF0IGlzIGJlaW5nIG1vZGRlZCBvciB1bm1vZGRlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnN1YnNjcmliZVRvTW9kZXJhdG9yRXZlbnRzRm9yVXNlciA9IGZ1bmN0aW9uIChicm9hZGNhc3RlciwgdXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kTW9kZXJhdG9yRXZlbnRzSHViUmVxdWVzdCgnc3Vic2NyaWJlJywgYnJvYWRjYXN0ZXIsIG9wdGlvbnMsIHVzZXIpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGV2ZW50cyByZXByZXNlbnRpbmcgYSB1c2VyIGdhaW5pbmcgb3IgbG9zaW5nIG1vZGVyYXRvciBwcml2aWxlZ2VzIGluIGEgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBicm9hZGNhc3RlciBUaGUgYnJvYWRjYXN0ZXIgZm9yIHdoaWNoIG5vdCB0byBnZXQgYW55IG1vcmUgbm90aWZpY2F0aW9ucyBhYm91dCBtb2RlcmF0b3IgY2hhbmdlcyBpbiB0aGVpciBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHRoYXQgaXMgYmVpbmcgbW9kZGVkIG9yIHVubW9kZGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUudW5zdWJzY3JpYmVGcm9tTW9kZXJhdG9yRXZlbnRzRm9yVXNlciA9IGZ1bmN0aW9uIChicm9hZGNhc3RlciwgdXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kTW9kZXJhdG9yRXZlbnRzSHViUmVxdWVzdCgndW5zdWJzY3JpYmUnLCBicm9hZGNhc3Rlciwgb3B0aW9ucywgdXNlcildO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUuX3NlbmRVc2VyRm9sbG93c0h1YlJlcXVlc3QgPSBmdW5jdGlvbiAobW9kZSwgZGlyZWN0aW9uLCB1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuc2VuZEh1YlJlcXVlc3QodHNsaWJfMS5fX2Fzc2lnbih7IG1vZGU6IG1vZGUsIHRvcGljVXJsOiBcImh0dHBzOi8vYXBpLnR3aXRjaC50di9oZWxpeC91c2Vycy9mb2xsb3dzP2ZpcnN0PTEmXCIgKyBkaXJlY3Rpb24gKyBcIl9pZD1cIiArIHVzZXJJZCB9LCBvcHRpb25zKSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUuX3NlbmRTdHJlYW1DaGFuZ2VIdWJSZXF1ZXN0ID0gZnVuY3Rpb24gKG1vZGUsIHVzZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5zZW5kSHViUmVxdWVzdCh0c2xpYl8xLl9fYXNzaWduKHsgbW9kZTogbW9kZSwgdG9waWNVcmw6IFwiaHR0cHM6Ly9hcGkudHdpdGNoLnR2L2hlbGl4L3N0cmVhbXM/dXNlcl9pZD1cIiArIHVzZXJJZCB9LCBvcHRpb25zKSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUuX3NlbmRVc2VyQ2hhbmdlSHViUmVxdWVzdCA9IGZ1bmN0aW9uIChtb2RlLCB1c2VyLCBvcHRpb25zLCB3aXRoRW1haWwpIHtcbiAgICAgICAgaWYgKHdpdGhFbWFpbCA9PT0gdm9pZCAwKSB7IHdpdGhFbWFpbCA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuc2VuZEh1YlJlcXVlc3QodHNsaWJfMS5fX2Fzc2lnbih7IG1vZGU6IG1vZGUsIHRvcGljVXJsOiBcImh0dHBzOi8vYXBpLnR3aXRjaC50di9oZWxpeC91c2Vycz9pZD1cIiArIHVzZXJJZCwgc2NvcGU6IHdpdGhFbWFpbCA/ICd1c2VyOnJlYWQ6ZW1haWwnIDogdW5kZWZpbmVkIH0sIG9wdGlvbnMpKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5fc2VuZFN1YnNjcmlwdGlvbkV2ZW50c0h1YlJlcXVlc3QgPSBmdW5jdGlvbiAobW9kZSwgdXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnNlbmRIdWJSZXF1ZXN0KHRzbGliXzEuX19hc3NpZ24oeyBtb2RlOiBtb2RlLCB0b3BpY1VybDogXCJodHRwczovL2FwaS50d2l0Y2gudHYvaGVsaXgvc3Vic2NyaXB0aW9ucy9ldmVudHM/YnJvYWRjYXN0ZXJfaWQ9XCIgKyB1c2VySWQgKyBcIiZmaXJzdD0xXCIsIHNjb3BlOiAnY2hhbm5lbDpyZWFkOnN1YnNjcmlwdGlvbnMnIH0sIG9wdGlvbnMpKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5fc2VuZEV4dGVuc2lvblRyYW5zYWN0aW9uc0h1YlJlcXVlc3QgPSBmdW5jdGlvbiAobW9kZSwgZXh0ZW5zaW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5zZW5kSHViUmVxdWVzdCh0c2xpYl8xLl9fYXNzaWduKHsgbW9kZTogbW9kZSwgdG9waWNVcmw6IFwiaHR0cHM6Ly9hcGkudHdpdGNoLnR2L2hlbGl4L2V4dGVuc2lvbnMvdHJhbnNhY3Rpb25zP2V4dGVuc2lvbl9pZD1cIiArIGV4dGVuc2lvbklkICsgXCImZmlyc3Q9MVwiIH0sIG9wdGlvbnMpKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5fc2VuZEJhbkV2ZW50c0h1YlJlcXVlc3QgPSBmdW5jdGlvbiAobW9kZSwgYnJvYWRjYXN0ZXIsIG9wdGlvbnMsIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYnJvYWRjYXN0ZXJJZCwgdG9waWNVcmw7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3RlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChicm9hZGNhc3Rlcik7XG4gICAgICAgICAgICAgICAgdG9waWNVcmwgPSBcImh0dHBzOi8vYXBpLnR3aXRjaC50di9oZWxpeC9tb2RlcmF0aW9uL2Jhbm5lZC9ldmVudHM/YnJvYWRjYXN0ZXJfaWQ9XCIgKyBicm9hZGNhc3RlcklkICsgXCImZmlyc3Q9MVwiO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljVXJsICs9IFwiJnVzZXJfaWQ9XCIgKyBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5zZW5kSHViUmVxdWVzdCh0c2xpYl8xLl9fYXNzaWduKHsgbW9kZTogbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljVXJsOiB0b3BpY1VybCwgc2NvcGU6ICdtb2RlcmF0aW9uOnJlYWQnIH0sIG9wdGlvbnMpKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5fc2VuZE1vZGVyYXRvckV2ZW50c0h1YlJlcXVlc3QgPSBmdW5jdGlvbiAobW9kZSwgYnJvYWRjYXN0ZXIsIG9wdGlvbnMsIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYnJvYWRjYXN0ZXJJZCwgdG9waWNVcmw7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3RlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChicm9hZGNhc3Rlcik7XG4gICAgICAgICAgICAgICAgdG9waWNVcmwgPSBcImh0dHBzOi8vYXBpLnR3aXRjaC50di9oZWxpeC9tb2RlcmF0aW9uL21vZGVyYXRvcnMvZXZlbnRzP2Jyb2FkY2FzdGVyX2lkPVwiICsgYnJvYWRjYXN0ZXJJZCArIFwiJmZpcnN0PTFcIjtcbiAgICAgICAgICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY1VybCArPSBcIiZ1c2VyX2lkPVwiICsgVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuc2VuZEh1YlJlcXVlc3QodHNsaWJfMS5fX2Fzc2lnbih7IG1vZGU6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpY1VybDogdG9waWNVcmwsIHNjb3BlOiAnbW9kZXJhdGlvbjpyZWFkJyB9LCBvcHRpb25zKSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEhlbGl4V2ViSG9va3NBUEk7XG59KEJhc2VBUElfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFdlYkhvb2tzQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhXZWJIb29rc0FQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4V2ViSG9va3NBUEk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBBIHN1YnNjcmlwdGlvbiB0byBhIFR3aXRjaCBXZWJIb29rLlxuICovXG52YXIgSGVsaXhXZWJIb29rU3Vic2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4V2ViSG9va1N1YnNjcmlwdGlvbihfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhXZWJIb29rU3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJ0b3BpY1VybFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9waWMgdGhlIFdlYkhvb2sgaXMgbGlzdGVuaW5nIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50b3BpYztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4V2ViSG9va1N1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwiY2FsbGJhY2tVcmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCB0aGF0IHdpbGwgYmUgY2FsbGVkIGZvciBldmVyeSBzdWJzY3JpYmVkIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5jYWxsYmFjaztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4V2ViSG9va1N1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwiZXhwaXJ5RGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSB3aGVuIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBleHBpcmUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmV4cGlyZXNfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBXZWJIb29rLlxuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va1N1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC53ZWJIb29rcy5zZW5kSHViUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAndW5zdWJzY3JpYmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWNVcmw6IHRoaXMudG9waWNVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1VybDogdGhpcy5jYWxsYmFja1VybFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgSGVsaXhXZWJIb29rU3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEhlbGl4V2ViSG9va1N1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFdlYkhvb2tTdWJzY3JpcHRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFdlYkhvb2tTdWJzY3JpcHRpb247XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFdlYkhvb2tTdWJzY3JpcHRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHJhdGVfbGltaXRlcl8xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvcmF0ZS1saW1pdGVyXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uLy4uL1R3aXRjaENsaWVudFwiKTtcbnZhciBIZWxpeFJhdGVMaW1pdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4UmF0ZUxpbWl0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhSYXRlTGltaXRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBIZWxpeFJhdGVMaW1pdGVyLnByb3RvdHlwZS5kb1JlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBjbGllbnRJZCA9IF9hLmNsaWVudElkLCBhY2Nlc3NUb2tlbiA9IF9hLmFjY2Vzc1Rva2VuO1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUd2l0Y2hDbGllbnRfMS5kZWZhdWx0Ll9jYWxsQVBJUmF3KG9wdGlvbnMsIGNsaWVudElkLCBhY2Nlc3NUb2tlbildO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVsaXhSYXRlTGltaXRlci5wcm90b3R5cGUubmVlZHNUb1JldHJ5QWZ0ZXIgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgICAgIHJldHVybiArcmVzLmhlYWRlcnMuZ2V0KCdyYXRlbGltaXQtcmVzZXQnKSAqIDEwMDAgLSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgSGVsaXhSYXRlTGltaXRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVyc0Zyb21SZXNwb25zZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSByZXMuaGVhZGVycztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbWl0OiAraGVhZGVycy5nZXQoJ3JhdGVsaW1pdC1saW1pdCcpLFxuICAgICAgICAgICAgcmVtYWluaW5nOiAraGVhZGVycy5nZXQoJ3JhdGVsaW1pdC1yZW1haW5pbmcnKSxcbiAgICAgICAgICAgIHJlc2V0c0F0OiAraGVhZGVycy5nZXQoJ3JhdGVsaW1pdC1yZXNldCcpICogMTAwMFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEhlbGl4UmF0ZUxpbWl0ZXI7XG59KHJhdGVfbGltaXRlcl8xLlJlc3BvbnNlQmFzZWRSYXRlTGltaXRlcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhSYXRlTGltaXRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4UmF0ZUxpbWl0ZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFJhdGVMaW1pdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyXzEgPSByZXF1aXJlKFwiLi9SZXNwb25zZUJhc2VkUmF0ZUxpbWl0ZXJcIik7XG5leHBvcnRzLlJlc3BvbnNlQmFzZWRSYXRlTGltaXRlciA9IFJlc3BvbnNlQmFzZWRSYXRlTGltaXRlcl8xLlJlc3BvbnNlQmFzZWRSYXRlTGltaXRlcjtcbnZhciBSZXRyeUFmdGVyRXJyb3JfMSA9IHJlcXVpcmUoXCIuL1JldHJ5QWZ0ZXJFcnJvclwiKTtcbmV4cG9ydHMuUmV0cnlBZnRlckVycm9yID0gUmV0cnlBZnRlckVycm9yXzEuUmV0cnlBZnRlckVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL2xvZ2dlclwiKTtcbnZhciBwcm9taXNlX2FsbHNldHRsZWRfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3Byb21pc2UuYWxsc2V0dGxlZFwiKTtcbnZhciBSZXRyeUFmdGVyRXJyb3JfMSA9IHJlcXVpcmUoXCIuL1JldHJ5QWZ0ZXJFcnJvclwiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG52YXIgUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc3BvbnNlQmFzZWRSYXRlTGltaXRlcihsb2dMZXZlbCkge1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLl9iYXRjaFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcih7IG5hbWU6ICdyYXRlLWxpbWl0ZXInLCBtaW5MZXZlbDogbG9nTGV2ZWwsIGVtb2ppOiB0cnVlIH0pO1xuICAgIH1cbiAgICBSZXNwb25zZUJhc2VkUmF0ZUxpbWl0ZXIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxU3BlYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXE6IHJlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9iYXRjaFJ1bm5pbmcgfHwgX3RoaXMuX25leHRCYXRjaFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3F1ZXVlLnB1c2gocmVxU3BlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcnVuUmVxdWVzdEJhdGNoKFtyZXFTcGVjXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc3BvbnNlQmFzZWRSYXRlTGltaXRlci5wcm90b3R5cGUuX3J1blJlcXVlc3RCYXRjaCA9IGZ1bmN0aW9uIChyZXFTcGVjcykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcywgc2V0dGxlZFByb21pc2VzLCByZWplY3RlZFByb21pc2VzLCBub3csIHJldHJ5QXQsIHJldHJ5QWZ0ZXIsIHBhcmFtcywgZGVsYXk7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYXRjaFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcxKFwicmVtYWluaW5nIHJlcXVlc3RzOiBcIiArIHRoaXMuX3BhcmFtZXRlcnMucmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZzIoXCJkb2luZyBcIiArIHJlcVNwZWNzLmxlbmd0aCArIFwiIHJlcXVlc3RzLCBuZXcgcXVldWUgbGVuZ3RoIGlzIFwiICsgdGhpcy5fcXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gcmVxU3BlY3MubWFwKGZ1bmN0aW9uIChyZXFTcGVjKSB7IHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxLCByZXNvbHZlLCByZWplY3QsIHJlc3VsdCwgcmV0cnksIHBhcmFtcywgZV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gcmVxU3BlYy5yZXEsIHJlc29sdmUgPSByZXFTcGVjLnJlc29sdmUsIHJlamVjdCA9IHJlcVNwZWMucmVqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZG9SZXF1ZXN0KHJlcSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeSA9IHRoaXMubmVlZHNUb1JldHJ5QWZ0ZXIocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0cnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWUudW5zaGlmdChyZXFTcGVjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJSZXRyeWluZyBhZnRlciBcIiArIHJldHJ5ICsgXCIgbXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXRyeUFmdGVyRXJyb3JfMS5SZXRyeUFmdGVyRXJyb3IocmV0cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLmdldFBhcmFtZXRlcnNGcm9tUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBhcmFtc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEgaW5zdGFuY2VvZiBSZXRyeUFmdGVyRXJyb3JfMS5SZXRyeUFmdGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvbWlzZV9hbGxzZXR0bGVkXzEuZGVmYXVsdCkocHJvbWlzZXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGxlZFByb21pc2VzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRQcm9taXNlcyA9IHNldHRsZWRQcm9taXNlcy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuc3RhdHVzID09PSAncmVqZWN0ZWQnOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVqZWN0ZWRQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUF0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdHNsaWJfMS5fX3NwcmVhZChbbm93XSwgcmVqZWN0ZWRQcm9taXNlcy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAucmVhc29uLnJldHJ5QXQ7IH0pKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlBZnRlciA9IHJldHJ5QXQgLSBub3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJ3YWl0aW5nIGZvciBcIiArIHJldHJ5QWZ0ZXIgKyBcIiBtcyBiZWNhdXNlIHRoZSByYXRlIGxpbWl0IHdhcyBleGNlZWRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0QmF0Y2hUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3J1bk5leHRCYXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJldHJ5QWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gc2V0dGxlZFByb21pc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudmFsdWU7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoY2FycnksIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYXJyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHYucmVzZXRzQXQgPiBjYXJyeS5yZXNldHNBdCA/IHYgOiBjYXJyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYucmVtYWluaW5nIDwgY2FycnkucmVtYWluaW5nID8gdiA6IGNhcnJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmF0Y2hSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnJlc2V0c0F0IDwgbm93IHx8IHBhcmFtcy5yZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydW5OZXh0QmF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGFyYW1zLnJlc2V0c0F0IC0gbm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJXYWl0aW5nIGZvciBcIiArIGRlbGF5ICsgXCIgbXMgYmVjYXVzZSB0aGUgcmF0ZSBsaW1pdCB3YXMgcmVhY2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25leHRCYXRjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3BhcmFtZXRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3J1bk5leHRCYXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc3BvbnNlQmFzZWRSYXRlTGltaXRlci5wcm90b3R5cGUuX3J1bk5leHRCYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYW1vdW50LCByZXFTcGVjcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXh0QmF0Y2hUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fbmV4dEJhdGNoVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0QmF0Y2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW1vdW50ID0gdGhpcy5fcGFyYW1ldGVycyA/IE1hdGgubWluKHRoaXMuX3BhcmFtZXRlcnMucmVtYWluaW5nLCB0aGlzLl9wYXJhbWV0ZXJzLmxpbWl0IC8gMTApIDogMTtcbiAgICAgICAgICAgICAgICByZXFTcGVjcyA9IHRoaXMuX3F1ZXVlLnNwbGljZSgwLCBhbW91bnQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXFTcGVjcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnVuUmVxdWVzdEJhdGNoKHJlcVNwZWNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc3BvbnNlQmFzZWRSYXRlTGltaXRlcjtcbn0oKSk7XG5leHBvcnRzLlJlc3BvbnNlQmFzZWRSYXRlTGltaXRlciA9IFJlc3BvbnNlQmFzZWRSYXRlTGltaXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc3BvbnNlQmFzZWRSYXRlTGltaXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIGVzbGludC1kaXNhYmxlIGZpbGVuYW1lcy9tYXRjaC1leHBvcnRlZCAqL1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoXCJkZXRlY3Qtbm9kZVwiKTtcbnZhciBOb2RlTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Ob2RlTG9nZ2VyXCIpO1xudmFyIEJyb3dzZXJMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0Jyb3dzZXJMb2dnZXJcIik7XG52YXIgTG9nZ2VyID0gaXNOb2RlID8gTm9kZUxvZ2dlcl8xLk5vZGVMb2dnZXIgOiBCcm93c2VyTG9nZ2VyXzEuQnJvd3NlckxvZ2dlcjtcbmV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xudmFyIExvZ0xldmVsXzEgPSByZXF1aXJlKFwiLi9Mb2dMZXZlbFwiKTtcbmV4cG9ydHMuTG9nTGV2ZWwgPSBMb2dMZXZlbF8xLkxvZ0xldmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2EsIF9iLCBfYztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIExvZ0xldmVsXzEgPSByZXF1aXJlKFwiLi9Mb2dMZXZlbFwiKTtcbnZhciBCYXNlTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9CYXNlTG9nZ2VyXCIpO1xuZXhwb3J0cy5Mb2dMZXZlbFRvRW1vamkgPSAoX2EgPSB7fSxcbiAgICBfYVtMb2dMZXZlbF8xLkxvZ0xldmVsLkNSSVRJQ0FMXSA9IFwiXFx1RDgzRFxcdURFRDFcIixcbiAgICBfYVtMb2dMZXZlbF8xLkxvZ0xldmVsLkVSUk9SXSA9IFwiXFx1Mjc0Q1wiLFxuICAgIC8vIHRoZXNlIGZvbGxvd2luZyB0d28gbmVlZCBleHRyYSBzcGFjZXMgYXQgdGhlIGVuZCBiZWNhdXNlIHNvbWVob3cgdGhleSBjb25zdW1lIGxlc3Mgc3BhY2UgaW4gYSB0ZXJtaW5hbCB0aGFuIHRoZXkgc2hvdWxkLi4uXG4gICAgX2FbTG9nTGV2ZWxfMS5Mb2dMZXZlbC5XQVJOSU5HXSA9IFwiXFx1MjZBMFxcdUZFMEYgXCIsXG4gICAgX2FbTG9nTGV2ZWxfMS5Mb2dMZXZlbC5JTkZPXSA9IFwiXFx1MjEzOVxcdUZFMEYgXCIsXG4gICAgX2FbTG9nTGV2ZWxfMS5Mb2dMZXZlbC5ERUJVR10gPSBcIlxcdUQ4M0RcXHVEQzFFXCIsXG4gICAgX2FbTG9nTGV2ZWxfMS5Mb2dMZXZlbC5UUkFDRV0gPSBcIlxcdUQ4M0RcXHVEQzNFXCIsXG4gICAgX2EpO1xudmFyIGNvbG9ycyA9IHtcbiAgICBibGFjazogMzAsXG4gICAgcmVkOiAzMSxcbiAgICBncmVlbjogMzIsXG4gICAgeWVsbG93OiAzMyxcbiAgICBibHVlOiAzNCxcbiAgICBtYWdlbnRhOiAzNSxcbiAgICBjeWFuOiAzNixcbiAgICB3aGl0ZTogMzcsXG4gICAgYmxhY2tCcmlnaHQ6IDkwLFxuICAgIHJlZEJyaWdodDogOTEsXG4gICAgZ3JlZW5CcmlnaHQ6IDkyLFxuICAgIHllbGxvd0JyaWdodDogOTMsXG4gICAgYmx1ZUJyaWdodDogOTQsXG4gICAgbWFnZW50YUJyaWdodDogOTUsXG4gICAgY3lhbkJyaWdodDogOTYsXG4gICAgd2hpdGVCcmlnaHQ6IDk3XG59O1xudmFyIGJnQ29sb3JzID0ge1xuICAgIGJnQmxhY2s6IDQwLFxuICAgIGJnUmVkOiA0MSxcbiAgICBiZ0dyZWVuOiA0MixcbiAgICBiZ1llbGxvdzogNDMsXG4gICAgYmdCbHVlOiA0NCxcbiAgICBiZ01hZ2VudGE6IDQ1LFxuICAgIGJnQ3lhbjogNDYsXG4gICAgYmdXaGl0ZTogNDcsXG4gICAgYmdCbGFja0JyaWdodDogMTAwLFxuICAgIGJnUmVkQnJpZ2h0OiAxMDEsXG4gICAgYmdHcmVlbkJyaWdodDogMTAyLFxuICAgIGJnWWVsbG93QnJpZ2h0OiAxMDMsXG4gICAgYmdCbHVlQnJpZ2h0OiAxMDQsXG4gICAgYmdNYWdlbnRhQnJpZ2h0OiAxMDUsXG4gICAgYmdDeWFuQnJpZ2h0OiAxMDYsXG4gICAgYmdXaGl0ZUJyaWdodDogMTA3XG59O1xuZnVuY3Rpb24gY3JlYXRlR2VuZXJpY1dyYXBwZXIoY29sb3IsIGVuZGluZywgaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gXCJcXHUwMDFCW1wiICsgY29sb3IgKyBcIm1cIiArIChpbm5lciA/IGlubmVyKHN0cikgOiBzdHIpICsgXCJcXHUwMDFCW1wiICsgZW5kaW5nICsgXCJtXCI7IH07XG59XG5mdW5jdGlvbiBjcmVhdGVDb2xvcldyYXBwZXIoY29sb3IpIHtcbiAgICByZXR1cm4gY3JlYXRlR2VuZXJpY1dyYXBwZXIoY29sb3JzW2NvbG9yXSwgMzkpO1xufVxuZnVuY3Rpb24gY3JlYXRlQmdXcmFwcGVyKGNvbG9yLCBmZ1dyYXBwZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlR2VuZXJpY1dyYXBwZXIoYmdDb2xvcnNbY29sb3JdLCA0OSwgZmdXcmFwcGVyKTtcbn1cbmV4cG9ydHMuTG9nTGV2ZWxUb0NvbG9yID0gKF9iID0ge30sXG4gICAgX2JbTG9nTGV2ZWxfMS5Mb2dMZXZlbC5DUklUSUNBTF0gPSBjcmVhdGVDb2xvcldyYXBwZXIoJ3JlZCcpLFxuICAgIF9iW0xvZ0xldmVsXzEuTG9nTGV2ZWwuRVJST1JdID0gY3JlYXRlQ29sb3JXcmFwcGVyKCdyZWRCcmlnaHQnKSxcbiAgICBfYltMb2dMZXZlbF8xLkxvZ0xldmVsLldBUk5JTkddID0gY3JlYXRlQ29sb3JXcmFwcGVyKCd5ZWxsb3cnKSxcbiAgICBfYltMb2dMZXZlbF8xLkxvZ0xldmVsLklORk9dID0gY3JlYXRlQ29sb3JXcmFwcGVyKCdibHVlJyksXG4gICAgX2JbTG9nTGV2ZWxfMS5Mb2dMZXZlbC5ERUJVR10gPSBjcmVhdGVDb2xvcldyYXBwZXIoJ21hZ2VudGEnKSxcbiAgICBfYltMb2dMZXZlbF8xLkxvZ0xldmVsLlRSQUNFXSA9IGNyZWF0ZUdlbmVyaWNXcmFwcGVyKDAsIDApLFxuICAgIF9iKTtcbmV4cG9ydHMuTG9nTGV2ZWxUb0JhY2tncm91bmRDb2xvciA9IChfYyA9IHt9LFxuICAgIF9jW0xvZ0xldmVsXzEuTG9nTGV2ZWwuQ1JJVElDQUxdID0gY3JlYXRlQmdXcmFwcGVyKCdiZ1JlZCcsIGNyZWF0ZUNvbG9yV3JhcHBlcignd2hpdGUnKSksXG4gICAgX2NbTG9nTGV2ZWxfMS5Mb2dMZXZlbC5FUlJPUl0gPSBjcmVhdGVCZ1dyYXBwZXIoJ2JnUmVkQnJpZ2h0JywgY3JlYXRlQ29sb3JXcmFwcGVyKCd3aGl0ZScpKSxcbiAgICBfY1tMb2dMZXZlbF8xLkxvZ0xldmVsLldBUk5JTkddID0gY3JlYXRlQmdXcmFwcGVyKCdiZ1llbGxvdycsIGNyZWF0ZUNvbG9yV3JhcHBlcignYmxhY2snKSksXG4gICAgX2NbTG9nTGV2ZWxfMS5Mb2dMZXZlbC5JTkZPXSA9IGNyZWF0ZUJnV3JhcHBlcignYmdCbHVlJywgY3JlYXRlQ29sb3JXcmFwcGVyKCd3aGl0ZScpKSxcbiAgICBfY1tMb2dMZXZlbF8xLkxvZ0xldmVsLkRFQlVHXSA9IGNyZWF0ZUJnV3JhcHBlcignYmdNYWdlbnRhJywgY3JlYXRlQ29sb3JXcmFwcGVyKCdibGFjaycpKSxcbiAgICBfY1tMb2dMZXZlbF8xLkxvZ0xldmVsLlRSQUNFXSA9IGNyZWF0ZUdlbmVyaWNXcmFwcGVyKDcsIDI3KSxcbiAgICBfYyk7XG52YXIgTm9kZUxvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhOb2RlTG9nZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vZGVMb2dnZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTm9kZUxvZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChsZXZlbCA+IHRoaXMuX21pbkxldmVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ0ZuID0gTG9nTGV2ZWxfMS5Mb2dMZXZlbFRvQ29uc29sZUZ1bmN0aW9uW2xldmVsXTtcbiAgICAgICAgdmFyIGJ1aWx0TWVzc2FnZSA9ICcnO1xuICAgICAgICBpZiAodGhpcy5fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgYnVpbHRNZXNzYWdlICs9IFwiW1wiICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCJdIFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbW9qaSkge1xuICAgICAgICAgICAgdmFyIGVtb2ppID0gZXhwb3J0cy5Mb2dMZXZlbFRvRW1vamlbbGV2ZWxdO1xuICAgICAgICAgICAgYnVpbHRNZXNzYWdlICs9IGVtb2ppICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbG9ycykge1xuICAgICAgICAgICAgYnVpbHRNZXNzYWdlICs9IGV4cG9ydHMuTG9nTGV2ZWxUb0JhY2tncm91bmRDb2xvcltsZXZlbF0odGhpcy5fbmFtZSkgKyBcIiBcIiArIGV4cG9ydHMuTG9nTGV2ZWxUb0JhY2tncm91bmRDb2xvcltsZXZlbF0oTG9nTGV2ZWxfMS5Mb2dMZXZlbFtsZXZlbF0pICsgXCIgXCIgKyBleHBvcnRzLkxvZ0xldmVsVG9Db2xvcltsZXZlbF0obWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidWlsdE1lc3NhZ2UgKz0gXCJbXCIgKyB0aGlzLl9uYW1lICsgXCI6XCIgKyBMb2dMZXZlbF8xLkxvZ0xldmVsW2xldmVsXS50b0xvd2VyQ2FzZSgpICsgXCJdIFwiICsgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBsb2dGbihidWlsdE1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vZGVMb2dnZXI7XG59KEJhc2VMb2dnZXJfMS5CYXNlTG9nZ2VyKSk7XG5leHBvcnRzLk5vZGVMb2dnZXIgPSBOb2RlTG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm9kZUxvZ2dlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIExvZ0xldmVsXzEgPSByZXF1aXJlKFwiLi9Mb2dMZXZlbFwiKTtcbnZhciBCYXNlTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9CYXNlTG9nZ2VyXCIpO1xudmFyIEJyb3dzZXJMb2dnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQnJvd3NlckxvZ2dlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcm93c2VyTG9nZ2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEJyb3dzZXJMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobGV2ZWwgPiB0aGlzLl9taW5MZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2dGbiA9IExvZ0xldmVsXzEuTG9nTGV2ZWxUb0NvbnNvbGVGdW5jdGlvbltsZXZlbF07XG4gICAgICAgIHZhciBmb3JtYXR0ZWRNZXNzYWdlID0gXCJbXCIgKyB0aGlzLl9uYW1lICsgXCJdIFwiICsgbWVzc2FnZTtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZE1lc3NhZ2UgPSBcIltcIiArIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArIFwiXSBcIiArIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgbG9nRm4oZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnJvd3NlckxvZ2dlcjtcbn0oQmFzZUxvZ2dlcl8xLkJhc2VMb2dnZXIpKTtcbmV4cG9ydHMuQnJvd3NlckxvZ2dlciA9IEJyb3dzZXJMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2VyTG9nZ2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9jYWxsQmluZCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbnZhciByZXF1aXJlUHJvbWlzZSA9IHJlcXVpcmUoJy4vcmVxdWlyZVByb21pc2UnKTtcbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnJlcXVpcmVQcm9taXNlKCk7XG52YXIgYm91bmQgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpKTtcblxudmFyIHJlYmluZGFibGUgPSBmdW5jdGlvbiBhbGxTZXR0bGVkKGl0ZXJhYmxlKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcblx0cmV0dXJuIGJvdW5kKHR5cGVvZiB0aGlzID09PSAndW5kZWZpbmVkJyA/IFByb21pc2UgOiB0aGlzLCBpdGVyYWJsZSk7XG59O1xuXG5kZWZpbmUocmViaW5kYWJsZSwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmViaW5kYWJsZTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSByZWJpbmRhYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xuXG52YXIgb3JpZ0tleXMgPSBPYmplY3Qua2V5cztcbnZhciBrZXlzU2hpbSA9IG9yaWdLZXlzID8gZnVuY3Rpb24ga2V5cyhvKSB7IHJldHVybiBvcmlnS2V5cyhvKTsgfSA6IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxudmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHR2YXIgYXJncyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gYXJncyAmJiBhcmdzLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXNTaGltO1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuXHR2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG5cdHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xuXHR2YXIgZG9udEVudW1zID0gW1xuXHRcdCd0b1N0cmluZycsXG5cdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHQndmFsdWVPZicsXG5cdFx0J2hhc093blByb3BlcnR5Jyxcblx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0XHQnY29uc3RydWN0b3InXG5cdF07XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xuXHR9O1xuXHR2YXIgZXhjbHVkZWRLZXlzID0ge1xuXHRcdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHRcdCRjb25zb2xlOiB0cnVlLFxuXHRcdCRleHRlcm5hbDogdHJ1ZSxcblx0XHQkZnJhbWU6IHRydWUsXG5cdFx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0XHQkZnJhbWVzOiB0cnVlLFxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0XHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcblx0XHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdFx0JG91dGVyV2lkdGg6IHRydWUsXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0XHQkcGFyZW50OiB0cnVlLFxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHRcdCRzY3JvbGxUb3A6IHRydWUsXG5cdFx0JHNjcm9sbFg6IHRydWUsXG5cdFx0JHNjcm9sbFk6IHRydWUsXG5cdFx0JHNlbGY6IHRydWUsXG5cdFx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdFx0JHdpbmRvdzogdHJ1ZVxuXHR9O1xuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KCkpO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdFx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdFx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0XHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdFx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhlS2V5cztcblx0fTtcbn1cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGxCb3VuZCcpO1xuXG52YXIgJFByb21pc2VSZXNvbHZlID0gY2FsbEJvdW5kKCdQcm9taXNlLnJlc29sdmUnLCB0cnVlKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzkuMC8jc2VjLXByb21pc2UtcmVzb2x2ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFByb21pc2VSZXNvbHZlKEMsIHgpIHtcblx0aWYgKCEkUHJvbWlzZVJlc29sdmUpIHtcblx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBQcm9taXNlcy4nKTtcblx0fVxuXHRyZXR1cm4gJFByb21pc2VSZXNvbHZlKEMsIHgpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLThcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUeXBlKHgpIHtcblx0aWYgKHggPT09IG51bGwpIHtcblx0XHRyZXR1cm4gJ051bGwnO1xuXHR9XG5cdGlmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gJ1VuZGVmaW5lZCc7XG5cdH1cblx0aWYgKHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiAnT2JqZWN0Jztcblx0fVxuXHRpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuICdOdW1iZXInO1xuXHR9XG5cdGlmICh0eXBlb2YgeCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0cmV0dXJuICdCb29sZWFuJztcblx0fVxuXHRpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuICdTdHJpbmcnO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0SXRlcmF0b3IgPSByZXF1aXJlKCdlcy1nZXQtaXRlcmF0b3InKTtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCdpdGVyYXRlLWl0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXRlcmF0ZVZhbHVlKGl0ZXJhYmxlKSB7XG5cdHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0aWYgKCFpdGVyYXRvcikge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdub24taXRlcmFibGUgdmFsdWUgcHJvdmlkZWQnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRyZXR1cm4gaXRlcmF0ZShpdGVyYXRvciwgYXJndW1lbnRzWzFdKTtcblx0fVxuXHRyZXR1cm4gaXRlcmF0ZShpdGVyYXRvcik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgZ2xvYmFsLXJlcXVpcmU6IDAgKi9cbi8vIHRoZSBjb2RlIGlzIHN0cnVjdHVyZWQgdGhpcyB3YXkgc28gdGhhdCBidW5kbGVycyBjYW5cbi8vIGFsaWFzIG91dCBgaGFzLXN5bWJvbHNgIHRvIGAoKSA9PiB0cnVlYCBvciBgKCkgPT4gZmFsc2VgIGlmIHlvdXIgdGFyZ2V0XG4vLyBlbnZpcm9ubWVudHMnIFN5bWJvbCBjYXBhYmlsaXRpZXMgYXJlIGtub3duLCBhbmQgdGhlbiB1c2Vcbi8vIGRlYWQgY29kZSBlbGltaW5hdGlvbiBvbiB0aGUgcmVzdCBvZiB0aGlzIG1vZHVsZS5cbi8vXG4vLyBTaW1pbGFybHksIGBpc2FycmF5YCBjYW4gYmUgYWxpYXNlZCB0byBgQXJyYXkuaXNBcnJheWAgaWZcbi8vIGF2YWlsYWJsZSBpbiBhbGwgdGFyZ2V0IGVudmlyb25tZW50cy5cblxudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG5cbmlmIChyZXF1aXJlKCdoYXMtc3ltYm9scycpKCkgfHwgcmVxdWlyZSgnaGFzLXN5bWJvbHMvc2hhbXMnKSgpKSB7XG5cdHZhciAkaXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG5cdC8vIFN5bWJvbCBpcyBhdmFpbGFibGUgbmF0aXZlbHkgb3Igc2hhbW1lZFxuXHQvLyBuYXRpdmVseTpcblx0Ly8gIC0gQ2hyb21lID49IDM4XG5cdC8vICAtIEVkZ2UgMTItMTQ/LCBFZGdlID49IDE1IGZvciBzdXJlXG5cdC8vICAtIEZGID49IDM2XG5cdC8vICAtIFNhZmFyaSA+PSA5XG5cdC8vICAtIG5vZGUgPj0gMC4xMlxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG5cdFx0Ly8gYWx0ZXJuYXRpdmVseSwgYGl0ZXJhYmxlWyRpdGVyYXRvcl0/LigpYFxuXHRcdGlmIChpdGVyYWJsZSAhPSBudWxsICYmIHR5cGVvZiBpdGVyYWJsZVskaXRlcmF0b3JdICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGl0ZXJhYmxlWyRpdGVyYXRvcl0oKTtcblx0XHR9XG5cdFx0aWYgKGlzQXJndW1lbnRzKGl0ZXJhYmxlKSkge1xuXHRcdFx0Ly8gYXJndW1lbnRzIG9iamVjdHMgbGFjayBTeW1ib2wuaXRlcmF0b3Jcblx0XHRcdC8vIC0gbm9kZSAwLjEyXG5cdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlWyRpdGVyYXRvcl0uY2FsbChpdGVyYWJsZSk7XG5cdFx0fVxuXHR9O1xufSBlbHNlIHtcblx0Ly8gU3ltYm9sIGlzIG5vdCBhdmFpbGFibGUsIG5hdGl2ZSBvciBzaGFtbWVkXG5cdHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXHR2YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdpcy1zdHJpbmcnKTtcblx0dmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L0dldEludHJpbnNpYycpO1xuXHR2YXIgJE1hcCA9IEdldEludHJpbnNpYygnJU1hcCUnLCB0cnVlKTtcblx0dmFyICRTZXQgPSBHZXRJbnRyaW5zaWMoJyVTZXQlJywgdHJ1ZSk7XG5cdHZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2NhbGxCb3VuZCcpO1xuXHR2YXIgJGFycmF5UHVzaCA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLnB1c2gnKTtcblx0dmFyICRjaGFyQ29kZUF0ID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQnKTtcblx0dmFyICRzdHJpbmdTbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xuXG5cdHZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSBmdW5jdGlvbiBhZHZhbmNlU3RyaW5nSW5kZXgoUywgaW5kZXgpIHtcblx0XHR2YXIgbGVuZ3RoID0gUy5sZW5ndGg7XG5cdFx0aWYgKChpbmRleCArIDEpID49IGxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGluZGV4ICsgMTtcblx0XHR9XG5cblx0XHR2YXIgZmlyc3QgPSAkY2hhckNvZGVBdChTLCBpbmRleCk7XG5cdFx0aWYgKGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggKyAxO1xuXHRcdH1cblxuXHRcdHZhciBzZWNvbmQgPSAkY2hhckNvZGVBdChTLCBpbmRleCArIDEpO1xuXHRcdGlmIChzZWNvbmQgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggKyAxO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleCArIDI7XG5cdH07XG5cblx0dmFyIGdldEFycmF5SXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRBcnJheUl0ZXJhdG9yKGFycmF5bGlrZSkge1xuXHRcdHZhciBpID0gMDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcblx0XHRcdFx0dmFyIGRvbmUgPSBpID49IGFycmF5bGlrZS5sZW5ndGg7XG5cdFx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdFx0aWYgKCFkb25lKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBhcnJheWxpa2VbaV07XG5cdFx0XHRcdFx0aSArPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZG9uZTogZG9uZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG5cdHZhciBnZXROb25Db2xsZWN0aW9uSXRlcmF0b3IgPSBmdW5jdGlvbiBnZXROb25Db2xsZWN0aW9uSXRlcmF0b3IoaXRlcmFibGUpIHtcblx0XHRpZiAoaXNBcnJheShpdGVyYWJsZSkgfHwgaXNBcmd1bWVudHMoaXRlcmFibGUpKSB7XG5cdFx0XHRyZXR1cm4gZ2V0QXJyYXlJdGVyYXRvcihpdGVyYWJsZSk7XG5cdFx0fVxuXHRcdGlmIChpc1N0cmluZyhpdGVyYWJsZSkpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG5cdFx0XHRcdFx0dmFyIG5leHRJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChpdGVyYWJsZSwgaSk7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gJHN0cmluZ1NsaWNlKGl0ZXJhYmxlLCBpLCBuZXh0SW5kZXgpO1xuXHRcdFx0XHRcdGkgPSBuZXh0SW5kZXg7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGRvbmU6IG5leHRJbmRleCA+IGl0ZXJhYmxlLmxlbmd0aCxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXG5cdGlmICghJE1hcCAmJiAhJFNldCkge1xuXHRcdC8vIHRoZSBvbmx5IGxhbmd1YWdlIGl0ZXJhYmxlcyBhcmUgQXJyYXksIFN0cmluZywgYXJndW1lbnRzXG5cdFx0Ly8gLSBTYWZhcmkgPD0gNi4wXG5cdFx0Ly8gLSBDaHJvbWUgPCAzOFxuXHRcdC8vIC0gbm9kZSA8IDAuMTJcblx0XHQvLyAtIEZGIDwgMTNcblx0XHQvLyAtIElFIDwgMTFcblx0XHQvLyAtIEVkZ2UgPCAxMVxuXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnZXROb25Db2xsZWN0aW9uSXRlcmF0b3I7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gZWl0aGVyIE1hcCBvciBTZXQgYXJlIGF2YWlsYWJsZSwgYnV0IFN5bWJvbCBpcyBub3Rcblx0XHQvLyAtIGVzNi1zaGltIG9uIGFuIEVTNSBicm93c2VyXG5cdFx0Ly8gLSBTYWZhcmkgNi4yIChtYXliZSA2LjE/KVxuXHRcdC8vIC0gRkYgdlsxMywgMzYpXG5cdFx0Ly8gLSBJRSAxMVxuXHRcdC8vIC0gRWRnZSAxMVxuXHRcdC8vIC0gU2FmYXJpIHZbNiwgOSlcblxuXHRcdHZhciBpc01hcCA9IHJlcXVpcmUoJ2lzLW1hcCcpO1xuXHRcdHZhciBpc1NldCA9IHJlcXVpcmUoJ2lzLXNldCcpO1xuXG5cdFx0Ly8gRmlyZWZveCA+PSAyNywgSUUgMTEsIFNhZmFyaSA2LjIgLSA5LCBFZGdlIDExLCBlczYtc2hpbSBpbiBvbGRlciBlbnZzLCBhbGwgaGF2ZSBmb3JFYWNoXG5cdFx0dmFyICRtYXBGb3JFYWNoID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLmZvckVhY2gnLCB0cnVlKTtcblx0XHR2YXIgJHNldEZvckVhY2ggPSBjYWxsQm91bmQoJ1NldC5wcm90b3R5cGUuZm9yRWFjaCcsIHRydWUpO1xuXHRcdGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXByb2Nlc3MudmVyc2lvbnMgfHwgIXByb2Nlc3MudmVyc2lvbnMubm9kZSkgeyAvLyBcImlmIGlzIG5vdCBub2RlXCJcblxuXHRcdFx0Ly8gRmlyZWZveCAxNyAtIDI2IGhhcyBgLml0ZXJhdG9yKClgLCB3aG9zZSBpdGVyYXRvciBgLm5leHQoKWAgZWl0aGVyXG5cdFx0XHQvLyByZXR1cm5zIGEgdmFsdWUsIG9yIHRocm93cyBhIFN0b3BJdGVyYXRpb24gb2JqZWN0LiBUaGVzZSBicm93c2Vyc1xuXHRcdFx0Ly8gZG8gbm90IGhhdmUgYW55IG90aGVyIG1lY2hhbmlzbSBmb3IgaXRlcmF0aW9uLlxuXHRcdFx0dmFyICRtYXBJdGVyYXRvciA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5pdGVyYXRvcicsIHRydWUpO1xuXHRcdFx0dmFyICRzZXRJdGVyYXRvciA9IGNhbGxCb3VuZCgnU2V0LnByb3RvdHlwZS5pdGVyYXRvcicsIHRydWUpO1xuXHRcdFx0dmFyIGdldFN0b3BJdGVyYXRpb25JdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuXHRcdFx0XHR2YXIgZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdGRvbmU6IGRvbmUsXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBpdGVyYXRvci5uZXh0KClcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdFx0ZG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0ZG9uZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0Ly8gRmlyZWZveCAyNy0zNSwgYW5kIHNvbWUgb2xkZXIgZXM2LXNoaW0gdmVyc2lvbnMsIHVzZSBhIHN0cmluZyBcIkBAaXRlcmF0b3JcIiBwcm9wZXJ0eVxuXHRcdC8vIHRoaXMgcmV0dXJucyBhIHByb3BlciBpdGVyYXRvciBvYmplY3QsIHNvIHdlIHNob3VsZCB1c2UgaXQgaW5zdGVhZCBvZiBmb3JFYWNoLlxuXHRcdC8vIG5ld2VyIGVzNi1zaGltIHZlcnNpb25zIHVzZSBhIHN0cmluZyBcIl9lczYtc2hpbSBpdGVyYXRvcl9cIiBwcm9wZXJ0eS5cblx0XHR2YXIgJG1hcEF0QXRJdGVyYXRvciA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5AQGl0ZXJhdG9yJywgdHJ1ZSkgfHwgY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLl9lczYtc2hpbSBpdGVyYXRvcl8nLCB0cnVlKTtcblx0XHR2YXIgJHNldEF0QXRJdGVyYXRvciA9IGNhbGxCb3VuZCgnU2V0LnByb3RvdHlwZS5AQGl0ZXJhdG9yJywgdHJ1ZSkgfHwgY2FsbEJvdW5kKCdTZXQucHJvdG90eXBlLl9lczYtc2hpbSBpdGVyYXRvcl8nLCB0cnVlKTtcblxuXHRcdHZhciBnZXRDb2xsZWN0aW9uSXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRDb2xsZWN0aW9uSXRlcmF0b3IoaXRlcmFibGUpIHtcblx0XHRcdGlmIChpc01hcChpdGVyYWJsZSkpIHtcblx0XHRcdFx0aWYgKCRtYXBJdGVyYXRvcikge1xuXHRcdFx0XHRcdHJldHVybiBnZXRTdG9wSXRlcmF0aW9uSXRlcmF0b3IoJG1hcEl0ZXJhdG9yKGl0ZXJhYmxlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCRtYXBBdEF0SXRlcmF0b3IpIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEF0QXRJdGVyYXRvcihpdGVyYWJsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCRtYXBGb3JFYWNoKSB7XG5cdFx0XHRcdFx0dmFyIGVudHJpZXMgPSBbXTtcblx0XHRcdFx0XHQkbWFwRm9yRWFjaChpdGVyYWJsZSwgZnVuY3Rpb24gKHYsIGspIHtcblx0XHRcdFx0XHRcdCRhcnJheVB1c2goZW50cmllcywgW2ssIHZdKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0QXJyYXlJdGVyYXRvcihlbnRyaWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlzU2V0KGl0ZXJhYmxlKSkge1xuXHRcdFx0XHRpZiAoJHNldEl0ZXJhdG9yKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdldFN0b3BJdGVyYXRpb25JdGVyYXRvcigkc2V0SXRlcmF0b3IoaXRlcmFibGUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJHNldEF0QXRJdGVyYXRvcikge1xuXHRcdFx0XHRcdHJldHVybiAkc2V0QXRBdEl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJHNldEZvckVhY2gpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cdFx0XHRcdFx0JHNldEZvckVhY2goaXRlcmFibGUsIGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdFx0XHQkYXJyYXlQdXNoKHZhbHVlcywgdik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIGdldEFycmF5SXRlcmF0b3IodmFsdWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG5cdFx0XHRyZXR1cm4gZ2V0Q29sbGVjdGlvbkl0ZXJhdG9yKGl0ZXJhYmxlKSB8fCBnZXROb25Db2xsZWN0aW9uSXRlcmF0b3IoaXRlcmFibGUpO1xuXHRcdH07XG5cdH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gdG9TdHIuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHR0b1N0ci5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJE1hcCA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgTWFwLnByb3RvdHlwZSA/IE1hcCA6IG51bGw7XG52YXIgJFNldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgU2V0LnByb3RvdHlwZSA/IFNldCA6IG51bGw7XG5cbnZhciBleHBvcnRlZDtcblxuaWYgKCEkTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXHRleHBvcnRlZCA9IGZ1bmN0aW9uIGlzTWFwKHgpIHtcblx0XHQvLyBgTWFwYCBpcyBub3QgcHJlc2VudCBpbiB0aGlzIGVudmlyb25tZW50LlxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxudmFyICRtYXBIYXMgPSAkTWFwID8gTWFwLnByb3RvdHlwZS5oYXMgOiBudWxsO1xudmFyICRzZXRIYXMgPSAkU2V0ID8gU2V0LnByb3RvdHlwZS5oYXMgOiBudWxsO1xuaWYgKCFleHBvcnRlZCAmJiAhJG1hcEhhcykge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblx0ZXhwb3J0ZWQgPSBmdW5jdGlvbiBpc01hcCh4KSB7XG5cdFx0Ly8gYE1hcGAgZG9lcyBub3QgaGF2ZSBhIGBoYXNgIG1ldGhvZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlZCB8fCBmdW5jdGlvbiBpc01hcCh4KSB7XG5cdGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHQkbWFwSGFzLmNhbGwoeCk7XG5cdFx0aWYgKCRzZXRIYXMpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdCRzZXRIYXMuY2FsbCh4KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB4IGluc3RhbmNlb2YgJE1hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG5cdH0gY2F0Y2ggKGUpIHt9XG5cdHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkTWFwID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXAucHJvdG90eXBlID8gTWFwIDogbnVsbDtcbnZhciAkU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBTZXQucHJvdG90eXBlID8gU2V0IDogbnVsbDtcblxudmFyIGV4cG9ydGVkO1xuXG5pZiAoISRTZXQpIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cdGV4cG9ydGVkID0gZnVuY3Rpb24gaXNTZXQoeCkge1xuXHRcdC8vIGBTZXRgIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgZW52aXJvbm1lbnQuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG52YXIgJG1hcEhhcyA9ICRNYXAgPyBNYXAucHJvdG90eXBlLmhhcyA6IG51bGw7XG52YXIgJHNldEhhcyA9ICRTZXQgPyBTZXQucHJvdG90eXBlLmhhcyA6IG51bGw7XG5pZiAoIWV4cG9ydGVkICYmICEkc2V0SGFzKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXHRleHBvcnRlZCA9IGZ1bmN0aW9uIGlzU2V0KHgpIHtcblx0XHQvLyBgU2V0YCBkb2VzIG5vdCBoYXZlIGEgYGhhc2AgbWV0aG9kXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVkIHx8IGZ1bmN0aW9uIGlzU2V0KHgpIHtcblx0aWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdCRzZXRIYXMuY2FsbCh4KTtcblx0XHRpZiAoJG1hcEhhcykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0JG1hcEhhcy5jYWxsKHgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHggaW5zdGFuY2VvZiAkU2V0OyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcblx0fSBjYXRjaCAoZSkge31cblx0cmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpdGVyYXRlSXRlcmF0b3IoaXRlcmF0b3IpIHtcblx0aWYgKCFpdGVyYXRvciB8fCB0eXBlb2YgaXRlcmF0b3IubmV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIGEgYG5leHRgIG1ldGhvZCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcblx0XHRpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGNhbGxiYWNrYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdH1cblx0fVxuXHR2YXIgdmFsdWVzID0gY2FsbGJhY2sgfHwgW107XG5cdHZhciByZXN1bHQ7XG5cdHdoaWxlICgocmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcblx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrKHJlc3VsdC52YWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlcy5wdXNoKHJlc3VsdC52YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdGlmICghY2FsbGJhY2spIHtcblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9jYWxsQm91bmQnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5zbGljZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBib3VuZE1hcFNoaW0gPSBmdW5jdGlvbiBtYXAoYXJyYXksIGNhbGxiYWNrZm4pIHtcblx0UmVxdWlyZU9iamVjdENvZXJjaWJsZShhcnJheSk7XG5cdHJldHVybiBwb2x5ZmlsbC5hcHBseShhcnJheSwgJHNsaWNlKGFyZ3VtZW50cywgMSkpO1xufTtcbmRlZmluZShib3VuZE1hcFNoaW0sIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJvdW5kTWFwU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTkuMTBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDaGVja09iamVjdENvZXJjaWJsZSh2YWx1ZSwgb3B0TWVzc2FnZSkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKG9wdE1lc3NhZ2UgfHwgKCdDYW5ub3QgY2FsbCBtZXRob2Qgb24gJyArIHZhbHVlKSk7XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJEFycmF5ID0gR2V0SW50cmluc2ljKCclQXJyYXklJyk7XG52YXIgJHNwZWNpZXMgPSBHZXRJbnRyaW5zaWMoJyVTeW1ib2wuc3BlY2llcyUnLCB0cnVlKTtcbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgR2V0ID0gcmVxdWlyZSgnLi9HZXQnKTtcbnZhciBJc0FycmF5ID0gcmVxdWlyZSgnLi9Jc0FycmF5Jyk7XG52YXIgSXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vSXNDb25zdHJ1Y3RvcicpO1xudmFyIElzSW50ZWdlciA9IHJlcXVpcmUoJy4vSXNJbnRlZ2VyJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuXHRpZiAoIUlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogbGVuZ3RoIG11c3QgYmUgYW4gaW50ZWdlciA+PSAwJyk7XG5cdH1cblx0dmFyIGxlbiA9IGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGg7XG5cdHZhciBDO1xuXHR2YXIgaXNBcnJheSA9IElzQXJyYXkob3JpZ2luYWxBcnJheSk7XG5cdGlmIChpc0FycmF5KSB7XG5cdFx0QyA9IEdldChvcmlnaW5hbEFycmF5LCAnY29uc3RydWN0b3InKTtcblx0XHQvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0byBtYWtlIGEgY3Jvc3MtcmVhbG0gbm9ybWFsIEFycmF5LCBhIHNhbWUtcmVhbG0gQXJyYXlcblx0XHQvLyBpZiAoSXNDb25zdHJ1Y3RvcihDKSkge1xuXHRcdC8vIFx0aWYgQyBpcyBhbm90aGVyIHJlYWxtJ3MgQXJyYXksIEMgPSB1bmRlZmluZWRcblx0XHQvLyBcdE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKEFycmF5KSkpID09PSBudWxsID9cblx0XHQvLyB9XG5cdFx0aWYgKCRzcGVjaWVzICYmIFR5cGUoQykgPT09ICdPYmplY3QnKSB7XG5cdFx0XHRDID0gR2V0KEMsICRzcGVjaWVzKTtcblx0XHRcdGlmIChDID09PSBudWxsKSB7XG5cdFx0XHRcdEMgPSB2b2lkIDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmICh0eXBlb2YgQyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gJEFycmF5KGxlbik7XG5cdH1cblx0aWYgKCFJc0NvbnN0cnVjdG9yKEMpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0MgbXVzdCBiZSBhIGNvbnN0cnVjdG9yJyk7XG5cdH1cblx0cmV0dXJuIG5ldyBDKGxlbik7IC8vIENvbnN0cnVjdChDLCBsZW4pO1xufTtcblxuIiwidmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgTWFwLnByb3RvdHlwZTtcbnZhciBtYXBTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzTWFwID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNYXAucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBtYXBTaXplID0gaGFzTWFwICYmIG1hcFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBtYXBTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBtYXBTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIG1hcEZvckVhY2ggPSBoYXNNYXAgJiYgTWFwLnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1NldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgU2V0LnByb3RvdHlwZTtcbnZhciBzZXRTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzU2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTZXQucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBzZXRTaXplID0gaGFzU2V0ICYmIHNldFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBzZXRTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBzZXRTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIHNldEZvckVhY2ggPSBoYXNTZXQgJiYgU2V0LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrTWFwLnByb3RvdHlwZTtcbnZhciB3ZWFrTWFwSGFzID0gaGFzV2Vha01hcCA/IFdlYWtNYXAucHJvdG90eXBlLmhhcyA6IG51bGw7XG52YXIgaGFzV2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nICYmIFdlYWtTZXQucHJvdG90eXBlO1xudmFyIHdlYWtTZXRIYXMgPSBoYXNXZWFrU2V0ID8gV2Vha1NldC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBib29sZWFuVmFsdWVPZiA9IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbWF0Y2ggPSBTdHJpbmcucHJvdG90eXBlLm1hdGNoO1xudmFyIGJpZ0ludFZhbHVlT2YgPSB0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nID8gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mIDogbnVsbDtcblxudmFyIGluc3BlY3RDdXN0b20gPSByZXF1aXJlKCcuL3V0aWwuaW5zcGVjdCcpLmN1c3RvbTtcbnZhciBpbnNwZWN0U3ltYm9sID0gaW5zcGVjdEN1c3RvbSAmJiBpc1N5bWJvbChpbnNwZWN0Q3VzdG9tKSA/IGluc3BlY3RDdXN0b20gOiBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluc3BlY3RfKG9iaiwgb3B0aW9ucywgZGVwdGgsIHNlZW4pIHtcbiAgICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoaGFzKG9wdHMsICdxdW90ZVN0eWxlJykgJiYgKG9wdHMucXVvdGVTdHlsZSAhPT0gJ3NpbmdsZScgJiYgb3B0cy5xdW90ZVN0eWxlICE9PSAnZG91YmxlJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwicXVvdGVTdHlsZVwiIG11c3QgYmUgXCJzaW5nbGVcIiBvciBcImRvdWJsZVwiJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICAgaGFzKG9wdHMsICdtYXhTdHJpbmdMZW5ndGgnKSAmJiAodHlwZW9mIG9wdHMubWF4U3RyaW5nTGVuZ3RoID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBvcHRzLm1heFN0cmluZ0xlbmd0aCA8IDAgJiYgb3B0cy5tYXhTdHJpbmdMZW5ndGggIT09IEluZmluaXR5XG4gICAgICAgICAgICA6IG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBudWxsXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwibWF4U3RyaW5nTGVuZ3RoXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgSW5maW5pdHksIG9yIGBudWxsYCcpO1xuICAgIH1cbiAgICB2YXIgY3VzdG9tSW5zcGVjdCA9IGhhcyhvcHRzLCAnY3VzdG9tSW5zcGVjdCcpID8gb3B0cy5jdXN0b21JbnNwZWN0IDogdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGN1c3RvbUluc3BlY3QgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJjdXN0b21JbnNwZWN0XCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCBvciBgZmFsc2VgJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBoYXMob3B0cywgJ2luZGVudCcpXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSBudWxsXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSAnXFx0J1xuICAgICAgICAmJiAhKHBhcnNlSW50KG9wdHMuaW5kZW50LCAxMCkgPT09IG9wdHMuaW5kZW50ICYmIG9wdHMuaW5kZW50ID4gMClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBcImluZGVudFwiIG11c3QgYmUgXCJcXFxcdFwiLCBhbiBpbnRlZ2VyID4gMCwgb3IgYG51bGxgJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvYmogPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhvYmosIG9wdHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5IC8gb2JqID4gMCA/ICcwJyA6ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZyhvYmopO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2JpZ2ludCcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgICAgcmV0dXJuIFN0cmluZyhvYmopICsgJ24nO1xuICAgIH1cblxuICAgIHZhciBtYXhEZXB0aCA9IHR5cGVvZiBvcHRzLmRlcHRoID09PSAndW5kZWZpbmVkJyA/IDUgOiBvcHRzLmRlcHRoO1xuICAgIGlmICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnKSB7IGRlcHRoID0gMDsgfVxuICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCAmJiBtYXhEZXB0aCA+IDAgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdbQXJyYXldJyA6ICdbT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IGdldEluZGVudChvcHRzLCBkZXB0aCk7XG5cbiAgICBpZiAodHlwZW9mIHNlZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlZW4gPSBbXTtcbiAgICB9IGVsc2UgaWYgKGluZGV4T2Yoc2Vlbiwgb2JqKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgZnJvbSwgbm9JbmRlbnQpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuLnNsaWNlKCk7XG4gICAgICAgICAgICBzZWVuLnB1c2goZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vSW5kZW50KSB7XG4gICAgICAgICAgICB2YXIgbmV3T3B0cyA9IHtcbiAgICAgICAgICAgICAgICBkZXB0aDogb3B0cy5kZXB0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoYXMob3B0cywgJ3F1b3RlU3R5bGUnKSkge1xuICAgICAgICAgICAgICAgIG5ld09wdHMucXVvdGVTdHlsZSA9IG9wdHMucXVvdGVTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgbmV3T3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zcGVjdF8odmFsdWUsIG9wdHMsIGRlcHRoICsgMSwgc2Vlbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lT2Yob2JqKTtcbiAgICAgICAgcmV0dXJuICdbRnVuY3Rpb24nICsgKG5hbWUgPyAnOiAnICsgbmFtZSA6ICcgKGFub255bW91cyknKSArICddJztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKG9iaikpIHtcbiAgICAgICAgdmFyIHN5bVN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgPyBtYXJrQm94ZWQoc3ltU3RyaW5nKSA6IHN5bVN0cmluZztcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChvYmopKSB7XG4gICAgICAgIHZhciBzID0gJzwnICsgU3RyaW5nKG9iai5ub2RlTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGF0dHJzID0gb2JqLmF0dHJpYnV0ZXMgfHwgW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHMgKz0gJyAnICsgYXR0cnNbaV0ubmFtZSArICc9JyArIHdyYXBRdW90ZXMocXVvdGUoYXR0cnNbaV0udmFsdWUpLCAnZG91YmxlJywgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSAnPic7XG4gICAgICAgIGlmIChvYmouY2hpbGROb2RlcyAmJiBvYmouY2hpbGROb2Rlcy5sZW5ndGgpIHsgcyArPSAnLi4uJzsgfVxuICAgICAgICBzICs9ICc8LycgKyBTdHJpbmcob2JqLm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpICsgJz4nO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJ1tdJzsgfVxuICAgICAgICB2YXIgeHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmIChpbmRlbnQgJiYgIXNpbmdsZUxpbmVWYWx1ZXMoeHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgaW5kZW50ZWRKb2luKHhzLCBpbmRlbnQpICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnWyAnICsgeHMuam9pbignLCAnKSArICcgXSc7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKG9iaikpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnWycgKyBTdHJpbmcob2JqKSArICddJzsgfVxuICAgICAgICByZXR1cm4gJ3sgWycgKyBTdHJpbmcob2JqKSArICddICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9JztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGN1c3RvbUluc3BlY3QpIHtcbiAgICAgICAgaWYgKGluc3BlY3RTeW1ib2wgJiYgdHlwZW9mIG9ialtpbnNwZWN0U3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtpbnNwZWN0U3ltYm9sXSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmouaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5pbnNwZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTWFwKG9iaikpIHtcbiAgICAgICAgdmFyIG1hcFBhcnRzID0gW107XG4gICAgICAgIG1hcEZvckVhY2guY2FsbChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBtYXBQYXJ0cy5wdXNoKGluc3BlY3Qoa2V5LCBvYmosIHRydWUpICsgJyA9PiAnICsgaW5zcGVjdCh2YWx1ZSwgb2JqKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbk9mKCdNYXAnLCBtYXBTaXplLmNhbGwob2JqKSwgbWFwUGFydHMsIGluZGVudCk7XG4gICAgfVxuICAgIGlmIChpc1NldChvYmopKSB7XG4gICAgICAgIHZhciBzZXRQYXJ0cyA9IFtdO1xuICAgICAgICBzZXRGb3JFYWNoLmNhbGwob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHNldFBhcnRzLnB1c2goaW5zcGVjdCh2YWx1ZSwgb2JqKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbk9mKCdTZXQnLCBzZXRTaXplLmNhbGwob2JqKSwgc2V0UGFydHMsIGluZGVudCk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtNYXAob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha01hcCcpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrU2V0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtTZXQnKTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KE51bWJlcihvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0JpZ0ludChvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKSkpO1xuICAgIH1cbiAgICBpZiAoaXNCb29sZWFuKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChib29sZWFuVmFsdWVPZi5jYWxsKG9iaikpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoU3RyaW5nKG9iaikpKTtcbiAgICB9XG4gICAgaWYgKCFpc0RhdGUob2JqKSAmJiAhaXNSZWdFeHAob2JqKSkge1xuICAgICAgICB2YXIgeXMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmICh5cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICd7fSc7IH1cbiAgICAgICAgaWYgKGluZGVudCkge1xuICAgICAgICAgICAgcmV0dXJuICd7JyArIGluZGVudGVkSm9pbih5cywgaW5kZW50KSArICd9JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3sgJyArIHlzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKG9iaik7XG59O1xuXG5mdW5jdGlvbiB3cmFwUXVvdGVzKHMsIGRlZmF1bHRTdHlsZSwgb3B0cykge1xuICAgIHZhciBxdW90ZUNoYXIgPSAob3B0cy5xdW90ZVN0eWxlIHx8IGRlZmF1bHRTdHlsZSkgPT09ICdkb3VibGUnID8gJ1wiJyA6IFwiJ1wiO1xuICAgIHJldHVybiBxdW90ZUNoYXIgKyBzICsgcXVvdGVDaGFyO1xufVxuXG5mdW5jdGlvbiBxdW90ZShzKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBBcnJheV0nOyB9XG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBEYXRlXSc7IH1cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH1cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBFcnJvcl0nOyB9XG5mdW5jdGlvbiBpc1N5bWJvbChvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFN5bWJvbF0nOyB9XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nOyB9XG5mdW5jdGlvbiBpc0JpZ0ludChvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEJpZ0ludF0nOyB9XG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7IH1cblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5IGluIHRoaXM7IH07XG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufVxuXG5mdW5jdGlvbiB0b1N0cihvYmopIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBuYW1lT2YoZikge1xuICAgIGlmIChmLm5hbWUpIHsgcmV0dXJuIGYubmFtZTsgfVxuICAgIHZhciBtID0gbWF0Y2guY2FsbChmdW5jdGlvblRvU3RyaW5nLmNhbGwoZiksIC9eZnVuY3Rpb25cXHMqKFtcXHckXSspLyk7XG4gICAgaWYgKG0pIHsgcmV0dXJuIG1bMV07IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSB7IHJldHVybiB4cy5pbmRleE9mKHgpOyB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSB7IHJldHVybiBpOyB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gaXNNYXAoeCkge1xuICAgIGlmICghbWFwU2l6ZSB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBtYXBTaXplLmNhbGwoeCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXRTaXplLmNhbGwoeCk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXZWFrTWFwKHgpIHtcbiAgICBpZiAoIXdlYWtNYXBIYXMgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha01hcEhhcy5jYWxsKHgsIHdlYWtNYXBIYXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2Vha1NldEhhcy5jYWxsKHgsIHdlYWtTZXRIYXMpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYWtNYXA7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1NldCh4KSB7XG4gICAgaWYgKCFzZXRTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtTZXQoeCkge1xuICAgIGlmICghd2Vha1NldEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha1NldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCh4KSB7XG4gICAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgeC5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHguZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0U3RyaW5nKHN0ciwgb3B0cykge1xuICAgIGlmIChzdHIubGVuZ3RoID4gb3B0cy5tYXhTdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHN0ci5sZW5ndGggLSBvcHRzLm1heFN0cmluZ0xlbmd0aDtcbiAgICAgICAgdmFyIHRyYWlsZXIgPSAnLi4uICcgKyByZW1haW5pbmcgKyAnIG1vcmUgY2hhcmFjdGVyJyArIChyZW1haW5pbmcgPiAxID8gJ3MnIDogJycpO1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhzdHIuc2xpY2UoMCwgb3B0cy5tYXhTdHJpbmdMZW5ndGgpLCBvcHRzKSArIHRyYWlsZXI7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgdmFyIHMgPSBzdHIucmVwbGFjZSgvKFsnXFxcXF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9bXFx4MDAtXFx4MWZdL2csIGxvd2J5dGUpO1xuICAgIHJldHVybiB3cmFwUXVvdGVzKHMsICdzaW5nbGUnLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gbG93Ynl0ZShjKSB7XG4gICAgdmFyIG4gPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHggPSB7XG4gICAgICAgIDg6ICdiJywgOTogJ3QnLCAxMDogJ24nLCAxMjogJ2YnLCAxMzogJ3InXG4gICAgfVtuXTtcbiAgICBpZiAoeCkgeyByZXR1cm4gJ1xcXFwnICsgeDsgfVxuICAgIHJldHVybiAnXFxcXHgnICsgKG4gPCAweDEwID8gJzAnIDogJycpICsgbi50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIG1hcmtCb3hlZChzdHIpIHtcbiAgICByZXR1cm4gJ09iamVjdCgnICsgc3RyICsgJyknO1xufVxuXG5mdW5jdGlvbiB3ZWFrQ29sbGVjdGlvbk9mKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSArICcgeyA/IH0nO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uT2YodHlwZSwgc2l6ZSwgZW50cmllcywgaW5kZW50KSB7XG4gICAgdmFyIGpvaW5lZEVudHJpZXMgPSBpbmRlbnQgPyBpbmRlbnRlZEpvaW4oZW50cmllcywgaW5kZW50KSA6IGVudHJpZXMuam9pbignLCAnKTtcbiAgICByZXR1cm4gdHlwZSArICcgKCcgKyBzaXplICsgJykgeycgKyBqb2luZWRFbnRyaWVzICsgJ30nO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVMaW5lVmFsdWVzKHhzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5kZXhPZih4c1tpXSwgJ1xcbicpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZW50KG9wdHMsIGRlcHRoKSB7XG4gICAgdmFyIGJhc2VJbmRlbnQ7XG4gICAgaWYgKG9wdHMuaW5kZW50ID09PSAnXFx0Jykge1xuICAgICAgICBiYXNlSW5kZW50ID0gJ1xcdCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5pbmRlbnQgPT09ICdudW1iZXInICYmIG9wdHMuaW5kZW50ID4gMCkge1xuICAgICAgICBiYXNlSW5kZW50ID0gQXJyYXkob3B0cy5pbmRlbnQgKyAxKS5qb2luKCcgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IGJhc2VJbmRlbnQsXG4gICAgICAgIHByZXY6IEFycmF5KGRlcHRoICsgMSkuam9pbihiYXNlSW5kZW50KVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGluZGVudGVkSm9pbih4cywgaW5kZW50KSB7XG4gICAgaWYgKHhzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJyc7IH1cbiAgICB2YXIgbGluZUpvaW5lciA9ICdcXG4nICsgaW5kZW50LnByZXYgKyBpbmRlbnQuYmFzZTtcbiAgICByZXR1cm4gbGluZUpvaW5lciArIHhzLmpvaW4oJywnICsgbGluZUpvaW5lcikgKyAnXFxuJyArIGluZGVudC5wcmV2O1xufVxuXG5mdW5jdGlvbiBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCkge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqKTtcbiAgICB2YXIgeHMgPSBbXTtcbiAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgeHMubGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHhzW2ldID0gaGFzKG9iaiwgaSkgPyBpbnNwZWN0KG9ialtpXSwgb2JqKSA6ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBpZiAoIWhhcyhvYmosIGtleSkpIHsgY29udGludWU7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgaWYgKGlzQXJyICYmIFN0cmluZyhOdW1iZXIoa2V5KSkgPT09IGtleSAmJiBrZXkgPCBvYmoubGVuZ3RoKSB7IGNvbnRpbnVlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIGlmICgoL1teXFx3JF0vKS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHhzLnB1c2goaW5zcGVjdChrZXksIG9iaikgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4cy5wdXNoKGtleSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geHM7XG59XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMuanMnKTtcblxudmFyICRjb25zdHJ1Y3QgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmNvbnN0cnVjdCUnLCB0cnVlKTtcblxudmFyIERlZmluZVByb3BlcnR5T3JUaHJvdyA9IHJlcXVpcmUoJy4vRGVmaW5lUHJvcGVydHlPclRocm93Jyk7XG50cnkge1xuXHREZWZpbmVQcm9wZXJ0eU9yVGhyb3coe30sICcnLCB7ICdbW0dldF1dJzogZnVuY3Rpb24gKCkge30gfSk7XG59IGNhdGNoIChlKSB7XG5cdC8vIEFjY2Vzc29yIHByb3BlcnRpZXMgYXJlbid0IHN1cHBvcnRlZFxuXHREZWZpbmVQcm9wZXJ0eU9yVGhyb3cgPSBudWxsO1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzY29uc3RydWN0b3JcblxuaWYgKERlZmluZVByb3BlcnR5T3JUaHJvdyAmJiAkY29uc3RydWN0KSB7XG5cdHZhciBpc0NvbnN0cnVjdG9yTWFya2VyID0ge307XG5cdHZhciBiYWRBcnJheUxpa2UgPSB7fTtcblx0RGVmaW5lUHJvcGVydHlPclRocm93KGJhZEFycmF5TGlrZSwgJ2xlbmd0aCcsIHtcblx0XHQnW1tHZXRdXSc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRocm93IGlzQ29uc3RydWN0b3JNYXJrZXI7XG5cdFx0fSxcblx0XHQnW1tFbnVtZXJhYmxlXV0nOiB0cnVlXG5cdH0pO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBgUmVmbGVjdC5jb25zdHJ1Y3RgIGludm9rZXMgYElzQ29uc3RydWN0b3IodGFyZ2V0KWAgYmVmb3JlIGBHZXQoYXJncywgJ2xlbmd0aCcpYDpcblx0XHRcdCRjb25zdHJ1Y3QoYXJndW1lbnQsIGJhZEFycmF5TGlrZSk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRyZXR1cm4gZXJyID09PSBpc0NvbnN0cnVjdG9yTWFya2VyO1xuXHRcdH1cblx0fTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuXHRcdC8vIHVuZm9ydHVuYXRlbHkgdGhlcmUncyBubyB3YXkgdG8gdHJ1bHkgY2hlY2sgdGhpcyB3aXRob3V0IHRyeS9jYXRjaCBgbmV3IGFyZ3VtZW50YCBpbiBvbGQgZW52aXJvbm1lbnRzXG5cdFx0cmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiAhIWFyZ3VtZW50LnByb3RvdHlwZTtcblx0fTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIGlzUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc1Byb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIERlZmluZU93blByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaGVscGVycy9EZWZpbmVPd25Qcm9wZXJ0eScpO1xuXG52YXIgRnJvbVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vRnJvbVByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIElzQWNjZXNzb3JEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9Jc0FjY2Vzc29yRGVzY3JpcHRvcicpO1xudmFyIElzRGF0YURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL0lzRGF0YURlc2NyaXB0b3InKTtcbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgU2FtZVZhbHVlID0gcmVxdWlyZSgnLi9TYW1lVmFsdWUnKTtcbnZhciBUb1Byb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vVG9Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZGVmaW5lcHJvcGVydHlvcnRocm93XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRGVmaW5lUHJvcGVydHlPclRocm93KE8sIFAsIGRlc2MpIHtcblx0aWYgKFR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFR5cGUoTykgaXMgbm90IE9iamVjdCcpO1xuXHR9XG5cblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IElzUHJvcGVydHlLZXkoUCkgaXMgbm90IHRydWUnKTtcblx0fVxuXG5cdHZhciBEZXNjID0gaXNQcm9wZXJ0eURlc2NyaXB0b3Ioe1xuXHRcdFR5cGU6IFR5cGUsXG5cdFx0SXNEYXRhRGVzY3JpcHRvcjogSXNEYXRhRGVzY3JpcHRvcixcblx0XHRJc0FjY2Vzc29yRGVzY3JpcHRvcjogSXNBY2Nlc3NvckRlc2NyaXB0b3Jcblx0fSwgZGVzYykgPyBkZXNjIDogVG9Qcm9wZXJ0eURlc2NyaXB0b3IoZGVzYyk7XG5cdGlmICghaXNQcm9wZXJ0eURlc2NyaXB0b3Ioe1xuXHRcdFR5cGU6IFR5cGUsXG5cdFx0SXNEYXRhRGVzY3JpcHRvcjogSXNEYXRhRGVzY3JpcHRvcixcblx0XHRJc0FjY2Vzc29yRGVzY3JpcHRvcjogSXNBY2Nlc3NvckRlc2NyaXB0b3Jcblx0fSwgRGVzYykpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogRGVzYyBpcyBub3QgYSB2YWxpZCBQcm9wZXJ0eSBEZXNjcmlwdG9yJyk7XG5cdH1cblxuXHRyZXR1cm4gRGVmaW5lT3duUHJvcGVydHkoXG5cdFx0SXNEYXRhRGVzY3JpcHRvcixcblx0XHRTYW1lVmFsdWUsXG5cdFx0RnJvbVByb3BlcnR5RGVzY3JpcHRvcixcblx0XHRPLFxuXHRcdFAsXG5cdFx0RGVzY1xuXHQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJc1Byb3BlcnR5RGVzY3JpcHRvcihFUywgRGVzYykge1xuXHRpZiAoRVMuVHlwZShEZXNjKSAhPT0gJ09iamVjdCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dmFyIGFsbG93ZWQgPSB7XG5cdFx0J1tbQ29uZmlndXJhYmxlXV0nOiB0cnVlLFxuXHRcdCdbW0VudW1lcmFibGVdXSc6IHRydWUsXG5cdFx0J1tbR2V0XV0nOiB0cnVlLFxuXHRcdCdbW1NldF1dJzogdHJ1ZSxcblx0XHQnW1tWYWx1ZV1dJzogdHJ1ZSxcblx0XHQnW1tXcml0YWJsZV1dJzogdHJ1ZVxuXHR9O1xuXG5cdGZvciAodmFyIGtleSBpbiBEZXNjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0XHRpZiAoaGFzKERlc2MsIGtleSkgJiYgIWFsbG93ZWRba2V5XSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGlmIChFUy5Jc0RhdGFEZXNjcmlwdG9yKERlc2MpICYmIEVTLklzQWNjZXNzb3JEZXNjcmlwdG9yKERlc2MpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1Byb3BlcnR5IERlc2NyaXB0b3JzIG1heSBub3QgYmUgYm90aCBhY2Nlc3NvciBhbmQgZGF0YSBkZXNjcmlwdG9ycycpO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcycpO1xuXG52YXIgYXNzZXJ0UmVjb3JkID0gcmVxdWlyZSgnLi4vaGVscGVycy9hc3NlcnRSZWNvcmQnKTtcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pc2FjY2Vzc29yZGVzY3JpcHRvclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIElzQWNjZXNzb3JEZXNjcmlwdG9yKERlc2MpIHtcblx0aWYgKHR5cGVvZiBEZXNjID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGFzc2VydFJlY29yZChUeXBlLCAnUHJvcGVydHkgRGVzY3JpcHRvcicsICdEZXNjJywgRGVzYyk7XG5cblx0aWYgKCFoYXMoRGVzYywgJ1tbR2V0XV0nKSAmJiAhaGFzKERlc2MsICdbW1NldF1dJykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRNYXRoID0gR2V0SW50cmluc2ljKCclTWF0aCUnKTtcblxudmFyICRmbG9vciA9ICRNYXRoLmZsb29yO1xudmFyICRhYnMgPSAkTWF0aC5hYnM7XG5cbnZhciAkaXNOYU4gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzTmFOJyk7XG52YXIgJGlzRmluaXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Zpbml0ZScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzaW50ZWdlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIElzSW50ZWdlcihhcmd1bWVudCkge1xuXHRpZiAodHlwZW9mIGFyZ3VtZW50ICE9PSAnbnVtYmVyJyB8fCAkaXNOYU4oYXJndW1lbnQpIHx8ICEkaXNGaW5pdGUoYXJndW1lbnQpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHZhciBhYnMgPSAkYWJzKGFyZ3VtZW50KTtcblx0cmV0dXJuICRmbG9vcihhYnMpID09PSBhYnM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhICE9PSBhOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmICEkaXNOYU4oeCkgJiYgeCAhPT0gSW5maW5pdHkgJiYgeCAhPT0gLUluZmluaXR5OyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxsQm91bmQnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgY2FsbEJvdW5kKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWNhbGxcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDYWxsKEYsIFYpIHtcblx0dmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXHRyZXR1cm4gJGFwcGx5KEYsIFYsIGFyZ3MpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIENyZWF0ZURhdGFQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ3JlYXRlRGF0YVByb3BlcnR5Jyk7XG52YXIgSXNQcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4vSXNQcm9wZXJ0eUtleScpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWNyZWF0ZWRhdGFwcm9wZXJ0eW9ydGhyb3dcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDcmVhdGVEYXRhUHJvcGVydHlPclRocm93KE8sIFAsIFYpIHtcblx0aWYgKFR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFR5cGUoTykgaXMgbm90IE9iamVjdCcpO1xuXHR9XG5cdGlmICghSXNQcm9wZXJ0eUtleShQKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBJc1Byb3BlcnR5S2V5KFApIGlzIG5vdCB0cnVlJyk7XG5cdH1cblx0dmFyIHN1Y2Nlc3MgPSBDcmVhdGVEYXRhUHJvcGVydHkoTywgUCwgVik7XG5cdGlmICghc3VjY2Vzcykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCd1bmFibGUgdG8gY3JlYXRlIGRhdGEgcHJvcGVydHknKTtcblx0fVxuXHRyZXR1cm4gc3VjY2Vzcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBEZWZpbmVPd25Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvRGVmaW5lT3duUHJvcGVydHknKTtcblxudmFyIEZyb21Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL0Zyb21Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBPcmRpbmFyeUdldE93blByb3BlcnR5ID0gcmVxdWlyZSgnLi9PcmRpbmFyeUdldE93blByb3BlcnR5Jyk7XG52YXIgSXNEYXRhRGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vSXNEYXRhRGVzY3JpcHRvcicpO1xudmFyIElzRXh0ZW5zaWJsZSA9IHJlcXVpcmUoJy4vSXNFeHRlbnNpYmxlJyk7XG52YXIgSXNQcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4vSXNQcm9wZXJ0eUtleScpO1xudmFyIFNhbWVWYWx1ZSA9IHJlcXVpcmUoJy4vU2FtZVZhbHVlJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWNyZWF0ZWRhdGFwcm9wZXJ0eVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENyZWF0ZURhdGFQcm9wZXJ0eShPLCBQLCBWKSB7XG5cdGlmIChUeXBlKE8pICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBUeXBlKE8pIGlzIG5vdCBPYmplY3QnKTtcblx0fVxuXHRpZiAoIUlzUHJvcGVydHlLZXkoUCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogSXNQcm9wZXJ0eUtleShQKSBpcyBub3QgdHJ1ZScpO1xuXHR9XG5cdHZhciBvbGREZXNjID0gT3JkaW5hcnlHZXRPd25Qcm9wZXJ0eShPLCBQKTtcblx0dmFyIGV4dGVuc2libGUgPSAhb2xkRGVzYyB8fCBJc0V4dGVuc2libGUoTyk7XG5cdHZhciBpbW11dGFibGUgPSBvbGREZXNjICYmICghb2xkRGVzY1snW1tXcml0YWJsZV1dJ10gfHwgIW9sZERlc2NbJ1tbQ29uZmlndXJhYmxlXV0nXSk7XG5cdGlmIChpbW11dGFibGUgfHwgIWV4dGVuc2libGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIERlZmluZU93blByb3BlcnR5KFxuXHRcdElzRGF0YURlc2NyaXB0b3IsXG5cdFx0U2FtZVZhbHVlLFxuXHRcdEZyb21Qcm9wZXJ0eURlc2NyaXB0b3IsXG5cdFx0Tyxcblx0XHRQLFxuXHRcdHtcblx0XHRcdCdbW0NvbmZpZ3VyYWJsZV1dJzogdHJ1ZSxcblx0XHRcdCdbW0VudW1lcmFibGVdXSc6IHRydWUsXG5cdFx0XHQnW1tWYWx1ZV1dJzogVixcblx0XHRcdCdbW1dyaXRhYmxlXV0nOiB0cnVlXG5cdFx0fVxuXHQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJGdPUEQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGxCb3VuZCcpO1xuXG52YXIgJGlzRW51bWVyYWJsZSA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZScpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG5cbnZhciBJc0FycmF5ID0gcmVxdWlyZSgnLi9Jc0FycmF5Jyk7XG52YXIgSXNQcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4vSXNQcm9wZXJ0eUtleScpO1xudmFyIElzUmVnRXhwID0gcmVxdWlyZSgnLi9Jc1JlZ0V4cCcpO1xudmFyIFRvUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9Ub1Byb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vcmRpbmFyeWdldG93bnByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gT3JkaW5hcnlHZXRPd25Qcm9wZXJ0eShPLCBQKSB7XG5cdGlmIChUeXBlKE8pICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBPIG11c3QgYmUgYW4gT2JqZWN0Jyk7XG5cdH1cblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFAgbXVzdCBiZSBhIFByb3BlcnR5IEtleScpO1xuXHR9XG5cdGlmICghaGFzKE8sIFApKSB7XG5cdFx0cmV0dXJuIHZvaWQgMDtcblx0fVxuXHRpZiAoISRnT1BEKSB7XG5cdFx0Ly8gRVMzIC8gSUUgOCBmYWxsYmFja1xuXHRcdHZhciBhcnJheUxlbmd0aCA9IElzQXJyYXkoTykgJiYgUCA9PT0gJ2xlbmd0aCc7XG5cdFx0dmFyIHJlZ2V4TGFzdEluZGV4ID0gSXNSZWdFeHAoTykgJiYgUCA9PT0gJ2xhc3RJbmRleCc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCdbW0NvbmZpZ3VyYWJsZV1dJzogIShhcnJheUxlbmd0aCB8fCByZWdleExhc3RJbmRleCksXG5cdFx0XHQnW1tFbnVtZXJhYmxlXV0nOiAkaXNFbnVtZXJhYmxlKE8sIFApLFxuXHRcdFx0J1tbVmFsdWVdXSc6IE9bUF0sXG5cdFx0XHQnW1tXcml0YWJsZV1dJzogdHJ1ZVxuXHRcdH07XG5cdH1cblx0cmV0dXJuIFRvUHJvcGVydHlEZXNjcmlwdG9yKCRnT1BEKE8sIFApKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnKTtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRtYXRjaCA9IEdldEludHJpbnNpYygnJVN5bWJvbC5tYXRjaCUnLCB0cnVlKTtcblxudmFyIGhhc1JlZ0V4cE1hdGNoZXIgPSByZXF1aXJlKCdpcy1yZWdleCcpO1xuXG52YXIgVG9Cb29sZWFuID0gcmVxdWlyZSgnLi9Ub0Jvb2xlYW4nKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzcmVnZXhwXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSXNSZWdFeHAoYXJndW1lbnQpIHtcblx0aWYgKCFhcmd1bWVudCB8fCB0eXBlb2YgYXJndW1lbnQgIT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICgkbWF0Y2gpIHtcblx0XHR2YXIgaXNSZWdFeHAgPSBhcmd1bWVudFskbWF0Y2hdO1xuXHRcdGlmICh0eXBlb2YgaXNSZWdFeHAgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gVG9Cb29sZWFuKGlzUmVnRXhwKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGhhc1JlZ0V4cE1hdGNoZXIoYXJndW1lbnQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSBoYXNTeW1ib2xzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xudmFyIGhhc093blByb3BlcnR5O1xudmFyIHJlZ2V4RXhlYztcbnZhciBpc1JlZ2V4TWFya2VyO1xudmFyIGJhZFN0cmluZ2lmaWVyO1xuXG5pZiAoaGFzVG9TdHJpbmdUYWcpIHtcblx0aGFzT3duUHJvcGVydHkgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cdHJlZ2V4RXhlYyA9IEZ1bmN0aW9uLmNhbGwuYmluZChSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xuXHRpc1JlZ2V4TWFya2VyID0ge307XG5cblx0dmFyIHRocm93UmVnZXhNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhyb3cgaXNSZWdleE1hcmtlcjtcblx0fTtcblx0YmFkU3RyaW5naWZpZXIgPSB7XG5cdFx0dG9TdHJpbmc6IHRocm93UmVnZXhNYXJrZXIsXG5cdFx0dmFsdWVPZjogdGhyb3dSZWdleE1hcmtlclxuXHR9O1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlID09PSAnc3ltYm9sJykge1xuXHRcdGJhZFN0cmluZ2lmaWVyW1N5bWJvbC50b1ByaW1pdGl2ZV0gPSB0aHJvd1JlZ2V4TWFya2VyO1xuXHR9XG59XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgcmVnZXhDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1RvU3RyaW5nVGFnXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHQ/IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcblx0XHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQodmFsdWUsICdsYXN0SW5kZXgnKTtcblx0XHR2YXIgaGFzTGFzdEluZGV4RGF0YVByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBoYXNPd25Qcm9wZXJ0eShkZXNjcmlwdG9yLCAndmFsdWUnKTtcblx0XHRpZiAoIWhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRyZWdleEV4ZWModmFsdWUsIGJhZFN0cmluZ2lmaWVyKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZSA9PT0gaXNSZWdleE1hcmtlcjtcblx0XHR9XG5cdH1cblx0OiBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG5cdFx0Ly8gSW4gb2xkZXIgYnJvd3NlcnMsIHR5cGVvZiByZWdleCBpbmNvcnJlY3RseSByZXR1cm5zICdmdW5jdGlvbidcblx0XHRpZiAoIXZhbHVlIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdG9TdHIuY2FsbCh2YWx1ZSkgPT09IHJlZ2V4Q2xhc3M7XG5cdH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRPYmplY3QgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QlJyk7XG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNQcmltaXRpdmUnKTtcblxudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9ICRPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG52YXIgJGlzRXh0ZW5zaWJsZSA9ICRPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzZXh0ZW5zaWJsZS1vXG5cbm1vZHVsZS5leHBvcnRzID0gJHByZXZlbnRFeHRlbnNpb25zXG5cdD8gZnVuY3Rpb24gSXNFeHRlbnNpYmxlKG9iaikge1xuXHRcdHJldHVybiAhaXNQcmltaXRpdmUob2JqKSAmJiAkaXNFeHRlbnNpYmxlKG9iaik7XG5cdH1cblx0OiBmdW5jdGlvbiBJc0V4dGVuc2libGUob2JqKSB7XG5cdFx0cmV0dXJuICFpc1ByaW1pdGl2ZShvYmopO1xuXHR9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgSXNQcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4vSXNQcm9wZXJ0eUtleScpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWhhc3Byb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSGFzUHJvcGVydHkoTywgUCkge1xuXHRpZiAoVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogYE9gIG11c3QgYmUgYW4gT2JqZWN0Jyk7XG5cdH1cblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IGBQYCBtdXN0IGJlIGEgUHJvcGVydHkgS2V5Jyk7XG5cdH1cblx0cmV0dXJuIFAgaW4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUb051bWJlciA9IHJlcXVpcmUoJy4vVG9OdW1iZXInKTtcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTkuNlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvVWludDMyKHgpIHtcblx0cmV0dXJuIFRvTnVtYmVyKHgpID4+PiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcbnZhciAkTnVtYmVyID0gR2V0SW50cmluc2ljKCclTnVtYmVyJScpO1xudmFyICRSZWdFeHAgPSBHZXRJbnRyaW5zaWMoJyVSZWdFeHAlJyk7XG52YXIgJHBhcnNlSW50ZWdlciA9IEdldEludHJpbnNpYygnJXBhcnNlSW50JScpO1xuXG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxsQm91bmQnKTtcbnZhciByZWdleFRlc3RlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVnZXhUZXN0ZXInKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNQcmltaXRpdmUnKTtcblxudmFyICRzdHJTbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIGlzQmluYXJ5ID0gcmVnZXhUZXN0ZXIoL14wYlswMV0rJC9pKTtcbnZhciBpc09jdGFsID0gcmVnZXhUZXN0ZXIoL14wb1swLTddKyQvaSk7XG52YXIgaXNJbnZhbGlkSGV4TGl0ZXJhbCA9IHJlZ2V4VGVzdGVyKC9eWy0rXTB4WzAtOWEtZl0rJC9pKTtcbnZhciBub25XUyA9IFsnXFx1MDA4NScsICdcXHUyMDBiJywgJ1xcdWZmZmUnXS5qb2luKCcnKTtcbnZhciBub25XU3JlZ2V4ID0gbmV3ICRSZWdFeHAoJ1snICsgbm9uV1MgKyAnXScsICdnJyk7XG52YXIgaGFzTm9uV1MgPSByZWdleFRlc3Rlcihub25XU3JlZ2V4KTtcblxuLy8gd2hpdGVzcGFjZSBmcm9tOiBodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS41LjQuMjBcbi8vIGltcGxlbWVudGF0aW9uIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2Jsb2IvdjMuNC4wL2VzNS1zaGltLmpzI0wxMzA0LUwxMzI0XG52YXIgd3MgPSBbXG5cdCdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycsXG5cdCdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOCcsXG5cdCdcXHUyMDI5XFx1RkVGRidcbl0uam9pbignJyk7XG52YXIgdHJpbVJlZ2V4ID0gbmV3IFJlZ0V4cCgnKF5bJyArIHdzICsgJ10rKXwoWycgKyB3cyArICddKyQpJywgJ2cnKTtcbnZhciAkcmVwbGFjZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlJyk7XG52YXIgJHRyaW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuICRyZXBsYWNlKHZhbHVlLCB0cmltUmVnZXgsICcnKTtcbn07XG5cbnZhciBUb1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vVG9QcmltaXRpdmUnKTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b251bWJlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvTnVtYmVyKGFyZ3VtZW50KSB7XG5cdHZhciB2YWx1ZSA9IGlzUHJpbWl0aXZlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogVG9QcmltaXRpdmUoYXJndW1lbnQsICROdW1iZXIpO1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIG51bWJlcicpO1xuXHR9XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0aWYgKGlzQmluYXJ5KHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIFRvTnVtYmVyKCRwYXJzZUludGVnZXIoJHN0clNsaWNlKHZhbHVlLCAyKSwgMikpO1xuXHRcdH0gZWxzZSBpZiAoaXNPY3RhbCh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiBUb051bWJlcigkcGFyc2VJbnRlZ2VyKCRzdHJTbGljZSh2YWx1ZSwgMiksIDgpKTtcblx0XHR9IGVsc2UgaWYgKGhhc05vbldTKHZhbHVlKSB8fCBpc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHRyaW1tZWQgPSAkdHJpbSh2YWx1ZSk7XG5cdFx0XHRpZiAodHJpbW1lZCAhPT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIFRvTnVtYmVyKHRyaW1tZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gJE51bWJlcih2YWx1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkdGVzdCA9IEdldEludHJpbnNpYygnUmVnRXhwLnByb3RvdHlwZS50ZXN0Jyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vY2FsbEJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWdleFRlc3RlcihyZWdleCkge1xuXHRyZXR1cm4gY2FsbEJpbmQoJHRlc3QsIHJlZ2V4KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2VzLXRvLXByaW1pdGl2ZS9lczIwMTUnKTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b3ByaW1pdGl2ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0KSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdHJldHVybiB0b1ByaW1pdGl2ZShpbnB1dCwgYXJndW1lbnRzWzFdKTtcblx0fVxuXHRyZXR1cm4gdG9QcmltaXRpdmUoaW5wdXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnO1xuXG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQcmltaXRpdmUnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcbnZhciBpc0RhdGUgPSByZXF1aXJlKCdpcy1kYXRlLW9iamVjdCcpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnaXMtc3ltYm9sJyk7XG5cbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gZnVuY3Rpb24gT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KSB7XG5cdGlmICh0eXBlb2YgTyA9PT0gJ3VuZGVmaW5lZCcgfHwgTyA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIG1ldGhvZCBvbiAnICsgTyk7XG5cdH1cblx0aWYgKHR5cGVvZiBoaW50ICE9PSAnc3RyaW5nJyB8fCAoaGludCAhPT0gJ251bWJlcicgJiYgaGludCAhPT0gJ3N0cmluZycpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignaGludCBtdXN0IGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIicpO1xuXHR9XG5cdHZhciBtZXRob2ROYW1lcyA9IGhpbnQgPT09ICdzdHJpbmcnID8gWyd0b1N0cmluZycsICd2YWx1ZU9mJ10gOiBbJ3ZhbHVlT2YnLCAndG9TdHJpbmcnXTtcblx0dmFyIG1ldGhvZCwgcmVzdWx0LCBpO1xuXHRmb3IgKGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyArK2kpIHtcblx0XHRtZXRob2QgPSBPW21ldGhvZE5hbWVzW2ldXTtcblx0XHRpZiAoaXNDYWxsYWJsZShtZXRob2QpKSB7XG5cdFx0XHRyZXN1bHQgPSBtZXRob2QuY2FsbChPKTtcblx0XHRcdGlmIChpc1ByaW1pdGl2ZShyZXN1bHQpKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIGRlZmF1bHQgdmFsdWUnKTtcbn07XG5cbnZhciBHZXRNZXRob2QgPSBmdW5jdGlvbiBHZXRNZXRob2QoTywgUCkge1xuXHR2YXIgZnVuYyA9IE9bUF07XG5cdGlmIChmdW5jICE9PSBudWxsICYmIHR5cGVvZiBmdW5jICE9PSAndW5kZWZpbmVkJykge1xuXHRcdGlmICghaXNDYWxsYWJsZShmdW5jKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihmdW5jICsgJyByZXR1cm5lZCBmb3IgcHJvcGVydHkgJyArIFAgKyAnIG9mIG9iamVjdCAnICsgTyArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmM7XG5cdH1cblx0cmV0dXJuIHZvaWQgMDtcbn07XG5cbi8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUb1ByaW1pdGl2ZShpbnB1dCkge1xuXHRpZiAoaXNQcmltaXRpdmUoaW5wdXQpKSB7XG5cdFx0cmV0dXJuIGlucHV0O1xuXHR9XG5cdHZhciBoaW50ID0gJ2RlZmF1bHQnO1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRpZiAoYXJndW1lbnRzWzFdID09PSBTdHJpbmcpIHtcblx0XHRcdGhpbnQgPSAnc3RyaW5nJztcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50c1sxXSA9PT0gTnVtYmVyKSB7XG5cdFx0XHRoaW50ID0gJ251bWJlcic7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGV4b3RpY1RvUHJpbTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRpZiAoU3ltYm9sLnRvUHJpbWl0aXZlKSB7XG5cdFx0XHRleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIFN5bWJvbC50b1ByaW1pdGl2ZSk7XG5cdFx0fSBlbHNlIGlmIChpc1N5bWJvbChpbnB1dCkpIHtcblx0XHRcdGV4b3RpY1RvUHJpbSA9IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZjtcblx0XHR9XG5cdH1cblx0aWYgKHR5cGVvZiBleG90aWNUb1ByaW0gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBoaW50KTtcblx0XHRpZiAoaXNQcmltaXRpdmUocmVzdWx0KSkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigndW5hYmxlIHRvIGNvbnZlcnQgZXhvdGljIG9iamVjdCB0byBwcmltaXRpdmUnKTtcblx0fVxuXHRpZiAoaGludCA9PT0gJ2RlZmF1bHQnICYmIChpc0RhdGUoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkpIHtcblx0XHRoaW50ID0gJ3N0cmluZyc7XG5cdH1cblx0cmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIGhpbnQgPT09ICdkZWZhdWx0JyA/ICdudW1iZXInIDogaGludCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldERheSA9IERhdGUucHJvdG90eXBlLmdldERheTtcbnZhciB0cnlEYXRlT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RGF0ZUdldERheUNhbGwodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRnZXREYXkuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RhdGVPYmplY3QodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5RGF0ZU9iamVjdCh2YWx1ZSkgOiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gZGF0ZUNsYXNzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG5pZiAoaGFzU3ltYm9scykge1xuXHR2YXIgc3ltVG9TdHIgPSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgc3ltU3RyaW5nUmVnZXggPSAvXlN5bWJvbFxcKC4qXFwpJC87XG5cdHZhciBpc1N5bWJvbE9iamVjdCA9IGZ1bmN0aW9uIGlzUmVhbFN5bWJvbE9iamVjdCh2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUudmFsdWVPZigpICE9PSAnc3ltYm9sJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gc3ltU3RyaW5nUmVnZXgudGVzdChzeW1Ub1N0ci5jYWxsKHZhbHVlKSk7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKHRvU3RyLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBTeW1ib2xdJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbHVlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xufSBlbHNlIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG5cdFx0Ly8gdGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFN5bWJvbHMuXG5cdFx0cmV0dXJuIGZhbHNlICYmIHZhbHVlO1xuXHR9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkT2JqZWN0ID0gR2V0SW50cmluc2ljKCclT2JqZWN0JScpO1xuXG52YXIgUmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4vUmVxdWlyZU9iamVjdENvZXJjaWJsZScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvb2JqZWN0XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9PYmplY3QodmFsdWUpIHtcblx0UmVxdWlyZU9iamVjdENvZXJjaWJsZSh2YWx1ZSk7XG5cdHJldHVybiAkT2JqZWN0KHZhbHVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRTdHJpbmcgPSBHZXRJbnRyaW5zaWMoJyVTdHJpbmclJyk7XG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b3N0cmluZ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvU3RyaW5nKGFyZ3VtZW50KSB7XG5cdGlmICh0eXBlb2YgYXJndW1lbnQgPT09ICdzeW1ib2wnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG5cdH1cblx0cmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJvcGVybHlCb3hlZChtZXRob2QpIHtcblx0Ly8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcblx0dmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuXHR2YXIgcHJvcGVybHlCb3hlc1N0cmljdCA9IHRydWU7XG5cdHZhciB0aHJld0V4Y2VwdGlvbiA9IGZhbHNlO1xuXHRpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuXHRcdFx0bWV0aG9kLmNhbGwoJ2YnLCBmdW5jdGlvbiAoXywgX18sIE8pIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBPICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdG1ldGhvZC5jYWxsKFxuXHRcdFx0XHRbbnVsbF0sXG5cdFx0XHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQndXNlIHN0cmljdCc7XG5cblx0XHRcdFx0XHRwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQneCdcblx0XHRcdCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dGhyZXdFeGNlcHRpb24gPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gIXRocmV3RXhjZXB0aW9uICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltQXJyYXlQcm90b3R5cGVNYXAoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShcblx0XHRBcnJheS5wcm90b3R5cGUsXG5cdFx0eyBtYXA6IHBvbHlmaWxsIH0sXG5cdFx0eyBtYXA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAgIT09IHBvbHlmaWxsOyB9IH1cblx0KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVQcm9taXNlID0gcmVxdWlyZSgnLi9yZXF1aXJlUHJvbWlzZScpO1xuXG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltQWxsU2V0dGxlZCgpIHtcblx0cmVxdWlyZVByb21pc2UoKTtcblxuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoUHJvbWlzZSwgeyBhbGxTZXR0bGVkOiBwb2x5ZmlsbCB9LCB7XG5cdFx0YWxsU2V0dGxlZDogZnVuY3Rpb24gdGVzdEFsbFNldHRsZWQoKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGxTZXR0bGVkICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8qKiBAcHJpdmF0ZSAqL1xudmFyIEN1c3RvbUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEN1c3RvbUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKCkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCB0c2xpYl8xLl9fc3ByZWFkKHBhcmFtcykpIHx8IHRoaXM7XG4gICAgICAgIC8vIHJlc3RvcmUgcHJvdG90eXBlIGNoYWluXG4gICAgICAgIHZhciBhY3R1YWxQcm90byA9IF9uZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcbiAgICAgICAgfVxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBfbmV3VGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21FcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5DdXN0b21FcnJvciA9IEN1c3RvbUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3VzdG9tRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjYWNoZV9kZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzXCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQVBJXCIpO1xudmFyIEJpdHNBUElfMSA9IHJlcXVpcmUoXCIuL0JpdHMvQml0c0FQSVwiKTtcbnZhciBDaGFubmVsQVBJXzEgPSByZXF1aXJlKFwiLi9DaGFubmVsL0NoYW5uZWxBUElcIik7XG52YXIgQ2hhdEFQSV8xID0gcmVxdWlyZShcIi4vQ2hhdC9DaGF0QVBJXCIpO1xudmFyIFNlYXJjaEFQSV8xID0gcmVxdWlyZShcIi4vU2VhcmNoL1NlYXJjaEFQSVwiKTtcbnZhciBTdHJlYW1BUElfMSA9IHJlcXVpcmUoXCIuL1N0cmVhbS9TdHJlYW1BUElcIik7XG52YXIgVGVhbUFQSV8xID0gcmVxdWlyZShcIi4vVGVhbS9UZWFtQVBJXCIpO1xudmFyIFVzZXJBUElfMSA9IHJlcXVpcmUoXCIuL1VzZXIvVXNlckFQSVwiKTtcbi8qKlxuICogR3JvdXBzIGFsbCBBUEkgY2FsbHMgYXZhaWxhYmxlIGluIEtyYWtlbiB2NS5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcge0BUd2l0Y2hDbGllbnQja3Jha2VufS5cbiAqL1xudmFyIEtyYWtlbkFQSUdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEtyYWtlbkFQSUdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEtyYWtlbkFQSUdyb3VwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLcmFrZW5BUElHcm91cC5wcm90b3R5cGUsIFwiYml0c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggYml0cy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaXRzQVBJXzEuZGVmYXVsdCh0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS3Jha2VuQVBJR3JvdXAucHJvdG90eXBlLCBcImNoYW5uZWxzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBjaGFubmVscy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFubmVsQVBJXzEuZGVmYXVsdCh0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS3Jha2VuQVBJR3JvdXAucHJvdG90eXBlLCBcImNoYXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIGNoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhdEFQSV8xLmRlZmF1bHQodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJzZWFyY2hcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIHNlYXJjaGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWFyY2hBUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLcmFrZW5BUElHcm91cC5wcm90b3R5cGUsIFwic3RyZWFtc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggc3RyZWFtcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1BUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLcmFrZW5BUElHcm91cC5wcm90b3R5cGUsIFwidXNlcnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIHVzZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVzZXJBUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLcmFrZW5BUElHcm91cC5wcm90b3R5cGUsIFwidGVhbXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIHRlYW1zLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlYW1BUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJiaXRzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJjaGFubmVsc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBLcmFrZW5BUElHcm91cC5wcm90b3R5cGUsIFwiY2hhdFwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBLcmFrZW5BUElHcm91cC5wcm90b3R5cGUsIFwic2VhcmNoXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJzdHJlYW1zXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJ1c2Vyc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBLcmFrZW5BUElHcm91cC5wcm90b3R5cGUsIFwidGVhbXNcIiwgbnVsbCk7XG4gICAgS3Jha2VuQVBJR3JvdXAgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVhYmxlXG4gICAgXSwgS3Jha2VuQVBJR3JvdXApO1xuICAgIHJldHVybiBLcmFrZW5BUElHcm91cDtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEtyYWtlbkFQSUdyb3VwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gS3Jha2VuQVBJR3JvdXA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBLcmFrZW5BUElHcm91cDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBVc2VyVG9vbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ub29sa2l0L1VzZXJUb29sc1wiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBDaGVlcm1vdGVMaXN0XzEgPSByZXF1aXJlKFwiLi9DaGVlcm1vdGVMaXN0XCIpO1xuLyoqXG4gKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggQml0cy9DaGVlcm1vdGVzLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmtyYWtlbi5iaXRzYCBvbiBhIHtAVHdpdGNoQ2xpZW50fSBpbnN0YW5jZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgY2xpZW50ID0gVHdpdGNoQ2xpZW50LndpdGhDcmVkZW50aWFscyhjbGllbnRJZCwgYWNjZXNzVG9rZW4pO1xuICogY29uc3QgY2hlZXJtb3RlcyA9IGF3YWl0IGNsaWVudC5rcmFrZW4uYml0cy5nZXRDaGVlcm1vdGVzKCk7XG4gKiBgYGBcbiAqL1xudmFyIEJpdHNBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQml0c0FQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaXRzQVBJKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBnbG9iYWwgYW5kIGNoYW5uZWwgY2hlZXJtb3Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHlvdSB3YW50IHRvIHJldHJpZXZlIHRoZSBhdmFpbGFibGUgY2hlZXJtb3RlcyBmb3IuXG4gICAgICogSWYgbm90IGdpdmVuLCB0aGlzIG1ldGhvZCByZXRyaWV2ZXMgYSBsaXN0IG9mIGdsb2JhbGx5IGF2YWlsYWJsZSBjaGVlcm1vdGVzLlxuICAgICAqIEBwYXJhbSBpbmNsdWRlU3BvbnNvcmVkIFdoZXRoZXIgdG8gaW5jbHVkZSBzcG9uc29yZWQgY2hlZXJtb3RlcyBpbiB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBCaXRzQVBJLnByb3RvdHlwZS5nZXRDaGVlcm1vdGVzID0gZnVuY3Rpb24gKGNoYW5uZWwsIGluY2x1ZGVTcG9uc29yZWQpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVTcG9uc29yZWQgPT09IHZvaWQgMCkgeyBpbmNsdWRlU3BvbnNvcmVkID0gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSwgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkuY2hhbm5lbF9pZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZVNwb25zb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LmluY2x1ZGVfc3BvbnNvcmVkID0gJ3RydWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6ICdiaXRzL2FjdGlvbnMnLCBxdWVyeTogcXVlcnkgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBDaGVlcm1vdGVMaXN0XzEuZGVmYXVsdChkYXRhLmFjdGlvbnMsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBCaXRzQVBJLnByb3RvdHlwZSwgXCJnZXRDaGVlcm1vdGVzXCIsIG51bGwpO1xuICAgIEJpdHNBUEkgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVhYmxlXG4gICAgXSwgQml0c0FQSSk7XG4gICAgcmV0dXJuIEJpdHNBUEk7XG59KEJhc2VBUElfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCaXRzQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQml0c0FQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJpdHNBUEk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNhY2hlX2RlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnNcIik7XG52YXIgSFRUUFN0YXR1c0NvZGVFcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0Vycm9ycy9IVFRQU3RhdHVzQ29kZUVycm9yXCIpO1xudmFyIE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRXJyb3JzL05vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXCIpO1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1Rvb2xraXQvVXNlclRvb2xzXCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIFVzZXJfMSA9IHJlcXVpcmUoXCIuLi9Vc2VyL1VzZXJcIik7XG52YXIgQ2hhbm5lbF8xID0gcmVxdWlyZShcIi4vQ2hhbm5lbFwiKTtcbnZhciBDaGFubmVsRm9sbG93XzEgPSByZXF1aXJlKFwiLi9DaGFubmVsRm9sbG93XCIpO1xudmFyIENoYW5uZWxTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuL0NoYW5uZWxTdWJzY3JpcHRpb25cIik7XG52YXIgUHJpdmlsZWdlZENoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL1ByaXZpbGVnZWRDaGFubmVsXCIpO1xudmFyIFRlYW1fMSA9IHJlcXVpcmUoXCIuLi9UZWFtL1RlYW1cIik7XG4vKipcbiAqIFRoZSBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBjaGFubmVscy5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcgYGNsaWVudC5rcmFrZW4uY2hhbm5lbHNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBjaGFubmVsID0gYXdhaXQgY2xpZW50LmtyYWtlbi5jaGFubmVscy5nZXRNeUNoYW5uZWwoKTtcbiAqIGBgYFxuICovXG52YXIgQ2hhbm5lbEFQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDaGFubmVsQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoYW5uZWxBUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2hhbm5lbCB0aGUgY2xpZW50IGlzIGxvZ2dlZCBpbiB0by5cbiAgICAgKi9cbiAgICBDaGFubmVsQVBJLnByb3RvdHlwZS5nZXRNeUNoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IFByaXZpbGVnZWRDaGFubmVsXzEuZGVmYXVsdC5iaW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6ICdjaGFubmVsJywgc2NvcGU6ICdjaGFubmVsX3JlYWQnIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IChfYS5hcHBseShQcml2aWxlZ2VkQ2hhbm5lbF8xLmRlZmF1bHQsIFt2b2lkIDAsIF9iLnNlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnRdKSkoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjaGFubmVsIGZvciB0aGUgZ2l2ZW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIHJldHJpZXZlIHRoZSBjaGFubmVsIGZvci5cbiAgICAgKi9cbiAgICBDaGFubmVsQVBJLnByb3RvdHlwZS5nZXRDaGFubmVsID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gQ2hhbm5lbF8xLmRlZmF1bHQuYmluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHsgdXJsOiBcImNoYW5uZWxzL1wiICsgVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyAoX2EuYXBwbHkoQ2hhbm5lbF8xLmRlZmF1bHQsIFt2b2lkIDAsIF9iLnNlbnQoKSwgdGhpcy5fY2xpZW50XSkpKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIGNoYW5uZWwgd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgdXBkYXRlZCBjaGFubmVsIGRhdGEuXG4gICAgICovXG4gICAgQ2hhbm5lbEFQSS5wcm90b3R5cGUudXBkYXRlQ2hhbm5lbCA9IGZ1bmN0aW9uIChjaGFubmVsLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxJZDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImNoYW5uZWxzL1wiICsgY2hhbm5lbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uQm9keTogeyBjaGFubmVsOiBkYXRhIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnY2hhbm5lbF9lZGl0b3InXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIHVzZXJzIHRoYXQgaGF2ZSBlZGl0b3IgcmlnaHRzIHRvIHRoZSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgeW91IHdhbnQgdG8gcmV0cmlldmUgdGhlIGxpc3Qgb2YgZWRpdG9ycyBmb3IuXG4gICAgICovXG4gICAgQ2hhbm5lbEFQSS5wcm90b3R5cGUuZ2V0Q2hhbm5lbEVkaXRvcnMgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsSWQsIGRhdGE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiY2hhbm5lbHMvXCIgKyBjaGFubmVsSWQgKyBcIi9lZGl0b3JzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnY2hhbm5lbF9yZWFkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhLnVzZXJzLm1hcChmdW5jdGlvbiAodXNlckRhdGEpIHsgcmV0dXJuIG5ldyBVc2VyXzEuZGVmYXVsdCh1c2VyRGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgZm9sbG93ZXJzIG9mIHRoZSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgeW91IHdhbnQgdG8gcmV0cmlldmUgdGhlIGxpc3Qgb2YgZm9sbG93ZXJzIG9mLlxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSByZXN1bHQgcGFnZSB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgVGhlIG51bWJlciBvZiByZXN1bHRzIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBvcmRlckRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRvIG9yZGVyIGluIC0gYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcuXG4gICAgICovXG4gICAgQ2hhbm5lbEFQSS5wcm90b3R5cGUuZ2V0Q2hhbm5lbEZvbGxvd2VycyA9IGZ1bmN0aW9uIChjaGFubmVsLCBwYWdlLCBsaW1pdCwgb3JkZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSAyNTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsSWQsIHF1ZXJ5LCBkYXRhO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0geyBsaW1pdDogbGltaXQudG9TdHJpbmcoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vZmZzZXQgPSAoKHBhZ2UgLSAxKSAqIGxpbWl0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkuZGlyZWN0aW9uID0gb3JkZXJEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJjaGFubmVscy9cIiArIGNoYW5uZWxJZCArIFwiL2ZvbGxvd3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEuZm9sbG93cy5tYXAoZnVuY3Rpb24gKGZvbGxvdykgeyByZXR1cm4gbmV3IENoYW5uZWxGb2xsb3dfMS5kZWZhdWx0KGZvbGxvdywgX3RoaXMuX2NsaWVudCk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2Ygc3Vic2NyaWJlcnMgb2YgdGhlIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB5b3Ugd2FudCB0byByZXRyaWV2ZSB0aGUgbGlzdCBvZiBzdWJzY3JpYmVycyBvZi5cbiAgICAgKiBAcGFyYW0gcGFnZSBUaGUgcmVzdWx0IHBhZ2UgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIGxpbWl0IFRoZSBudW1iZXIgb2YgcmVzdWx0cyB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gb3JkZXJEaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0byBvcmRlciBpbiAtIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nLlxuICAgICAqL1xuICAgIENoYW5uZWxBUEkucHJvdG90eXBlLmdldENoYW5uZWxTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKGNoYW5uZWwsIHBhZ2UsIGxpbWl0LCBvcmRlckRpcmVjdGlvbikge1xuICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IDI1OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldENoYW5uZWxTdWJzY3JpcHRpb25zKGNoYW5uZWwsIHBhZ2UsIGxpbWl0LCBvcmRlckRpcmVjdGlvbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEuc3Vic2NyaXB0aW9ucy5tYXAoZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gbmV3IENoYW5uZWxTdWJzY3JpcHRpb25fMS5kZWZhdWx0KHN1YiwgX3RoaXMuX2NsaWVudCk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHRvdGFsIG51bWJlciBvZiBzdWJzY3JpYmVycyBmb3IgdGhlIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB5b3Ugd2FudCB0byByZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIHN1YnNjcmliZXJzIGZvci5cbiAgICAgKi9cbiAgICBDaGFubmVsQVBJLnByb3RvdHlwZS5nZXRDaGFubmVsU3Vic2NyaXB0aW9uQ291bnQgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldENoYW5uZWxTdWJzY3JpcHRpb25zKGNoYW5uZWwsIDAsIDEpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhLl90b3RhbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBzdWJzY3JpcHRpb24gZGF0YSBmb3IgdGhlIGdpdmVuIHVzZXIgdG8gYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogVGhyb3dzIGlmIHRoZSBjaGFubmVsIGRvZXNuJ3QgaGF2ZSBhIHN1YnNjcmlwdGlvbiBwcm9ncmFtIG9yIHRoZSB1c2VyIGlzIG5vdCBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmVxdWlyZXMgYWNjZXNzIHRvIHRoZSBjaGFubmVsLiBJZiB5b3Ugb25seSBoYXZlIGFjY2VzcyB0byB0aGUgdXNlcixcbiAgICAgKiB1c2Uge0BVc2VyQVBJI2dldFN1YnNjcmlwdGlvbkRhdGF9IGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byBjaGVjayB0aGUgc3Vic2NyaXB0aW9uIHRvLlxuICAgICAqIEBwYXJhbSBieVVzZXIgVGhlIHVzZXIgdG8gY2hlY2sgdGhlIHN1YnNjcmlwdGlvbiBmb3IuXG4gICAgICovXG4gICAgQ2hhbm5lbEFQSS5wcm90b3R5cGUuZ2V0Q2hhbm5lbFN1YnNjcmlwdGlvbkJ5VXNlciA9IGZ1bmN0aW9uIChjaGFubmVsLCBieVVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbElkLCB1c2VySWQsIF9hLCBlXzE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGJ5VXNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IENoYW5uZWxTdWJzY3JpcHRpb25fMS5kZWZhdWx0LmJpbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJjaGFubmVscy9cIiArIGNoYW5uZWxJZCArIFwiL3N1YnNjcmlwdGlvbnMvXCIgKyB1c2VySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnY2hhbm5lbF9jaGVja19zdWJzY3JpcHRpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgKF9hLmFwcGx5KENoYW5uZWxTdWJzY3JpcHRpb25fMS5kZWZhdWx0LCBbdm9pZCAwLCBfYi5zZW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50XSkpKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xIGluc3RhbmNlb2YgSFRUUFN0YXR1c0NvZGVFcnJvcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVfMS5zdGF0dXNDb2RlID09PSA0MjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXzEuZGVmYXVsdChjaGFubmVsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiB0ZWFtcyBvZiB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHlvdSB3YW50IHRvIHJldHJpZXZlIHRoZSBsaXN0IG9mIHRlYW1zIG9mLlxuICAgICAqL1xuICAgIENoYW5uZWxBUEkucHJvdG90eXBlLmdldENoYW5uZWxUZWFtcyA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxJZCwgZGF0YTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJjaGFubmVscy9cIiArIGNoYW5uZWxJZCArIFwiL3RlYW1zXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YS50ZWFtcy5tYXAoZnVuY3Rpb24gKHRlYW0pIHsgcmV0dXJuIG5ldyBUZWFtXzEuZGVmYXVsdCh0ZWFtLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIGNvbW1lcmNpYWwgaW4gdGhlIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byBzdGFydCB0aGUgY29tbWVyY2lhbCBpbi5cbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIGNvbW1lcmNpYWwuXG4gICAgICovXG4gICAgQ2hhbm5lbEFQSS5wcm90b3R5cGUuc3RhcnRDaGFubmVsQ29tbWVyY2lhbCA9IGZ1bmN0aW9uIChjaGFubmVsLCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbElkO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImNoYW5uZWxzL1wiICsgY2hhbm5lbElkICsgXCIvY29tbWVyY2lhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uQm9keTogeyBsZW5ndGg6IGxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdjaGFubmVsX2NvbW1lcmNpYWwnXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgZ2l2ZW4gY2hhbm5lbCdzIHN0cmVhbSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byByZXNldCB0aGUgc3RyZWFtIGtleSBmb3IuXG4gICAgICovXG4gICAgQ2hhbm5lbEFQSS5wcm90b3R5cGUucmVzZXRDaGFubmVsU3RyZWFtS2V5ID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbElkO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImNoYW5uZWxzL1wiICsgY2hhbm5lbElkICsgXCIvc3RyZWFtX2tleVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnY2hhbm5lbF9zdHJlYW0nXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYW5uZWxBUEkucHJvdG90eXBlLl9nZXRDaGFubmVsU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uIChjaGFubmVsLCBwYWdlLCBsaW1pdCwgb3JkZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSAyNTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsSWQsIHF1ZXJ5LCBlXzI7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHsgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkub2Zmc2V0ID0gKChwYWdlIC0gMSkgKiBsaW1pdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlckRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LmRpcmVjdGlvbiA9IG9yZGVyRGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiY2hhbm5lbHMvXCIgKyBjaGFubmVsSWQgKyBcIi9zdWJzY3JpcHRpb25zXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdjaGFubmVsX3N1YnNjcmlwdGlvbnMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8yIGluc3RhbmNlb2YgSFRUUFN0YXR1c0NvZGVFcnJvcl8xLmRlZmF1bHQgJiYgZV8yLnN0YXR1c0NvZGUgPT09IDQyMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvcl8xLmRlZmF1bHQoY2hhbm5lbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIENoYW5uZWxBUEkucHJvdG90eXBlLCBcImdldE15Q2hhbm5lbFwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgQ2hhbm5lbEFQSS5wcm90b3R5cGUsIFwiZ2V0Q2hhbm5lbFwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2xlYXJzQ2FjaGUoJ2dldENoYW5uZWwnLCAxKVxuICAgIF0sIENoYW5uZWxBUEkucHJvdG90eXBlLCBcInVwZGF0ZUNoYW5uZWxcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIENoYW5uZWxBUEkucHJvdG90eXBlLCBcImdldENoYW5uZWxFZGl0b3JzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzApXG4gICAgXSwgQ2hhbm5lbEFQSS5wcm90b3R5cGUsIFwiZ2V0Q2hhbm5lbEZvbGxvd2Vyc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDMwKVxuICAgIF0sIENoYW5uZWxBUEkucHJvdG90eXBlLCBcImdldENoYW5uZWxTdWJzY3JpcHRpb25zXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzApXG4gICAgXSwgQ2hhbm5lbEFQSS5wcm90b3R5cGUsIFwiZ2V0Q2hhbm5lbFN1YnNjcmlwdGlvbkNvdW50XCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBDaGFubmVsQVBJLnByb3RvdHlwZSwgXCJnZXRDaGFubmVsU3Vic2NyaXB0aW9uQnlVc2VyXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzApXG4gICAgXSwgQ2hhbm5lbEFQSS5wcm90b3R5cGUsIFwiZ2V0Q2hhbm5lbFRlYW1zXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DbGVhcnNDYWNoZSgnZ2V0TXlDaGFubmVsJylcbiAgICBdLCBDaGFubmVsQVBJLnByb3RvdHlwZSwgXCJyZXNldENoYW5uZWxTdHJlYW1LZXlcIiwgbnVsbCk7XG4gICAgQ2hhbm5lbEFQSSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBDaGFubmVsQVBJKTtcbiAgICByZXR1cm4gQ2hhbm5lbEFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYW5uZWxBUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDaGFubmVsQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbEFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBVc2VyVG9vbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ub29sa2l0L1VzZXJUb29sc1wiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBDaGF0RW1vdGVMaXN0XzEgPSByZXF1aXJlKFwiLi9DaGF0RW1vdGVMaXN0XCIpO1xudmFyIENoYXRSb29tXzEgPSByZXF1aXJlKFwiLi9DaGF0Um9vbVwiKTtcbi8qKlxuICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIGNoYXQgYW5kIGNoYXRyb29tcy5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcgYGNsaWVudC5rcmFrZW4uY2hhdGAgb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IGVtb3RlcyA9IGF3YWl0IGNsaWVudC5rcmFrZW4uY2hhdC5nZXRFbW90ZXNCeVNldHMoJzEnKTtcbiAqIGBgYFxuICovXG52YXIgQ2hhdEFQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDaGF0QVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoYXRBUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBlbW90ZXMgZm9yIGEgZ2l2ZW4gbGlzdCBvZiBlbm90ZSBzZXQgSURzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVtb3Rlc2V0cyBUaGUgbGlzdCBvZiBlbW90ZSBzZXQgSURzLCBlaXRoZXIgYXMgYXJyYXkgb2Ygc3RyaW5ncyBvciBhcyBhIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgQ2hhdEFQSS5wcm90b3R5cGUuZ2V0RW1vdGVzQnlTZXRzID0gZnVuY3Rpb24gKGVtb3Rlc2V0cykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVtb3Rlc2V0cyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbW90ZXNldHMgPSBlbW90ZXNldHMuam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdjaGF0L2Vtb3RpY29uX2ltYWdlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbW90ZXNldHM6IGVtb3Rlc2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBDaGF0RW1vdGVMaXN0XzEuZGVmYXVsdChkYXRhLmVtb3RpY29ucywgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBjaGF0IHJvb21zIGZvciBhIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byByZXRyaWV2ZSB0aGUgY2hhdCByb29tcyBvZi5cbiAgICAgKi9cbiAgICBDaGF0QVBJLnByb3RvdHlwZS5nZXRDaGF0Um9vbXNGb3JDaGFubmVsID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJjaGF0L1wiICsgVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKSArIFwiL3Jvb21zXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhLnJvb21zLm1hcChmdW5jdGlvbiAocm9vbSkgeyByZXR1cm4gbmV3IENoYXRSb29tXzEuZGVmYXVsdChyb29tLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBDaGF0QVBJLnByb3RvdHlwZSwgXCJnZXRFbW90ZXNCeVNldHNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIENoYXRBUEkucHJvdG90eXBlLCBcImdldENoYXRSb29tc0ZvckNoYW5uZWxcIiwgbnVsbCk7XG4gICAgQ2hhdEFQSSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBDaGF0QVBJKTtcbiAgICByZXR1cm4gQ2hhdEFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYXRBUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDaGF0QVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBDaGF0RW1vdGVfMSA9IHJlcXVpcmUoXCIuL0NoYXRFbW90ZVwiKTtcbi8qKlxuICogQSBsaXN0IG9mIGVtb3Rlcy5cbiAqL1xudmFyIENoYXRFbW90ZUxpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gQ2hhdEVtb3RlTGlzdChfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdEVtb3RlTGlzdC5wcm90b3R5cGUsIFwiZW1vdGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBhbGwgZW1vdGVzIGluIHRoZSBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubWFwKGZ1bmN0aW9uIChlbW90ZSkgeyByZXR1cm4gbmV3IENoYXRFbW90ZV8xLmRlZmF1bHQoZW1vdGUsIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgZW1vdGVzIGZyb20gdGhlIGxpc3QgdGhhdCBhcmUgZnJvbSBhIGdpdmVuIGVtb3RlIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXRJZFxuICAgICAqL1xuICAgIENoYXRFbW90ZUxpc3QucHJvdG90eXBlLmdldEFsbEZyb21TZXQgPSBmdW5jdGlvbiAoc2V0SWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVtb3RlKSB7IHJldHVybiBlbW90ZS5lbW90aWNvbl9zZXQgPT09IHNldElkOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZW1vdGUpIHsgcmV0dXJuIG5ldyBDaGF0RW1vdGVfMS5kZWZhdWx0KGVtb3RlLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIHNpbmdsZSBlbW90ZSBieSBpdHMgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWRcbiAgICAgKi9cbiAgICBDaGF0RW1vdGVMaXN0LnByb3RvdHlwZS5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YS5maW5kKGZ1bmN0aW9uIChlbW90ZSkgeyByZXR1cm4gZW1vdGUuaWQgPT09IGlkOyB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgPyBuZXcgQ2hhdEVtb3RlXzEuZGVmYXVsdChkYXRhLCB0aGlzLl9jbGllbnQpIDogbnVsbDtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBDaGF0RW1vdGVMaXN0LnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgQ2hhdEVtb3RlTGlzdC5wcm90b3R5cGUsIFwiZW1vdGVzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoKVxuICAgIF0sIENoYXRFbW90ZUxpc3QucHJvdG90eXBlLCBcImdldEFsbEZyb21TZXRcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgpXG4gICAgXSwgQ2hhdEVtb3RlTGlzdC5wcm90b3R5cGUsIFwiZ2V0QnlJZFwiLCBudWxsKTtcbiAgICBDaGF0RW1vdGVMaXN0ID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIENoYXRFbW90ZUxpc3QpO1xuICAgIHJldHVybiBDaGF0RW1vdGVMaXN0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYXRFbW90ZUxpc3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDaGF0RW1vdGVMaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEVtb3RlTGlzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG4vKipcbiAqIEEgY2hhdCBlbW90ZS5cbiAqL1xudmFyIENoYXRFbW90ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBDaGF0RW1vdGUoX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRFbW90ZS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVtb3RlIElELlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRFbW90ZS5wcm90b3R5cGUsIFwiY29kZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZW1vdGUgY29kZSwgaS5lLiBob3cgeW91IHdyaXRlIGl0IGluIGNoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmNvZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0RW1vdGUucHJvdG90eXBlLCBcInNldElkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgZW1vdGUgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5lbW90aWNvbl9zZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBDaGF0RW1vdGUucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQ2hhdEVtb3RlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYXRFbW90ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENoYXRFbW90ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYXRFbW90ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG4vKiogQHByaXZhdGUgKi9cbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBDaGF0Um9vbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBDaGF0Um9vbShfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdFJvb20ucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgY2hhdCByb29tLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0Um9vbS5wcm90b3R5cGUsIFwib3duZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlciBJRCBvZiB0aGUgY2hhdCByb29tIG93bmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5vd25lcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgb2YgdGhlIGNoYXQgcm9vbSBvd25lci5cbiAgICAgKi9cbiAgICBDaGF0Um9vbS5wcm90b3R5cGUuZ2V0T3duZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuZ2V0VXNlcih0aGlzLl9kYXRhLm93bmVyX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdFJvb20ucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGNoYXQgcm9vbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRSb29tLnByb3RvdHlwZSwgXCJ0b3BpY1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9waWMgb2YgdGhlIGNoYXQgcm9vbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudG9waWM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0Um9vbS5wcm90b3R5cGUsIFwiaXNQcmV2aWV3YWJsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjaGF0IHJvb20gaXMgcHJldmlld2FibGUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlzX3ByZXZpZXdhYmxlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdFJvb20ucHJvdG90eXBlLCBcIm1pblJvbGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gcm9sZSBhbGxvd2VkIHRvIGVudGVyIHRoaXMgY2hhdCByb29tLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5taW5pbXVtX2FsbG93ZWRfcm9sZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRSb29tLnByb3RvdHlwZSwgXCJpcmNOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBJUkMgY2hhbm5lbCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoaXMgY2hhdCByb29tLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIjY2hhdHJvb21zOlwiICsgdGhpcy5fZGF0YS5vd25lcl9pZCArIFwiOlwiICsgdGhpcy5fZGF0YS5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBDaGF0Um9vbS5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBDaGF0Um9vbTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGF0Um9vbTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENoYXRSb29tO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdFJvb207XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNhY2hlX2RlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnNcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uLy4uL0Jhc2VBUElcIik7XG52YXIgQ2hhbm5lbF8xID0gcmVxdWlyZShcIi4uL0NoYW5uZWwvQ2hhbm5lbFwiKTtcbnZhciBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi9TdHJlYW0vU3RyZWFtXCIpO1xuLyoqXG4gKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggc2VhcmNoaW5nLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmtyYWtlbi5zZWFyY2hgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBjaGFubmVsID0gYXdhaXQgY2xpZW50LmtyYWtlbi5zZWFyY2guc2VhcmNoU3RyZWFtcygnSGVhcnRoc3RvbmUnKTtcbiAqIGBgYFxuICovXG52YXIgU2VhcmNoQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFNlYXJjaEFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWFyY2hBUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBjaGFubmVscyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzZWFyY2ggdGVybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXJtIFRoZSB0ZXJtIHlvdSB3YW50IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHBhZ2UgVGhlIHJlc3VsdCBwYWdlIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBsaW1pdCBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICovXG4gICAgU2VhcmNoQVBJLnByb3RvdHlwZS5zZWFyY2hDaGFubmVscyA9IGZ1bmN0aW9uICh0ZXJtLCBwYWdlLCBsaW1pdCkge1xuICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IDI1OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5LCBkYXRhO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB7IHF1ZXJ5OiB0ZXJtLCBsaW1pdDogbGltaXQudG9TdHJpbmcoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vZmZzZXQgPSAoKHBhZ2UgLSAxKSAqIGxpbWl0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6ICdzZWFyY2gvY2hhbm5lbHMnLCBxdWVyeTogcXVlcnkgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEuY2hhbm5lbHMubWFwKGZ1bmN0aW9uIChjaGFubmVsRGF0YSkgeyByZXR1cm4gbmV3IENoYW5uZWxfMS5kZWZhdWx0KGNoYW5uZWxEYXRhLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2Ygc3RyZWFtcyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzZWFyY2ggdGVybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXJtIFRoZSB0ZXJtIHlvdSB3YW50IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHBhZ2UgVGhlIHJlc3VsdCBwYWdlIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBsaW1pdCBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIGhscyBXaGV0aGVyIHlvdSB3YW50IG9ubHkgSExTIG9yIG9ubHkgbm9uLUhMUyAoUlRNUCkgc3RyZWFtcy4gSWYgbm90IHNldCwgZmluZHMgYm90aCB0eXBlcyBvZiBzdHJlYW1zLlxuICAgICAqL1xuICAgIFNlYXJjaEFQSS5wcm90b3R5cGUuc2VhcmNoU3RyZWFtcyA9IGZ1bmN0aW9uICh0ZXJtLCBwYWdlLCBsaW1pdCwgaGxzKSB7XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gMjU7IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnksIGRhdGE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHsgcXVlcnk6IHRlcm0sIGxpbWl0OiBsaW1pdC50b1N0cmluZygpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9mZnNldCA9ICgocGFnZSAtIDEpICogbGltaXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5obHMgPSBobHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHsgdXJsOiAnc2VhcmNoL3N0cmVhbXMnLCBxdWVyeTogcXVlcnkgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEuc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbURhdGEpIHsgcmV0dXJuIG5ldyBTdHJlYW1fMS5kZWZhdWx0KHN0cmVhbURhdGEsIF90aGlzLl9jbGllbnQpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzMDApXG4gICAgXSwgU2VhcmNoQVBJLnByb3RvdHlwZSwgXCJzZWFyY2hDaGFubmVsc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDMwMClcbiAgICBdLCBTZWFyY2hBUEkucHJvdG90eXBlLCBcInNlYXJjaFN0cmVhbXNcIiwgbnVsbCk7XG4gICAgU2VhcmNoQVBJID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIFNlYXJjaEFQSSk7XG4gICAgcmV0dXJuIFNlYXJjaEFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNlYXJjaEFQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNlYXJjaEFQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNlYXJjaEFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBVc2VyVG9vbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ub29sa2l0L1VzZXJUb29sc1wiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL1N0cmVhbVwiKTtcbi8qKlxuICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIHN0cmVhbXMuXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQua3Jha2VuLnN0cmVhbXNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBzdHJlYW0gPSBhd2FpdCBjbGllbnQua3Jha2VuLnN0cmVhbXMuZ2V0U3RyZWFtQnlDaGFubmVsKCcxMjUzMjg2NTUnKTtcbiAqIGBgYFxuICovXG52YXIgU3RyZWFtQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFN0cmVhbUFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJlYW1BUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHN0cmVhbSBvbiB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsXG4gICAgICovXG4gICAgU3RyZWFtQVBJLnByb3RvdHlwZS5nZXRTdHJlYW1CeUNoYW5uZWwgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsSWQsIGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7IHVybDogXCJzdHJlYW1zL1wiICsgY2hhbm5lbElkIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhLnN0cmVhbSA/IG5ldyBTdHJlYW1fMS5kZWZhdWx0KGRhdGEuc3RyZWFtLCB0aGlzLl9jbGllbnQpIDogbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBzdHJlYW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWxzIEEgY2hhbm5lbCBJRCBvciBhIGxpc3QgdGhlcmVvZi5cbiAgICAgKiBAcGFyYW0gZ2FtZSBTaG93IG9ubHkgc3RyZWFtcyBwbGF5aW5nIGEgY2VydGFpbiBnYW1lLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUNvZGUgU2hvdyBvbmx5IHN0cmVhbXMgaW4gYSBjZXJ0YWluIGxhbmd1YWdlLlxuICAgICAqIEBwYXJhbSB0eXBlIFNob3cgb25seSBzdHJlYW1zIG9mIGEgY2VydGFpbiB0eXBlLlxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSByZXN1bHQgcGFnZSB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgVGhlIG51bWJlciBvZiByZXN1bHRzIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIFN0cmVhbUFQSS5wcm90b3R5cGUuZ2V0U3RyZWFtcyA9IGZ1bmN0aW9uIChjaGFubmVscywgZ2FtZSwgbGFuZ3VhZ2VDb2RlLCB0eXBlLCBwYWdlLCBsaW1pdCkge1xuICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IDI1OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5LCBkYXRhO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB7IGxpbWl0OiBsaW1pdC50b1N0cmluZygpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5jaGFubmVsID0gdHlwZW9mIGNoYW5uZWxzID09PSAnc3RyaW5nJyA/IGNoYW5uZWxzIDogY2hhbm5lbHMuam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5nYW1lID0gZ2FtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5sYW5ndWFnZSA9IGxhbmd1YWdlQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkuc3RyZWFtX3R5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vZmZzZXQgPSAoKHBhZ2UgLSAxKSAqIGxpbWl0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6ICdzdHJlYW1zJywgcXVlcnk6IHF1ZXJ5IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhLnN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW1EYXRhKSB7IHJldHVybiBuZXcgU3RyZWFtXzEuZGVmYXVsdChzdHJlYW1EYXRhLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgYWxsIHN0cmVhbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZSBUaGUgcmVzdWx0IHBhZ2UgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIGxpbWl0IFRoZSBudW1iZXIgb2YgcmVzdWx0cyB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBTdHJlYW1BUEkucHJvdG90eXBlLmdldEFsbFN0cmVhbXMgPSBmdW5jdGlvbiAocGFnZSwgbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5nZXRTdHJlYW1zKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmVhbV8xLlN0cmVhbVR5cGUuQWxsLCBwYWdlLCBsaW1pdCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgbGl2ZSBzdHJlYW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhZ2UgVGhlIHJlc3VsdCBwYWdlIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBsaW1pdCBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICovXG4gICAgU3RyZWFtQVBJLnByb3RvdHlwZS5nZXRBbGxMaXZlU3RyZWFtcyA9IGZ1bmN0aW9uIChwYWdlLCBsaW1pdCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmdldFN0cmVhbXModW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyZWFtXzEuU3RyZWFtVHlwZS5MaXZlLCBwYWdlLCBsaW1pdCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgc3RyZWFtcyBvbiBjaGFubmVscyB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlciBpcyBmb2xsb3dpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSBTaG93IG9ubHkgc3RyZWFtcyBvZiBhIGNlcnRhaW4gdHlwZS5cbiAgICAgKiBAcGFyYW0gcGFnZSBUaGUgcmVzdWx0IHBhZ2UgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIGxpbWl0IFRoZSBudW1iZXIgb2YgcmVzdWx0cyB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBTdHJlYW1BUEkucHJvdG90eXBlLmdldEZvbGxvd2VkU3RyZWFtcyA9IGZ1bmN0aW9uICh0eXBlLCBwYWdlLCBsaW1pdCkge1xuICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IDI1OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5LCBkYXRhO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB7IGxpbWl0OiBsaW1pdC50b1N0cmluZygpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vZmZzZXQgPSAoKHBhZ2UgLSAxKSAqIGxpbWl0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdzdHJlYW1zL2ZvbGxvd2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ3VzZXJfcmVhZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YS5zdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtRGF0YSkgeyByZXR1cm4gbmV3IFN0cmVhbV8xLmRlZmF1bHQoc3RyZWFtRGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDYwKVxuICAgIF0sIFN0cmVhbUFQSS5wcm90b3R5cGUsIFwiZ2V0U3RyZWFtQnlDaGFubmVsXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoNjApXG4gICAgXSwgU3RyZWFtQVBJLnByb3RvdHlwZSwgXCJnZXRGb2xsb3dlZFN0cmVhbXNcIiwgbnVsbCk7XG4gICAgU3RyZWFtQVBJID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIFN0cmVhbUFQSSk7XG4gICAgcmV0dXJuIFN0cmVhbUFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmVhbUFQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFN0cmVhbUFQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmVhbUFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBUZWFtXzEgPSByZXF1aXJlKFwiLi9UZWFtXCIpO1xudmFyIFRlYW1XaXRoVXNlcnNfMSA9IHJlcXVpcmUoXCIuL1RlYW1XaXRoVXNlcnNcIik7XG4vKipcbiAqIFRoZSBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCB0ZWFtcy5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcgYGNsaWVudC5rcmFrZW4udGVhbXNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCB0ZWFtID0gYXdhaXQgY2xpZW50LmtyYWtlbi50ZWFtcy5nZXRUZWFtQnlOYW1lKCdzdGFmZicpO1xuICogYGBgXG4gKi9cbnZhciBUZWFtQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRlYW1BUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVhbUFQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIHRlYW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhZ2UgVGhlIHJlc3VsdCBwYWdlIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBsaW1pdCBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICovXG4gICAgVGVhbUFQSS5wcm90b3R5cGUuZ2V0VGVhbXMgPSBmdW5jdGlvbiAocGFnZSwgbGltaXQpIHtcbiAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSAyNTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSwgZGF0YTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9mZnNldCA9ICgocGFnZSAtIDEpICogbGltaXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5saW1pdCA9IGxpbWl0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3RlYW1zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEudGVhbXMubWFwKGZ1bmN0aW9uICh0ZWFtKSB7IHJldHVybiBuZXcgVGVhbV8xLmRlZmF1bHQodGVhbSwgX3RoaXMuX2NsaWVudCk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHRlYW0gZGF0YSBmb3IgdGhlIGdpdmVuIHRlYW0gbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZWFtIFRoZSB0ZWFtIG5hbWUgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKi9cbiAgICBUZWFtQVBJLnByb3RvdHlwZS5nZXRUZWFtQnlOYW1lID0gZnVuY3Rpb24gKHRlYW0pIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGVhbURhdGE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6IFwidGVhbXMvXCIgKyB0ZWFtIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGVhbURhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFRlYW1XaXRoVXNlcnNfMS5kZWZhdWx0KHRlYW1EYXRhLCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgVGVhbUFQSS5wcm90b3R5cGUsIFwiZ2V0VGVhbXNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIFRlYW1BUEkucHJvdG90eXBlLCBcImdldFRlYW1CeU5hbWVcIiwgbnVsbCk7XG4gICAgVGVhbUFQSSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBUZWFtQVBJKTtcbiAgICByZXR1cm4gVGVhbUFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRlYW1BUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBUZWFtQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gVGVhbUFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgVGVhbV8xID0gcmVxdWlyZShcIi4vVGVhbVwiKTtcbnZhciBVc2VyXzEgPSByZXF1aXJlKFwiLi4vVXNlci9Vc2VyXCIpO1xudmFyIFRlYW1XaXRoVXNlcnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGVhbVdpdGhVc2VycywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZWFtV2l0aFVzZXJzKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIHVzZXJzIGluIHRoZSB0ZWFtLlxuICAgICAqL1xuICAgIFRlYW1XaXRoVXNlcnMucHJvdG90eXBlLmdldFVzZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZGF0YS51c2Vycy5tYXAoZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBVc2VyXzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRlYW1XaXRoVXNlcnM7XG59KFRlYW1fMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUZWFtV2l0aFVzZXJzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVGVhbVdpdGhVc2Vycztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRlYW1XaXRoVXNlcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNhY2hlX2RlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnNcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FcnJvcnMvSGVsbEZyZWV6ZXNPdmVyRXJyb3JcIik7XG52YXIgSFRUUFN0YXR1c0NvZGVFcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0Vycm9ycy9IVFRQU3RhdHVzQ29kZUVycm9yXCIpO1xudmFyIE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRXJyb3JzL05vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXCIpO1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1Rvb2xraXQvVXNlclRvb2xzXCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIEVtb3RlU2V0TGlzdF8xID0gcmVxdWlyZShcIi4uL0NoYW5uZWwvRW1vdGVTZXRMaXN0XCIpO1xudmFyIFByaXZpbGVnZWRVc2VyXzEgPSByZXF1aXJlKFwiLi9Qcml2aWxlZ2VkVXNlclwiKTtcbnZhciBVc2VyXzEgPSByZXF1aXJlKFwiLi9Vc2VyXCIpO1xudmFyIFVzZXJCbG9ja18xID0gcmVxdWlyZShcIi4vVXNlckJsb2NrXCIpO1xudmFyIFVzZXJDaGF0SW5mb18xID0gcmVxdWlyZShcIi4vVXNlckNoYXRJbmZvXCIpO1xudmFyIFVzZXJGb2xsb3dfMSA9IHJlcXVpcmUoXCIuL1VzZXJGb2xsb3dcIik7XG52YXIgVXNlclN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vVXNlclN1YnNjcmlwdGlvblwiKTtcbi8qKlxuICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIHVzZXJzLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmtyYWtlbi51c2Vyc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IHVzZXIgPSBhd2FpdCBjbGllbnQua3Jha2VuLnVzZXJzLmdldFVzZXIoJzEyNTMyODY1NScpO1xuICogYGBgXG4gKi9cbnZhciBVc2VyQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFVzZXJBUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVXNlckFQSSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl91c2VyQnlOYW1lQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgb2YgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAgICovXG4gICAgVXNlckFQSS5wcm90b3R5cGUuZ2V0TWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IFByaXZpbGVnZWRVc2VyXzEuZGVmYXVsdC5iaW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6ICd1c2VyJywgc2NvcGU6ICd1c2VyX3JlYWQnIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IChfYS5hcHBseShQcml2aWxlZ2VkVXNlcl8xLmRlZmF1bHQsIFt2b2lkIDAsIF9iLnNlbnQoKSwgdGhpcy5fY2xpZW50XSkpKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdXNlciBkYXRhIGZvciB0aGUgZ2l2ZW4gdXNlciBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VySWQgVGhlIHVzZXIgSUQgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKi9cbiAgICBVc2VyQVBJLnByb3RvdHlwZS5nZXRVc2VyID0gZnVuY3Rpb24gKHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VyRGF0YTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7IHVybDogXCJ1c2Vycy9cIiArIFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcklkKSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBIZWxsRnJlZXplc092ZXJFcnJvcl8xLmRlZmF1bHQoJ0NvdWxkIG5vdCBnZXQgYXV0aGVudGljYXRlZCB1c2VyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFVzZXJfMS5kZWZhdWx0KHVzZXJEYXRhLCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHVzZXIgZGF0YSBmb3IgdGhlIGdpdmVuIHVzZXIgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyTmFtZSBUaGUgdXNlciBuYW1lIHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICovXG4gICAgVXNlckFQSS5wcm90b3R5cGUuZ2V0VXNlckJ5TmFtZSA9IGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VycywgdXNlcjtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IHVzaW5nIHRoZSBkZWNvcmF0b3IncyBjYWNoZSBoZXJlIGFzIHVzZXJzLWJ5LW5hbWUgaXMgc2xpZ2h0bHkgbW9yZSBjb21wbGV4IHRvIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhblVzZXJDYWNoZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VzZXJCeU5hbWVDYWNoZS5oYXModXNlck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3VzZXJCeU5hbWVDYWNoZS5nZXQodXNlck5hbWUpLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHsgdXJsOiAndXNlcnMnLCBxdWVyeTogeyBsb2dpbjogdXNlck5hbWUgfSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJzID0gKF9hLnNlbnQoKSkudXNlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlciA9IG5ldyBVc2VyXzEuZGVmYXVsdCh1c2Vyc1swXSwgdGhpcy5fY2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZXJCeU5hbWVDYWNoZS5zZXQodXNlck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXNlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzOiBEYXRlLm5vdygpICsgMzYwMCAqIDEwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVzZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdXNlciBkYXRhIGZvciB0aGUgZ2l2ZW4gdXNlciBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyTmFtZXMgVGhlIHVzZXIgbmFtZXMgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKi9cbiAgICBVc2VyQVBJLnByb3RvdHlwZS5nZXRVc2Vyc0J5TmFtZXMgPSBmdW5jdGlvbiAodXNlck5hbWVzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlZEVudHJpZXMsIGNhY2hlZE9iamVjdCwgY2FjaGVkVXNlcnMsIHRvRmV0Y2gsIHVzZXJzRGF0YSwgdXNlcnNBcnIsIHVzZXJzO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW5Vc2VyQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJOYW1lcyA9IHVzZXJOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRFbnRyaWVzID0gQXJyYXkuZnJvbSh0aGlzLl91c2VyQnlOYW1lQ2FjaGUuZW50cmllcygpKS5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gdHNsaWJfMS5fX3JlYWQoX2EsIDEpLCBrZXkgPSBfYlswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlck5hbWVzLmluY2x1ZGVzKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZE9iamVjdCA9IHNoYXJlZF91dGlsc18xLmVudHJpZXNUb09iamVjdChjYWNoZWRFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFVzZXJzID0gc2hhcmVkX3V0aWxzXzEubWFwT2JqZWN0KGNhY2hlZE9iamVjdCwgZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS52YWx1ZTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0ZldGNoID0gdXNlck5hbWVzLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIShuYW1lIGluIGNhY2hlZFVzZXJzKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRvRmV0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNhY2hlZFVzZXJzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHsgdXJsOiAndXNlcnMnLCBxdWVyeTogeyBsb2dpbjogdG9GZXRjaC5qb2luKCcsJykgfSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJzRGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJzQXJyID0gdXNlcnNEYXRhLnVzZXJzLm1hcChmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IFVzZXJfMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJzQXJyLmZvckVhY2goZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3VzZXJCeU5hbWVDYWNoZS5zZXQodXNlci5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1c2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzOiBEYXRlLm5vdygpICsgMzYwMCAqIDEwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnMgPSBzaGFyZWRfdXRpbHNfMS5pbmRleEJ5KHVzZXJzQXJyLCAnbmFtZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgY2FjaGVkVXNlcnMpLCB1c2VycyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlcidzIGNoYXQgYXBwZWFyYW5jZSBhbmQgcHJpdmlsZWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIGdldCBjaGF0IGluZm8gZm9yLlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLmdldENoYXRJbmZvID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkLCBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6IFwidXNlcnMvXCIgKyB1c2VySWQgKyBcIi9jaGF0XCIgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBVc2VyQ2hhdEluZm9fMS5kZWZhdWx0KGRhdGEsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZW1vdGVzIGEgZ2l2ZW4gdXNlciBjYW4gdXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgeW91IHdhbnQgdG8gZ2V0IGVtb3RlcyBmb3IuXG4gICAgICovXG4gICAgVXNlckFQSS5wcm90b3R5cGUuZ2V0VXNlckVtb3RlcyA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZCwgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHsgdXJsOiBcInVzZXJzL1wiICsgdXNlcklkICsgXCIvZW1vdGVzXCIsIHNjb3BlOiAndXNlcl9zdWJzY3JpcHRpb25zJyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEVtb3RlU2V0TGlzdF8xLmRlZmF1bHQoZGF0YS5lbW90aWNvbl9zZXRzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBzdWJzY3JpcHRpb24gZGF0YSBmb3IgYSBnaXZlbiB1c2VyIHRvIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHRvIHJldHJpZXZlIHRoZSBzdWJzY3JpcHRpb24gZGF0YSBvZi5cbiAgICAgKiBAcGFyYW0gdG9DaGFubmVsIFRoZSBjaGFubmVsIHlvdSB3YW50IHRvIHJldHJpZXZlIHRoZSBzdWJzY3JpcHRpb24gZGF0YSB0by5cbiAgICAgKi9cbiAgICBVc2VyQVBJLnByb3RvdHlwZS5nZXRTdWJzY3JpcHRpb25EYXRhID0gZnVuY3Rpb24gKHVzZXIsIHRvQ2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQsIGNoYW5uZWxJZCwgX2EsIGVfMTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodG9DaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gVXNlclN1YnNjcmlwdGlvbl8xLmRlZmF1bHQuYmluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcInVzZXJzL1wiICsgdXNlcklkICsgXCIvc3Vic2NyaXB0aW9ucy9cIiArIGNoYW5uZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICd1c2VyX3N1YnNjcmlwdGlvbnMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgKF9hLmFwcGx5KFVzZXJTdWJzY3JpcHRpb25fMS5kZWZhdWx0LCBbdm9pZCAwLCBfYi5zZW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50XSkpKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xIGluc3RhbmNlb2YgSFRUUFN0YXR1c0NvZGVFcnJvcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVfMS5zdGF0dXNDb2RlID09PSA0MjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXzEuZGVmYXVsdChjaGFubmVsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiBjaGFubmVscyBhIGdpdmVuIHVzZXIgZm9sbG93cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIHJldHJpZXZlIHRoZSBmb2xsb3dzIG9mLlxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSByZXN1bHQgcGFnZSB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgVGhlIG51bWJlciBvZiByZXN1bHRzIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBvcmRlckJ5IFRoZSBmaWVsZCB0byBvcmRlciBieS5cbiAgICAgKiBAcGFyYW0gb3JkZXJEaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0byBvcmRlciBpbiAtIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nLlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLmdldEZvbGxvd2VkQ2hhbm5lbHMgPSBmdW5jdGlvbiAodXNlciwgcGFnZSwgbGltaXQsIG9yZGVyQnksIG9yZGVyRGlyZWN0aW9uKSB7XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gMjU7IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkLCBxdWVyeSwgZGF0YTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vZmZzZXQgPSAoKHBhZ2UgLSAxKSAqIGxpbWl0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkubGltaXQgPSBsaW1pdC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyQnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5zb3J0YnkgPSBvcmRlckJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkuZGlyZWN0aW9uID0gb3JkZXJEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJ1c2Vycy9cIiArIHVzZXJJZCArIFwiL2ZvbGxvd3MvY2hhbm5lbHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEuZm9sbG93cy5tYXAoZnVuY3Rpb24gKGZvbGxvdykgeyByZXR1cm4gbmV3IFVzZXJGb2xsb3dfMS5kZWZhdWx0KGZvbGxvdywgX3RoaXMuX2NsaWVudCk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgZm9sbG93IGRhdGEgZm9yIGEgZ2l2ZW4gdXNlciB0byBhIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB5b3Ugd2FudCB0byByZXRyaWV2ZSBmb2xsb3cgZGF0YSBvZi5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB5b3Ugd2FudCB0byByZXRyaWV2ZSBmb2xsb3cgZGF0YSB0by5cbiAgICAgKi9cbiAgICBVc2VyQVBJLnByb3RvdHlwZS5nZXRGb2xsb3dlZENoYW5uZWwgPSBmdW5jdGlvbiAodXNlciwgY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQsIGNoYW5uZWxJZCwgZGF0YSwgZV8yO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHsgdXJsOiBcInVzZXJzL1wiICsgdXNlcklkICsgXCIvZm9sbG93cy9jaGFubmVscy9cIiArIGNoYW5uZWxJZCB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFVzZXJGb2xsb3dfMS5kZWZhdWx0KGRhdGEsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8yIGluc3RhbmNlb2YgSFRUUFN0YXR1c0NvZGVFcnJvcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8yLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8yO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2xsb3dzIGEgZ2l2ZW4gY2hhbm5lbCB3aXRoIGEgZ2l2ZW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIGZvbGxvdyB3aXRoLlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIGZvbGxvdy5cbiAgICAgKiBAcGFyYW0gbm90aWZpY2F0aW9ucyBXaGV0aGVyIHRoZSB1c2VyIHdpbGwgcmVjZWl2ZSBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLmZvbGxvd0NoYW5uZWwgPSBmdW5jdGlvbiAodXNlciwgY2hhbm5lbCwgbm90aWZpY2F0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQsIGNoYW5uZWxJZCwgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJ1c2Vycy9cIiArIHVzZXJJZCArIFwiL2ZvbGxvd3MvY2hhbm5lbHMvXCIgKyBjaGFubmVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAndXNlcl9mb2xsb3dzX2VkaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7IG5vdGlmaWNhdGlvbnM6IEJvb2xlYW4obm90aWZpY2F0aW9ucykudG9TdHJpbmcoKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBVc2VyRm9sbG93XzEuZGVmYXVsdChkYXRhLCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmZvbGxvd3MgYSBnaXZlbiBjaGFubmVsIHdpdGggYSBnaXZlbiB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgeW91IHdhbnQgdG8gdW5mb2xsb3cgd2l0aC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byB1bmZvbGxvdy5cbiAgICAgKi9cbiAgICBVc2VyQVBJLnByb3RvdHlwZS51bmZvbGxvd0NoYW5uZWwgPSBmdW5jdGlvbiAodXNlciwgY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQsIGNoYW5uZWxJZDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJ1c2Vycy9cIiArIHVzZXJJZCArIFwiL2ZvbGxvd3MvY2hhbm5lbHMvXCIgKyBjaGFubmVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAndXNlcl9mb2xsb3dzX2VkaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiB1c2VycyBhIGdpdmVuIHVzZXIgaGFzIGJsb2NrZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB5b3Ugd2FudCB0byByZXRyaWV2ZSB0aGUgYmxvY2sgbGlzdCBvZi5cbiAgICAgKiBAcGFyYW0gcGFnZSBUaGUgcmVzdWx0IHBhZ2UgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIGxpbWl0IFRoZSBudW1iZXIgb2YgcmVzdWx0cyB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBVc2VyQVBJLnByb3RvdHlwZS5nZXRCbG9ja2VkVXNlcnMgPSBmdW5jdGlvbiAodXNlciwgcGFnZSwgbGltaXQpIHtcbiAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSAyNTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQsIHF1ZXJ5LCBkYXRhO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0geyBsaW1pdDogbGltaXQudG9TdHJpbmcoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vZmZzZXQgPSAoKHBhZ2UgLSAxKSAqIGxpbWl0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwidXNlcnMvXCIgKyB1c2VySWQgKyBcIi9ibG9ja3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ3VzZXJfYmxvY2tzX3JlYWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEuYmxvY2tzLm1hcChmdW5jdGlvbiAoYmxvY2spIHsgcmV0dXJuIG5ldyBVc2VyQmxvY2tfMS5kZWZhdWx0KGJsb2NrLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBhIGdpdmVuIHVzZXIgd2l0aCBhbm90aGVyIGdpdmVuIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB5b3Ugd2FudCB0byBibG9jayB3aXRoLlxuICAgICAqIEBwYXJhbSB1c2VyVG9CbG9jayBUaGUgdXNlciB0byBibG9jay5cbiAgICAgKi9cbiAgICBVc2VyQVBJLnByb3RvdHlwZS5ibG9ja1VzZXIgPSBmdW5jdGlvbiAodXNlciwgdXNlclRvQmxvY2spIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkLCB1c2VySWRUb0Jsb2NrLCBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkVG9CbG9jayA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlclRvQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwidXNlcnMvXCIgKyB1c2VySWQgKyBcIi9ibG9ja3MvXCIgKyB1c2VySWRUb0Jsb2NrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ3VzZXJfYmxvY2tzX2VkaXQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBVc2VyQmxvY2tfMS5kZWZhdWx0KGRhdGEsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuYmxvY2tzIGEgZ2l2ZW4gdXNlciB3aXRoIGFub3RoZXIgZ2l2ZW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIHVuYmxvY2sgd2l0aC5cbiAgICAgKiBAcGFyYW0gdXNlclRvVW5ibG9jayBUaGUgdXNlciB0byB1bmJsb2NrLlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLnVuYmxvY2tVc2VyID0gZnVuY3Rpb24gKHVzZXIsIHVzZXJUb1VuYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkLCB1c2VySWRUb1VuYmxvY2s7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWRUb1VuYmxvY2sgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXJUb1VuYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwidXNlcnMvXCIgKyB1c2VySWQgKyBcIi9ibG9ja3MvXCIgKyB1c2VySWRUb1VuYmxvY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAndXNlcl9ibG9ja3NfZWRpdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBVc2VyQVBJLnByb3RvdHlwZS5fY2xlYW5Vc2VyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLl91c2VyQnlOYW1lQ2FjaGUuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgICAgICAgIGlmICh2YWwuZXhwaXJlcyA8IG5vdykge1xuICAgICAgICAgICAgICAgIF90aGlzLl91c2VyQnlOYW1lQ2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIFVzZXJBUEkucHJvdG90eXBlLCBcImdldE1lXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBVc2VyQVBJLnByb3RvdHlwZSwgXCJnZXRVc2VyXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBVc2VyQVBJLnByb3RvdHlwZSwgXCJnZXRDaGF0SW5mb1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgVXNlckFQSS5wcm90b3R5cGUsIFwiZ2V0VXNlckVtb3Rlc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgVXNlckFQSS5wcm90b3R5cGUsIFwiZ2V0U3Vic2NyaXB0aW9uRGF0YVwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDMwMClcbiAgICBdLCBVc2VyQVBJLnByb3RvdHlwZSwgXCJnZXRGb2xsb3dlZENoYW5uZWxzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzAwKVxuICAgIF0sIFVzZXJBUEkucHJvdG90eXBlLCBcImdldEZvbGxvd2VkQ2hhbm5lbFwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2xlYXJzQ2FjaGUoJ2dldEZvbGxvd2VkQ2hhbm5lbHMnLCAxKSxcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNsZWFyc0NhY2hlKCdnZXRGb2xsb3dlZENoYW5uZWwnLCAyKVxuICAgIF0sIFVzZXJBUEkucHJvdG90eXBlLCBcImZvbGxvd0NoYW5uZWxcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNsZWFyc0NhY2hlKCdnZXRGb2xsb3dlZENoYW5uZWxzJywgMSksXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DbGVhcnNDYWNoZSgnZ2V0Rm9sbG93ZWRDaGFubmVsJywgMilcbiAgICBdLCBVc2VyQVBJLnByb3RvdHlwZSwgXCJ1bmZvbGxvd0NoYW5uZWxcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIFVzZXJBUEkucHJvdG90eXBlLCBcImdldEJsb2NrZWRVc2Vyc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2xlYXJzQ2FjaGUoJ2dldEJsb2NrZWRVc2VycycsIDEpXG4gICAgXSwgVXNlckFQSS5wcm90b3R5cGUsIFwiYmxvY2tVc2VyXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DbGVhcnNDYWNoZSgnZ2V0QmxvY2tlZFVzZXJzJywgMSlcbiAgICBdLCBVc2VyQVBJLnByb3RvdHlwZSwgXCJ1bmJsb2NrVXNlclwiLCBudWxsKTtcbiAgICBVc2VyQVBJID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIFVzZXJBUEkpO1xuICAgIHJldHVybiBVc2VyQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVXNlckFQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFVzZXJBUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVc2VyQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgYSB1c2VyJ3MgY2hhdCBhcHBlYXJhbmNlIGFuZCBwcml2aWxlZ2VzLlxuICovXG52YXIgVXNlckNoYXRJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIFVzZXJDaGF0SW5mbyhfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckNoYXRJbmZvLnByb3RvdHlwZSwgXCJ1c2VySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBtb3JlIGRhdGEgYWJvdXQgdGhlIHVzZXIuXG4gICAgICovXG4gICAgVXNlckNoYXRJbmZvLnByb3RvdHlwZS5nZXRVc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLmdldFVzZXIodGhpcy5fZGF0YS5faWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQ2hhdEluZm8ucHJvdG90eXBlLCBcInVzZXJOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sb2dpbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJDaGF0SW5mby5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZGlzcGxheV9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckNoYXRJbmZvLnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29sb3IgdGhhdCB0aGUgdXNlciBhcHBlYXJzIGluIGluIGNoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckNoYXRJbmZvLnByb3RvdHlwZSwgXCJpc0tub3duQm90XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgaXMgYSBrbm93biBib3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlzX2tub3duX2JvdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJDaGF0SW5mby5wcm90b3R5cGUsIFwiaXNWZXJpZmllZEJvdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIGlzIGEgdmVyaWZpZWQgYm90LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pc192ZXJpZmllZF9ib3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQ2hhdEluZm8ucHJvdG90eXBlLCBcImlzQXRMZWFzdEtub3duQm90XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgaXMgYXQgbGVhc3QgYSBrbm93biBib3QgKGkuZS4ga25vd24gb3IgdmVyaWZpZWQpLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pc19rbm93bl9ib3QgfHwgdGhpcy5fZGF0YS5pc192ZXJpZmllZF9ib3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGhhcyBhY2Nlc3MgdG8gYSBnaXZlbiBnbG9iYWwgYmFkZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIG9mIGEgYmFkZ2UuXG4gICAgICovXG4gICAgVXNlckNoYXRJbmZvLnByb3RvdHlwZS5oYXNCYWRnZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5iYWRnZXMuc29tZShmdW5jdGlvbiAoYmFkZ2UpIHsgcmV0dXJuIGJhZGdlLmlkID09PSBpZDsgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgVXNlckNoYXRJbmZvLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFVzZXJDaGF0SW5mbztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVc2VyQ2hhdEluZm87XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBVc2VyQ2hhdEluZm87XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVc2VyQ2hhdEluZm87XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNhY2hlX2RlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnNcIik7XG52YXIgVXNlclRvb2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vVG9vbGtpdC9Vc2VyVG9vbHNcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vVHdpdGNoQ2xpZW50XCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQVBJXCIpO1xudmFyIENoYXR0ZXJzTGlzdF8xID0gcmVxdWlyZShcIi4vQ2hhdHRlcnNMaXN0XCIpO1xuLyoqXG4gKiBEaWZmZXJlbnQgQVBJIG1ldGhvZHMgdGhhdCBhcmUgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkIGJ5IFR3aXRjaC5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcgYGNsaWVudC51bnN1cHBvcnRlZGAgb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IGV2ZW50cyA9IGF3YWl0IGNsaWVudC51bnN1cHBvcnRlZC5nZXRFdmVudHMoJzEyNTMyODY1NScpO1xuICogYGBgXG4gKi9cbnZhciBVbnN1cHBvcnRlZEFQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhVbnN1cHBvcnRlZEFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbnN1cHBvcnRlZEFQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGNoYXR0ZXJzIGluIHRoZSBUd2l0Y2ggY2hhdCBvZiB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqICoqV0FSTklORyoqOiBJbiBjb250cmFzdCB0byBtb3N0IG90aGVyIG1ldGhvZHMsIHRoaXMgdGFrZXMgYSBjaGFubmVsICpuYW1lKiwgbm90IGEgdXNlciBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHJldHJpZXZlIHRoZSBjaGF0dGVycyBmb3IuXG4gICAgICovXG4gICAgVW5zdXBwb3J0ZWRBUEkucHJvdG90eXBlLmdldENoYXR0ZXJzID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbE5hbWUsIGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxOYW1lID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJOYW1lKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiaHR0cHM6Ly90bWkudHdpdGNoLnR2L2dyb3VwL3VzZXIvXCIgKyBjaGFubmVsTmFtZSArIFwiL2NoYXR0ZXJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkN1c3RvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgQ2hhdHRlcnNMaXN0XzEuZGVmYXVsdChkYXRhKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCg2MClcbiAgICBdLCBVbnN1cHBvcnRlZEFQSS5wcm90b3R5cGUsIFwiZ2V0Q2hhdHRlcnNcIiwgbnVsbCk7XG4gICAgVW5zdXBwb3J0ZWRBUEkgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVhYmxlXG4gICAgXSwgVW5zdXBwb3J0ZWRBUEkpO1xuICAgIHJldHVybiBVbnN1cHBvcnRlZEFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVuc3VwcG9ydGVkQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVW5zdXBwb3J0ZWRBUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVbnN1cHBvcnRlZEFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vVHdpdGNoQ2xpZW50XCIpO1xuLyoqXG4gKiBBbiBhdXRoIHByb3ZpZGVyIHRoYXQgcmV0cmlldmUgdG9rZW5zIHVzaW5nIGNsaWVudCBjcmVkZW50aWFscy5cbiAqL1xudmFyIENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXV0aCBwcm92aWRlciB0byByZWNlaXZlIGFuIGFwcGxpY2F0aW9uIHRva2VuIHdpdGggdXNpbmcgdGhlIGNsaWVudCBJRCBhbmQgc2VjcmV0LlxuICAgICAqXG4gICAgICogWW91IGRvbid0IHVzdWFsbHkgaGF2ZSB0byBjcmVhdGUgdGhpcyBtYW51YWxseS4gWW91IHNob3VsZCB1c2UgYFR3aXRjaENsaWVudC53aXRoQ2xpZW50Q3JlZGVudGlhbHNgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBjbGllbnRTZWNyZXQgVGhlIGNsaWVudCBzZWNyZXQgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIFlvdSBuZWVkIHRvIG9idGFpbiBvbmUgdXNpbmcgb25lIG9mIHRoZSBbVHdpdGNoIE9BdXRoIGZsb3dzXShodHRwczovL2Rldi50d2l0Y2gudHYvZG9jcy9hdXRoZW50aWNhdGlvbi9nZXR0aW5nLXRva2Vucy1vYXV0aC8pLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyKGNsaWVudElkLCBjbGllbnRTZWNyZXQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRva2VucyB0aGlzIHByb3ZpZGVyIGdlbmVyYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBhdXRoIHByb3ZpZGVyIGdlbmVyYXRlcyBhcHAgdG9rZW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2tlblR5cGUgPSAnYXBwJztcbiAgICAgICAgdGhpcy5fY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5fY2xpZW50U2VjcmV0ID0gY2xpZW50U2VjcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYWNjZXNzIHRva2VuLlxuICAgICAqXG4gICAgICogSWYgYW55IHNjb3BlcyBhcmUgcHJvdmlkZWQsIHRoaXMgdGhyb3dzLiBUaGUgY2xpZW50IGNyZWRlbnRpYWxzIGZsb3cgZG9lcyBub3Qgc3VwcG9ydCBzY29wZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NvcGVzIFRoZSByZXF1ZXN0ZWQgc2NvcGVzLlxuICAgICAqL1xuICAgIENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyLnByb3RvdHlwZS5nZXRBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uIChzY29wZXMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVzICYmIHNjb3Blcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjb3BlIFwiICsgKHR5cGVvZiBzY29wZXMgPT09ICdzdHJpbmcnID8gc2NvcGVzIDogc2NvcGVzLmpvaW4oJywnKSkgKyBcIiByZXF1ZXN0ZWQgYnV0IHRoZSBjbGllbnQgY3JlZGVudGlhbHMgZmxvdyBkb2VzIG5vdCBzdXBwb3J0IHNjb3Blc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90b2tlbiB8fCB0aGlzLl90b2tlbi5pc0V4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucmVmcmVzaCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3Rva2VuXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIG5ldyBhcHAgYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgVHdpdGNoQ2xpZW50XzEuZGVmYXVsdC5nZXRBcHBBY2Nlc3NUb2tlbih0aGlzLl9jbGllbnRJZCwgdGhpcy5fY2xpZW50U2VjcmV0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5fdG9rZW4gPSBfYi5zZW50KCkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBDbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlci5wcm90b3R5cGUuc2V0QWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdGhpcy5fdG9rZW4gPSB0b2tlbjtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlci5wcm90b3R5cGUsIFwiY2xpZW50SWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsaWVudCBJRC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudElkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcImN1cnJlbnRTY29wZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjb3BlcyB0aGF0IGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlIHVzaW5nIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyLnByb3RvdHlwZSwgXCJfY2xpZW50SWRcIiwgdm9pZCAwKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcIl9jbGllbnRTZWNyZXRcIiwgdm9pZCAwKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcIl90b2tlblwiLCB2b2lkIDApO1xuICAgIHJldHVybiBDbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEN1c3RvbUVycm9yXzEgPSByZXF1aXJlKFwiLi9DdXN0b21FcnJvclwiKTtcbi8qKlxuICogVGhyb3duIHdoZW5ldmVyIGEgZGlmZmVyZW50IHRva2VuIHR5cGUgKHVzZXIgdnMuIGFwcCkgaXMgZXhwZWN0ZWQgaW4gdGhlIG1ldGhvZCB5b3UncmUgY2FsbGluZy5cbiAqL1xudmFyIEludmFsaWRUb2tlblR5cGVFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnZhbGlkVG9rZW5UeXBlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW52YWxpZFRva2VuVHlwZUVycm9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBJbnZhbGlkVG9rZW5UeXBlRXJyb3I7XG59KEN1c3RvbUVycm9yXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSW52YWxpZFRva2VuVHlwZUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSW52YWxpZFRva2VuVHlwZUVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSW52YWxpZFRva2VuVHlwZUVycm9yO1xuIiwiXHJcblxyXG5jb25zdCBkZWZhdWx0Q2xpZW50SWQgPSBcIjU5eDhqeWF1ZHczcG55aTcyMngzZTJ4OWF3aDM4NVwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgQ29uZmlnTWFuYWdlciB7XHJcbiAgICBzdGF0aWMgdXNlckNsaWVudElkIDogc3RyaW5nO1xyXG5cclxuICAgIHN0YXRpYyBzZXRVc2VyQ2xpZW50SWQoY2xpZW50SWQ6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMudXNlckNsaWVudElkID0gY2xpZW50SWQ7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldENsaWVudElkKCkgOiBzdHJpbmcge1xyXG4gICAgICAgIGlmKHRoaXMudXNlckNsaWVudElkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJDbGllbnRJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDbGllbnRJZDtcclxuICAgIH1cclxufSIsIi8vIEZpbGUgd2l0aCBjb25maWcgdmFsdWVzIGFuZCBjb25zdGFudHNcclxuXHJcbmV4cG9ydCBjb25zdCBjbGllbnRJZCA9IFwieWJ1bTFmdnVyc25vNG5mM2Nreng1NmptaHF5bmprXCI7ICAvLyBBZGQgY2xpZW50IElEIGhlcmVcclxuXHJcbmV4cG9ydCBjb25zdCBkZWZhdWx0SGVhZGVycyA9IHtcclxuICAgIFwiQ2xpZW50LUlEXCI6IGNsaWVudElkLFxyXG4gICAgXCJBY2NlcHRcIjogXCJhcHBsaWNhdGlvbi92bmQudHdpdGNodHYudjUranNvblwiLFxyXG4gICAgXCJBdXRob3JpemF0aW9uXCI6IFwiT0F1dGggZ2N1OXBkMGtjbjZ4MngzZHJpeDZlc2JobHJmcWZ2XCIsXHJcbn1cclxuXHJcbi8vIFR5cGVTY3JpcHQgZG9lcyBub3QgYWxsb3cgcGFyYW1ldHJpemVkIHN0cmluZyB0byBiZSBmb3JtYXR0ZWQgaW4gcnVudGltZSxcclxuLy8gc28gdGhpcyBpcyB0aGUgYmVzdCB3YXkgdG8gZ2V0IGEgZm9ybWF0dGVkIFVSTC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFwaVVybCh2aWRlb0lkOiBzdHJpbmcsIG5leHRDdXJzb3I6IHN0cmluZykgOiBzdHJpbmcge1xyXG4gICAgaWYobmV4dEN1cnNvcikge1xyXG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9hcGkudHdpdGNoLnR2L3Y1L3ZpZGVvcy8ke3ZpZGVvSWR9L2NvbW1lbnRzP2N1cnNvcj0ke25leHRDdXJzb3J9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBgaHR0cHM6Ly9hcGkudHdpdGNoLnR2L3Y1L3ZpZGVvcy8ke3ZpZGVvSWR9L2NvbW1lbnRzYDtcclxufSIsIlxyXG5pbXBvcnQgeyBnZXRBcGlVcmwsIGRlZmF1bHRIZWFkZXJzIH0gZnJvbSAnLi9jb25maWcnO1xyXG5cclxuY29uc3QgdG9vTWFueVJlcXVlc3RzID0gNDI5OyAgLy8gSFRUUCA0MjkgdG9vIG1hbnkgcmVxdWVzdHMgcmVzcG9uc2UgY29kZVxyXG5cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHNsZWVwKG1zOiBudW1iZXIpIDogUHJvbWlzZTxhbnk+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShfID0+IHNldFRpbWVvdXQoXywgbXMpKTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hSZXNwb25zZSB7XHJcbiAgICBzdGF0dXM6IG51bWJlcjtcclxuICAgIHRleHQ6IHN0cmluZztcclxufVxyXG5cclxuXHJcbmV4cG9ydCB0eXBlIExvb3BFdmVudEhhbmRsZXIgPSAodHVybjogbnVtYmVyLCBzdGF0dXM6IG51bWJlciwgZG93bmxvYWRDb3VudDogbnVtYmVyKSA9PiB2b2lkO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBDaGF0RG93bmxvYWRlciB7XHJcbiAgICBsb29wSGFuZGxlcjogTG9vcEV2ZW50SGFuZGxlcjtcclxuXHJcbiAgICBhZGRMb29wRXZlbnRMaXN0ZW5lcihoYW5kbGVyOiBMb29wRXZlbnRIYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5sb29wSGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG93bmxvYWQgY2hhdCBvZiBzaW5nbGUgVHdpdGNoIHZpZGVvXHJcbiAgICBhc3luYyBkb3dubG9hZENoYXQodmlkZW9JZDogc3RyaW5nKSA6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xyXG4gICAgICAgIGNvbnN0IGNvbW1lbnRzID0gW107XHJcbiAgICAgICAgbGV0IHR1cm4gPSAwO1xyXG4gICAgICAgIGxldCBuZXh0Q3Vyc29yIDogc3RyaW5nID0gbnVsbDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsQXBpKHZpZGVvSWQsIG5leHRDdXJzb3IpO1xyXG4gICAgICAgICAgICBpZihyZXNwb25zZS50ZXh0KSB7ICAvLyByZXNwb25zZS50ZXh0IGlzIG51bGwgaWYgc3RhdHVzIGlzIG5vdCBvay5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbkNvbnRlbnQgPSBKU09OLnBhcnNlKHJlc3BvbnNlLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgbmV3Q29tbWVudCBvZiBqc29uQ29udGVudFtcImNvbW1lbnRzXCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2gobmV3Q29tbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRDdXJzb3IgPSBqc29uQ29udGVudFtcIl9uZXh0XCJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHR1cm4gKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvb3BIYW5kbGVyPy4odHVybiwgcmVzcG9uc2Uuc3RhdHVzLCBjb21tZW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBwYXJzaW5nIEpTT04gcmVzcG9uc2U6ICR7cmVzcG9uc2UudGV4dH1gKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvb3BIYW5kbGVyPy4odHVybiwgcmVzcG9uc2Uuc3RhdHVzLCBjb21tZW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYocmVzcG9uc2Uuc3RhdHVzID09IHRvb01hbnlSZXF1ZXN0cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb29wSGFuZGxlcj8uKHR1cm4sIHJlc3BvbnNlLnN0YXR1cywgY29tbWVudHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIC8vIEFzIG9mIDIwMjAtMDctMjUsIEtyYWtlbiBBUEkgZG9lcyBub3Qgc2VlbSB0byB1c2UgNDI5IHJlc3BvbnNlIGNvZGUgYXQgYWxsLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzbGVlcCBpcyBoZXJlIG9ubHkgYXMgYW4gYWRkaXRpb25hbCBjaGVja1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoNTAwKTsgIC8vIFNsZWVwIGZvciAxIHNlY29uZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQVBJIGNhbGwgZmFpbGVkIHdpdGggZXJyb3IgY29kZTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvb3BIYW5kbGVyPy4odHVybiwgcmVzcG9uc2Uuc3RhdHVzLCBjb21tZW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlKG5leHRDdXJzb3IpO1xyXG5cclxuICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsbCBUd2l0Y2ggQVBJIG9uZSB0aW1lXHJcbiAgICBwcml2YXRlIGFzeW5jIGNhbGxBcGkodmlkZW9JZDogc3RyaW5nLCBjdXJzb3I6IHN0cmluZykgOiBQcm9taXNlPEZldGNoUmVzcG9uc2U+IHtcclxuICAgICAgICBjb25zdCB1cmwgPSBnZXRBcGlVcmwodmlkZW9JZCwgY3Vyc29yKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge2hlYWRlcnM6IGRlZmF1bHRIZWFkZXJzfSk7XHJcbiAgICAgICAgaWYoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIHRleHQ6IG51bGx9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICAgIHJldHVybiB7c3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIHRleHQ6IGNvbnRlbnR9O1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBUd2l0Y2hDbGllbnQsIHsgSGVsaXhVc2VyIH0gZnJvbSAndHdpdGNoJztcclxuaW1wb3J0IHsgQ29uZmlnTWFuYWdlciB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgQ2hhdERvd25sb2FkZXIgfSBmcm9tICcuL2Rvd25sb2FkZXIvY2hhdCc7XHJcblxyXG5cclxubGV0IHR3aXRjaENsaWVudCA6IFR3aXRjaENsaWVudDtcclxuXHJcbmZ1bmN0aW9uIGdldFR3aXRjaENsaWVudCgpIDogVHdpdGNoQ2xpZW50IHtcclxuICAgIGlmKHR3aXRjaENsaWVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0d2l0Y2hDbGllbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXNlciBub3QgbG9nZ2VkIGluXHJcbiAgICBjb25zdCB0b2tlbiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJ0d2l0Y2hfY2hhdF9hbmFseXplcl9hY2Nlc3NfdG9rZW5cIik7XHJcbiAgICBpZighdG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjbGllbnRJZCA9IENvbmZpZ01hbmFnZXIuZ2V0Q2xpZW50SWQoKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIHRva2VuKTtcclxuICAgIHR3aXRjaENsaWVudCA9IGNsaWVudDtcclxuICAgIHJldHVybiBjbGllbnQ7XHJcbn1cclxuXHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXRTdHJlYW1lckluZm8odXNlcm5hbWU6IHN0cmluZykgOiBQcm9taXNlPEhlbGl4VXNlcj4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwidHdpdGNoX2NoYXRfYW5hbHl6ZXJfYWNjZXNzX3Rva2VuXCIpO1xyXG4gICAgaWYoIXRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2xpZW50SWQgPSBDb25maWdNYW5hZ2VyLmdldENsaWVudElkKCk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCB0b2tlbik7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeU5hbWUodXNlcm5hbWUpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gdXNlcjtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGFkZEZvbGxvd2VyRG93bmxvYWRlckxpc3RlbmVycygpIHtcclxuICAgIGNvbnN0IHN0cmVhbWVyTmFtZUlucHV0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RyZWFtZXItdXNlcm5hbWUtaW5wdXRcIikgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgIGNvbnN0IHN0cmVhbWVyU2VhcmNoQnV0dG9tRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RyZWFtZXItc2VhcmNoLWJ1dHRvblwiKTtcclxuICAgIGNvbnN0IHN0cmVhbWVySW5mb0VsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0cmVhbWVyLWluZm9cIik7XHJcbiAgICBjb25zdCBkb3dubG9hZEJ1dHRvbkVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZvbGxvd2VyLWxpc3QtZG93bmxvYWQtYnV0dG9uXCIpO1xyXG4gICAgXHJcbiAgICBzdHJlYW1lclNlYXJjaEJ1dHRvbUVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBuYW1lID0gc3RyZWFtZXJOYW1lSW5wdXRFbGVtLnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGdldFR3aXRjaENsaWVudCgpO1xyXG4gICAgICAgIGNsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlOYW1lKG5hbWUpLnRoZW4oKGhlbGl4VXNlcikgPT4ge1xyXG4gICAgICAgICAgICBpZighaGVsaXhVc2VyKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW1lckluZm9FbGVtLnRleHRDb250ZW50ID0gYOyKpO2KuOumrOuouOulvCDssL7snYQg7IiYIOyXhuyKteuLiOuLpDogJHtuYW1lfWA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RyZWFtZXJJbmZvRWxlbS50ZXh0Q29udGVudCA9IGDsiqTtirjrpqzrqLg6ICR7aGVsaXhVc2VyLmRpc3BsYXlOYW1lfWA7XHJcbiAgICAgICAgICAgIC8vIFNob3cgZG93bmxvYWQgYnV0dG9uXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkb3dubG9hZEJ1dHRvbkVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAvLyBEaXNwbGF5IGRvd25sb2FkIHN0YXR1c1xyXG4gICAgICAgIC8vIGRvd25sb2FkXHJcbiAgICAgICAgLy8gV2hlbiBmaW5pc2hlZCBkb3dubG9hZGluZywgZG93bmxvYWQgdGhlIGZpbGUgdG8gbG9jYWwgZGlza1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZENoYXREb3dubG9hZGVyTGlzdGVuZXJzKCkge1xyXG4gICAgY29uc3QgdmlkZW9JZElucHV0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmlkZW8taWQtaW5wdXRcIikgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgIGNvbnN0IHZpZGVvU2VhcmNoQnV0dG9tRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmlkZW8tc2VhcmNoLWJ1dHRvblwiKTtcclxuICAgIGNvbnN0IHZpZGVvSW5mb0VsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInZpZGVvLWluZm9cIik7XHJcbiAgICBjb25zdCBkb3dubG9hZEJ1dHRvbkVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInZpZGVvLWNoYXQtZG93bmxvYWQtYnV0dG9uXCIpO1xyXG5cclxuICAgIHZpZGVvU2VhcmNoQnV0dG9tRWxlbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZpZGVvSWQgPSB2aWRlb0lkSW5wdXRFbGVtLnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGdldFR3aXRjaENsaWVudCgpO1xyXG4gICAgICAgIGNsaWVudC5oZWxpeC52aWRlb3MuZ2V0VmlkZW9CeUlkKHZpZGVvSWQpLnRoZW4oKHZpZGVvKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIHZpZGVvIGluZm8gZWxlbVxyXG4gICAgICAgICAgICB2aWRlb0luZm9FbGVtLnRleHRDb250ZW50ID0gdmlkZW8udGl0bGUgKyBcIiwgXCIgKyB2aWRlby5kZXNjcmlwdGlvbjtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGxvb3BIYW5kbGVyID0gKHR1cm46IG51bWJlciwgc3RhdHVzOiBudW1iZXIsIGRvd25sb2FkQ291bnQ6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIC8vIERpc3BsYXkgZG93bmxvYWQgc3RhdHVzIGluIHNvbWUgPGRpdj5cclxuICAgIH07XHJcblxyXG4gICAgZG93bmxvYWRCdXR0b25FbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmlkZW9JZCA9IHZpZGVvSWRJbnB1dEVsZW0udmFsdWU7XHJcbiAgICAgICAgY29uc3QgZG93bmxvYWRlciA9IG5ldyBDaGF0RG93bmxvYWRlcigpO1xyXG4gICAgICAgIGRvd25sb2FkZXIuYWRkTG9vcEV2ZW50TGlzdGVuZXIobG9vcEhhbmRsZXIpO1xyXG4gICAgICAgIGNvbnN0IGNoYXRzID0gYXdhaXQgZG93bmxvYWRlci5kb3dubG9hZENoYXQodmlkZW9JZCk7XHJcbiAgICAgICAgLy8gRGlzcGxheSBkb3dubG9hZCBzdGF0dXNcclxuICAgICAgICAvLyBkb3dubG9hZFxyXG4gICAgICAgIC8vIFdoZW4gZmluaXNoZWQgZG93bmxvYWRpbmcsIGRvd25sb2FkIHRoZSBmaWxlIHRvIGxvY2FsIGRpc2tcclxuICAgIH0pO1xyXG59XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG5hZGRGb2xsb3dlckRvd25sb2FkZXJMaXN0ZW5lcnMoKTtcclxuYWRkQ2hhdERvd25sb2FkZXJMaXN0ZW5lcnMoKTtcclxuXHJcblxyXG5cclxufSkoKTtcclxuXHJcblxyXG5cclxuLypcclxuZnVuY3Rpb24gbWFpbigpIHtcclxuXHJcbiAgLy9jb25zdCBpbnB1dCA9IFwicmFuZG9tIGZpbHRlciBuYW1lICYgRm9sbG93IDFkYXkgfCBzdWJzY3JpYmVyICYgYWFhYWEgJiAoQmJiYilcIjtcclxuICAvL2NvbnN0IGlucHV0ID0gXCIhKOuenOuNpO2VnCDtlYTthLAg7J2066aEKSAmIO2MlOuhnOyasCAx7J28IOydtO2VmCB8IOu5hOq1rOuPheyekCAmIOq3uOuDpSDsnbTqsoPsoIDqsoMgJiAo7JWE66y06rGw64KYIOydtOqyg+yggOqygylcIjtcclxuICBjb25zdCBpbnB1dCA9IFwiISjrnpzrjaTtlZwg7ZWE7YSwIOydtOumhCkgfCDtjJTroZzsmrAgMeydvCDsnbTtlZh8ICjruYTqtazrj4XsnpAgfCHqt7jrg6Ug7J206rKD7KCA6rKDKSAmIOyVhOustOqxsOuCmCDsnbTqsoPsoIDqsoNcIjtcclxuICBjb25zdCBmID0gZ2V0RmlsdGVyKGlucHV0KTtcclxuICBjb25zb2xlLmxvZyhcImY6IFwiICsgZik7XHJcbiAgY29uc29sZS5sb2coXCJ0eXBlIGY6IFwiICsgT2JqZWN0LmtleXMoZikpO1xyXG4gIGNvbnNvbGUubG9nKFwidG9TdHJpbmc6IFwiICsgZi50b1N0cmluZygpKTtcclxuXHJcbiAgcmV0dXJuO1xyXG5cclxuICBjb25zdCBiZWZvcmVGaWxlID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgY29uc3QgZmlsZUNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsIFwidXRmOFwiKTtcclxuICBjb25zdCBmaWxlSnNvbiA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpO1xyXG4gIGNvbnN0IGNvbW1lbnRzRGF0YSA9IGZpbGVKc29uW1wiY29tbWVudHNcIl0gYXMgQXJyYXk8Q29tbWVudERhdGE+O1xyXG4gIFxyXG4gIGNvbnN0IHJlcG9zaXRvcnkgPSBuZXcgQ29tbWVudFJlcG9zaXRvcnkoY29tbWVudHNEYXRhKTtcclxuICBjb25zb2xlLmxvZyhcIlVzZXIgY291bnQ6IFwiICsgcmVwb3NpdG9yeS51c2VyQ291bnQoKSk7XHJcbiAgY29uc29sZS5sb2coXCJDaGF0IGNvdW50OiBcIiArIHJlcG9zaXRvcnkuY29tbWVudENvdW50KCkpO1xyXG4gIFxyXG4gIGNvbnN0IGdyb3VwID0gbmV3IEFuZEV4cHJlc3Npb25Hcm91cCgpO1xyXG4gIGdyb3VwLmFkZFJlZ2V4KHt0eXBlOiBcInVzZXJcIiwga2V5OiBcInVzZXJuYW1lXCJ9LCBcImNcIik7XHJcbiAgZ3JvdXAuYWRkUmVnZXgoe3R5cGU6IFwiY29tbWVudFwiLCBrZXk6IFwicmF3VGV4dFwifSwgXCJoZWFydFwiKTtcclxuICBncm91cC5hZGRHcmVhdGVyVGhhbih7dHlwZTogXCJjb21tZW50XCIsIGtleTogXCJyZWxhdGl2ZVRpbWVcIn0sIDIwMCk7XHJcblxyXG4gIGNvbnN0IGJlZm9yZUZpbHRlciA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gIGNvbnNvbGUubG9nKFwiUmVwb3NpdG9yeSBjcmVhdGVkIGluIFwiICsgKGJlZm9yZUZpbHRlciAtIGJlZm9yZUZpbGUpICsgXCIgbWlsbGlzZWNvbmRzXCIpO1xyXG4gIGNvbnN0IGZpbHRlcmVkID0gcmVwb3NpdG9yeS5maWx0ZXIoZ3JvdXApO1xyXG4gIC8vY29uc3QgZmlsdGVyID0gbmV3IFJlZ2V4RXhwcmVzc2lvbih7dHlwZTogXCJjb21tZW50XCIsIGtleTogXCJyYXdUZXh0XCJ9LCBcIuOFi+OFi+OFi1wiKTtcclxuICAvL2NvbnN0IGZpbHRlciA9IG5ldyBSZWdleEV4cHJlc3Npb24oe3R5cGU6IFwidXNlclwiLCBrZXk6IFwidXNlcm5hbWVcIn0sIFwiclwiKTtcclxuXHJcbiAgLy9jb25zdCBmaWx0ZXJlZCA9IHJlcG9zaXRvcnkuZmlsdGVyKGZpbHRlcik7XHJcbiAgXHJcbiAgY29uc3QgYWZ0ZXJGaWx0ZXIgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICBjb25zb2xlLmxvZyhcIkZpbHRlcmVkIGNvbXBsZXRlIGluIFwiICsgKGFmdGVyRmlsdGVyIC0gYmVmb3JlRmlsdGVyKSArIFwiIG1pbGxpc2Vjb25kc1wiKTtcclxuXHJcbiAgY29uc29sZS5sb2coZmlsdGVyZWQubGVuZ3RoKTtcclxuICBmb3IobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xyXG4gICAgICBjb25zb2xlLmxvZyhmaWx0ZXJlZFtpXS50b0Rpc3BsYXlTdHJpbmcoKSk7XHJcbiAgfVxyXG4gIGZvcihsZXQgY2hhdCBvZiBmaWx0ZXJlZCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhjaGF0LnRvRGlzcGxheVN0cmluZygpKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5tYWluKCk7XHJcblxyXG4qLyJdLCJzb3VyY2VSb290IjoiIn0=