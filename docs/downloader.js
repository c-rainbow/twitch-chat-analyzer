/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 102);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Enumerable_1 = __webpack_require__(111);
var __export_Enumerable = Enumerable_1.Enumerable;
exports.Enumerable = __export_Enumerable;
var __export_NonEnumerable = Enumerable_1.NonEnumerable;
exports.NonEnumerable = __export_NonEnumerable;
var flatten_1 = __webpack_require__(112);
var __export_flatten = flatten_1.flatten;
exports.flatten = __export_flatten;
var resolveConfigValue_1 = __webpack_require__(113);
var __export_resolveConfigValue = resolveConfigValue_1.resolveConfigValue;
exports.resolveConfigValue = __export_resolveConfigValue;
var deprecateClass_1 = __webpack_require__(114);
var __export_deprecateClass = deprecateClass_1.deprecateClass;
exports.deprecateClass = __export_deprecateClass;
var match_1 = __webpack_require__(115);
var __export_match = match_1.match;
exports.match = __export_match;
var __export_eq = match_1.eq;
exports.eq = __export_eq;
var arrayToObject_1 = __webpack_require__(28);
var __export_arrayToObject = arrayToObject_1.arrayToObject;
exports.arrayToObject = __export_arrayToObject;
var entriesToObject_1 = __webpack_require__(116);
var __export_entriesToObject = entriesToObject_1.entriesToObject;
exports.entriesToObject = __export_entriesToObject;
var forEachObjectEntry_1 = __webpack_require__(117);
var __export_forEachObjectEntry = forEachObjectEntry_1.forEachObjectEntry;
exports.forEachObjectEntry = __export_forEachObjectEntry;
var indexBy_1 = __webpack_require__(118);
var __export_indexBy = indexBy_1.indexBy;
exports.indexBy = __export_indexBy;
var mapObject_1 = __webpack_require__(119);
var __export_mapObject = mapObject_1.mapObject;
exports.mapObject = __export_mapObject;
var omit_1 = __webpack_require__(120);
var __export_omit = omit_1.omit;
exports.omit = __export_omit;
var pick_1 = __webpack_require__(46);
var __export_pick = pick_1.pick;
exports.pick = __export_pick;
var delay_1 = __webpack_require__(121);
var __export_delay = delay_1.delay;
exports.delay = __export_delay;
var padLeft_1 = __webpack_require__(122);
var __export_padLeft = padLeft_1.padLeft;
exports.padLeft = __export_padLeft;
var splitWithLimit_1 = __webpack_require__(123);
var __export_splitWithLimit = splitWithLimit_1.splitWithLimit;
exports.splitWithLimit = __export_splitWithLimit;
var utf8Length_1 = __webpack_require__(124);
var __export_utf8Length = utf8Length_1.utf8Length;
exports.utf8Length = __export_utf8Length;
var utf8Substring_1 = __webpack_require__(125);
var __export_utf8Substring = utf8Substring_1.utf8Substring;
exports.utf8Substring = __export_utf8Substring;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Enumerable = __export_Enumerable;
exports.NonEnumerable = __export_NonEnumerable;
exports.flatten = __export_flatten;
exports.resolveConfigValue = __export_resolveConfigValue;
exports.deprecateClass = __export_deprecateClass;
exports.match = __export_match;
exports.eq = __export_eq;
exports.arrayToObject = __export_arrayToObject;
exports.entriesToObject = __export_entriesToObject;
exports.forEachObjectEntry = __export_forEachObjectEntry;
exports.indexBy = __export_indexBy;
exports.mapObject = __export_mapObject;
exports.omit = __export_omit;
exports.pick = __export_pick;
exports.delay = __export_delay;
exports.padLeft = __export_padLeft;
exports.splitWithLimit = __export_splitWithLimit;
exports.utf8Length = __export_utf8Length;
exports.utf8Substring = __export_utf8Substring;
//# sourceMappingURL=index.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* globals
	Atomics,
	SharedArrayBuffer,
*/

var undefined;

var $TypeError = TypeError;

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () { throw new $TypeError(); };
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(23)();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var generator; // = function * () {};
var generatorFunction = generator ? getProto(generator) : undefined;
var asyncFn; // async function() {};
var asyncFunction = asyncFn ? asyncFn.constructor : undefined;
var asyncGen; // async function * () {};
var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;
var asyncGenIterator = asyncGen ? asyncGen() : undefined;

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%ArrayPrototype%': Array.prototype,
	'%ArrayProto_entries%': Array.prototype.entries,
	'%ArrayProto_forEach%': Array.prototype.forEach,
	'%ArrayProto_keys%': Array.prototype.keys,
	'%ArrayProto_values%': Array.prototype.values,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': asyncFunction,
	'%AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,
	'%AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,
	'%AsyncGeneratorFunction%': asyncGenFunction,
	'%AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,
	'%AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%Boolean%': Boolean,
	'%BooleanPrototype%': Boolean.prototype,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,
	'%Date%': Date,
	'%DatePrototype%': Date.prototype,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%ErrorPrototype%': Error.prototype,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%EvalErrorPrototype%': EvalError.prototype,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,
	'%Function%': Function,
	'%FunctionPrototype%': Function.prototype,
	'%Generator%': generator ? getProto(generator()) : undefined,
	'%GeneratorFunction%': generatorFunction,
	'%GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,
	'%Math%': Math,
	'%Number%': Number,
	'%NumberPrototype%': Number.prototype,
	'%Object%': Object,
	'%ObjectPrototype%': Object.prototype,
	'%ObjProto_toString%': Object.prototype.toString,
	'%ObjProto_valueOf%': Object.prototype.valueOf,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,
	'%PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,
	'%Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,
	'%Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,
	'%Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%RangeErrorPrototype%': RangeError.prototype,
	'%ReferenceError%': ReferenceError,
	'%ReferenceErrorPrototype%': ReferenceError.prototype,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%RegExpPrototype%': RegExp.prototype,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%StringPrototype%': String.prototype,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,
	'%SyntaxError%': SyntaxError,
	'%SyntaxErrorPrototype%': SyntaxError.prototype,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,
	'%TypeError%': $TypeError,
	'%TypeErrorPrototype%': $TypeError.prototype,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,
	'%URIError%': URIError,
	'%URIErrorPrototype%': URIError.prototype,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
	'%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype
};

var bind = __webpack_require__(35);
var $replace = bind.call(Function.call, String.prototype.replace);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	if (!(name in INTRINSICS)) {
		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
	}

	// istanbul ignore if // hopefully this is impossible to test :-)
	if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
		throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
	}

	return INTRINSICS[name];
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);

	var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);
	for (var i = 1; i < parts.length; i += 1) {
		if (value != null) {
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, parts[i]);
				if (!allowMissing && !(parts[i] in value)) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				value = desc ? (desc.get || desc.value) : value[parts[i]];
			} else {
				value = value[parts[i]];
			}
		}
	}
	return value;
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/** @private */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(client) {
        this._client = client;
    }
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], BaseAPI.prototype, "_client", void 0);
    return BaseAPI;
}());
exports.default = BaseAPI;
module.exports = exports = BaseAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseAPI;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/// <reference lib="dom" />
var cache_decorators_1 = __webpack_require__(5);
var cross_fetch_1 = __webpack_require__(103);
var logger_1 = __webpack_require__(104);
var qs_1 = __webpack_require__(107);
var AccessToken_1 = __webpack_require__(27);
var BadgesAPI_1 = __webpack_require__(110);
var HelixAPIGroup_1 = __webpack_require__(126);
var HelixRateLimiter_1 = __webpack_require__(139);
var CheermoteList_1 = __webpack_require__(37);
var KrakenAPIGroup_1 = __webpack_require__(194);
var TokenInfo_1 = __webpack_require__(96);
var UnsupportedAPI_1 = __webpack_require__(207);
var ClientCredentialsAuthProvider_1 = __webpack_require__(208);
var RefreshableAuthProvider_1 = __webpack_require__(98);
var StaticAuthProvider_1 = __webpack_require__(99);
var ConfigError_1 = __webpack_require__(100);
var HTTPStatusCodeError_1 = __webpack_require__(19);
var InvalidTokenError_1 = __webpack_require__(101);
/**
 * The endpoint to call, i.e. /kraken, /helix or a custom (potentially unsupported) endpoint.
 */
var TwitchAPICallType;
(function (TwitchAPICallType) {
    /**
     * Call a Kraken API endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Kraken"] = 0] = "Kraken";
    /**
     * Call a Helix API endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Helix"] = 1] = "Helix";
    /**
     * Call an authentication endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Auth"] = 2] = "Auth";
    /**
     * Call a custom (potentially unsupported) endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Custom"] = 3] = "Custom";
})(TwitchAPICallType || (TwitchAPICallType = {}));
exports.TwitchAPICallType = TwitchAPICallType;
/**
 * The main entry point of this library. Manages API calls and the use of access tokens in these.
 */
var TwitchClient = /** @class */ (function () {
    /**
     * Creates a new Twitch client instance.
     *
     * @param config Configuration for the client instance.
     */
    function TwitchClient(config) {
        var authProvider = config.authProvider, restConfig = tslib_1.__rest(config, ["authProvider"]);
        if (!authProvider) {
            throw new ConfigError_1.default('No auth provider given');
        }
        this._helixRateLimiter = new HelixRateLimiter_1.default(config.logLevel || logger_1.LogLevel.CRITICAL);
        this._config = tslib_1.__assign({ preAuth: false, cheermotes: {
                defaultBackground: CheermoteList_1.CheermoteBackground.dark,
                defaultState: CheermoteList_1.CheermoteState.animated,
                defaultScale: CheermoteList_1.CheermoteScale.x1
            }, authProvider: authProvider }, restConfig);
        if (this._config.preAuth) {
            // tslint:disable-next-line:no-floating-promises
            authProvider.getAccessToken(this._config.initialScopes);
        }
    }
    TwitchClient_1 = TwitchClient;
    // TODO 5.0: config object!
    /**
     * Creates a new instance with fixed credentials.
     *
     * @param clientId The client ID of your application.
     * @param accessToken The access token to call the API with.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     * @param scopes The scopes your supplied token has.
     *
     * If this argument is given, the scopes need to be correct, or weird things might happen. If it's not (i.e. it's `undefined`), we fetch the correct scopes for you.
     *
     * If you can't exactly say which scopes your token has, don't use this parameter/set it to `undefined`.
     * @param refreshConfig Configuration to automatically refresh expired tokens.
     * @param config Additional configuration to pass to the constructor.
     *
     * Note that if you provide a custom `authProvider`, this method will overwrite it. In this case, you should use the constructor directly.
     * @param tokenType The type of token you passed.
     *
     * This should almost always be 'user' (which is the default).
     *
     * If you're passing 'app' here, please consider using {@TwitchClient.withClientCredentials} instead.
     */
    TwitchClient.withCredentials = function (clientId, accessToken, scopes, refreshConfig, config, tokenType) {
        if (config === void 0) { config = {}; }
        if (tokenType === void 0) { tokenType = 'user'; }
        var authProvider = refreshConfig
            ? new RefreshableAuthProvider_1.default(new StaticAuthProvider_1.default(clientId, accessToken, scopes, tokenType), refreshConfig)
            : new StaticAuthProvider_1.default(clientId, accessToken, scopes, tokenType);
        return new this(tslib_1.__assign(tslib_1.__assign({}, config), { authProvider: authProvider }));
    };
    /**
     * Creates a new instance with client credentials.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param config Additional configuration to pass to the constructor.
     *
     * Note that if you provide a custom `authProvider`, this method will overwrite it. In this case, you should use the constructor directly.
     */
    TwitchClient.withClientCredentials = function (clientId, clientSecret, config) {
        if (config === void 0) { config = {}; }
        var authProvider = clientSecret
            ? new ClientCredentialsAuthProvider_1.default(clientId, clientSecret)
            : new StaticAuthProvider_1.default(clientId);
        return new this(tslib_1.__assign(tslib_1.__assign({}, config), { authProvider: authProvider }));
    };
    /**
     * Makes a call to the Twitch API using given credentials.
     *
     * @param options The configuration of the call.
     * @param clientId The client ID of your application.
     * @param accessToken The access token to call the API with.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    TwitchClient.callAPI = function (options, clientId, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._callAPIRaw(options, clientId, accessToken)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, this._transformResponse(response)];
                }
            });
        });
    };
    /**
     * Retrieves an access token with your client credentials and an authorization code.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param code The authorization code.
     * @param redirectUri The redirect URI. This serves no real purpose here, but must still match with the redirect URI you configured in the Twitch Developer dashboard.
     */
    TwitchClient.getAccessToken = function (clientId, clientSecret, code, redirectUri) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = AccessToken_1.default.bind;
                        return [4 /*yield*/, this.callAPI({
                                type: TwitchAPICallType.Auth,
                                url: 'token',
                                method: 'POST',
                                query: {
                                    grant_type: 'authorization_code',
                                    client_id: clientId,
                                    client_secret: clientSecret,
                                    code: code,
                                    redirect_uri: redirectUri
                                }
                            })];
                    case 1: return [2 /*return*/, new (_a.apply(AccessToken_1.default, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    /**
     * Retrieves an app access token with your client credentials.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param clientSecret
     */
    TwitchClient.getAppAccessToken = function (clientId, clientSecret) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = AccessToken_1.default.bind;
                        return [4 /*yield*/, this.callAPI({
                                type: TwitchAPICallType.Auth,
                                url: 'token',
                                method: 'POST',
                                query: {
                                    grant_type: 'client_credentials',
                                    client_id: clientId,
                                    client_secret: clientSecret
                                }
                            })];
                    case 1: return [2 /*return*/, new (_a.apply(AccessToken_1.default, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    /**
     * Refreshes an expired access token with your client credentials and the refresh token that was given by the initial authentication.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param refreshToken The refresh token.
     */
    TwitchClient.refreshAccessToken = function (clientId, clientSecret, refreshToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = AccessToken_1.default.bind;
                        return [4 /*yield*/, this.callAPI({
                                type: TwitchAPICallType.Auth,
                                url: 'token',
                                method: 'POST',
                                query: {
                                    grant_type: 'refresh_token',
                                    client_id: clientId,
                                    client_secret: clientSecret,
                                    refresh_token: refreshToken
                                }
                            })];
                    case 1: return [2 /*return*/, new (_a.apply(AccessToken_1.default, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    /**
     * Retrieves information about an access token.
     *
     * @param clientId The client ID of your application.
     * @param accessToken The access token to get the information of.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     */
    TwitchClient.getTokenInfo = function (accessToken, clientId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.callAPI({ type: TwitchAPICallType.Auth, url: 'validate' }, clientId, accessToken)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new TokenInfo_1.default(data)];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default && e_1.statusCode === 401) {
                            throw new InvalidTokenError_1.default();
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @private
     */
    TwitchClient._callAPIRaw = function (options, clientId, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var type, url, params, headers, body, requestOptions;
            return tslib_1.__generator(this, function (_a) {
                type = options.type === undefined ? TwitchAPICallType.Kraken : options.type;
                url = this._getUrl(options.url, type);
                params = qs_1.stringify(options.query, { arrayFormat: 'repeat' });
                headers = new cross_fetch_1.Headers({
                    Accept: type === TwitchAPICallType.Kraken
                        ? "application/vnd.twitchtv.v" + (options.version || 5) + "+json"
                        : 'application/json'
                });
                if (options.body) {
                    body = qs_1.stringify(options.body);
                    headers.append('Content-Type', 'application/x-www-form-urlencoded');
                }
                else if (options.jsonBody) {
                    body = JSON.stringify(options.jsonBody);
                    headers.append('Content-Type', 'application/json');
                }
                if (clientId && type !== TwitchAPICallType.Auth) {
                    headers.append('Client-ID', clientId);
                }
                if (accessToken) {
                    headers.append('Authorization', (type === TwitchAPICallType.Helix ? 'Bearer' : 'OAuth') + " " + accessToken);
                }
                requestOptions = {
                    method: options.method || 'GET',
                    headers: headers,
                    body: body
                };
                return [2 /*return*/, cross_fetch_1.default(params ? url + "?" + params : url, requestOptions)];
            });
        });
    };
    /**
     * Retrieves information about your access token.
     */
    TwitchClient.prototype.getTokenInfo = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.callAPI({ type: TwitchAPICallType.Auth, url: 'validate' })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new TokenInfo_1.default(data)];
                    case 2:
                        e_2 = _a.sent();
                        if (e_2 instanceof HTTPStatusCodeError_1.default && e_2.statusCode === 401) {
                            throw new InvalidTokenError_1.default();
                        }
                        throw e_2;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves an access token for the authentication provider.
     *
     * @param scopes The scopes to request.
     */
    TwitchClient.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._config.authProvider.getAccessToken(scopes)];
            });
        });
    };
    /**
     * Forces the authentication provider to refresh the access token, if possible.
     */
    TwitchClient.prototype.refreshAccessToken = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._config.authProvider.refresh && this._config.authProvider.refresh()];
            });
        });
    };
    Object.defineProperty(TwitchClient.prototype, "tokenType", {
        /**
         * The type of token used by the client.
         */
        get: function () {
            return this._config.authProvider.tokenType || 'user';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Makes a call to the Twitch API using your access token.
     *
     * @param options The configuration of the call.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    TwitchClient.prototype.callAPI = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var authProvider, accessToken, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        authProvider = this._config.authProvider;
                        return [4 /*yield*/, authProvider.getAccessToken(options.scope ? [options.scope] : undefined)];
                    case 1:
                        accessToken = _a.sent();
                        if (!accessToken) {
                            return [2 /*return*/, TwitchClient_1.callAPI(options, authProvider.clientId)];
                        }
                        if (!(accessToken.isExpired && authProvider.refresh)) return [3 /*break*/, 3];
                        return [4 /*yield*/, authProvider.refresh()];
                    case 2:
                        accessToken = _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this._callAPIInternal(options, authProvider.clientId, accessToken.accessToken)];
                    case 4:
                        response = _a.sent();
                        if (!(response.status === 401 && authProvider.refresh)) return [3 /*break*/, 8];
                        return [4 /*yield*/, authProvider.refresh()];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, authProvider.getAccessToken(options.scope ? [options.scope] : [])];
                    case 6:
                        accessToken = _a.sent();
                        if (!accessToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, this._callAPIInternal(options, authProvider.clientId, accessToken.accessToken)];
                    case 7:
                        response = _a.sent();
                        _a.label = 8;
                    case 8: return [2 /*return*/, TwitchClient_1._transformResponse(response)];
                }
            });
        });
    };
    Object.defineProperty(TwitchClient.prototype, "cheermoteDefaults", {
        /**
         * The default specs for cheermotes.
         */
        get: function () {
            return this._config.cheermotes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "kraken", {
        /**
         * A group of Kraken API methods.
         */
        get: function () {
            return new KrakenAPIGroup_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "helix", {
        /**
         * A group of Helix API methods.
         */
        get: function () {
            return new HelixAPIGroup_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "badges", {
        /**
         * The API methods that deal with badges.
         */
        get: function () {
            return new BadgesAPI_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "unsupported", {
        /**
         * Various API methods that are not officially supported by Twitch.
         */
        get: function () {
            return new UnsupportedAPI_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    /** @private */
    TwitchClient.prototype._getAuthProvider = function () {
        return this._config.authProvider;
    };
    TwitchClient.prototype._callAPIInternal = function (options, clientId, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (options.type === TwitchAPICallType.Helix) {
                    return [2 /*return*/, this._helixRateLimiter.request({ options: options, clientId: clientId, accessToken: accessToken })];
                }
                return [2 /*return*/, TwitchClient_1._callAPIRaw(options, clientId, accessToken)];
            });
        });
    };
    TwitchClient._getUrl = function (url, type) {
        switch (type) {
            case TwitchAPICallType.Kraken:
            case TwitchAPICallType.Helix:
                var typeName = type === TwitchAPICallType.Kraken ? 'kraken' : 'helix';
                return "https://api.twitch.tv/" + typeName + "/" + url.replace(/^\//, '');
            case TwitchAPICallType.Auth:
                return "https://id.twitch.tv/oauth2/" + url.replace(/^\//, '');
            case TwitchAPICallType.Custom:
                return url;
            default:
                return url; // wat
        }
    };
    TwitchClient._transformResponse = function (response) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, _b, text;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!!response.ok) return [3 /*break*/, 2];
                        _a = HTTPStatusCodeError_1.default.bind;
                        _b = [void 0, response.status, response.statusText];
                        return [4 /*yield*/, response.json()];
                    case 1: throw new (_a.apply(HTTPStatusCodeError_1.default, _b.concat([_c.sent()])))();
                    case 2:
                        if (response.status === 204) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            return [2 /*return*/, undefined]; // oof
                        }
                        return [4 /*yield*/, response.text()];
                    case 3:
                        text = _c.sent();
                        if (!text) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            return [2 /*return*/, undefined]; // mega oof - twitch doesn't return a response when it should
                        }
                        return [2 /*return*/, JSON.parse(text)];
                }
            });
        });
    };
    var TwitchClient_1;
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "kraken", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "helix", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "badges", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "unsupported", null);
    TwitchClient = TwitchClient_1 = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], TwitchClient);
    return TwitchClient;
}());
exports.default = TwitchClient;
module.exports = exports = TwitchClient;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TwitchAPICallType = TwitchAPICallType;
exports.default = TwitchClient;


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "Cacheable", function() { return /* reexport */ Cacheable; });
__webpack_require__.d(__webpack_exports__, "Cached", function() { return /* reexport */ Cached; });
__webpack_require__.d(__webpack_exports__, "CachedGetter", function() { return /* reexport */ CachedGetter; });
__webpack_require__.d(__webpack_exports__, "ClearsCache", function() { return /* reexport */ ClearsCache; });
__webpack_require__.d(__webpack_exports__, "createCacheKey", function() { return /* reexport */ createCacheKey; });

// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/utils/createCacheKey.js

function createSingleCacheKey(param) {
    // noinspection FallThroughInSwitchStatementJS
    switch (typeof param) {
        case 'undefined': {
            return '';
        }
        case 'object': {
            if (param === null) {
                return '';
            }
            if ('cacheKey' in param) {
                return param.cacheKey;
            }
            var objKey = JSON.stringify(param);
            if (objKey !== '{}') {
                return objKey;
            }
        }
        // fallthrough
        default: {
            return param.toString();
        }
    }
}
function createCacheKey(propName, params, prefix) {
    return __spread([propName], params.map(createSingleCacheKey)).join('/') + (prefix ? '/' : '');
}
//# sourceMappingURL=createCacheKey.js.map
// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/decorators/Cacheable.js


function Cacheable(cls) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.cache = new Map();
            return _this;
        }
        class_1.prototype.getFromCache = function (cacheKey) {
            this._cleanCache();
            if (this.cache.has(cacheKey)) {
                var entry = this.cache.get(cacheKey);
                if (entry) {
                    return entry.value;
                }
            }
            return undefined;
        };
        class_1.prototype.setCache = function (cacheKey, value, timeInSeconds) {
            this.cache.set(cacheKey, {
                value: value,
                expires: Date.now() + timeInSeconds * 1000
            });
        };
        class_1.prototype.removeFromCache = function (cacheKey, prefix) {
            var _this = this;
            var internalCacheKey;
            if (typeof cacheKey === 'string') {
                internalCacheKey = cacheKey;
                if (!internalCacheKey.endsWith('/')) {
                    internalCacheKey += '/';
                }
            }
            else {
                var propName = cacheKey.shift();
                internalCacheKey = createCacheKey(propName, cacheKey, prefix);
            }
            if (prefix) {
                this.cache.forEach(function (val, key) {
                    if (key.startsWith(internalCacheKey)) {
                        _this.cache.delete(key);
                    }
                });
            }
            else {
                this.cache.delete(internalCacheKey);
            }
        };
        class_1.prototype._cleanCache = function () {
            var _this = this;
            var now = Date.now();
            this.cache.forEach(function (val, key) {
                if (val.expires < now) {
                    _this.cache.delete(key);
                }
            });
        };
        return class_1;
    }(cls));
}
//# sourceMappingURL=Cacheable.js.map
// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/decorators/Cached.js


function Cached(timeInSeconds, cacheFailures) {
    if (timeInSeconds === void 0) { timeInSeconds = Infinity; }
    if (cacheFailures === void 0) { cacheFailures = false; }
    return function (target, propName, descriptor) {
        var origFn = descriptor.value;
        descriptor.value = function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            return __awaiter(this, void 0, void 0, function () {
                var cacheKey, cachedValue, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            cacheKey = createCacheKey(propName, params);
                            cachedValue = this.getFromCache(cacheKey);
                            if (cachedValue) {
                                return [2 /*return*/, cachedValue];
                            }
                            return [4 /*yield*/, origFn.apply(this, params)];
                        case 1:
                            result = _a.sent();
                            if (result != null || cacheFailures) {
                                this.setCache(cacheKey, result, timeInSeconds);
                            }
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        return descriptor;
    };
}
//# sourceMappingURL=Cached.js.map
// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/decorators/CachedGetter.js

function CachedGetter(timeInSeconds) {
    if (timeInSeconds === void 0) { timeInSeconds = Infinity; }
    return function (target, propName, descriptor) {
        if (descriptor.get) {
            var origFn_1 = descriptor.get;
            descriptor.get = function () {
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                var cacheKey = createCacheKey(propName, params);
                var cachedValue = this.getFromCache(cacheKey);
                if (cachedValue) {
                    return cachedValue;
                }
                var result = origFn_1.apply(this, params);
                this.setCache(cacheKey, result, timeInSeconds);
                return result;
            };
        }
        return descriptor;
    };
}
//# sourceMappingURL=CachedGetter.js.map
// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/decorators/ClearsCache.js

function ClearsCache(cacheName, numberOfArguments) {
    return function (target, propName, descriptor) {
        var origFn = descriptor.value;
        descriptor.value = function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            return __awaiter(this, void 0, void 0, function () {
                var result, args;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, origFn.apply(this, params)];
                        case 1:
                            result = _a.sent();
                            args = numberOfArguments === undefined ? params.slice() : params.slice(0, numberOfArguments);
                            this.removeFromCache(__spread([cacheName], args), true);
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        return descriptor;
    };
}
//# sourceMappingURL=ClearsCache.js.map
// CONCATENATED MODULE: ./node_modules/@d-fischer/cache-decorators/es/index.js





//# sourceMappingURL=index.js.map

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Extracts the user ID from an argument that is possibly an object containing that ID.
 *
 * @param user The user ID or object.
 */
function extractUserId(user) {
    if (typeof user === 'string') {
        return user;
    }
    else if (typeof user === 'number') {
        return user.toString(10);
    }
    else {
        return user.id;
    }
}
exports.extractUserId = extractUserId;
/**
 * Extracts the user name from an argument that is possibly an object containing that name.
 *
 * @param user The user name or object.
 */
function extractUserName(user) {
    return typeof user === 'string' ? user : user.name;
}
exports.extractUserName = extractUserName;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ES5Type = __webpack_require__(151);

// https://ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	return ES5Type(x);
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var callBind = __webpack_require__(34);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/// <reference lib="esnext.asynciterable" />
var shared_utils_1 = __webpack_require__(1);
var TwitchClient_1 = __webpack_require__(4);
if (!Object.prototype.hasOwnProperty.call(Symbol, 'asyncIterator')) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for('Symbol.asyncIterator');
}
/**
 * Represents a request to the new Twitch API (Helix) that utilizes a cursor to paginate through its results.
 *
 * Aside from the methods described below, you can also utilize the async iterator using `for await .. of`:
 *
 * ```ts
 * const result = client.helix.videos.getVideosByUser('125328655');
 * for await (const video of result) {
 *     console.log(video.title);
 * }
 * ```
 */
var HelixPaginatedRequest = /** @class */ (function () {
    /** @private */
    function HelixPaginatedRequest(_callOptions, client, _mapper) {
        this._callOptions = _callOptions;
        this._mapper = _mapper;
        /** @private */
        this._isFinished = false;
        this._client = client;
    }
    Object.defineProperty(HelixPaginatedRequest.prototype, "current", {
        /**
         * The last retrieved page of data associated to the requested resource.
         *
         * Only works with {@HelixPaginatedRequest#getNext} and not with any other methods of data retrieval.
         */
        get: function () {
            return this._currentData ? this._currentData.data : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves and returns the next available page of data associated to the requested resource, or an empty array if there are no more available pages.
     */
    HelixPaginatedRequest.prototype.getNext = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._isFinished) {
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, this._fetchData()];
                    case 1:
                        result = _a.sent();
                        if (!result.data.length) {
                            this._isFinished = true;
                            return [2 /*return*/, []];
                        }
                        return [2 /*return*/, this._processResult(result)];
                }
            });
        });
    };
    /**
     * Retrieves and returns all data associated to the requested resource.
     *
     * Be aware that this makes multiple calls to the Twitch API. Due to this, you might be more suspectible to rate limits.
     *
     * Also be aware that this resets the internal cursor, so avoid using this and {@HelixPaginatedRequest#getNext} together.
     */
    HelixPaginatedRequest.prototype.getAll = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.reset();
                        result = [];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, this.getNext()];
                    case 2:
                        data = _a.sent();
                        if (!data.length) {
                            return [3 /*break*/, 4];
                        }
                        result.push.apply(result, tslib_1.__spread(data));
                        _a.label = 3;
                    case 3:
                        if (this._currentCursor) return [3 /*break*/, 1];
                        _a.label = 4;
                    case 4:
                        this.reset();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    Object.defineProperty(HelixPaginatedRequest.prototype, "currentCursor", {
        /**
         * Retrieves the current cursor.
         *
         * Only useful if you want to make manual requests to the API.
         */
        get: function () {
            return this._currentCursor;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the internal cursor.
     *
     * This will make {@HelixPaginatedRequest#getNext} start from the first page again.
     */
    HelixPaginatedRequest.prototype.reset = function () {
        this._currentCursor = undefined;
        this._isFinished = false;
        this._currentData = undefined;
    };
    HelixPaginatedRequest.prototype[Symbol.asyncIterator] = function () {
        return tslib_1.__asyncGenerator(this, arguments, function _a() {
            var data;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.reset();
                        _b.label = 1;
                    case 1:
                        if (false) {}
                        return [4 /*yield*/, tslib_1.__await(this.getNext())];
                    case 2:
                        data = _b.sent();
                        if (!data.length) {
                            return [3 /*break*/, 5];
                        }
                        return [5 /*yield**/, tslib_1.__values(tslib_1.__asyncDelegator(tslib_1.__asyncValues(data[Symbol.iterator]())))];
                    case 3: return [4 /*yield*/, tslib_1.__await.apply(void 0, [_b.sent()])];
                    case 4:
                        _b.sent();
                        return [3 /*break*/, 1];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /** @private */
    HelixPaginatedRequest.prototype._fetchData = function (additionalOptions) {
        if (additionalOptions === void 0) { additionalOptions = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.callAPI(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ type: TwitchClient_1.TwitchAPICallType.Helix }, this._callOptions), additionalOptions), { query: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this._callOptions.query), { after: this._currentCursor, first: '100' }), additionalOptions.query) }))];
            });
        });
    };
    /** @private */
    HelixPaginatedRequest.prototype._processResult = function (result) {
        var _this = this;
        this._currentCursor = result.pagination ? result.pagination.cursor : undefined;
        if (this._currentCursor === undefined) {
            this._isFinished = true;
        }
        this._currentData = result;
        return result.data.reduce(function (acc, elem) {
            var mapped = _this._mapper(elem);
            return Array.isArray(mapped) ? tslib_1.__spread(acc, mapped) : tslib_1.__spread(acc, [mapped]);
        }, []);
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixPaginatedRequest.prototype, "_client", void 0);
    return HelixPaginatedRequest;
}());
exports.default = HelixPaginatedRequest;
module.exports = exports = HelixPaginatedRequest;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixPaginatedRequest;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var NoSubscriptionProgramError_1 = __webpack_require__(15);
var ChannelPlaceholder_1 = __webpack_require__(38);
/**
 * A Twitch user.
 */
var User = /** @class */ (function () {
    /** @private */
    function User(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(User.prototype, "cacheKey", {
        /** @private */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "id", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "bio", {
        /**
         * The bio of the user.
         */
        get: function () {
            return this._data.bio;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "creationDate", {
        /**
         * The date when the user was created, i.e. when they registered on Twitch.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "updateDate", {
        /**
         * The last date when the user changed anything in their profile, e.g. their description or their profile picture.
         */
        get: function () {
            return new Date(this._data.updated_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "name", {
        /**
         * The user name of the user.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "displayName", {
        /**
         * The display name of the user.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "logoUrl", {
        /**
         * The URL to the profile picture of the user.
         */
        get: function () {
            return this._data.logo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "type", {
        /**
         * The type of the user.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the channel data of the user.
     */
    User.prototype.getChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannel(this)];
            });
        });
    };
    /**
     * Gets a channel placeholder object for the user, which can do anything you can do to a channel with just the ID.
     */
    User.prototype.getChannelPlaceholder = function () {
        return new ChannelPlaceholder_1.default(this._data._id, this._client);
    };
    /**
     * Retrieves the currently running stream of the user.
     */
    User.prototype.getStream = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getChannelPlaceholder().getStream()];
            });
        });
    };
    /**
     * Retrieves the subscription data for the user to the given channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the user. If you only have access to the channel,
     * use {@ChannelPlaceholder#getSubscriptionBy} instead.
     *
     * @param channel The channel you want to get the subscription data for.
     */
    User.prototype.getSubscriptionTo = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getSubscriptionData(this, channel)];
            });
        });
    };
    /**
     * Checks whether the user is subscribed to the given channel.
     *
     * @param channel The channel you want to check the subscription for.
     */
    User.prototype.isSubscribedTo = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getSubscriptionTo(channel)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof NoSubscriptionProgramError_1.default) {
                            return [2 /*return*/, false];
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a list of channels followed by the user.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderBy The field to order by.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    User.prototype.getFollows = function (page, limit, orderBy, orderDirection) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getFollowedChannels(this, page, limit, orderBy, orderDirection)];
            });
        });
    };
    /**
     * Retrieves the follow data of the user to a given channel.
     *
     * @param channel The channel to retrieve the follow data for.
     */
    User.prototype.getFollowTo = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getFollowedChannel(this, channel)];
            });
        });
    };
    /**
     * Checks whether the user is following the given channel.
     *
     * @param channel The channel to check for the user's follow.
     */
    User.prototype.follows = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getFollowTo(channel)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_2 = _a.sent();
                        throw e_2;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Follows the channel with the authenticated user.
     */
    User.prototype.follow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.followChannel(this)];
                }
            });
        });
    };
    /**
     * Unfollows the channel with the authenticated user.
     */
    User.prototype.unfollow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.unfollowChannel(this)];
                }
            });
        });
    };
    /**
     * Retrieves the emotes the user can use.
     */
    User.prototype.getEmotes = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getUserEmotes(this)];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], User.prototype, "_client", void 0);
    return User;
}());
exports.default = User;
module.exports = exports = User;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = User;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @private */
function createPaginatedResult(response, type, client) {
    var _a, _b, _c;
    return {
        data: (_b = (_a = response.data) === null || _a === void 0 ? void 0 : _a.map(function (data) { return new type(data, client); }), (_b !== null && _b !== void 0 ? _b : [])),
        cursor: (_c = response.pagination) === null || _c === void 0 ? void 0 : _c.cursor
    };
}
exports.createPaginatedResult = createPaginatedResult;
/** @private */
function createPaginatedResultWithTotal(response, type, client) {
    return {
        data: response.data.map(function (data) { return new type(data, client); }),
        cursor: response.pagination.cursor,
        total: response.total
    };
}
exports.createPaginatedResultWithTotal = createPaginatedResultWithTotal;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/** @private */
var CustomError = /** @class */ (function (_super) {
    tslib_1.__extends(CustomError, _super);
    function CustomError() {
        var _newTarget = this.constructor;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var _this = _super.apply(this, tslib_1.__spread(params)) || this;
        // restore prototype chain
        var actualProto = _newTarget.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(_this, actualProto);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            _this.__proto__ = actualProto;
        }
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _newTarget.constructor);
        }
        return _this;
    }
    Object.defineProperty(CustomError.prototype, "name", {
        get: function () {
            return this.constructor.name;
        },
        enumerable: true,
        configurable: true
    });
    return CustomError;
}(Error));
exports.default = CustomError;
module.exports = exports = CustomError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CustomError;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var ChannelPlaceholder_1 = __webpack_require__(38);
/**
 * A Twitch Channel.
 */
var Channel = /** @class */ (function (_super) {
    tslib_1.__extends(Channel, _super);
    /** @private */
    function Channel(data, client) {
        var _this = _super.call(this, data._id, client) || this;
        _this._data = data;
        return _this;
    }
    // override parent's method so we avoid the API/cache request here if someone wrongly assumes this is a placeholder
    /** @private */
    Channel.prototype.getChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this];
            });
        });
    };
    /**
     * Retrieves a list of the teams of the channel.
     */
    Channel.prototype.getTeams = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelTeams(this._data._id)];
            });
        });
    };
    /**
     * Updates the game, title or delay of a channel or toggles the channel feed.
     */
    Channel.prototype.update = function (data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.updateChannel(this, data)];
            });
        });
    };
    Object.defineProperty(Channel.prototype, "name", {
        /**
         * The name of the channel.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "displayName", {
        /**
         * The display name of the channel, with proper capitalization or as Asian script.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "broadcasterLanguage", {
        /**
         * The broadcaster's language.
         */
        get: function () {
            return this._data.broadcaster_language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "broadcasterType", {
        /**
         * The broadcaster's type, i.e. "partner", "affiliate" or "" (empty string, so neither of them).
         */
        get: function () {
            return this._data.broadcaster_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "creationDate", {
        /**
         * The date when the channel was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "description", {
        /**
         * The description of the channel.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "followers", {
        /**
         * The number of people following the channel.
         */
        get: function () {
            return this._data.followers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "game", {
        /**
         * The game that is currently being played on the channel (or was played when it was last online).
         */
        get: function () {
            return this._data.game;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "language", {
        /**
         * The language of the channel.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "logo", {
        /**
         * The URL to the logo of the channel.
         */
        get: function () {
            return this._data.logo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "isMature", {
        /**
         * Whether the channel is flagged as suitable for mature audiences only.
         */
        get: function () {
            return this._data.mature;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "isPartner", {
        /**
         * Whether the channel is partnered.
         */
        get: function () {
            return this._data.partner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "profileBanner", {
        /**
         * The URL to the profile's banner image.
         */
        get: function () {
            return this._data.profile_banner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "profileBannerBackgroundColor", {
        /**
         * The background color of the profile's banner.
         */
        get: function () {
            return this._data.profile_banner_background_color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "status", {
        /**
         * The current status message (i.e. the title) of the channel.
         */
        get: function () {
            return this._data.status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "updateDate", {
        /**
         * The date when the channel was last updated.
         */
        get: function () {
            return new Date(this._data.updated_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "url", {
        /**
         * The URL to the channel.
         */
        get: function () {
            return this._data.url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "videoBanner", {
        /**
         * The URL to the channel's video banner, i.e. the offline image.
         */
        get: function () {
            return this._data.video_banner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "views", {
        /**
         * The total number of views of the channel.
         */
        get: function () {
            return this._data.views;
        },
        enumerable: true,
        configurable: true
    });
    return Channel;
}(ChannelPlaceholder_1.default));
exports.default = Channel;
module.exports = exports = Channel;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Channel;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = false;



/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever you try accessing a subscription-related resource
 * (for example {@ChannelAPI#getChannelSubscriptions})
 * and the given channel does not have a subscription program.
 */
var NoSubscriptionProgramError = /** @class */ (function (_super) {
    tslib_1.__extends(NoSubscriptionProgramError, _super);
    /** @private */
    function NoSubscriptionProgramError(channelId) {
        return _super.call(this, "Channel " + channelId + " does not have a subscription program") || this;
    }
    return NoSubscriptionProgramError;
}(CustomError_1.default));
exports.default = NoSubscriptionProgramError;
module.exports = exports = NoSubscriptionProgramError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = NoSubscriptionProgramError;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://www.ecma-international.org/ecma-262/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return typeof argument === 'string' || typeof argument === 'symbol';
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(35);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @private */
function makePaginationQuery(_a) {
    var _b = _a === void 0 ? {} : _a, after = _b.after, before = _b.before, limit = _b.limit;
    return {
        after: after,
        before: before,
        first: limit
    };
}
exports.makePaginationQuery = makePaginationQuery;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever a HTTP error occurs. Some HTTP errors are handled in the library when they're expected.
 */
var HTTPStatusCodeError = /** @class */ (function (_super) {
    tslib_1.__extends(HTTPStatusCodeError, _super);
    /** @private */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function HTTPStatusCodeError(statusCode, statusText, body) {
        var _this = _super.call(this, "Encountered HTTP status code " + statusCode + ": " + statusText + "\n\nBody:\n" + JSON.stringify(body, null, 2)) || this;
        _this._statusCode = statusCode;
        _this._body = body;
        return _this;
    }
    Object.defineProperty(HTTPStatusCodeError.prototype, "statusCode", {
        get: function () {
            return this._statusCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPStatusCodeError.prototype, "body", {
        get: function () {
            return this._body;
        },
        enumerable: true,
        configurable: true
    });
    return HTTPStatusCodeError;
}(CustomError_1.default));
exports.default = HTTPStatusCodeError;
module.exports = exports = HTTPStatusCodeError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HTTPStatusCodeError;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * These are the kind of errors that should never happen.
 *
 * If you see one thrown, please file a bug in the GitHub issue tracker.
 */
var HellFreezesOverError = /** @class */ (function (_super) {
    tslib_1.__extends(HellFreezesOverError, _super);
    function HellFreezesOverError(message) {
        return _super.call(this, message + " - this should never happen, please file a bug in the GitHub issue tracker") || this;
    }
    return HellFreezesOverError;
}(CustomError_1.default));
exports.default = HellFreezesOverError;
module.exports = exports = HellFreezesOverError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HellFreezesOverError;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var isNode = __webpack_require__(14);
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["CRITICAL"] = 0] = "CRITICAL";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["WARNING"] = 2] = "WARNING";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG1"] = 4] = "DEBUG1";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG2"] = 4] = "DEBUG2";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG3"] = 4] = "DEBUG3";
    LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
    LogLevel[LogLevel["TRACE"] = 7] = "TRACE";
})(LogLevel || (LogLevel = {}));
exports.default = LogLevel;
function resolveLogLevel(level) {
    if (typeof level === 'number') {
        if (Object.prototype.hasOwnProperty.call(LogLevel, level)) {
            return level;
        }
        var eligibleLevels = Object.keys(LogLevel)
            .map(function (k) { return parseInt(k, 10); })
            .filter(function (k) { return !isNaN(k) && k < level; });
        if (!eligibleLevels) {
            return LogLevel.WARNING;
        }
        return Math.max.apply(Math, eligibleLevels);
    }
    var strLevel = level.toUpperCase();
    if (!Object.prototype.hasOwnProperty.call(LogLevel, strLevel)) {
        throw new Error("Unknown log level string: " + strLevel);
    }
    return LogLevel[strLevel];
}
exports.resolveLogLevel = resolveLogLevel;
// Node 8+ defines console.debug as noop, and earlier versions don't define it at all
var debugFunction = isNode ? console.log.bind(console) : console.debug.bind(console);
var __export_LogLevelToConsoleFunction = (_a = {},
    _a[LogLevel.CRITICAL] = console.error.bind(console),
    _a[LogLevel.ERROR] = console.error.bind(console),
    _a[LogLevel.WARNING] = console.warn.bind(console),
    _a[LogLevel.INFO] = console.info.bind(console),
    _a[LogLevel.DEBUG] = debugFunction.bind(console),
    _a[LogLevel.TRACE] = console.trace.bind(console),
    _a);
exports.LogLevelToConsoleFunction = __export_LogLevelToConsoleFunction;
module.exports = exports = LogLevel;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LogLevel;
exports.resolveLogLevel = resolveLogLevel;
exports.LogLevelToConsoleFunction = __export_LogLevelToConsoleFunction;
//# sourceMappingURL=LogLevel.js.map

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var isNode = __webpack_require__(14);
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["CRITICAL"] = 0] = "CRITICAL";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["WARNING"] = 2] = "WARNING";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG1"] = 4] = "DEBUG1";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG2"] = 4] = "DEBUG2";
    /** @deprecated use DEBUG instead */
    LogLevel[LogLevel["DEBUG3"] = 4] = "DEBUG3";
    LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
    LogLevel[LogLevel["TRACE"] = 7] = "TRACE";
})(LogLevel || (LogLevel = {}));
exports.LogLevel = LogLevel;
function resolveLogLevel(level) {
    if (typeof level === 'number') {
        if (Object.prototype.hasOwnProperty.call(LogLevel, level)) {
            return level;
        }
        var eligibleLevels = Object.keys(LogLevel)
            .map(function (k) { return parseInt(k, 10); })
            .filter(function (k) { return !isNaN(k) && k < level; });
        if (!eligibleLevels) {
            return LogLevel.WARNING;
        }
        return Math.max.apply(Math, eligibleLevels);
    }
    var strLevel = level.toUpperCase();
    if (!Object.prototype.hasOwnProperty.call(LogLevel, strLevel)) {
        throw new Error("Unknown log level string: " + strLevel);
    }
    return LogLevel[strLevel];
}
exports.resolveLogLevel = resolveLogLevel;
// Node 8+ defines console.debug as noop, and earlier versions don't define it at all
var debugFunction = isNode ? console.log.bind(console) : console.debug.bind(console);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.LogLevelToConsoleFunction = (_a = {},
    _a[LogLevel.CRITICAL] = console.error.bind(console),
    _a[LogLevel.ERROR] = console.error.bind(console),
    _a[LogLevel.WARNING] = console.warn.bind(console),
    _a[LogLevel.INFO] = console.info.bind(console),
    _a[LogLevel.DEBUG] = debugFunction.bind(console),
    _a[LogLevel.TRACE] = console.trace.bind(console),
    _a);
//# sourceMappingURL=LogLevel.js.map

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var origSymbol = global.Symbol;
var hasSymbolSham = __webpack_require__(67);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(147)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = __webpack_require__(148);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function requirePromise() {
	if (typeof Promise !== 'function') {
		throw new TypeError('`Promise.allSettled` requires a global `Promise` be available.');
	}
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the data of an OAuth access token returned by Twitch.
 */
var AccessToken = /** @class */ (function () {
    /** @private */
    function AccessToken(_data, obtainmentDate) {
        this._data = _data;
        this._obtainmentDate = obtainmentDate || new Date();
    }
    Object.defineProperty(AccessToken.prototype, "accessToken", {
        /**
         * The access token which is necessary for every request to the Twitch API.
         */
        get: function () {
            return this._data.access_token;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "refreshToken", {
        /**
         * The refresh token which is necessary to refresh the access token once it expires.
         */
        get: function () {
            return this._data.refresh_token;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "expiryDate", {
        /**
         * The time when the access token will expire.
         *
         * May be `null`, in which case the token does not expire.
         * This can only be the case with very old Client IDs.
         */
        get: function () {
            if (!this._data.expires_in) {
                return null;
            }
            return new Date(this._obtainmentDate.getTime() + this._data.expires_in * 1000);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "isExpired", {
        get: function () {
            if (!this._data.expires_in) {
                return false;
            }
            return Date.now() > this._obtainmentDate.getTime() + this._data.expires_in * 1000;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "scope", {
        /**
         * The scope the access token is valid for, i.e. what this token enables you to do.
         */
        get: function () {
            return this._data.scope || [];
        },
        enumerable: true,
        configurable: true
    });
    return AccessToken;
}());
exports.default = AccessToken;
module.exports = exports = AccessToken;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = AccessToken;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function arrayToObject(arr, fn) {
    return Object.assign.apply(Object, tslib_1.__spread([{}], arr.map(fn)));
}
exports.arrayToObject = arrayToObject;
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayToObject = arrayToObject;
//# sourceMappingURL=arrayToObject.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * Information about the ban of a user.
 */
var HelixBan = /** @class */ (function () {
    /** @private */
    function HelixBan(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixBan.prototype, "userId", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the user.
     */
    HelixBan.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixBan.prototype, "userName", {
        /**
         * The name of the user.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBan.prototype, "expiryDate", {
        /**
         * The date when the ban will expire; null for permanent bans.
         */
        get: function () {
            return this._data.expires_at ? new Date(this._data.expires_at) : null;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixBan.prototype, "_client", void 0);
    return HelixBan;
}());
exports.default = HelixBan;
module.exports = exports = HelixBan;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixBan;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * Information about the moderator status of a user.
 */
var HelixModerator = /** @class */ (function () {
    /** @private */
    function HelixModerator(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixModerator.prototype, "userId", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the user.
     */
    HelixModerator.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixModerator.prototype, "userName", {
        /**
         * The name of the user.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixModerator.prototype, "_client", void 0);
    return HelixModerator;
}());
exports.default = HelixModerator;
module.exports = exports = HelixModerator;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixModerator;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A (paid) subscription of a user to a broadcaster.
 */
var HelixSubscription = /** @class */ (function () {
    /** @private */
    function HelixSubscription(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixSubscription.prototype, "broadcasterId", {
        /**
         * The user ID of the broadcaster.
         */
        get: function () {
            return this._data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "broadcasterDisplayName", {
        /**
         * The display name of the broadcaster.
         */
        get: function () {
            return this._data.broadcaster_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the broadcaster.
     */
    HelixSubscription.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this.broadcasterId)];
            });
        });
    };
    Object.defineProperty(HelixSubscription.prototype, "isGift", {
        /**
         * Whether the subscription has been gifted by another user.
         */
        get: function () {
            return this._data.is_gift;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "tier", {
        /**
         * The tier of the subscription.
         */
        get: function () {
            return this._data.tier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "userId", {
        /**
         * The user ID of the subscribed user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "userDisplayName", {
        /**
         * The display name of the subscribed user.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the subscribed user.
     */
    HelixSubscription.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this.userId)];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixSubscription.prototype, "_client", void 0);
    return HelixSubscription;
}());
exports.default = HelixSubscription;
module.exports = exports = HelixSubscription;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixSubscription;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var NoSubscriptionProgramError_1 = __webpack_require__(15);
/**
 * The type of a broadcaster.
 */
var HelixBroadcasterType;
(function (HelixBroadcasterType) {
    /**
     * A Twitch Partner.
     */
    HelixBroadcasterType["Partner"] = "partner";
    /**
     * A Twitch Affiliate.
     */
    HelixBroadcasterType["Affiliate"] = "affiliate";
    /**
     * A user that's neither a partner nor an affiliate.
     */
    HelixBroadcasterType["None"] = "";
})(HelixBroadcasterType || (HelixBroadcasterType = {}));
exports.HelixBroadcasterType = HelixBroadcasterType;
/**
 * The type of a user.
 */
var HelixUserType;
(function (HelixUserType) {
    /**
     * A Twitch staff member.
     */
    HelixUserType["Staff"] = "staff";
    /**
     * A Twitch administrator.
     */
    HelixUserType["Admin"] = "admin";
    /**
     * A global moderator.
     */
    HelixUserType["GlobalMod"] = "global_mod";
    /**
     * A user with no special permissions across Twitch.
     */
    HelixUserType["None"] = "";
})(HelixUserType || (HelixUserType = {}));
exports.HelixUserType = HelixUserType;
/**
 * A Twitch user.
 */
var HelixUser = /** @class */ (function () {
    /** @private */
    function HelixUser(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixUser.prototype, "cacheKey", {
        /** @private */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "id", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "name", {
        /**
         * The user name of the user.
         */
        get: function () {
            return this._data.login;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "displayName", {
        /**
         * The display name of the user.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "description", {
        /**
         * The description of the user.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "type", {
        /**
         * The type of the user.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "broadcasterType", {
        /**
         * The type of the user.
         */
        get: function () {
            return this._data.broadcaster_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "profilePictureUrl", {
        /**
         * The URL to the profile picture of the user.
         */
        get: function () {
            return this._data.profile_image_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "offlinePlaceholderUrl", {
        /**
         * The URL to the offline video placeholder of the user.
         */
        get: function () {
            return this._data.offline_image_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "views", {
        /**
         * The total number of views of the user's channel.
         */
        get: function () {
            return this._data.view_count;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the channel's stream data.
     */
    HelixUser.prototype.getStream = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.streams.getStreamByUserId(this)];
            });
        });
    };
    /**
     * Retrieves a list of broadcasters the user follows.
     */
    HelixUser.prototype.getFollows = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getFollows({ user: this })];
            });
        });
    };
    /**
     * Retrieves the follow data of the user to the given broadcaster.
     *
     * @param broadcaster The broadcaster to check the follow to.
     */
    HelixUser.prototype.getFollowTo = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var params, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            user: this.id,
                            followedUser: broadcaster
                        };
                        return [4 /*yield*/, this._client.helix.users.getFollows(params)];
                    case 1:
                        result = (_a.sent()).data;
                        return [2 /*return*/, result.length ? result[0] : null];
                }
            });
        });
    };
    /**
     * Checks whether the user is following the given broadcaster.
     *
     * @param broadcaster The broadcaster to check the user's follow to.
     */
    HelixUser.prototype.follows = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getFollowTo(broadcaster)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                }
            });
        });
    };
    /**
     * Follows the broadcaster.
     */
    HelixUser.prototype.follow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.followChannel(this)];
                }
            });
        });
    };
    /**
     * Unfollows the broadcaster.
     */
    HelixUser.prototype.unfollow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.unfollowChannel(this)];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for the user to the given broadcaster, or `null` if the user is not subscribed.
     *
     * @param broadcaster The broadcaster you want to get the subscription data for.
     */
    HelixUser.prototype.getSubscriptionTo = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.subscriptions.getSubscriptionForUser(broadcaster, this)];
            });
        });
    };
    /**
     * Checks whether the user is subscribed to the given broadcaster.
     *
     * @param broadcaster The broadcaster you want to check the subscription for.
     */
    HelixUser.prototype.isSubscribedTo = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getSubscriptionTo(broadcaster)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof NoSubscriptionProgramError_1.default) {
                            return [2 /*return*/, false];
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixUser.prototype, "_client", void 0);
    return HelixUser;
}());
exports.default = HelixUser;
module.exports = exports = HelixUser;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixBroadcasterType = HelixBroadcasterType;
exports.HelixUserType = HelixUserType;
exports.default = HelixUser;


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(35);

var GetIntrinsic = __webpack_require__(2);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

module.exports = function callBind() {
	return $reflectApply(bind, $call, arguments);
};

module.exports.apply = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(146);

module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');
var $SyntaxError = GetIntrinsic('%SyntaxError%');

var has = __webpack_require__(17);

var predicates = {
	// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
	'Property Descriptor': function isPropertyDescriptor(Type, Desc) {
		if (Type(Desc) !== 'Object') {
			return false;
		}
		var allowed = {
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Get]]': true,
			'[[Set]]': true,
			'[[Value]]': true,
			'[[Writable]]': true
		};

		for (var key in Desc) { // eslint-disable-line
			if (has(Desc, key) && !allowed[key]) {
				return false;
			}
		}

		var isData = has(Desc, '[[Value]]');
		var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');
		if (isData && IsAccessor) {
			throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
		}
		return true;
	}
};

module.exports = function assertRecord(Type, recordType, argumentName, value) {
	var predicate = predicates[recordType];
	if (typeof predicate !== 'function') {
		throw new $SyntaxError('unknown record type: ' + recordType);
	}
	if (!predicate(Type, value)) {
		throw new $TypeError(argumentName + ' must be a ' + recordType);
	}
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var HellFreezesOverError_1 = __webpack_require__(20);
/**
 * The type of background a cheermote is supposed to appear on.
 *
 * We will supply a fitting graphic that does not show any artifacts
 * on the given type of background.
 */
var CheermoteBackground;
(function (CheermoteBackground) {
    /**
     * A dark background.
     *
     * Cheermotes might show artifacts on bright backgrounds.
     */
    CheermoteBackground["dark"] = "dark";
    /**
     * A bright background.
     *
     * Cheermotes might show artifacts on dark backgrounds.
     */
    CheermoteBackground["light"] = "light";
})(CheermoteBackground || (CheermoteBackground = {}));
exports.CheermoteBackground = CheermoteBackground;
/**
 * The state of a cheermote, i.e. whether it's animated or not.
 */
var CheermoteState;
(function (CheermoteState) {
    /**
     * The cheermote should be animated.
     */
    CheermoteState["animated"] = "animated";
    /**
     * The cheermote should not be animated.
     */
    CheermoteState["static"] = "static";
})(CheermoteState || (CheermoteState = {}));
exports.CheermoteState = CheermoteState;
/**
 * The scale of the cheermote, which usually relates to the pixel density of the device in use.
 */
var CheermoteScale;
(function (CheermoteScale) {
    /**
     * The cheermote should not be scaled.
     */
    CheermoteScale["x1"] = "1";
    /**
     * The cheermote should be scaled 1.5x.
     */
    CheermoteScale["x1_5"] = "1.5";
    /**
     * The cheermote should be scaled 2x.
     */
    CheermoteScale["x2"] = "2";
    /**
     * The cheermote should be scaled 3x.
     */
    CheermoteScale["x3"] = "3";
    /**
     * The cheermote should be scaled 4x.
     */
    CheermoteScale["x4"] = "4";
})(CheermoteScale || (CheermoteScale = {}));
exports.CheermoteScale = CheermoteScale;
/**
 * A list of cheermotes you can use globally or in a specific channel, depending on how you fetched the list.
 */
var CheermoteList = /** @class */ (function () {
    /** @private */
    function CheermoteList(data, client) {
        this._client = client;
        this._data = shared_utils_1.indexBy(data, function (action) { return action.prefix.toLowerCase(); });
    }
    /**
     * Gets the URL and color needed to properly represent a cheer of the given amount of bits with the given prefix.
     *
     * @param name The name/prefix of the cheermote.
     * @param bits The amount of bits cheered.
     * @param format The format of the cheermote you want to request.
     */
    CheermoteList.prototype.getCheermoteDisplayInfo = function (name, bits, format) {
        if (format === void 0) { format = {}; }
        name = name.toLowerCase();
        var cheermoteDefaults = this._client.cheermoteDefaults;
        var fullOptions = tslib_1.__assign({ background: cheermoteDefaults.defaultBackground, state: cheermoteDefaults.defaultState, scale: cheermoteDefaults.defaultScale }, format);
        var tiers = this._data[name].tiers;
        var correctTier = tiers.sort(function (a, b) { return b.min_bits - a.min_bits; }).find(function (tier) { return tier.min_bits <= bits; });
        if (!correctTier) {
            throw new HellFreezesOverError_1.default("Cheermote \"" + name + "\" does not have an applicable tier for " + bits + " bits");
        }
        return {
            url: correctTier.images[fullOptions.background][fullOptions.state][fullOptions.scale],
            color: correctTier.color
        };
    };
    /**
     * Gets all possible cheermote names.
     */
    CheermoteList.prototype.getPossibleNames = function () {
        return Object.keys(this._data);
    };
    /**
     * Parses all the cheermotes out of a message.
     *
     * @param message The message.
     */
    CheermoteList.prototype.parseMessage = function (message) {
        var result = [];
        var names = this.getPossibleNames();
        // TODO fix this regex so it works in firefox, which does not support lookbehind
        var re = new RegExp('(?<=^|\\s)([a-z0-9]+?)(\\d+)(?=\\s|$)', 'gi');
        var match;
        while ((match = re.exec(message))) {
            var name_1 = match[1].toLowerCase();
            if (names.includes(name_1)) {
                var amount = Number(match[2]);
                result.push({
                    name: name_1,
                    amount: amount,
                    position: shared_utils_1.utf8Length(message.substr(0, match.index)),
                    length: match[0].length,
                    displayInfo: this.getCheermoteDisplayInfo(name_1, amount)
                });
            }
        }
        return result;
    };
    /**
     * Transforms all the cheermotes in a message and returns an array of all the message parts.
     *
     * @param message The message.
     * @param transformer A function that transforms a message part into an arbitrary structure.
     */
    CheermoteList.prototype.transformCheerMessage = function (message, transformer) {
        var e_1, _a;
        var result = [];
        var currentPosition = 0;
        try {
            for (var _b = tslib_1.__values(this.parseMessage(message)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var foundCheermote = _c.value;
                if (currentPosition < foundCheermote.position) {
                    result.push(message.substring(currentPosition, foundCheermote.position));
                }
                result.push(transformer(foundCheermote));
                currentPosition = foundCheermote.position + foundCheermote.length;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (currentPosition < message.length) {
            result.push(message.substr(currentPosition));
        }
        return result;
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], CheermoteList.prototype, "_client", void 0);
    return CheermoteList;
}());
exports.default = CheermoteList;
module.exports = exports = CheermoteList;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheermoteBackground = CheermoteBackground;
exports.CheermoteState = CheermoteState;
exports.CheermoteScale = CheermoteScale;
exports.default = CheermoteList;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var NoSubscriptionProgramError_1 = __webpack_require__(15);
/**
 * A placeholder for a channel.
 *
 * This is used for example when you only have retrieved user data, but not channel data.
 * This can do anything you can do with only a channel ID, as it's equivalent to the user ID.
 */
var ChannelPlaceholder = /** @class */ (function () {
    /** @private */
    function ChannelPlaceholder(id, client) {
        this._data = { _id: id };
        this._client = client;
    }
    Object.defineProperty(ChannelPlaceholder.prototype, "cacheKey", {
        /** @private */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelPlaceholder.prototype, "id", {
        /**
         * The ID of the channel.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the list of cheermotes you can use in the channel.
     */
    ChannelPlaceholder.prototype.getCheermotes = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.bits.getCheermotes(this)];
            });
        });
    };
    /**
     * Retrieves the channel data.
     */
    ChannelPlaceholder.prototype.getChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannel(this)];
            });
        });
    };
    /**
     * Retrieves the channel's stream data.
     */
    ChannelPlaceholder.prototype.getStream = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.streams.getStreamByChannel(this)];
            });
        });
    };
    /**
     * Retrieves the channel's followers.
     */
    ChannelPlaceholder.prototype.getFollowers = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelFollowers(this)];
            });
        });
    };
    /**
     * Retrieves the channel's subscribers.
     */
    ChannelPlaceholder.prototype.getSubscriptions = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelSubscriptions(this)];
            });
        });
    };
    /**
     * Retrieves the subscription data for the given user to the channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the channel. If you only have access to the user,
     * use {@User#getSubscriptionTo} instead.
     *
     * @param user The user you want to get the subscription data for.
     */
    ChannelPlaceholder.prototype.getSubscriptionBy = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelSubscriptionByUser(this, user)];
            });
        });
    };
    /**
     * Checks whether the given user is subscribed to the channel.
     *
     * @param user The user you want to check the subscription for.
     */
    ChannelPlaceholder.prototype.hasSubscriber = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getSubscriptionBy(user)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof NoSubscriptionProgramError_1.default) {
                            return [2 /*return*/, false];
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChannelPlaceholder.prototype, "_client", void 0);
    return ChannelPlaceholder;
}());
exports.default = ChannelPlaceholder;
module.exports = exports = ChannelPlaceholder;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChannelPlaceholder;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A subscription to a Twitch channel.
 */
var Subscription = /** @class */ (function () {
    /** @private */
    function Subscription(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(Subscription.prototype, "id", {
        /**
         * The ID of the subscription.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Subscription.prototype, "subPlan", {
        /**
         * The identifier of the subscription plan.
         */
        get: function () {
            return this._data.sub_plan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Subscription.prototype, "subPlanName", {
        /**
         * The name of the subscription plan.
         */
        get: function () {
            return this._data.sub_plan_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Subscription.prototype, "startDate", {
        /**
         * The date when the subscription was started.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], Subscription.prototype, "_client", void 0);
    return Subscription;
}());
exports.default = Subscription;
module.exports = exports = Subscription;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Subscription;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A Twitch team.
 */
var Team = /** @class */ (function () {
    /** @private */
    function Team(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(Team.prototype, "id", {
        /**
         * The ID of the team.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "background", {
        /**
         * The background url of the team.
         */
        get: function () {
            return this._data.background;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "banner", {
        /**
         * The banner url of the team.
         */
        get: function () {
            return this._data.banner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "creationDate", {
        /**
         * The date when the team was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "updateDate", {
        /**
         * The last date when the team changed anything.
         */
        get: function () {
            return new Date(this._data.updated_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "name", {
        /**
         * The name of the team.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "info", {
        /**
         * The info of the team.
         */
        get: function () {
            return this._data.info;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "displayName", {
        /**
         * The display name of the team.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "logoUrl", {
        /**
         * The URL to the profile picture of the team.
         */
        get: function () {
            return this._data.logo;
        },
        enumerable: true,
        configurable: true
    });
    Team.prototype.getUsers = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var team;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.teams.getTeamByName(this.name)];
                    case 1:
                        team = _a.sent();
                        return [2 /*return*/, team.getUsers()];
                }
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], Team.prototype, "_client", void 0);
    return Team;
}());
exports.default = Team;
module.exports = exports = Team;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Team;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var Channel_1 = __webpack_require__(13);
/**
 * The type of a stream.
 */
var StreamType;
(function (StreamType) {
    /**
     * A live stream.
     */
    StreamType["Live"] = "live";
    /**
     * An upload to the channel (VoD) that is streamed live for the first time.
     */
    StreamType["Premiere"] = "premiere";
    /**
     * A rerun of a past live stream.
     */
    StreamType["ReRun"] = "rerun";
    /**
     * All types of streams. Used for filtering.
     */
    StreamType["All"] = "all";
})(StreamType || (StreamType = {}));
exports.StreamType = StreamType;
/**
 * A Twitch stream.
 */
var Stream = /** @class */ (function () {
    /** @private */
    function Stream(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(Stream.prototype, "id", {
        /**
         * The ID of the stream.
         */
        get: function () {
            return this._data._id.toString();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "game", {
        /**
         * The game played on the stream.
         */
        get: function () {
            return this._data.game;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "viewers", {
        /**
         * The current number of concurrent viewers.
         */
        get: function () {
            return this._data.viewers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "videoHeight", {
        /**
         * The height of the stream video.
         */
        get: function () {
            return this._data.video_height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "averageFPS", {
        /**
         * The average FPS (frames per second) that are shown on the stream.
         */
        get: function () {
            return this._data.average_fps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "delay", {
        /**
         * The delay of the stream, in seconds.
         */
        get: function () {
            return this._data.delay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "startDate", {
        /**
         * The time when the stream started.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "isPlaylist", {
        /**
         * Whether the stream is running a playlist.
         */
        get: function () {
            return this._data.is_playlist;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "type", {
        /**
         * The type of the stream.
         */
        get: function () {
            return this._data.stream_type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the URL of a preview image for the stream
     *
     * @param size The size of the image.
     */
    Stream.prototype.getPreviewUrl = function (size) {
        return this._data.preview[size];
    };
    Object.defineProperty(Stream.prototype, "channel", {
        /**
         * The channel where the stream is shown.
         */
        get: function () {
            return new Channel_1.default(this._data.channel, this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], Stream.prototype, "_client", void 0);
    return Stream;
}());
exports.default = Stream;
module.exports = exports = Stream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamType = StreamType;
exports.default = Stream;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable filenames/match-exported */
var TwitchClient_1 = __webpack_require__(4);
exports.TwitchAPICallType = TwitchClient_1.TwitchAPICallType;
exports.default = TwitchClient_1.default;
var ConfigError_1 = __webpack_require__(100);
exports.ConfigError = ConfigError_1.default;
var HellFreezesOverError_1 = __webpack_require__(20);
exports.HellFreezesOverError = HellFreezesOverError_1.default;
var HTTPStatusCodeError_1 = __webpack_require__(19);
exports.HTTPStatusCodeError = HTTPStatusCodeError_1.default;
var InvalidTokenError_1 = __webpack_require__(101);
exports.InvalidTokenError = InvalidTokenError_1.default;
var InvalidTokenTypeError_1 = __webpack_require__(209);
exports.InvalidTokenTypeError = InvalidTokenTypeError_1.default;
var NoSubscriptionProgramError_1 = __webpack_require__(15);
exports.NoSubscriptionProgramError = NoSubscriptionProgramError_1.default;
var StreamNotLiveError_1 = __webpack_require__(57);
exports.StreamNotLiveError = StreamNotLiveError_1.default;
var StaticAuthProvider_1 = __webpack_require__(99);
exports.StaticAuthProvider = StaticAuthProvider_1.default;
var RefreshableAuthProvider_1 = __webpack_require__(98);
exports.RefreshableAuthProvider = RefreshableAuthProvider_1.default;
var AccessToken_1 = __webpack_require__(27);
exports.AccessToken = AccessToken_1.default;
var TokenInfo_1 = __webpack_require__(96);
exports.TokenInfo = TokenInfo_1.default;
var Subscription_1 = __webpack_require__(39);
exports.Subscription = Subscription_1.default;
var CheermoteList_1 = __webpack_require__(37);
exports.CheermoteList = CheermoteList_1.default;
exports.CheermoteBackground = CheermoteList_1.CheermoteBackground;
exports.CheermoteScale = CheermoteList_1.CheermoteScale;
exports.CheermoteState = CheermoteList_1.CheermoteState;
var Channel_1 = __webpack_require__(13);
exports.Channel = Channel_1.default;
var ChannelFollow_1 = __webpack_require__(88);
exports.ChannelFollow = ChannelFollow_1.default;
var ChannelPlaceholder_1 = __webpack_require__(38);
exports.ChannelPlaceholder = ChannelPlaceholder_1.default;
var ChannelSubscription_1 = __webpack_require__(89);
exports.ChannelSubscription = ChannelSubscription_1.default;
var EmoteSetList_1 = __webpack_require__(91);
exports.EmoteSetList = EmoteSetList_1.default;
var PrivilegedChannel_1 = __webpack_require__(90);
exports.PrivilegedChannel = PrivilegedChannel_1.default;
var Stream_1 = __webpack_require__(41);
exports.Stream = Stream_1.default;
exports.StreamType = Stream_1.StreamType;
var ChattersList_1 = __webpack_require__(97);
exports.ChattersList = ChattersList_1.default;
var PrivilegedUser_1 = __webpack_require__(92);
exports.PrivilegedUser = PrivilegedUser_1.default;
var User_1 = __webpack_require__(10);
exports.User = User_1.default;
var UserBlock_1 = __webpack_require__(93);
exports.UserBlock = UserBlock_1.default;
var UserFollow_1 = __webpack_require__(94);
exports.UserFollow = UserFollow_1.default;
var UserSubscription_1 = __webpack_require__(95);
exports.UserSubscription = UserSubscription_1.default;
var HelixPaginatedRequest_1 = __webpack_require__(9);
exports.HelixPaginatedRequest = HelixPaginatedRequest_1.default;
var HelixBitsLeaderboard_1 = __webpack_require__(50);
exports.HelixBitsLeaderboard = HelixBitsLeaderboard_1.default;
var HelixBitsLeaderboardEntry_1 = __webpack_require__(51);
exports.HelixBitsLeaderboardEntry = HelixBitsLeaderboardEntry_1.default;
var HelixClip_1 = __webpack_require__(52);
exports.HelixClip = HelixClip_1.default;
var HelixExtensionTransaction_1 = __webpack_require__(53);
exports.HelixExtensionTransaction = HelixExtensionTransaction_1.default;
var HelixGame_1 = __webpack_require__(54);
exports.HelixGame = HelixGame_1.default;
var HelixBan_1 = __webpack_require__(29);
exports.HelixBan = HelixBan_1.default;
var HelixBanEvent_1 = __webpack_require__(55);
exports.HelixBanEvent = HelixBanEvent_1.default;
var HelixModerator_1 = __webpack_require__(30);
exports.HelixModerator = HelixModerator_1.default;
var HelixModeratorEvent_1 = __webpack_require__(56);
exports.HelixModeratorEvent = HelixModeratorEvent_1.default;
var HelixStream_1 = __webpack_require__(58);
exports.HelixStream = HelixStream_1.default;
exports.HelixStreamType = HelixStream_1.HelixStreamType;
var HelixFollow_1 = __webpack_require__(62);
exports.HelixFollow = HelixFollow_1.default;
var HelixPrivilegedUser_1 = __webpack_require__(63);
exports.HelixPrivilegedUser = HelixPrivilegedUser_1.default;
var HelixUser_1 = __webpack_require__(32);
exports.HelixUser = HelixUser_1.default;
exports.HelixBroadcasterType = HelixUser_1.HelixBroadcasterType;
exports.HelixUserType = HelixUser_1.HelixUserType;
var HelixVideo_1 = __webpack_require__(64);
exports.HelixVideo = HelixVideo_1.default;
var HelixSubscription_1 = __webpack_require__(31);
exports.HelixSubscription = HelixSubscription_1.default;
var HelixSubscriptionEvent_1 = __webpack_require__(60);
exports.HelixSubscriptionEvent = HelixSubscriptionEvent_1.default;
var ChatBadgeList_1 = __webpack_require__(47);
exports.ChatBadgeList = ChatBadgeList_1.default;
var ChatBadgeSet_1 = __webpack_require__(48);
exports.ChatBadgeSet = ChatBadgeSet_1.default;
var ChatBadgeVersion_1 = __webpack_require__(49);
exports.ChatBadgeVersion = ChatBadgeVersion_1.default;
var UserTools_1 = __webpack_require__(6);
exports.extractUserId = UserTools_1.extractUserId;
exports.extractUserName = UserTools_1.extractUserName;
module.exports = exports = TwitchClient_1.default;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TwitchAPICallType = TwitchClient_1.TwitchAPICallType;
exports.default = TwitchClient_1.default;
exports.ConfigError = ConfigError_1.default;
exports.HellFreezesOverError = HellFreezesOverError_1.default;
exports.HTTPStatusCodeError = HTTPStatusCodeError_1.default;
exports.InvalidTokenError = InvalidTokenError_1.default;
exports.InvalidTokenTypeError = InvalidTokenTypeError_1.default;
exports.NoSubscriptionProgramError = NoSubscriptionProgramError_1.default;
exports.StreamNotLiveError = StreamNotLiveError_1.default;
exports.StaticAuthProvider = StaticAuthProvider_1.default;
exports.RefreshableAuthProvider = RefreshableAuthProvider_1.default;
exports.AccessToken = AccessToken_1.default;
exports.TokenInfo = TokenInfo_1.default;
exports.Subscription = Subscription_1.default;
exports.CheermoteList = CheermoteList_1.default;
exports.CheermoteBackground = CheermoteList_1.CheermoteBackground;
exports.CheermoteScale = CheermoteList_1.CheermoteScale;
exports.CheermoteState = CheermoteList_1.CheermoteState;
exports.Channel = Channel_1.default;
exports.ChannelFollow = ChannelFollow_1.default;
exports.ChannelPlaceholder = ChannelPlaceholder_1.default;
exports.ChannelSubscription = ChannelSubscription_1.default;
exports.EmoteSetList = EmoteSetList_1.default;
exports.PrivilegedChannel = PrivilegedChannel_1.default;
exports.Stream = Stream_1.default;
exports.StreamType = Stream_1.StreamType;
exports.ChattersList = ChattersList_1.default;
exports.PrivilegedUser = PrivilegedUser_1.default;
exports.User = User_1.default;
exports.UserBlock = UserBlock_1.default;
exports.UserFollow = UserFollow_1.default;
exports.UserSubscription = UserSubscription_1.default;
exports.HelixPaginatedRequest = HelixPaginatedRequest_1.default;
exports.HelixBitsLeaderboard = HelixBitsLeaderboard_1.default;
exports.HelixBitsLeaderboardEntry = HelixBitsLeaderboardEntry_1.default;
exports.HelixClip = HelixClip_1.default;
exports.HelixExtensionTransaction = HelixExtensionTransaction_1.default;
exports.HelixGame = HelixGame_1.default;
exports.HelixBan = HelixBan_1.default;
exports.HelixBanEvent = HelixBanEvent_1.default;
exports.HelixModerator = HelixModerator_1.default;
exports.HelixModeratorEvent = HelixModeratorEvent_1.default;
exports.HelixStream = HelixStream_1.default;
exports.HelixStreamType = HelixStream_1.HelixStreamType;
exports.HelixFollow = HelixFollow_1.default;
exports.HelixPrivilegedUser = HelixPrivilegedUser_1.default;
exports.HelixUser = HelixUser_1.default;
exports.HelixBroadcasterType = HelixUser_1.HelixBroadcasterType;
exports.HelixUserType = HelixUser_1.HelixUserType;
exports.HelixVideo = HelixVideo_1.default;
exports.HelixSubscription = HelixSubscription_1.default;
exports.HelixSubscriptionEvent = HelixSubscriptionEvent_1.default;
exports.ChatBadgeList = ChatBadgeList_1.default;
exports.ChatBadgeSet = ChatBadgeSet_1.default;
exports.ChatBadgeVersion = ChatBadgeVersion_1.default;
exports.extractUserId = UserTools_1.extractUserId;
exports.extractUserName = UserTools_1.extractUserName;


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LogLevel_1 = __webpack_require__(21);
var isNode = __webpack_require__(14);
var BaseLogger = /** @class */ (function () {
    function BaseLogger(_a) {
        var name = _a.name, _b = _a.minLevel, minLevel = _b === void 0 ? LogLevel_1.default.WARNING : _b, _c = _a.emoji, emoji = _c === void 0 ? false : _c, _d = _a.colors, colors = _d === void 0 ? true : _d, _e = _a.timestamps, timestamps = _e === void 0 ? isNode : _e;
        this._name = name;
        this._minLevel = LogLevel_1.resolveLogLevel(minLevel);
        this._emoji = emoji;
        this._colors = colors;
        this._timestamps = timestamps;
    }
    // region convenience methods
    BaseLogger.prototype.crit = function (message) {
        this.log(LogLevel_1.default.CRITICAL, message);
    };
    BaseLogger.prototype.critical = function (message) {
        this.log(LogLevel_1.default.CRITICAL, message);
    };
    BaseLogger.prototype.err = function (message) {
        this.log(LogLevel_1.default.ERROR, message);
    };
    BaseLogger.prototype.error = function (message) {
        this.log(LogLevel_1.default.ERROR, message);
    };
    BaseLogger.prototype.warn = function (message) {
        this.log(LogLevel_1.default.WARNING, message);
    };
    BaseLogger.prototype.warning = function (message) {
        this.log(LogLevel_1.default.WARNING, message);
    };
    BaseLogger.prototype.info = function (message) {
        this.log(LogLevel_1.default.INFO, message);
    };
    BaseLogger.prototype.debug = function (message) {
        this.log(LogLevel_1.default.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug1 = function (message) {
        this.log(LogLevel_1.default.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug2 = function (message) {
        this.log(LogLevel_1.default.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug3 = function (message) {
        this.log(LogLevel_1.default.DEBUG, message);
    };
    BaseLogger.prototype.trace = function (message) {
        this.log(LogLevel_1.default.TRACE, message);
    };
    return BaseLogger;
}());
exports.default = BaseLogger;
module.exports = exports = BaseLogger;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseLogger;
//# sourceMappingURL=BaseLogger.js.map

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var util = __webpack_require__(26);

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = util.assign(
    {
        'default': Format.RFC3986,
        formatters: {
            RFC1738: function (value) {
                return replace.call(value, percentTwenties, '+');
            },
            RFC3986: function (value) {
                return String(value);
            }
        }
    },
    Format
);


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function pick(obj, keys) {
    return Object.assign.apply(Object, tslib_1.__spread([{}], Object.entries(obj)
        .filter(function (_a) {
        var _b = tslib_1.__read(_a, 1), key = _b[0];
        return keys.includes(key);
    })
        .map(function (_a) {
        var _b;
        var _c = tslib_1.__read(_a, 2), key = _c[0], value = _c[1];
        return (_b = {}, _b[key] = value, _b);
    })));
}
exports.pick = pick;
Object.defineProperty(exports, "__esModule", { value: true });
exports.pick = pick;
//# sourceMappingURL=pick.js.map

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var ChatBadgeSet_1 = __webpack_require__(48);
/**
 * A list of badge sets.
 */
var ChatBadgeList = /** @class */ (function () {
    /** @private */
    function ChatBadgeList(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatBadgeList.prototype, "badgeSetNames", {
        /**
         * Names of all badge sets in the list.
         */
        get: function () {
            return Object.keys(this._data);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a specific badge set by name.
     *
     * @param name The name of the badge set.
     */
    ChatBadgeList.prototype.getBadgeSet = function (name) {
        return new ChatBadgeSet_1.default(this._data[name], this._client);
    };
    /** @private */
    ChatBadgeList.prototype._merge = function (additionalData) {
        if (additionalData instanceof ChatBadgeList) {
            additionalData = additionalData._data;
        }
        return new ChatBadgeList(tslib_1.__assign(tslib_1.__assign({}, this._data), additionalData), this._client);
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatBadgeList.prototype, "_client", void 0);
    return ChatBadgeList;
}());
exports.default = ChatBadgeList;
module.exports = exports = ChatBadgeList;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatBadgeList;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var ChatBadgeVersion_1 = __webpack_require__(49);
/**
 * A set of badges.
 */
var ChatBadgeSet = /** @class */ (function () {
    /** @private */
    function ChatBadgeSet(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatBadgeSet.prototype, "versionNames", {
        /**
         * Names of all versions of the badge set.
         */
        get: function () {
            return Object.keys(this._data.versions);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a specific version of a badge by name.
     *
     * @param name The name of the version.
     */
    ChatBadgeSet.prototype.getVersion = function (name) {
        return new ChatBadgeVersion_1.default(this._data.versions[name], this._client);
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatBadgeSet.prototype, "_client", void 0);
    return ChatBadgeSet;
}());
exports.default = ChatBadgeSet;
module.exports = exports = ChatBadgeSet;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatBadgeSet;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A version of a badge.
 */
var ChatBadgeVersion = /** @class */ (function () {
    /** @private */
    function ChatBadgeVersion(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatBadgeVersion.prototype, "clickAction", {
        /**
         * The action to execute when the badge is clicked.
         */
        get: function () {
            return this._data.click_action;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatBadgeVersion.prototype, "clickUrl", {
        /**
         * The URL to visit when the badge is clicked.
         *
         * Only applies if clickAction === 'visit_url'.
         */
        get: function () {
            return this._data.click_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatBadgeVersion.prototype, "description", {
        /**
         * The description of the badge.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets an image URL for the given scale.
     *
     * @param scale The scale of the badge image.
     */
    ChatBadgeVersion.prototype.getImageUrl = function (scale) {
        return this._data["image_url_" + scale + "x"];
    };
    Object.defineProperty(ChatBadgeVersion.prototype, "title", {
        /**
         * The title of the badge.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatBadgeVersion.prototype, "_client", void 0);
    return ChatBadgeVersion;
}());
exports.default = ChatBadgeVersion;
module.exports = exports = ChatBadgeVersion;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatBadgeVersion;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var shared_utils_1 = __webpack_require__(1);
var HelixBitsLeaderboardEntry_1 = __webpack_require__(51);
/**
 * A leaderboard where the users who used the most bits to a broadcaster are listed.
 */
var HelixBitsLeaderboard = /** @class */ (function () {
    /** @private */
    function HelixBitsLeaderboard(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixBitsLeaderboard.prototype, "entries", {
        /**
         * The entries of the leaderboard.
         */
        get: function () {
            var _this = this;
            return this._data.data.map(function (entry) { return new HelixBitsLeaderboardEntry_1.default(entry, _this._client); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboard.prototype, "totalCount", {
        /**
         * The total amount of people on the requested leaderboard.
         */
        get: function () {
            return this._data.total;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixBitsLeaderboard.prototype, "_client", void 0);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixBitsLeaderboard.prototype, "entries", null);
    HelixBitsLeaderboard = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], HelixBitsLeaderboard);
    return HelixBitsLeaderboard;
}());
exports.default = HelixBitsLeaderboard;
module.exports = exports = HelixBitsLeaderboard;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixBitsLeaderboard;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A Bits leaderboard entry.
 */
var HelixBitsLeaderboardEntry = /** @class */ (function () {
    /** @private */
    function HelixBitsLeaderboardEntry(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "userId", {
        /**
         * The ID of the user on the leaderboard.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "userDisplayName", {
        /**
         * The display name of the user on the leaderboard.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "rank", {
        /**
         * The position of the user on the leaderboard.
         */
        get: function () {
            return this._data.rank;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "amount", {
        /**
         * The amount of bits used in the given period of time.
         */
        get: function () {
            return this._data.score;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the user that's on this place on the leaderboard.
     */
    HelixBitsLeaderboardEntry.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixBitsLeaderboardEntry.prototype, "_client", void 0);
    return HelixBitsLeaderboardEntry;
}());
exports.default = HelixBitsLeaderboardEntry;
module.exports = exports = HelixBitsLeaderboardEntry;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixBitsLeaderboardEntry;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var HelixClip = /** @class */ (function () {
    /** @private */
    function HelixClip(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixClip.prototype, "id", {
        /**
         * The clip ID.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "url", {
        /**
         * The URL of the clip.
         */
        get: function () {
            return this._data.url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "embedUrl", {
        /**
         * The embed URL of the clip.
         */
        get: function () {
            return this._data.embed_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "broadcasterId", {
        /**
         * The user ID of the broadcaster of the stream where the clip was created.
         */
        get: function () {
            return this._data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "broadcasterDisplayName", {
        /**
         * The display name of the broadcaster of the stream where the clip was created.
         */
        get: function () {
            return this._data.broadcaster_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the broadcaster of the stream where the clip was created.
     */
    HelixClip.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "creatorId", {
        /**
         * The user ID of the creator of the clip.
         */
        get: function () {
            return this._data.creator_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "creatorDisplayName", {
        /**
         * The display name of the creator of the clip.
         */
        get: function () {
            return this._data.creator_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the creator of the clip.
     */
    HelixClip.prototype.getCreator = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.creator_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "videoId", {
        /**
         * The ID of the video the clip is taken from.
         */
        get: function () {
            return this._data.video_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the video the clip is taken from.
     */
    HelixClip.prototype.getVideo = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.videos.getVideoById(this._data.video_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "gameId", {
        /**
         * The ID of the game that was being played when the clip was created.
         */
        get: function () {
            return this._data.game_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the game that was being played when the clip was created.
     */
    HelixClip.prototype.getGame = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.games.getGameById(this._data.game_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "language", {
        /**
         * The language of the stream where the clip was created.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "title", {
        /**
         * The title of the clip.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "views", {
        /**
         * The number of views of the clip.
         */
        get: function () {
            return this._data.view_count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "creationDate", {
        /**
         * The date when the clip was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "thumbnailUrl", {
        /**
         * The URL of the thumbnail of the clip.
         */
        get: function () {
            return this._data.thumbnail_url;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixClip.prototype, "_client", void 0);
    return HelixClip;
}());
exports.default = HelixClip;
module.exports = exports = HelixClip;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixClip;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A bits transaction made inside an extension.
 */
var HelixExtensionTransaction = /** @class */ (function () {
    /** @private */
    function HelixExtensionTransaction(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixExtensionTransaction.prototype, "id", {
        /**
         * The ID of the transaction.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "transactionDate", {
        /**
         * The time when the transaction was made.
         */
        get: function () {
            return new Date(this._data.timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "broadcasterId", {
        /**
         * The ID of the broadcaster that runs the extension on their channel.
         */
        get: function () {
            return this._data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "broadcasterDisplayName", {
        /**
         * The display name of the broadcaster that runs the extension on their channel.
         */
        get: function () {
            return this._data.broadcaster_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the broadcaster that runs the extension on their channel.
     */
    HelixExtensionTransaction.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixExtensionTransaction.prototype, "userId", {
        /**
         * The ID of the user that made the transaction.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "userDisplayName", {
        /**
         * The display name of the user that made the transaction.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the user that made the transaction.
     */
    HelixExtensionTransaction.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixExtensionTransaction.prototype, "productType", {
        /**
         * The product type. Currently always BITS_IN_EXTENSION.
         */
        get: function () {
            return this._data.product_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productSKU", {
        /**
         * The product SKU.
         */
        get: function () {
            return this._data.product_data.sku;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productCost", {
        /**
         * The cost of the product, in bits.
         */
        get: function () {
            return this._data.product_data.cost.amount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productDisplayName", {
        /**
         * The display name of the product.
         */
        get: function () {
            return this._data.product_data.displayName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productInDevelopment", {
        /**
         * Whether the product is in development.
         */
        get: function () {
            return this._data.product_data.inDevelopment;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixExtensionTransaction.prototype, "_client", void 0);
    return HelixExtensionTransaction;
}());
exports.default = HelixExtensionTransaction;
module.exports = exports = HelixExtensionTransaction;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixExtensionTransaction;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A game as displayed on Twitch.
 */
var HelixGame = /** @class */ (function () {
    /** @private */
    function HelixGame(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixGame.prototype, "id", {
        /**
         * The ID of the game.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixGame.prototype, "name", {
        /**
         * The name of the game.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixGame.prototype, "boxArtUrl", {
        /**
         * The URL of the box art of the game.
         */
        get: function () {
            return this._data.box_art_url;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixGame.prototype, "_client", void 0);
    return HelixGame;
}());
exports.default = HelixGame;
module.exports = exports = HelixGame;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixGame;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixBan_1 = __webpack_require__(29);
/**
 * The different types a ban event can have.
 */
var HelixBanEventType;
(function (HelixBanEventType) {
    /**
     * Sent when a user gets banned.
     */
    HelixBanEventType["Ban"] = "moderation.user.ban";
    /**
     * Sent when a user gets unbanned.
     */
    HelixBanEventType["Unban"] = "moderation.user.unban";
})(HelixBanEventType || (HelixBanEventType = {}));
exports.HelixBanEventType = HelixBanEventType;
/**
 * An event that indicates the change of a ban status, i.e. banning or unbanning a user.
 */
var HelixBanEvent = /** @class */ (function (_super) {
    tslib_1.__extends(HelixBanEvent, _super);
    /** @private */
    function HelixBanEvent(_eventData, client) {
        var _this = _super.call(this, _eventData.event_data, client) || this;
        _this._eventData = _eventData;
        return _this;
    }
    Object.defineProperty(HelixBanEvent.prototype, "eventId", {
        /**
         * The unique ID of the ban event.
         */
        get: function () {
            return this._eventData.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "eventType", {
        /**
         * The type of the ban event.
         */
        get: function () {
            return this._eventData.event_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "eventDate", {
        /**
         * The date of the ban event.
         */
        get: function () {
            return new Date(this._eventData.event_timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "eventVersion", {
        /**
         * The version of the ban event.
         */
        get: function () {
            return this._eventData.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "broadcasterId", {
        /**
         * The id of the broadcaster from whose chat the user was banned/unbanned.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the broadcaster.
     */
    HelixBanEvent.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._eventData.event_data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixBanEvent.prototype, "broadcasterName", {
        /**
         * The name of the broadcaster from whose chat the user was banned/unbanned.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    return HelixBanEvent;
}(HelixBan_1.default));
exports.default = HelixBanEvent;
module.exports = exports = HelixBanEvent;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixBanEventType = HelixBanEventType;
exports.default = HelixBanEvent;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixModerator_1 = __webpack_require__(30);
/**
 * The different types a moderator event can have.
 */
var HelixModeratorEventType;
(function (HelixModeratorEventType) {
    /**
     * Sent when a user gains moderation privileges.
     */
    HelixModeratorEventType["Add"] = "moderation.moderator.add";
    /**
     * Sent when a user loses moderation privileges.
     */
    HelixModeratorEventType["Remove"] = "moderation.moderator.remove";
})(HelixModeratorEventType || (HelixModeratorEventType = {}));
exports.HelixModeratorEventType = HelixModeratorEventType;
/**
 * An event that indicates the change of a moderator status, i.e. gaining or losing moderation privileges.
 */
var HelixModeratorEvent = /** @class */ (function (_super) {
    tslib_1.__extends(HelixModeratorEvent, _super);
    /** @private */
    function HelixModeratorEvent(_eventData, client) {
        var _this = _super.call(this, _eventData.event_data, client) || this;
        _this._eventData = _eventData;
        return _this;
    }
    Object.defineProperty(HelixModeratorEvent.prototype, "eventId", {
        /**
         * The unique ID of the moderator event.
         */
        get: function () {
            return this._eventData.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "eventType", {
        /**
         * The type of the moderator event.
         */
        get: function () {
            return this._eventData.event_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "eventDate", {
        /**
         * The date of the moderator event.
         */
        get: function () {
            return new Date(this._eventData.event_timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "eventVersion", {
        /**
         * The version of the moderator event.
         */
        get: function () {
            return this._eventData.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "broadcasterId", {
        /**
         * The id of the broadcaster where the user gained/lost moderation privileges.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the broadcaster.
     */
    HelixModeratorEvent.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._eventData.event_data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixModeratorEvent.prototype, "broadcasterName", {
        /**
         * The name of the broadcaster where the user gained/lost moderation privileges.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    return HelixModeratorEvent;
}(HelixModerator_1.default));
exports.default = HelixModeratorEvent;
module.exports = exports = HelixModeratorEvent;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixModeratorEventType = HelixModeratorEventType;
exports.default = HelixModeratorEvent;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever you try something that requires your own stream to be live.
 */
var StreamNotLiveError = /** @class */ (function (_super) {
    tslib_1.__extends(StreamNotLiveError, _super);
    /** @private */
    function StreamNotLiveError() {
        return _super.call(this, 'Your stream needs to be live to do this') || this;
    }
    return StreamNotLiveError;
}(CustomError_1.default));
exports.default = StreamNotLiveError;
module.exports = exports = StreamNotLiveError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StreamNotLiveError;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * The type of a stream.
 */
var HelixStreamType;
(function (HelixStreamType) {
    /**
     * Returned by Twitch in case of an error.
     */
    HelixStreamType["None"] = "";
    /**
     * A live stream.
     */
    HelixStreamType["Live"] = "live";
    /**
     * A vodcast.
     *
     * Currently not supported by Twitch - but one can only hope and leave it in here.
     */
    HelixStreamType["Vodcast"] = "vodcast";
})(HelixStreamType || (HelixStreamType = {}));
exports.HelixStreamType = HelixStreamType;
/**
 * A Twitch stream.
 */
var HelixStream = /** @class */ (function () {
    /** @private */
    function HelixStream(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixStream.prototype, "id", {
        /**
         * The stream ID.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "userId", {
        /**
         * The user ID.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "userDisplayName", {
        /**
         * The user's display name.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the user broadcasting the stream.
     */
    HelixStream.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixStream.prototype, "gameId", {
        /**
         * The game ID.
         */
        get: function () {
            return this._data.game_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the game that is being played on this stream.
     */
    HelixStream.prototype.getGame = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.games.getGameById(this._data.game_id)];
            });
        });
    };
    Object.defineProperty(HelixStream.prototype, "type", {
        /**
         * The type of the stream.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "title", {
        /**
         * The title of the stream.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "viewers", {
        /**
         * The number of viewers the stream currently has.
         */
        get: function () {
            return this._data.viewer_count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "startDate", {
        /**
         * The time when the stream started.
         */
        get: function () {
            return new Date(this._data.started_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "language", {
        /**
         * The language of the stream.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "thumbnailUrl", {
        /**
         * The URL of the thumbnail of the stream.
         */
        get: function () {
            return this._data.thumbnail_url;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixStream.prototype, "_client", void 0);
    return HelixStream;
}());
exports.default = HelixStream;
module.exports = exports = HelixStream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixStreamType = HelixStreamType;
exports.default = HelixStream;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var HelixStreamMarker = /** @class */ (function () {
    /** @private */
    function HelixStreamMarker(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixStreamMarker.prototype, "id", {
        /**
         * The ID of the marker.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarker.prototype, "creationDate", {
        /**
         * The date and time when the marker was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarker.prototype, "description", {
        /**
         * The description of the marker.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarker.prototype, "positionInSeconds", {
        /**
         * The position in the stream when the marker was created, in seconds.
         */
        get: function () {
            return this._data.position_seconds;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixStreamMarker.prototype, "_client", void 0);
    return HelixStreamMarker;
}());
exports.default = HelixStreamMarker;
module.exports = exports = HelixStreamMarker;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixStreamMarker;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixSubscription_1 = __webpack_require__(31);
/**
 * The different types a subscription event can have.
 */
var HelixSubscriptionEventType;
(function (HelixSubscriptionEventType) {
    /**
     * Sent when a new user subscribes.
     */
    HelixSubscriptionEventType["Subscribe"] = "subscriptions.subscribe";
    /**
     * Sent when a previous subscriber stops subscribing.
     */
    HelixSubscriptionEventType["Unsubscribe"] = "subscriptions.unsubscribe";
    /**
     * Sent when a new or recurring subscriber sends their monthly notification.
     */
    HelixSubscriptionEventType["Notification"] = "subscriptions.notification";
})(HelixSubscriptionEventType || (HelixSubscriptionEventType = {}));
exports.HelixSubscriptionEventType = HelixSubscriptionEventType;
/**
 * An event that indicates the change of a subscription status, i.e. subscribing, unsubscribing or sending the monthly notification.
 */
var HelixSubscriptionEvent = /** @class */ (function (_super) {
    tslib_1.__extends(HelixSubscriptionEvent, _super);
    /** @private */
    function HelixSubscriptionEvent(_eventData, client) {
        var _this = _super.call(this, _eventData.event_data, client) || this;
        _this._eventData = _eventData;
        return _this;
    }
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventId", {
        /**
         * The unique ID of the subscription event.
         */
        get: function () {
            return this._eventData.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventType", {
        /**
         * The type of the subscription event.
         */
        get: function () {
            return this._eventData.event_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventDate", {
        /**
         * The date of the subscription event.
         */
        get: function () {
            return new Date(this._eventData.event_timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventVersion", {
        /**
         * The version of the subscription event.
         */
        get: function () {
            return this._eventData.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventMessage", {
        /**
         * The message sent with the subscription event.
         */
        get: function () {
            return this._eventData.event_data.message || '';
        },
        enumerable: true,
        configurable: true
    });
    return HelixSubscriptionEvent;
}(HelixSubscription_1.default));
exports.default = HelixSubscriptionEvent;
module.exports = exports = HelixSubscriptionEvent;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixSubscriptionEventType = HelixSubscriptionEventType;
exports.default = HelixSubscriptionEvent;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixPaginatedRequest_1 = __webpack_require__(9);
/**
 * A special case of {@HelixPaginatedRequest} with support for fetching the total number of entities, whenever an endpoint supports it.
 */
var HelixPaginatedRequestWithTotal = /** @class */ (function (_super) {
    tslib_1.__extends(HelixPaginatedRequestWithTotal, _super);
    function HelixPaginatedRequestWithTotal() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves and returns the total number of entities existing in the queried result set.
     */
    HelixPaginatedRequestWithTotal.prototype.getTotalCount = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this._currentData;
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._fetchData({ query: { after: undefined } })];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        data = _a;
                        return [2 /*return*/, data.total];
                }
            });
        });
    };
    return HelixPaginatedRequestWithTotal;
}(HelixPaginatedRequest_1.default));
exports.default = HelixPaginatedRequestWithTotal;
module.exports = exports = HelixPaginatedRequestWithTotal;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixPaginatedRequestWithTotal;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A relation of a user following a broadcaster.
 */
var HelixFollow = /** @class */ (function () {
    /** @private */
    function HelixFollow(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixFollow.prototype, "userId", {
        /**
         * The user ID of the following user.
         */
        get: function () {
            return this._data.from_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixFollow.prototype, "userDisplayName", {
        /**
         * The display name of the following user.
         */
        get: function () {
            return this._data.from_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the data of the following user.
     */
    HelixFollow.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.from_id)];
            });
        });
    };
    Object.defineProperty(HelixFollow.prototype, "followedUserId", {
        /**
         * The user ID of the followed broadcaster.
         */
        get: function () {
            return this._data.to_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixFollow.prototype, "followedUserDisplayName", {
        /**
         * The display name of the followed user.
         */
        get: function () {
            return this._data.to_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the data of the followed broadcaster.
     */
    HelixFollow.prototype.getFollowedUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.to_id)];
            });
        });
    };
    Object.defineProperty(HelixFollow.prototype, "followDate", {
        /**
         * The date when the user followed the broadcaster.
         */
        get: function () {
            return new Date(this._data.followed_at);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixFollow.prototype, "_client", void 0);
    return HelixFollow;
}());
exports.default = HelixFollow;
module.exports = exports = HelixFollow;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixFollow;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixUser_1 = __webpack_require__(32);
/**
 * A user you have extended privilges for, i.e. yourself.
 *
 * @inheritDoc
 */
var HelixPrivilegedUser = /** @class */ (function (_super) {
    tslib_1.__extends(HelixPrivilegedUser, _super);
    function HelixPrivilegedUser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(HelixPrivilegedUser.prototype, "email", {
        /**
         * The email address of the user.
         */
        get: function () {
            return this._data.email;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Changes the description of the user.
     *
     * @param description The new description.
     */
    HelixPrivilegedUser.prototype.setDescription = function (description) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.updateUser({ description: description })];
            });
        });
    };
    return HelixPrivilegedUser;
}(HelixUser_1.default));
exports.default = HelixPrivilegedUser;
module.exports = exports = HelixPrivilegedUser;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixPrivilegedUser;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var shared_utils_1 = __webpack_require__(1);
var HellFreezesOverError_1 = __webpack_require__(20);
/**
 * A video on Twitch.
 */
var HelixVideo = /** @class */ (function () {
    /** @private */
    function HelixVideo(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixVideo.prototype, "id", {
        /**
         * The ID of the video.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "userId", {
        /**
         * The ID of the user who created the video.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "userDisplayName", {
        /**
         * The display name of the user who created the video.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the user who created the video.
     */
    HelixVideo.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixVideo.prototype, "title", {
        /**
         * The title of the video.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "description", {
        /**
         * The description of the video.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "creationDate", {
        /**
         * The date when the video was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "publishDate", {
        /**
         * The date when the video was published.
         */
        get: function () {
            return new Date(this._data.published_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "url", {
        /**
         * The URL of the video.
         */
        get: function () {
            return this._data.url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "thumbnailUrl", {
        /**
         * The URL of the thumbnail of the video.
         */
        get: function () {
            return this._data.thumbnail_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "isPublic", {
        /**
         * Whether the video is public or not.
         */
        get: function () {
            return this._data.viewable === 'public';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "views", {
        /**
         * The number of views of the video.
         */
        get: function () {
            return this._data.view_count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "language", {
        /**
         * The language of the video.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "type", {
        /**
         * The type of the video.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "duration", {
        /**
         * The duration of the video, as formatted by Twitch.
         */
        get: function () {
            return this._data.duration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "durationInSeconds", {
        /**
         * The duration of the video, in seconds.
         */
        get: function () {
            var parts = this._data.duration.match(/\d+[hms]/g);
            if (!parts) {
                throw new HellFreezesOverError_1.default("Could not parse duration string: " + this._data.duration);
            }
            return parts
                .map(function (part) {
                var partialMatch = part.match(/(\d+)([hms])/);
                if (!partialMatch) {
                    throw new HellFreezesOverError_1.default("Could not parse partial duration string: " + part);
                }
                var _a = tslib_1.__read(partialMatch, 3), num = _a[1], unit = _a[2];
                return parseInt(num, 10) * { h: 3600, m: 60, s: 1 }[unit];
            })
                .reduce(function (a, b) { return a + b; });
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixVideo.prototype, "_client", void 0);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixVideo.prototype, "durationInSeconds", null);
    HelixVideo = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], HelixVideo);
    return HelixVideo;
}());
exports.default = HelixVideo;
module.exports = exports = HelixVideo;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixVideo;


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LogLevel_1 = __webpack_require__(22);
var isNode = __webpack_require__(14);
var BaseLogger = /** @class */ (function () {
    function BaseLogger(_a) {
        var name = _a.name, _b = _a.minLevel, minLevel = _b === void 0 ? LogLevel_1.LogLevel.WARNING : _b, _c = _a.emoji, emoji = _c === void 0 ? false : _c, _d = _a.colors, colors = _d === void 0 ? true : _d, _e = _a.timestamps, timestamps = _e === void 0 ? isNode : _e;
        this._name = name;
        this._minLevel = LogLevel_1.resolveLogLevel(minLevel);
        this._emoji = emoji;
        this._colors = colors;
        this._timestamps = timestamps;
    }
    // region convenience methods
    BaseLogger.prototype.crit = function (message) {
        this.log(LogLevel_1.LogLevel.CRITICAL, message);
    };
    BaseLogger.prototype.critical = function (message) {
        this.log(LogLevel_1.LogLevel.CRITICAL, message);
    };
    BaseLogger.prototype.err = function (message) {
        this.log(LogLevel_1.LogLevel.ERROR, message);
    };
    BaseLogger.prototype.error = function (message) {
        this.log(LogLevel_1.LogLevel.ERROR, message);
    };
    BaseLogger.prototype.warn = function (message) {
        this.log(LogLevel_1.LogLevel.WARNING, message);
    };
    BaseLogger.prototype.warning = function (message) {
        this.log(LogLevel_1.LogLevel.WARNING, message);
    };
    BaseLogger.prototype.info = function (message) {
        this.log(LogLevel_1.LogLevel.INFO, message);
    };
    BaseLogger.prototype.debug = function (message) {
        this.log(LogLevel_1.LogLevel.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug1 = function (message) {
        this.log(LogLevel_1.LogLevel.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug2 = function (message) {
        this.log(LogLevel_1.LogLevel.DEBUG, message);
    };
    /** @deprecated use debug instead */
    BaseLogger.prototype.debug3 = function (message) {
        this.log(LogLevel_1.LogLevel.DEBUG, message);
    };
    BaseLogger.prototype.trace = function (message) {
        this.log(LogLevel_1.LogLevel.TRACE, message);
    };
    return BaseLogger;
}());
exports.BaseLogger = BaseLogger;
//# sourceMappingURL=BaseLogger.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var requirePromise = __webpack_require__(25);

requirePromise();

var PromiseResolve = __webpack_require__(150);
var Type = __webpack_require__(7);
var iterate = __webpack_require__(152);
var map = __webpack_require__(160);
var callBound = __webpack_require__(8);

var all = callBound('Promise.all');
var reject = callBound('Promise.reject');

module.exports = function allSettled(iterable) {
	var C = this;
	if (Type(C) !== 'Object') {
		throw new TypeError('`this` value must be an object');
	}
	var values = iterate(iterable);
	return all(C, map(values, function (item) {
		var onFulfill = function (value) {
			return { status: 'fulfilled', value: value };
		};
		var onReject = function (reason) {
			return { status: 'rejected', reason: reason };
		};
		var itemPromise = PromiseResolve(C, item);
		try {
			return itemPromise.then(onFulfill, onReject);
		} catch (e) {
			return reject(C, e);
		}
	}));
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject(value) {
	try {
		strValue.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var strClass = '[object String]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isString(value) {
	if (typeof value === 'string') {
		return true;
	}
	if (typeof value !== 'object') {
		return false;
	}
	return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(161);


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArraySpeciesCreate = __webpack_require__(162);
var Call = __webpack_require__(171);
var CreateDataPropertyOrThrow = __webpack_require__(172);
var Get = __webpack_require__(73);
var HasProperty = __webpack_require__(179);
var IsCallable = __webpack_require__(82);
var ToUint32 = __webpack_require__(180);
var ToObject = __webpack_require__(188);
var ToString = __webpack_require__(189);
var callBound = __webpack_require__(8);
var isString = __webpack_require__(70);

// Check failure of by-index access of string characters (IE < 9) and failure of `0 in boxedString` (Rhino)
var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var strSplit = callBound('String.prototype.split');

module.exports = function map(callbackfn) {
	var O = ToObject(this);
	var self = splitString && isString(O) ? strSplit(O, '') : O;
	var len = ToUint32(self.length);

	// If no callback function or if callback is not a callable function
	if (!IsCallable(callbackfn)) {
		throw new TypeError('Array.prototype.map callback must be a function');
	}

	var T;
	if (arguments.length > 1) {
		T = arguments[1];
	}

	var A = ArraySpeciesCreate(O, len);
	var k = 0;
	while (k < len) {
		var Pk = ToString(k);
		var kPresent = HasProperty(O, Pk);
		if (kPresent) {
			var kValue = Get(O, Pk);
			var mappedValue = Call(callbackfn, T, [kValue, k, O]);
			CreateDataPropertyOrThrow(A, Pk, mappedValue);
		}
		k += 1;
	}

	return A;
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var inspect = __webpack_require__(163);

var IsPropertyKey = __webpack_require__(16);
var Type = __webpack_require__(7);

/**
 * 7.3.1 Get (O, P) - https://ecma-international.org/ecma-262/6.0/#sec-get-o-p
 * 1. Assert: Type(O) is Object.
 * 2. Assert: IsPropertyKey(P) is true.
 * 3. Return O.[[Get]](P, O).
 */

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $Array = GetIntrinsic('%Array%');

// eslint-disable-next-line global-require
var toStr = !$Array.isArray && __webpack_require__(8)('Object.prototype.toString');

// https://www.ecma-international.org/ecma-262/6.0/#sec-isarray

module.exports = $Array.isArray || function IsArray(argument) {
	return toStr(argument) === '[object Array]';
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

var callBound = __webpack_require__(8);

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

// eslint-disable-next-line max-params
module.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
	if (!$defineProperty) {
		if (!IsDataDescriptor(desc)) {
			// ES3 does not support getters/setters
			return false;
		}
		if (!desc['[[Configurable]]'] || !desc['[[Writable]]']) {
			return false;
		}

		// fallback for ES3
		if (P in O && $isEnumerable(O, P) !== !!desc['[[Enumerable]]']) {
			// a non-enumerable existing property
			return false;
		}

		// property does not exist at all, or exists but is enumerable
		var V = desc['[[Value]]'];
		// eslint-disable-next-line no-param-reassign
		O[P] = V; // will use [[Define]]
		return SameValue(O[P], V);
	}
	$defineProperty(O, P, FromPropertyDescriptor(desc));
	return true;
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assertRecord = __webpack_require__(36);

var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return Desc;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	var obj = {};
	if ('[[Value]]' in Desc) {
		obj.value = Desc['[[Value]]'];
	}
	if ('[[Writable]]' in Desc) {
		obj.writable = Desc['[[Writable]]'];
	}
	if ('[[Get]]' in Desc) {
		obj.get = Desc['[[Get]]'];
	}
	if ('[[Set]]' in Desc) {
		obj.set = Desc['[[Set]]'];
	}
	if ('[[Enumerable]]' in Desc) {
		obj.enumerable = Desc['[[Enumerable]]'];
	}
	if ('[[Configurable]]' in Desc) {
		obj.configurable = Desc['[[Configurable]]'];
	}
	return obj;
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(17);

var assertRecord = __webpack_require__(36);

var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-isdatadescriptor

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	if (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $isNaN = __webpack_require__(79);

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(17);

var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var Type = __webpack_require__(7);
var ToBoolean = __webpack_require__(81);
var IsCallable = __webpack_require__(82);

// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (Type(Obj) !== 'Object') {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (has(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (has(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (has(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (has(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (has(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (has(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://www.ecma-international.org/ecma-262/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://www.ecma-international.org/ecma-262/5.1/#sec-9.11

module.exports = __webpack_require__(83);


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
	} catch (_) {
		reflectApply = null;
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = reflectApply
	? function isCallable(value) {
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value);
	}
	: function isCallable(value) {
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayMethodBoxesProperly = __webpack_require__(190);

var implementation = __webpack_require__(72);

module.exports = function getPolyfill() {
	var method = Array.prototype.map;
	return arrayMethodBoxesProperly(method) ? method : implementation;
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var requirePromise = __webpack_require__(25);

var implementation = __webpack_require__(69);

module.exports = function getPolyfill() {
	requirePromise();
	return typeof Promise.allSettled === 'function' ? Promise.allSettled : implementation;
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(33);
var CustomError_1 = __webpack_require__(193);
var RetryAfterError = /** @class */ (function (_super) {
    tslib_1.__extends(RetryAfterError, _super);
    function RetryAfterError(after) {
        var _this = _super.call(this, "Need to retry after " + after + " ms") || this;
        _this._retryAt = Date.now() + after;
        return _this;
    }
    Object.defineProperty(RetryAfterError.prototype, "retryAt", {
        get: function () {
            return this._retryAt;
        },
        enumerable: true,
        configurable: true
    });
    return RetryAfterError;
}(CustomError_1.CustomError));
exports.RetryAfterError = RetryAfterError;
//# sourceMappingURL=RetryAfterError.js.map

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var User_1 = __webpack_require__(10);
/**
 * A relation of a user following a previously given channel.
 */
var ChannelFollow = /** @class */ (function () {
    /** @private */
    function ChannelFollow(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChannelFollow.prototype, "user", {
        /**
         * The user following the given channel.
         */
        get: function () {
            return new User_1.default(this._data.user, this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelFollow.prototype, "hasNotifications", {
        /**
         * Whether the user has notifications enabled for the channel.
         */
        get: function () {
            return this._data.notifications;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelFollow.prototype, "followDate", {
        /**
         * The date when the user followed.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChannelFollow.prototype, "_client", void 0);
    return ChannelFollow;
}());
exports.default = ChannelFollow;
module.exports = exports = ChannelFollow;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChannelFollow;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Subscription_1 = __webpack_require__(39);
var User_1 = __webpack_require__(10);
/**
 * A relation of a user subscribing to a previously given channel.
 */
var ChannelSubscription = /** @class */ (function (_super) {
    tslib_1.__extends(ChannelSubscription, _super);
    function ChannelSubscription() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ChannelSubscription.prototype, "user", {
        /**
         * The user subscribing to the given channel.
         */
        get: function () {
            return new User_1.default(this._data.user, this._client);
        },
        enumerable: true,
        configurable: true
    });
    return ChannelSubscription;
}(Subscription_1.default));
exports.default = ChannelSubscription;
module.exports = exports = ChannelSubscription;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChannelSubscription;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Channel_1 = __webpack_require__(13);
/**
 * A channel you have extended privileges for, i.e. the channel of the currently authenticated user.
 */
var PrivilegedChannel = /** @class */ (function (_super) {
    tslib_1.__extends(PrivilegedChannel, _super);
    function PrivilegedChannel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PrivilegedChannel.prototype, "streamKey", {
        /**
         * The channel's stream key.
         */
        get: function () {
            return this._data.stream_key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedChannel.prototype, "email", {
        /**
         * The channel's email address.
         */
        get: function () {
            return this._data.email;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the list of editors of the channel.
     */
    PrivilegedChannel.prototype.getEditors = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelEditors(this)];
            });
        });
    };
    /**
     * Starts a commercial in the channel.
     *
     * @param length The length of the commercial.
     */
    PrivilegedChannel.prototype.startCommercial = function (length) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.startChannelCommercial(this, length)];
            });
        });
    };
    /**
     * Resets the given channel's stream key.
     */
    PrivilegedChannel.prototype.resetStreamKey = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelData, streamKey;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.channels.resetChannelStreamKey(this)];
                    case 1:
                        channelData = _a.sent();
                        streamKey = channelData.stream_key;
                        this._data.stream_key = streamKey;
                        return [2 /*return*/, streamKey];
                }
            });
        });
    };
    return PrivilegedChannel;
}(Channel_1.default));
exports.default = PrivilegedChannel;
module.exports = exports = PrivilegedChannel;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PrivilegedChannel;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
/**
 * A list of emotes, grouped into emote sets, that a user can use.
 */
var EmoteSetList = /** @class */ (function () {
    /** @private */
    function EmoteSetList(_data) {
        this._data = _data;
    }
    /**
     * Finds the emote ID for the given emote code.
     *
     * @param emoteCode The emote code to check for.
     */
    EmoteSetList.prototype.findEmoteId = function (emoteCode) {
        var e_1, _a, e_2, _b;
        try {
            for (var _c = tslib_1.__values(Object.values(this._data)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var emoteSet = _d.value;
                try {
                    for (var emoteSet_1 = (e_2 = void 0, tslib_1.__values(emoteSet)), emoteSet_1_1 = emoteSet_1.next(); !emoteSet_1_1.done; emoteSet_1_1 = emoteSet_1.next()) {
                        var emote = emoteSet_1_1.value;
                        if (new RegExp(emote.code).test(emoteCode)) {
                            return emote.id;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (emoteSet_1_1 && !emoteSet_1_1.done && (_b = emoteSet_1.return)) _b.call(emoteSet_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return undefined;
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(Infinity, true)
    ], EmoteSetList.prototype, "findEmoteId", null);
    EmoteSetList = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], EmoteSetList);
    return EmoteSetList;
}());
exports.default = EmoteSetList;
module.exports = exports = EmoteSetList;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EmoteSetList;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var User_1 = __webpack_require__(10);
/**
 * A user you have extended privileges for, i.e. the currently authenticated user.
 *
 * @inheritDoc
 */
var PrivilegedUser = /** @class */ (function (_super) {
    tslib_1.__extends(PrivilegedUser, _super);
    function PrivilegedUser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PrivilegedUser.prototype, "email", {
        /**
         * The user's email address.
         */
        get: function () {
            return this._data.email;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "isEmailVerified", {
        /**
         * Whether the user's email address is verified.
         */
        get: function () {
            return this._data.email_verified;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "hasEmailNotifications", {
        /**
         * Whether the user has email notifications enabled.
         */
        get: function () {
            return this._data.notifications.email;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "hasPushNotifications", {
        /**
         * Whether the user has push notifications enabled.
         */
        get: function () {
            return this._data.notifications.push;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "isPartnered", {
        /**
         * Whether the user is partnered.
         */
        get: function () {
            return this._data.partnered;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "hasTwitter", {
        /**
         * Whether the user has a Twitter account connected.
         */
        get: function () {
            return this._data.twitter_connected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Follows a channel.
     *
     * @param channel The channel to follow.
     * @param notifications Whether the user will receive notifications.
     */
    PrivilegedUser.prototype.followChannel = function (channel, notifications) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.followChannel(this, channel, notifications)];
            });
        });
    };
    /**
     * Unfollows a channel.
     *
     * @param channel The channel to unfollow.
     */
    PrivilegedUser.prototype.unfollowChannel = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.unfollowChannel(this, channel)];
            });
        });
    };
    /**
     * Blocks a user.
     *
     * @param userToBlock The user to block.
     */
    PrivilegedUser.prototype.blockUser = function (userToBlock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.blockUser(this, userToBlock)];
            });
        });
    };
    /**
     * Unblocks a user.
     *
     * @param userToUnblock The user to unblock.
     */
    PrivilegedUser.prototype.unblockUser = function (userToUnblock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.unblockUser(this, userToUnblock)];
            });
        });
    };
    return PrivilegedUser;
}(User_1.default));
exports.default = PrivilegedUser;
module.exports = exports = PrivilegedUser;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PrivilegedUser;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var User_1 = __webpack_require__(10);
/**
 * A relation of a previously givn user blocking another user.
 */
var UserBlock = /** @class */ (function () {
    /** @private */
    function UserBlock(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(UserBlock.prototype, "blockedUser", {
        /**
         * The blocked user.
         */
        get: function () {
            return new User_1.default(this._data.user, this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], UserBlock.prototype, "_client", void 0);
    return UserBlock;
}());
exports.default = UserBlock;
module.exports = exports = UserBlock;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UserBlock;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var Channel_1 = __webpack_require__(13);
/**
 * A relation of a previously given user following a channel.
 */
var UserFollow = /** @class */ (function () {
    /** @private */
    function UserFollow(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(UserFollow.prototype, "followDate", {
        /**
         * The date when the user followed the channel.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserFollow.prototype, "hasNotifications", {
        /**
         * Whether the user has notifications enabled for the channel.
         */
        get: function () {
            return this._data.notifications;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserFollow.prototype, "channel", {
        /**
         * The followed channel.
         */
        get: function () {
            return new Channel_1.default(this._data.channel, this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], UserFollow.prototype, "_client", void 0);
    return UserFollow;
}());
exports.default = UserFollow;
module.exports = exports = UserFollow;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UserFollow;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Subscription_1 = __webpack_require__(39);
var Channel_1 = __webpack_require__(13);
/**
 * A relation of a previously given user subscribing to a channel.
 */
var UserSubscription = /** @class */ (function (_super) {
    tslib_1.__extends(UserSubscription, _super);
    function UserSubscription() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(UserSubscription.prototype, "channel", {
        /**
         * The subscribed channel.
         */
        get: function () {
            return new Channel_1.default(this._data.channel, this._client);
        },
        enumerable: true,
        configurable: true
    });
    return UserSubscription;
}(Subscription_1.default));
exports.default = UserSubscription;
module.exports = exports = UserSubscription;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UserSubscription;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Information about an access token.
 */
var TokenInfo = /** @class */ (function () {
    /** @private */
    function TokenInfo(_data) {
        this._data = _data;
        this._obtainmentDate = new Date();
    }
    Object.defineProperty(TokenInfo.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._data.client_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "userId", {
        /**
         * The ID of the authenticated user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "userName", {
        /**
         * The user name of the authenticated user.
         */
        get: function () {
            return this._data.login;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "scopes", {
        /**
         * The scopes for which this token is valid.
         */
        get: function () {
            return this._data.scopes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "expiryDate", {
        /**
         * The time when the token will expire.
         *
         * If this returns null, it means that the token is either invalid or never expires (happens with old client IDs).
         */
        get: function () {
            if (!this._data.expires_in) {
                return null;
            }
            return new Date(this._obtainmentDate.getTime() + this._data.expires_in * 1000);
        },
        enumerable: true,
        configurable: true
    });
    return TokenInfo;
}());
exports.default = TokenInfo;
module.exports = exports = TokenInfo;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TokenInfo;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A list of chatters in a Twitch chat.
 */
var ChattersList = /** @class */ (function () {
    /** @private */
    function ChattersList(_data) {
        this._data = _data;
    }
    Object.defineProperty(ChattersList.prototype, "allChatters", {
        /**
         * A list of user names of all chatters in the chat.
         */
        get: function () {
            return shared_utils_1.flatten(Object.values(this._data.chatters));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChattersList.prototype, "allChattersWithStatus", {
        /**
         * A map of user names of all chatters in the chat, mapped to their status in the channel.
         */
        get: function () {
            return new Map(shared_utils_1.flatten(Object.entries(this._data.chatters).map(function (_a) {
                var _b = tslib_1.__read(_a, 2), status = _b[0], names = _b[1];
                return names.map(function (name) { return [name, status]; });
            })));
        },
        enumerable: true,
        configurable: true
    });
    return ChattersList;
}());
exports.default = ChattersList;
module.exports = exports = ChattersList;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChattersList;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var TwitchClient_1 = __webpack_require__(4);
/**
 * Enhances another auth provider with the ability to make use of refresh
 * tokens, automatically refreshing the access token whenever necessary.
 */
var RefreshableAuthProvider = /** @class */ (function () {
    /**
     * Creates a new auth provider based on the given one that can automatically
     * refresh access tokens.
     *
     * You don't usually have to create this manually. You should use `TwitchClient.withCredentials`
     * with the `refreshConfig` parameter instead.
     *
     * @param childProvider The base auth provider.
     * @param refreshConfig The information necessary to automatically refresh an access token.
     */
    function RefreshableAuthProvider(childProvider, refreshConfig) {
        this._clientSecret = refreshConfig.clientSecret;
        this._refreshToken = refreshConfig.refreshToken;
        this._childProvider = childProvider;
        this._initialExpiry = refreshConfig.expiry;
        this._onRefresh = refreshConfig.onRefresh;
    }
    Object.defineProperty(RefreshableAuthProvider.prototype, "tokenType", {
        /**
         * The type of tokens this provider generates.
         *
         * It is the same as the underlying base auth provider's token type.
         */
        get: function () {
            return this._childProvider.tokenType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves an access token.
     *
     * If the current access token does not have the requested scopes, the base auth
     * provider is called.
     *
     * If the current access token is expired, automatically renew it.
     *
     * @param scopes The requested scopes.
     */
    RefreshableAuthProvider.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var oldToken, newToken, now, refreshedToken;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof scopes === 'string') {
                            scopes = scopes.split(' ');
                        }
                        return [4 /*yield*/, this._childProvider.getAccessToken()];
                    case 1:
                        oldToken = _a.sent();
                        if (!(oldToken && scopes && scopes.some(function (scope) { return !_this.currentScopes.includes(scope); }))) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._childProvider.getAccessToken(scopes)];
                    case 2:
                        newToken = _a.sent();
                        // ...but if the token doesn't change, carry on
                        if (newToken !== oldToken) {
                            return [2 /*return*/, newToken];
                        }
                        _a.label = 3;
                    case 3:
                        // if we don't have a current token, we just pass this and refresh right away
                        if (oldToken) {
                            if (this._initialExpiry) {
                                now = new Date();
                                if (now < this._initialExpiry) {
                                    return [2 /*return*/, oldToken];
                                }
                            }
                            else if (!oldToken.isExpired) {
                                return [2 /*return*/, oldToken];
                            }
                        }
                        return [4 /*yield*/, this.refresh()];
                    case 4:
                        refreshedToken = _a.sent();
                        if (oldToken) {
                            return [2 /*return*/, refreshedToken];
                        }
                        // need to check again for scopes after refreshing, in case a refresh token was passed without an access token
                        return [2 /*return*/, this._childProvider.getAccessToken(scopes)];
                }
            });
        });
    };
    /**
     * Force a refresh of the access token.
     */
    RefreshableAuthProvider.prototype.refresh = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tokenData;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, TwitchClient_1.default.refreshAccessToken(this.clientId, this._clientSecret, this._refreshToken)];
                    case 1:
                        tokenData = _a.sent();
                        this.setAccessToken(tokenData);
                        this._refreshToken = tokenData.refreshToken;
                        this._initialExpiry = undefined;
                        if (this._onRefresh) {
                            this._onRefresh(tokenData);
                        }
                        return [2 /*return*/, tokenData];
                }
            });
        });
    };
    /** @private */
    RefreshableAuthProvider.prototype.setAccessToken = function (token) {
        this._childProvider.setAccessToken(token);
    };
    Object.defineProperty(RefreshableAuthProvider.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._childProvider.clientId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RefreshableAuthProvider.prototype, "currentScopes", {
        /**
         * The scopes that are currently available using the access token.
         */
        get: function () {
            return this._childProvider.currentScopes;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], RefreshableAuthProvider.prototype, "_clientSecret", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], RefreshableAuthProvider.prototype, "_refreshToken", void 0);
    return RefreshableAuthProvider;
}());
exports.default = RefreshableAuthProvider;
module.exports = exports = RefreshableAuthProvider;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RefreshableAuthProvider;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var AccessToken_1 = __webpack_require__(27);
var TwitchClient_1 = __webpack_require__(4);
/**
 * An auth provider that always returns the same initially given credentials.
 *
 * You are advised to roll your own auth provider that can handle scope upgrades,
 * or to plan ahead and supply only access tokens that account for all scopes
 * you will ever need.
 */
var StaticAuthProvider = /** @class */ (function () {
    /**
     * Creates a new auth provider with static credentials.
     *
     * You don't usually have to create this manually. You should use `TwitchClient.withCredentials` instead.
     *
     * @param clientId The client ID.
     * @param accessToken The access token to provide.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     * @param scopes The scopes this token has.
     * @param tokenType The type of the supplied token.
     */
    function StaticAuthProvider(clientId, accessToken, scopes, tokenType) {
        if (tokenType === void 0) { tokenType = 'user'; }
        this._clientId = clientId || '';
        this.tokenType = tokenType;
        if (accessToken) {
            this._accessToken =
                typeof accessToken === 'string'
                    ? new AccessToken_1.default({
                        access_token: accessToken,
                        scope: scopes,
                        refresh_token: ''
                    })
                    : accessToken;
            this._scopes = scopes;
        }
    }
    /**
     * Retrieves an access token.
     *
     * If the current access token does not have the requested scopes, this method throws.
     * This makes supplying an access token with the correct scopes from the beginning necessary.
     *
     * @param scopes The requested scopes.
     */
    StaticAuthProvider.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tokenInfo;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(scopes && scopes.length > 0)) return [3 /*break*/, 3];
                        if (!!this._scopes) return [3 /*break*/, 2];
                        if (!this._accessToken) {
                            throw new Error('Auth provider has not been initialized with a token yet and is requesting scopes');
                        }
                        return [4 /*yield*/, TwitchClient_1.default.getTokenInfo(this._accessToken.accessToken, this._clientId)];
                    case 1:
                        tokenInfo = _a.sent();
                        this._scopes = tokenInfo.scopes;
                        _a.label = 2;
                    case 2:
                        if (typeof scopes === 'string') {
                            scopes = scopes.split(' ');
                        }
                        if (scopes.some(function (scope) { return !_this._scopes.includes(scope); })) {
                            throw new Error("This token does not have the requested scopes (" + scopes.join(', ') + ") and can not be upgraded");
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/, this._accessToken || null];
                }
            });
        });
    };
    /** @private */
    StaticAuthProvider.prototype.setAccessToken = function (token) {
        this._accessToken = token;
    };
    Object.defineProperty(StaticAuthProvider.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._clientId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StaticAuthProvider.prototype, "currentScopes", {
        /**
         * The scopes that are currently available using the access token.
         */
        get: function () {
            return this._scopes || [];
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], StaticAuthProvider.prototype, "_clientId", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], StaticAuthProvider.prototype, "_accessToken", void 0);
    return StaticAuthProvider;
}());
exports.default = StaticAuthProvider;
module.exports = exports = StaticAuthProvider;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StaticAuthProvider;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever you try using invalid values in the client configuration.
 */
var ConfigError = /** @class */ (function (_super) {
    tslib_1.__extends(ConfigError, _super);
    function ConfigError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ConfigError;
}(CustomError_1.default));
exports.default = ConfigError;
module.exports = exports = ConfigError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ConfigError;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever an invalid token is supplied.
 */
var InvalidTokenError = /** @class */ (function (_super) {
    tslib_1.__extends(InvalidTokenError, _super);
    /** @private */
    function InvalidTokenError() {
        return _super.call(this, 'Invalid token supplied') || this;
    }
    return InvalidTokenError;
}(CustomError_1.default));
exports.default = InvalidTokenError;
module.exports = exports = InvalidTokenError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = InvalidTokenError;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(210);


/***/ }),
/* 103 */
/***/ (function(module, exports) {

var __self__ = (function (root) {
function F() {
this.fetch = false;
this.DOMException = root.DOMException
}
F.prototype = root;
return new F();
})(typeof self !== 'undefined' ? self : this);
(function(self) {

var irrelevant = (function (exports) {
  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  return exports;

}({}));
})(__self__);
delete __self__.fetch.polyfill
exports = __self__.fetch // To enable: import fetch from 'cross-fetch'
exports.default = __self__.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = __self__.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = __self__.Headers
exports.Request = __self__.Request
exports.Response = __self__.Response
module.exports = exports


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable filenames/match-exported */
var isNode = __webpack_require__(14);
var NodeLogger_1 = __webpack_require__(105);
var BrowserLogger_1 = __webpack_require__(106);
var Logger = isNode ? NodeLogger_1.default : BrowserLogger_1.default;
exports.default = Logger;
var LogLevel_1 = __webpack_require__(21);
var __export_LogLevel = LogLevel_1.default;
exports.LogLevel = __export_LogLevel;
module.exports = exports = Logger;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Logger;
exports.LogLevel = __export_LogLevel;
//# sourceMappingURL=index.js.map

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(43);
var LogLevel_1 = __webpack_require__(21);
var BaseLogger_1 = __webpack_require__(44);
var __export_LogLevelToEmoji = (_a = {},
    _a[LogLevel_1.default.CRITICAL] = "\uD83D\uDED1",
    _a[LogLevel_1.default.ERROR] = "\u274C",
    // these following two need extra spaces at the end because somehow they consume less space in a terminal than they should...
    _a[LogLevel_1.default.WARNING] = "\u26A0\uFE0F ",
    _a[LogLevel_1.default.INFO] = "\u2139\uFE0F ",
    _a[LogLevel_1.default.DEBUG] = "\uD83D\uDC1E",
    _a[LogLevel_1.default.TRACE] = "\uD83D\uDC3E",
    _a);
exports.LogLevelToEmoji = __export_LogLevelToEmoji;
var colors = {
    black: 30,
    red: 31,
    green: 32,
    yellow: 33,
    blue: 34,
    magenta: 35,
    cyan: 36,
    white: 37,
    blackBright: 90,
    redBright: 91,
    greenBright: 92,
    yellowBright: 93,
    blueBright: 94,
    magentaBright: 95,
    cyanBright: 96,
    whiteBright: 97
};
var bgColors = {
    bgBlack: 40,
    bgRed: 41,
    bgGreen: 42,
    bgYellow: 43,
    bgBlue: 44,
    bgMagenta: 45,
    bgCyan: 46,
    bgWhite: 47,
    bgBlackBright: 100,
    bgRedBright: 101,
    bgGreenBright: 102,
    bgYellowBright: 103,
    bgBlueBright: 104,
    bgMagentaBright: 105,
    bgCyanBright: 106,
    bgWhiteBright: 107
};
function createGenericWrapper(color, ending, inner) {
    return function (str) { return "\u001B[" + color + "m" + (inner ? inner(str) : str) + "\u001B[" + ending + "m"; };
}
function createColorWrapper(color) {
    return createGenericWrapper(colors[color], 39);
}
function createBgWrapper(color, fgWrapper) {
    return createGenericWrapper(bgColors[color], 49, fgWrapper);
}
var __export_LogLevelToColor = (_b = {},
    _b[LogLevel_1.default.CRITICAL] = createColorWrapper('red'),
    _b[LogLevel_1.default.ERROR] = createColorWrapper('redBright'),
    _b[LogLevel_1.default.WARNING] = createColorWrapper('yellow'),
    _b[LogLevel_1.default.INFO] = createColorWrapper('blue'),
    _b[LogLevel_1.default.DEBUG] = createColorWrapper('magenta'),
    _b[LogLevel_1.default.TRACE] = createGenericWrapper(0, 0),
    _b);
exports.LogLevelToColor = __export_LogLevelToColor;
var __export_LogLevelToBackgroundColor = (_c = {},
    _c[LogLevel_1.default.CRITICAL] = createBgWrapper('bgRed', createColorWrapper('white')),
    _c[LogLevel_1.default.ERROR] = createBgWrapper('bgRedBright', createColorWrapper('white')),
    _c[LogLevel_1.default.WARNING] = createBgWrapper('bgYellow', createColorWrapper('black')),
    _c[LogLevel_1.default.INFO] = createBgWrapper('bgBlue', createColorWrapper('white')),
    _c[LogLevel_1.default.DEBUG] = createBgWrapper('bgMagenta', createColorWrapper('black')),
    _c[LogLevel_1.default.TRACE] = createGenericWrapper(7, 27),
    _c);
exports.LogLevelToBackgroundColor = __export_LogLevelToBackgroundColor;
var NodeLogger = /** @class */ (function (_super) {
    tslib_1.__extends(NodeLogger, _super);
    function NodeLogger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeLogger.prototype.log = function (level, message) {
        if (level > this._minLevel) {
            return;
        }
        var logFn = LogLevel_1.LogLevelToConsoleFunction[level];
        var builtMessage = '';
        if (this._timestamps) {
            builtMessage += "[" + new Date().toISOString() + "] ";
        }
        if (this._emoji) {
            var emoji = exports.LogLevelToEmoji[level];
            builtMessage += emoji + " ";
        }
        if (this._colors) {
            builtMessage += exports.LogLevelToBackgroundColor[level](this._name) + " " + exports.LogLevelToBackgroundColor[level](LogLevel_1.default[level]) + " " + exports.LogLevelToColor[level](message);
        }
        else {
            builtMessage += "[" + this._name + ":" + LogLevel_1.default[level].toLowerCase() + "] " + message;
        }
        logFn(builtMessage);
    };
    return NodeLogger;
}(BaseLogger_1.default));
exports.default = NodeLogger;
module.exports = exports = NodeLogger;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogLevelToEmoji = __export_LogLevelToEmoji;
exports.LogLevelToColor = __export_LogLevelToColor;
exports.LogLevelToBackgroundColor = __export_LogLevelToBackgroundColor;
exports.default = NodeLogger;
//# sourceMappingURL=NodeLogger.js.map

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(43);
var LogLevel_1 = __webpack_require__(21);
var BaseLogger_1 = __webpack_require__(44);
var BrowserLogger = /** @class */ (function (_super) {
    tslib_1.__extends(BrowserLogger, _super);
    function BrowserLogger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BrowserLogger.prototype.log = function (level, message) {
        if (level > this._minLevel) {
            return;
        }
        var logFn = LogLevel_1.LogLevelToConsoleFunction[level];
        var formattedMessage = "[" + this._name + "] " + message;
        if (this._timestamps) {
            formattedMessage = "[" + new Date().toISOString() + "] " + message;
        }
        logFn(formattedMessage);
    };
    return BrowserLogger;
}(BaseLogger_1.default));
exports.default = BrowserLogger;
module.exports = exports = BrowserLogger;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BrowserLogger;
//# sourceMappingURL=BrowserLogger.js.map

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(108);
var parse = __webpack_require__(109);
var formats = __webpack_require__(45);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(26);
var formats = __webpack_require__(45);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = obj.join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key') : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key');
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value'))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(26);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj; // eslint-disable-line no-param-reassign
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var ChatBadgeList_1 = __webpack_require__(47);
/**
 * The API methods that deal with badges.
 *
 * Can be accessed using `client.badges` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const cheermotes = await client.badges.getGlobalBadges();
 * ```
 */
var BadgesAPI = /** @class */ (function (_super) {
    tslib_1.__extends(BadgesAPI, _super);
    function BadgesAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves all globally applicable chat badges.
     */
    BadgesAPI.prototype.getGlobalBadges = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'https://badges.twitch.tv/v1/badges/global/display',
                            type: TwitchClient_1.TwitchAPICallType.Custom
                        })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new ChatBadgeList_1.default(data.badge_sets, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves all applicable chat badges for a given channel.
     *
     * @param channel The channel to retrieve the chat badges for.
     * @param includeGlobal Whether to include global badges in the result list.
     */
    BadgesAPI.prototype.getChannelBadges = function (channel, includeGlobal) {
        if (includeGlobal === void 0) { includeGlobal = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, channelBadges;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: "https://badges.twitch.tv/v1/badges/channels/" + UserTools_1.extractUserId(channel) + "/display",
                            type: TwitchClient_1.TwitchAPICallType.Custom
                        })];
                    case 1:
                        data = _a.sent();
                        channelBadges = new ChatBadgeList_1.default(data.badge_sets, this._client);
                        if (!includeGlobal) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getGlobalBadges()];
                    case 2: return [2 /*return*/, (_a.sent())._merge(channelBadges)];
                    case 3: return [2 /*return*/, channelBadges];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], BadgesAPI.prototype, "getGlobalBadges", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], BadgesAPI.prototype, "getChannelBadges", null);
    BadgesAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], BadgesAPI);
    return BadgesAPI;
}(BaseAPI_1.default));
exports.default = BadgesAPI;
module.exports = exports = BadgesAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BadgesAPI;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
function Enumerable(enumerable) {
    if (enumerable === void 0) { enumerable = true; }
    return function (target, key) {
        // first property defined in prototype, that's why we use getters/setters
        // (otherwise assignment in object will override property in prototype)
        Object.defineProperty(target, key, {
            get: function () {
                return;
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            set: function (val) {
                // here we have a reference to the instance and can set property directly to it
                Object.defineProperty(this, key, {
                    value: val,
                    writable: true,
                    enumerable: enumerable
                });
            },
            enumerable: enumerable
        });
    };
}
exports.Enumerable = Enumerable;
/** @deprecated use Enumerable(false) instead */
function NonEnumerable(target, key) {
    return Enumerable(false)(target, key);
}
exports.NonEnumerable = NonEnumerable;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Enumerable = Enumerable;
exports.NonEnumerable = NonEnumerable;
//# sourceMappingURL=Enumerable.js.map

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function flatten(arr) {
    var _a;
    return (_a = []).concat.apply(_a, tslib_1.__spread(arr));
}
exports.flatten = flatten;
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatten = flatten;
//# sourceMappingURL=flatten.js.map

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function resolveConfigValue(value) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            if (typeof value === 'function') {
                return [2 /*return*/, value()];
            }
            return [2 /*return*/, value];
        });
    });
}
exports.resolveConfigValue = resolveConfigValue;
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveConfigValue = resolveConfigValue;
//# sourceMappingURL=resolveConfigValue.js.map

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
// eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/naming-convention
function deprecateClass(Base, msg) {
    var deprecateNoticeShown = false;
    return /** @class */ (function (_super) {
        tslib_1.__extends(class_1, _super);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = this;
            if (!deprecateNoticeShown) {
                // eslint-disable-next-line no-console
                console.warn("[deprecated] " + msg);
                deprecateNoticeShown = true;
            }
            _this = _super.apply(this, tslib_1.__spread(args)) || this;
            return _this;
        }
        return class_1;
    }(Base));
}
exports.deprecateClass = deprecateClass;
Object.defineProperty(exports, "__esModule", { value: true });
exports.deprecateClass = deprecateClass;
//# sourceMappingURL=deprecateClass.js.map

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var matched = function (x) { return ({
    otherwise: function () { return x; },
    on: function () { return matched(x); }
}); };
var match = function (x) { return ({
    on: function (predicate, fn) { return (predicate(x) ? matched(fn(x)) : match(x)); },
    otherwise: function (fn) { return fn(x); }
}); };
exports.match = match;
var __export_eq = function (x) { return function (y) { return x === y; }; };
exports.eq = __export_eq;
match.eq = exports.eq;
Object.defineProperty(exports, "__esModule", { value: true });
exports.match = match;
exports.eq = __export_eq;
//# sourceMappingURL=match.js.map

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var arrayToObject_1 = __webpack_require__(28);
function entriesToObject(obj) {
    return arrayToObject_1.arrayToObject(obj, function (_a) {
        var _b;
        var _c = tslib_1.__read(_a, 2), key = _c[0], val = _c[1];
        return (_b = {}, _b[key] = val, _b);
    });
}
exports.entriesToObject = entriesToObject;
Object.defineProperty(exports, "__esModule", { value: true });
exports.entriesToObject = entriesToObject;
//# sourceMappingURL=entriesToObject.js.map

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function forEachObjectEntry(obj, fn) {
    Object.entries(obj).forEach(function (_a) {
        var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
        return fn(value, key);
    });
}
exports.forEachObjectEntry = forEachObjectEntry;
Object.defineProperty(exports, "__esModule", { value: true });
exports.forEachObjectEntry = forEachObjectEntry;
//# sourceMappingURL=forEachObjectEntry.js.map

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var arrayToObject_1 = __webpack_require__(28);
function indexBy(arr, keyFn) {
    if (typeof keyFn !== 'function') {
        var key_1 = keyFn;
        keyFn = (function (value) { return value[key_1].toString(); });
    }
    return arrayToObject_1.arrayToObject(arr, function (val) {
        var _a;
        return (_a = {}, _a[keyFn(val)] = val, _a);
    });
}
exports.indexBy = indexBy;
Object.defineProperty(exports, "__esModule", { value: true });
exports.indexBy = indexBy;
//# sourceMappingURL=indexBy.js.map

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function mapObject(obj, fn) {
    var mapped = Object.entries(obj).map(
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    function (_a) {
        var _b;
        var _c = tslib_1.__read(_a, 2), key = _c[0], value = _c[1];
        return (_b = {}, _b[key] = fn(value, key), _b);
    });
    return Object.assign.apply(Object, tslib_1.__spread([{}], mapped));
}
exports.mapObject = mapObject;
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapObject = mapObject;
//# sourceMappingURL=mapObject.js.map

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var pick_1 = __webpack_require__(46);
function omit(obj, keys) {
    return pick_1.pick(obj, Object.keys(obj).filter(function (key) { return !keys.includes(key); }));
}
exports.omit = omit;
Object.defineProperty(exports, "__esModule", { value: true });
exports.omit = omit;
//# sourceMappingURL=omit.js.map

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function delay(ms) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, ms); })];
        });
    });
}
exports.delay = delay;
Object.defineProperty(exports, "__esModule", { value: true });
exports.delay = delay;
//# sourceMappingURL=delay.js.map

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function padLeft(str, length, padding) {
    if (typeof str === 'number') {
        str = str.toString();
    }
    length = length - str.length;
    if (length <= 0) {
        return str;
    }
    if (padding === undefined) {
        padding = ' ';
    }
    var paddingStr = '';
    do {
        /* eslint-disable no-bitwise */
        if ((length & 1) === 1) {
            paddingStr += padding;
        }
        length >>= 1;
        if (length) {
            padding += padding;
        }
        /* eslint-enable no-bitwise */
    } while (length);
    return paddingStr + str;
}
exports.padLeft = padLeft;
Object.defineProperty(exports, "__esModule", { value: true });
exports.padLeft = padLeft;
//# sourceMappingURL=padLeft.js.map

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function splitWithLimit(str, delim, count) {
    var parts = str.split(delim);
    if (parts.length <= count) {
        return parts;
    }
    return tslib_1.__spread(parts.slice(0, count - 1), [parts.slice(count - 1).join(delim)]);
}
exports.splitWithLimit = splitWithLimit;
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitWithLimit = splitWithLimit;
//# sourceMappingURL=splitWithLimit.js.map

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function utf8Length(str) {
    return tslib_1.__spread(str).length;
}
exports.utf8Length = utf8Length;
Object.defineProperty(exports, "__esModule", { value: true });
exports.utf8Length = utf8Length;
//# sourceMappingURL=utf8Length.js.map

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
function utf8Substring(str, start, end) {
    return tslib_1.__spread(str).slice(start, end).join('');
}
exports.utf8Substring = utf8Substring;
Object.defineProperty(exports, "__esModule", { value: true });
exports.utf8Substring = utf8Substring;
//# sourceMappingURL=utf8Substring.js.map

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var BaseAPI_1 = __webpack_require__(3);
var HelixBitsAPI_1 = __webpack_require__(127);
var HelixClipAPI_1 = __webpack_require__(128);
var HelixExtensionsAPI_1 = __webpack_require__(129);
var HelixGameAPI_1 = __webpack_require__(130);
var HelixModerationAPI_1 = __webpack_require__(131);
var HelixStreamAPI_1 = __webpack_require__(132);
var HelixSubscriptionAPI_1 = __webpack_require__(134);
var HelixUserAPI_1 = __webpack_require__(135);
var HelixVideoAPI_1 = __webpack_require__(136);
var HelixWebHooksAPI_1 = __webpack_require__(137);
/**
 * Groups all API calls available in Helix a.k.a. the "New Twitch API".
 *
 * Can be accessed using {@TwitchClient#helix}.
 */
var HelixAPIGroup = /** @class */ (function (_super) {
    tslib_1.__extends(HelixAPIGroup, _super);
    function HelixAPIGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(HelixAPIGroup.prototype, "bits", {
        /**
         * The Helix bits API methods.
         */
        get: function () {
            return new HelixBitsAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "clips", {
        /**
         * The Helix clips API methods.
         */
        get: function () {
            return new HelixClipAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "extensions", {
        /**
         * The Helix extensions API methods.
         */
        get: function () {
            return new HelixExtensionsAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "games", {
        /**
         * The Helix game API methods.
         */
        get: function () {
            return new HelixGameAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "moderation", {
        /**
         * The Helix moderation API methods.
         */
        get: function () {
            return new HelixModerationAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "streams", {
        /**
         * The Helix stream API methods.
         */
        get: function () {
            return new HelixStreamAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "subscriptions", {
        /**
         * The Helix subscription API methods.
         */
        get: function () {
            return new HelixSubscriptionAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "users", {
        /**
         * The Helix user API methods.
         */
        get: function () {
            return new HelixUserAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "webHooks", {
        /**
         * The Helix WebHook API methods.
         */
        get: function () {
            return new HelixWebHooksAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "videos", {
        /**
         * The Helix video API methods.
         */
        get: function () {
            return new HelixVideoAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "bits", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "clips", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "extensions", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "games", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "moderation", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "streams", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "subscriptions", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "users", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "webHooks", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "videos", null);
    HelixAPIGroup = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], HelixAPIGroup);
    return HelixAPIGroup;
}(BaseAPI_1.default));
exports.default = HelixAPIGroup;
module.exports = exports = HelixAPIGroup;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixAPIGroup;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseAPI_1 = __webpack_require__(3);
var TwitchClient_1 = __webpack_require__(4);
var HelixBitsLeaderboard_1 = __webpack_require__(50);
/**
 * The Helix API methods that deal with bits.
 *
 * Can be accessed using `client.helix.bits` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const leaderboard = await client.helix.bits.getLeaderboard({ period: 'day' });
 * ```
 */
var HelixBitsAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixBitsAPI, _super);
    function HelixBitsAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a bits leaderboard of your channel.
     *
     * @expandParams
     */
    HelixBitsAPI.prototype.getLeaderboard = function (params) {
        if (params === void 0) { params = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, count, _b, period, startDate, contextUserId, result;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = params.count, count = _a === void 0 ? 10 : _a, _b = params.period, period = _b === void 0 ? 'all' : _b, startDate = params.startDate, contextUserId = params.contextUserId;
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'bits/leaderboard',
                                scope: 'bits:read',
                                query: {
                                    count: count.toString(),
                                    period: period,
                                    started_at: startDate ? startDate.toISOString() : undefined,
                                    user_id: contextUserId
                                }
                            })];
                    case 1:
                        result = _c.sent();
                        return [2 /*return*/, new HelixBitsLeaderboard_1.default(result, this._client)];
                }
            });
        });
    };
    return HelixBitsAPI;
}(BaseAPI_1.default));
exports.default = HelixBitsAPI;
module.exports = exports = HelixBitsAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixBitsAPI;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixClip_1 = __webpack_require__(52);
/**
 * The Helix API methods that deal with clips.
 *
 * Can be accessed using `client.helix.clips` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const clipId = await client.helix.clips.createClip({ channelId: '125328655' });
 * ```
 */
var HelixClipAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixClipAPI, _super);
    function HelixClipAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the latest clips for the specified broadcaster.
     *
     * @param userId The broadcaster's user ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForBroadcaster = function (userId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getClips(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'broadcaster_id', ids: userId }))];
            });
        });
    };
    /**
     * Creates a paginator for the latest clips for the specified broadcaster.
     *
     * @param userId The broadcaster's user ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForBroadcasterPaginated = function (userId, filter) {
        if (filter === void 0) { filter = {}; }
        return this._getClipsPaginated(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'broadcaster_id', ids: userId }));
    };
    /**
     * Retrieves the latest clips for the specified game.
     *
     * @param gameId The game ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForGame = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getClips(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'game_id', ids: gameId }))];
            });
        });
    };
    /**
     * Creates a paginator for the latest clips for the specified game.
     *
     * @param gameId The game ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForGamePaginated = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return this._getClipsPaginated(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'game_id', ids: gameId }));
    };
    /**
     * Retrieves the clips identified by the given IDs.
     *
     * @param ids The clip IDs.
     */
    HelixClipAPI.prototype.getClipsByIds = function (ids) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getClips({
                            filterType: 'id',
                            ids: ids
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data];
                }
            });
        });
    };
    /**
     * Retrieves the clip identified by the given ID.
     *
     * @param id The clip ID.
     */
    HelixClipAPI.prototype.getClipById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var clips;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getClipsByIds([id])];
                    case 1:
                        clips = _a.sent();
                        return [2 /*return*/, clips.length ? clips[0] : null];
                }
            });
        });
    };
    /**
     * Creates a clip of a running stream.
     *
     * Returns the ID of the clip.
     *
     * @expandParams
     */
    HelixClipAPI.prototype.createClip = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, _a, createAfterDelay, result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        channelId = params.channelId, _a = params.createAfterDelay, createAfterDelay = _a === void 0 ? false : _a;
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'clips',
                                method: 'POST',
                                scope: 'clips:edit',
                                query: {
                                    broadcaster_id: channelId,
                                    has_delay: createAfterDelay.toString()
                                }
                            })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, result.data[0].id];
                }
            });
        });
    };
    HelixClipAPI.prototype._getClips = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var filterType, ids, startDate, endDate, _a, limit, result;
            var _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        filterType = params.filterType, ids = params.ids, startDate = params.startDate, endDate = params.endDate, _a = params.limit, limit = _a === void 0 ? 20 : _a;
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'clips',
                                query: (_b = {},
                                    _b[filterType] = ids,
                                    _b.started_at = startDate,
                                    _b.ended_at = endDate,
                                    _b.first = limit.toString(),
                                    _b)
                            })];
                    case 1:
                        result = _c.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixClip_1.default, this._client)];
                }
            });
        });
    };
    HelixClipAPI.prototype._getClipsPaginated = function (params) {
        var _a;
        var _this = this;
        var filterType = params.filterType, ids = params.ids, startDate = params.startDate, endDate = params.endDate;
        return new HelixPaginatedRequest_1.default({
            url: 'clips',
            query: (_a = {},
                _a[filterType] = ids,
                _a.started_at = startDate,
                _a.ended_at = endDate,
                _a)
        }, this._client, function (data) { return new HelixClip_1.default(data, _this._client); });
    };
    return HelixClipAPI;
}(BaseAPI_1.default));
exports.default = HelixClipAPI;
module.exports = exports = HelixClipAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixClipAPI;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixPagination_1 = __webpack_require__(18);
var HelixExtensionTransaction_1 = __webpack_require__(53);
/**
 * The Helix API methods that deal with extensions.
 *
 * Can be accessed using `client.helix.extensions` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const transactions = await client.helix.extionsions.getExtensionTransactions('abcd');
 * ```
 */
var HelixExtensionsAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixExtensionsAPI, _super);
    function HelixExtensionsAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of transactions for the given extension.
     *
     * @param extensionId The ID of the extension to retrieve transactions for.
     * @param filter Additional filters.
     */
    HelixExtensionsAPI.prototype.getExtensionTransactions = function (extensionId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'extensions/transactions',
                            query: tslib_1.__assign({ extension_id: extensionId, id: filter.transactionIds }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixExtensionTransaction_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for transactions for the given extension.
     *
     * @param extensionId The ID of the extension to retrieve transactions for.
     * @param filter Additional filters.
     */
    HelixExtensionsAPI.prototype.getExtensionTransactionsPaginated = function (extensionId, filter) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        return new HelixPaginatedRequest_1.default({
            url: 'extensions/transactions',
            query: {
                extension_id: extensionId,
                id: filter.transactionIds
            }
        }, this._client, function (data) { return new HelixExtensionTransaction_1.default(data, _this._client); });
    };
    return HelixExtensionsAPI;
}(BaseAPI_1.default));
exports.default = HelixExtensionsAPI;
module.exports = exports = HelixExtensionsAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixExtensionsAPI;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixPagination_1 = __webpack_require__(18);
var HelixGame_1 = __webpack_require__(54);
/**
 * The Helix API methods that deal with games.
 *
 * Can be accessed using `client.helix.games` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const game = await client.helix.games.getGameByName('Hearthstone');
 * ```
 */
var HelixGameAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixGameAPI, _super);
    function HelixGameAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the game data for the given list of game IDs.
     *
     * @param ids The game IDs you want to look up.
     */
    HelixGameAPI.prototype.getGamesByIds = function (ids) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getGames('id', ids)];
            });
        });
    };
    /**
     * Retrieves the game data for the given list of game names.
     *
     * @param names The game names you want to look up.
     */
    HelixGameAPI.prototype.getGamesByNames = function (names) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getGames('name', names)];
            });
        });
    };
    /**
     * Retrieves the game data for the given game ID.
     *
     * @param id The game ID you want to look up.
     */
    HelixGameAPI.prototype.getGameById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var games;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getGames('id', id)];
                    case 1:
                        games = _a.sent();
                        return [2 /*return*/, games.length ? games[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the game data for the given game name.
     *
     * @param name The game name you want to look up.
     */
    HelixGameAPI.prototype.getGameByName = function (name) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var games;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getGames('name', name)];
                    case 1:
                        games = _a.sent();
                        return [2 /*return*/, games.length ? games[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves a list of the most viewed games at the moment.
     *
     * @param pagination Pagination info.
     */
    HelixGameAPI.prototype.getTopGames = function (pagination) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'games/top',
                            query: HelixPagination_1.makePaginationQuery(pagination)
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixGame_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for the most viewed games at the moment.
     */
    HelixGameAPI.prototype.getTopGamesPaginated = function () {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'games/top'
        }, this._client, function (data) { return new HelixGame_1.default(data, _this._client); });
    };
    HelixGameAPI.prototype._getGames = function (filterType, filterValues) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'games',
                            query: (_a = {},
                                _a[filterType] = filterValues,
                                _a)
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, result.data.map(function (entry) { return new HelixGame_1.default(entry, _this._client); })];
                }
            });
        });
    };
    return HelixGameAPI;
}(BaseAPI_1.default));
exports.default = HelixGameAPI;
module.exports = exports = HelixGameAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixGameAPI;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixPagination_1 = __webpack_require__(18);
var HelixBan_1 = __webpack_require__(29);
var HelixBanEvent_1 = __webpack_require__(55);
var HelixModerator_1 = __webpack_require__(30);
var HelixModeratorEvent_1 = __webpack_require__(56);
/**
 * The Helix API methods that deal with moderation.
 *
 * Can be accessed using `client.helix.moderation` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const game = await client.helix.moderation.getBannedUsers('61369223');
 * ```
 */
var HelixModerationAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixModerationAPI, _super);
    function HelixModerationAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of banned users in a given channel.
     *
     * @param channel The channel to retrieve the banned users from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getBannedUsers = function (channel, filter) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/banned',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixBan_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for banned users in a given channel.
     *
     * @param channel The channel to retrieve the banned users from.
     */
    HelixModerationAPI.prototype.getBannedUsersPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/banned',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixBan_1.default(data, _this._client); });
    };
    /**
     * Checks whether a given user is banned in a given channel.
     *
     * @param channel The channel to check for a ban of the given user.
     * @param user The user to check for a ban in the given channel.
     */
    HelixModerationAPI.prototype.checkUserBan = function (channel, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this.getBannedUsers(channel, { userId: userId })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.some(function (ban) { return ban.userId === userId; })];
                }
            });
        });
    };
    /**
     * Retrieves a list of ban events for a given channel.
     *
     * @param channel The channel to retrieve the ban events from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getBanEvents = function (channel, filter) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _this = this;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/banned/events',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _c.sent();
                        return [2 /*return*/, {
                                data: result.data.map(function (data) { return new HelixBanEvent_1.default(data, _this._client); }),
                                cursor: (_b = result.pagination) === null || _b === void 0 ? void 0 : _b.cursor
                            }];
                }
            });
        });
    };
    /**
     * Creates a paginator for ban events for a given channel.
     *
     * @param channel The channel to retrieve the ban events from.
     */
    HelixModerationAPI.prototype.getBanEventsPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/banned/events',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixBanEvent_1.default(data, _this._client); });
    };
    /**
     * Retrieves a list of moderators in a given channel.
     *
     * @param channel The channel to retrieve moderators from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getModerators = function (channel, filter) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/moderators',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixModerator_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for moderators in a given channel.
     *
     * @param channel The channel to retrieve moderators from.
     */
    HelixModerationAPI.prototype.getModeratorsPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/moderators',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixModerator_1.default(data, _this._client); });
    };
    /**
     * Checks whether a given user is a moderator of a given channel.
     *
     * @param channel The channel to check.
     * @param user The user to check.
     */
    HelixModerationAPI.prototype.checkUserMod = function (channel, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this.getModerators(channel, { userId: userId })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.some(function (mod) { return mod.userId === userId; })];
                }
            });
        });
    };
    /**
     * Retrieves a list of moderator events for a given channel.
     *
     * @param channel The channel to retrieve the moderator events from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getModeratorEvents = function (channel, filter) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/moderators/events',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixModeratorEvent_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for moderator events for a given channel.
     *
     * @param channel The channel to retrieve the moderator events from.
     */
    HelixModerationAPI.prototype.getModeratorEventsPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/moderators/events',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixModeratorEvent_1.default(data, _this._client); });
    };
    return HelixModerationAPI;
}(BaseAPI_1.default));
exports.default = HelixModerationAPI;
module.exports = exports = HelixModerationAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixModerationAPI;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var HTTPStatusCodeError_1 = __webpack_require__(19);
var StreamNotLiveError_1 = __webpack_require__(57);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixPagination_1 = __webpack_require__(18);
var HelixStream_1 = __webpack_require__(58);
var HelixStreamMarker_1 = __webpack_require__(59);
var HelixStreamMarkerWithVideo_1 = __webpack_require__(133);
/**
 * The Helix API methods that deal with streams.
 *
 * Can be accessed using `client.helix.streams` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const stream = await client.helix.streams.getStreamByUserId('125328655');
 * ```
 */
var HelixStreamAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixStreamAPI, _super);
    function HelixStreamAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of streams.
     *
     * @expandParams
     */
    HelixStreamAPI.prototype.getStreams = function (filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'streams',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: tslib_1.__assign(tslib_1.__assign({}, HelixPagination_1.makePaginationQuery(filter)), { community_id: filter.community, game_id: filter.game, language: filter.language, type: filter.type, user_id: filter.userId, user_login: filter.userName })
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixStream_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for streams.
     *
     * @expandParams
     */
    HelixStreamAPI.prototype.getStreamsPaginated = function (filter) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        return new HelixPaginatedRequest_1.default({
            url: 'streams',
            query: {
                community_id: filter.community,
                game_id: filter.game,
                language: filter.language,
                type: filter.type,
                user_id: filter.userId,
                user_login: filter.userName
            }
        }, this._client, function (data) { return new HelixStream_1.default(data, _this._client); });
    };
    /**
     * Retrieves the current stream for the given user name.
     *
     * @param user The user name to retrieve the stream for.
     */
    HelixStreamAPI.prototype.getStreamByUserName = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getStreams({ userName: UserTools_1.extractUserName(user) })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.length ? result.data[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the current stream for the given user ID.
     *
     * @param user The user ID to retrieve the stream for.
     */
    HelixStreamAPI.prototype.getStreamByUserId = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getStreams({ userId: UserTools_1.extractUserId(user) })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.length ? result.data[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves a list of all stream markers for an user.
     *
     * @param user The user to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForUser = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getStreamMarkers('user_id', UserTools_1.extractUserId(user))];
            });
        });
    };
    /**
     * Creates a paginator for all stream markers for an user.
     *
     * @param user The user to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForUserPaginated = function (user) {
        return this._getStreamMarkersPaginated('user_id', UserTools_1.extractUserId(user));
    };
    /**
     * Retrieves a list of all stream markers for a video.
     *
     * @param videoId The video to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForVideo = function (videoId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getStreamMarkers('video_id', videoId)];
            });
        });
    };
    /**
     * Creates a paginator for all stream markers for a video.
     *
     * @param videoId The video to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForVideoPaginated = function (videoId) {
        return this._getStreamMarkersPaginated('video_id', videoId);
    };
    /**
     * Creates a new stream marker.
     *
     * Only works while the specified user's stream is live.
     */
    HelixStreamAPI.prototype.createStreamMarker = function (userId, description) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'streams/markers',
                                method: 'POST',
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                scope: 'user:edit:broadcast',
                                query: {
                                    user_id: userId,
                                    description: description
                                }
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new HelixStreamMarker_1.default(result.data[0], this._client)];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default && e_1.statusCode === 404) {
                            throw new StreamNotLiveError_1.default();
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    HelixStreamAPI.prototype._getStreamMarkers = function (queryType, id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'streams/markers',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: (_a = {},
                                _a[queryType] = id,
                                _a),
                            scope: 'user:read:broadcast'
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, {
                                data: shared_utils_1.flatten(result.data.map(HelixStreamAPI._mapGetStreamMarkersResult.bind(this._client))),
                                cursor: result.pagination && result.pagination.cursor
                            }];
                }
            });
        });
    };
    HelixStreamAPI.prototype._getStreamMarkersPaginated = function (queryType, id) {
        var _a;
        return new HelixPaginatedRequest_1.default({
            url: 'streams/markers',
            query: (_a = {},
                _a[queryType] = id,
                _a),
            scope: 'user:read:broadcast'
        }, this._client, HelixStreamAPI._mapGetStreamMarkersResult.bind(this._client));
    };
    HelixStreamAPI._mapGetStreamMarkersResult = function (data) {
        var _this = this;
        return data.videos.reduce(function (result, video) { return tslib_1.__spread(result, video.markers.map(function (marker) { return new HelixStreamMarkerWithVideo_1.default(marker, video.video_id, _this); })); }, []);
    };
    return HelixStreamAPI;
}(BaseAPI_1.default));
exports.default = HelixStreamAPI;
module.exports = exports = HelixStreamAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixStreamAPI;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HelixStreamMarker_1 = __webpack_require__(59);
var HelixStreamMarkerWithVideo = /** @class */ (function (_super) {
    tslib_1.__extends(HelixStreamMarkerWithVideo, _super);
    /** @private */
    function HelixStreamMarkerWithVideo(data, _videoId, client) {
        var _this = _super.call(this, data, client) || this;
        _this._videoId = _videoId;
        return _this;
    }
    Object.defineProperty(HelixStreamMarkerWithVideo.prototype, "url", {
        /**
         * The URL of the video, which will start playing at the position of the stream marker.
         */
        get: function () {
            return this._data.URL;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarkerWithVideo.prototype, "videoId", {
        /**
         * The ID of the video.
         */
        get: function () {
            return this._videoId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the video data of the video the marker was set in.
     */
    HelixStreamMarkerWithVideo.prototype.getVideo = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.videos.getVideoById(this._videoId)];
            });
        });
    };
    return HelixStreamMarkerWithVideo;
}(HelixStreamMarker_1.default));
exports.default = HelixStreamMarkerWithVideo;
module.exports = exports = HelixStreamMarkerWithVideo;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixStreamMarkerWithVideo;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixSubscription_1 = __webpack_require__(31);
var HelixSubscriptionEvent_1 = __webpack_require__(60);
/**
 * The Helix API methods that deal with subscriptions.
 *
 * Can be accessed using `client.helix.subscriptions` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const subscriptions = await client.helix.subscriptions.getSubscriptionsForUsers('61369223', '125328655');
 * ```
 */
var HelixSubscriptionAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixSubscriptionAPI, _super);
    function HelixSubscriptionAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of all subscriptions to a given broadcaster.
     *
     * @param broadcaster The broadcaster to list subscriptions to.
     */
    HelixSubscriptionAPI.prototype.getSubscriptions = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'subscriptions',
                            scope: 'channel:read:subscriptions',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: {
                                broadcaster_id: UserTools_1.extractUserId(broadcaster)
                            }
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixSubscription_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for all subscriptions to a given broadcaster.
     *
     * @param broadcaster The broadcaster to list subscriptions to.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionsPaginated = function (broadcaster) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'subscriptions',
            scope: 'channel:read:subscriptions',
            query: {
                broadcaster_id: UserTools_1.extractUserId(broadcaster)
            }
        }, this._client, function (data) { return new HelixSubscription_1.default(data, _this._client); });
    };
    /**
     * Retrieves the subset of the given user list that is subscribed to the given broadcaster.
     *
     * @param broadcaster The broadcaster to find subscriptions to.
     * @param users The users that should be checked for subscriptions.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionsForUsers = function (broadcaster, users) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'subscriptions',
                            scope: 'channel:read:subscriptions',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: {
                                broadcaster_id: UserTools_1.extractUserId(broadcaster),
                                user_id: users.map(UserTools_1.extractUserId)
                            }
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.map(function (data) { return new HelixSubscription_1.default(data, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for a given user to a given broadcaster.
     *
     * @param broadcaster The broadcaster to check.
     * @param user The user to check.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionForUser = function (broadcaster, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var list;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getSubscriptionsForUsers(broadcaster, [user])];
                    case 1:
                        list = _a.sent();
                        return [2 /*return*/, list.length ? list[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the most recent subscription events for a given broadcaster.
     *
     * @param broadcaster The broadcaster to retrieve subscription events for.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionEventsForBroadcaster = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getSubscriptionEvents('broadcaster_id', UserTools_1.extractUserId(broadcaster))];
            });
        });
    };
    /**
     * Creates a paginator for the recent subscription events for a given broadcaster.
     *
     * @param broadcaster The broadcaster to retrieve subscription events for.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionEventsForBroadcasterPaginated = function (broadcaster) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'subscriptions/events',
            scope: 'channel:read:subscriptions',
            query: {
                broadcaster_id: UserTools_1.extractUserId(broadcaster)
            }
        }, this._client, function (data) { return new HelixSubscriptionEvent_1.default(data, _this._client); });
    };
    /**
     * Retrieves a single subscription event by ID.
     *
     * @param id The event ID.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionEventById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getSubscriptionEvents('id', id)];
            });
        });
    };
    HelixSubscriptionAPI.prototype._getSubscriptionEvents = function (by, id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'subscriptions/events',
                            scope: 'channel:read:subscriptions',
                            query: (_a = {},
                                _a[by] = id,
                                _a)
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixSubscriptionEvent_1.default, this._client)];
                }
            });
        });
    };
    return HelixSubscriptionAPI;
}(BaseAPI_1.default));
exports.default = HelixSubscriptionAPI;
module.exports = exports = HelixSubscriptionAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixSubscriptionAPI;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HellFreezesOverError_1 = __webpack_require__(20);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequestWithTotal_1 = __webpack_require__(61);
var HelixPaginatedResult_1 = __webpack_require__(11);
var HelixFollow_1 = __webpack_require__(62);
var HelixPrivilegedUser_1 = __webpack_require__(63);
var HelixUser_1 = __webpack_require__(32);
/** @private */
var UserLookupType;
(function (UserLookupType) {
    UserLookupType["Id"] = "id";
    UserLookupType["Login"] = "login";
})(UserLookupType || (UserLookupType = {}));
exports.UserLookupType = UserLookupType;
/**
 * The Helix API methods that deal with users.
 *
 * Can be accessed using `client.helix.users` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const user = await client.helix.users.getUserById('125328655');
 * ```
 */
var HelixUserAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixUserAPI, _super);
    function HelixUserAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the user data for the given list of user IDs.
     *
     * @param userIds The user IDs you want to look up.
     */
    HelixUserAPI.prototype.getUsersByIds = function (userIds) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getUsers(UserLookupType.Id, userIds.map(UserTools_1.extractUserId))];
            });
        });
    };
    /**
     * Retrieves the user data for the given list of user names.
     *
     * @param userNames The user names you want to look up.
     */
    HelixUserAPI.prototype.getUsersByNames = function (userNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getUsers(UserLookupType.Login, userNames.map(UserTools_1.extractUserName))];
            });
        });
    };
    /**
     * Retrieves the user data for the given user ID.
     *
     * @param userId The user ID you want to look up.
     */
    HelixUserAPI.prototype.getUserById = function (userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var users;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getUsers(UserLookupType.Id, UserTools_1.extractUserId(userId))];
                    case 1:
                        users = _a.sent();
                        return [2 /*return*/, users.length ? users[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user name.
     *
     * @param userName The user name you want to look up.
     */
    HelixUserAPI.prototype.getUserByName = function (userName) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var users;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getUsers(UserLookupType.Login, UserTools_1.extractUserName(userName))];
                    case 1:
                        users = _a.sent();
                        return [2 /*return*/, users.length ? users[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the user data of the currently authenticated user.
     *
     * @param withEmail Whether you need the user's email address.
     */
    HelixUserAPI.prototype.getMe = function (withEmail) {
        if (withEmail === void 0) { withEmail = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'users',
                            scope: withEmail ? 'user:read:email' : ''
                        })];
                    case 1:
                        result = _a.sent();
                        if (!result.data || !result.data.length) {
                            throw new HellFreezesOverError_1.default('Could not get authenticated user');
                        }
                        return [2 /*return*/, new HelixPrivilegedUser_1.default(result.data[0], this._client)];
                }
            });
        });
    };
    /**
     * Updates the currently authenticated user's data.
     *
     * @param data The data to update.
     */
    HelixUserAPI.prototype.updateUser = function (data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'users',
                            method: 'PUT',
                            scope: 'user:edit',
                            query: {
                                description: data.description
                            }
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new HelixPrivilegedUser_1.default(result.data[0], this._client)];
                }
            });
        });
    };
    /**
     * Retrieves a list of follow relations.
     *
     * @param filter Several filtering and pagination parameters. See the {@HelixFollowFilter} documentation.
     */
    HelixUserAPI.prototype.getFollows = function (filter) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = HelixUserAPI._makeFollowsQuery(filter);
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'users/follows',
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                query: query
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResultWithTotal(result, HelixFollow_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for follow relations.
     *
     * @param filter Several filtering and pagination parameters. See the {@HelixFollowFilter} documentation.
     */
    HelixUserAPI.prototype.getFollowsPaginated = function (filter) {
        var _this = this;
        var query = HelixUserAPI._makeFollowsQuery(filter);
        return new HelixPaginatedRequestWithTotal_1.default({
            url: 'users/follows',
            query: query
        }, this._client, function (data) { return new HelixFollow_1.default(data, _this._client); });
    };
    HelixUserAPI._makeFollowsQuery = function (filter) {
        var query = {};
        var hasUserIdParam = false;
        if (filter.user) {
            query.from_id = UserTools_1.extractUserId(filter.user);
            hasUserIdParam = true;
        }
        if (filter.followedUser) {
            query.to_id = UserTools_1.extractUserId(filter.followedUser);
            hasUserIdParam = true;
        }
        if (!hasUserIdParam) {
            throw new TypeError('At least one of user and followedUser have to be set');
        }
        return query;
    };
    HelixUserAPI.prototype._getUsers = function (lookupType, param) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, result;
            var _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        query = (_a = {}, _a[lookupType] = param, _a);
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'users',
                                query: query
                            })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, result.data.map(function (userData) { return new HelixUser_1.default(userData, _this._client); })];
                }
            });
        });
    };
    return HelixUserAPI;
}(BaseAPI_1.default));
exports.default = HelixUserAPI;
module.exports = exports = HelixUserAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserLookupType = UserLookupType;
exports.default = HelixUserAPI;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequest_1 = __webpack_require__(9);
var HelixPagination_1 = __webpack_require__(18);
var HelixVideo_1 = __webpack_require__(64);
/**
 * The Helix API methods that deal with videos.
 *
 * Can be accessed using `client.helix.videos` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const videos = await client.helix.videos.getVideosByUser('125328655');
 * ```
 */
var HelixVideoAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixVideoAPI, _super);
    function HelixVideoAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the video data for the given list of video IDs.
     *
     * @param ids The video IDs you want to look up.
     */
    HelixVideoAPI.prototype.getVideosByIds = function (ids) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getVideos('id', ids)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data];
                }
            });
        });
    };
    /**
     * Retrieves the video data for the given video ID.
     *
     * @param id The video ID you want to look up.
     */
    HelixVideoAPI.prototype.getVideoById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var videos;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getVideosByIds(id)];
                    case 1:
                        videos = _a.sent();
                        return [2 /*return*/, videos.length ? videos[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the videos of the given user.
     *
     * @param user The user you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByUser = function (user, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this._getVideos('user_id', userId, filter)];
            });
        });
    };
    /**
     * Creates a paginator for videos of the given user.
     *
     * @param user The user you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByUserPaginated = function (user, filter) {
        if (filter === void 0) { filter = {}; }
        var userId = UserTools_1.extractUserId(user);
        return this._getVideosPaginated('user_id', userId, filter);
    };
    /**
     * Retrieves the videos of the given game.
     *
     * @param gameId The game you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByGame = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getVideos('game_id', gameId, filter)];
            });
        });
    };
    /**
     * Creates a paginator for videos of the given game.
     *
     * @param gameId The game you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByGamePaginated = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return this._getVideosPaginated('game_id', gameId, filter);
    };
    HelixVideoAPI.prototype._getVideos = function (filterType, filterValues, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'videos',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: tslib_1.__assign(tslib_1.__assign({}, HelixVideoAPI._makeVideosQuery(filterType, filterValues, filter)), HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, {
                                data: result.data.map(function (data) { return new HelixVideo_1.default(data, _this._client); }),
                                cursor: result.pagination && result.pagination.cursor
                            }];
                }
            });
        });
    };
    HelixVideoAPI.prototype._getVideosPaginated = function (filterType, filterValues, filter) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        return new HelixPaginatedRequest_1.default({
            url: 'videos',
            query: HelixVideoAPI._makeVideosQuery(filterType, filterValues, filter)
        }, this._client, function (data) { return new HelixVideo_1.default(data, _this._client); });
    };
    HelixVideoAPI._makeVideosQuery = function (filterType, filterValues, filter) {
        var _a;
        if (filter === void 0) { filter = {}; }
        var language = filter.language, period = filter.period, orderBy = filter.orderBy, type = filter.type;
        return _a = {},
            _a[filterType] = filterValues,
            _a.language = language,
            _a.period = period,
            _a.sort = orderBy,
            _a.type = type,
            _a;
    };
    return HelixVideoAPI;
}(BaseAPI_1.default));
exports.default = HelixVideoAPI;
module.exports = exports = HelixVideoAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixVideoAPI;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var HelixPaginatedRequestWithTotal_1 = __webpack_require__(61);
var HelixWebHookSubscription_1 = __webpack_require__(138);
/**
 * The API methods that deal with WebHooks.
 *
 * Can be accessed using `client.helix.webHooks` on a {@TwitchClient} instance.
 *
 * ## Before using these methods...
 *
 * All of the methods in this class assume that you are already running a working WebHook listener at the given callback URL.
 *
 * If you don't already have one, we recommend use of the `twitch-webhooks` library, which handles subscribing and unsubscribing to these topics automatically.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const accepted = await client.helix.webHooks.subscribeToUserFollowsTo('125328655', { callbackUrl: 'https://example.com' });
 * ```
 */
var HelixWebHooksAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixWebHooksAPI, _super);
    function HelixWebHooksAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the current WebHook subscriptions for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     */
    HelixWebHooksAPI.prototype.getSubscriptions = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new HelixPaginatedRequestWithTotal_1.default({
                        url: 'webhooks/subscriptions'
                    }, this._client, function (data) { return new HelixWebHookSubscription_1.default(data, _this._client); })];
            });
        });
    };
    /**
     * Sends an arbitrary request to subscribe to or unsubscribe from an event.
     *
     * @expandParams
     */
    HelixWebHooksAPI.prototype.sendHubRequest = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var mode, callbackUrl, topicUrl, _a, validityInSeconds, secret, scope;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        mode = options.mode, callbackUrl = options.callbackUrl, topicUrl = options.topicUrl, _a = options.validityInSeconds, validityInSeconds = _a === void 0 ? 3600 : _a, secret = options.secret, scope = options.scope;
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'webhooks/hub',
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                method: 'POST',
                                scope: scope,
                                jsonBody: {
                                    'hub.mode': mode,
                                    'hub.topic': topicUrl,
                                    'hub.callback': callbackUrl,
                                    'hub.lease_seconds': mode === 'subscribe' ? validityInSeconds.toString() : undefined,
                                    'hub.secret': secret
                                }
                            })];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Subscribes to events representing a user following other users.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about the users they will follow.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToUserFollowsFrom = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('subscribe', 'from', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a user being followed by other users.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about the users they will be followed by.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToUserFollowsTo = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('subscribe', 'to', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user following other users.
     *
     * @expandParams
     *
     * @param user The user for which to not get any more notifications about the users they will follow.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromUserFollowsFrom = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('unsubscribe', 'from', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user being followed by other users.
     *
     * @expandParams
     *
     * @param user The user for which to not get any more notifications about the users they will be followed by.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromUserFollowsTo = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('unsubscribe', 'to', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a stream changing, i.e. going live, offline or changing its title or category.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about their streams changing.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToStreamChanges = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendStreamChangeHubRequest('subscribe', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a stream changing.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about their streams changing.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromStreamChanges = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendStreamChangeHubRequest('unsubscribe', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a user changing a public setting or their email address.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about changing a setting.
     * @param options
     * @param withEmail Whether to subscribe to email address changes. This adds the necessary scope to read the email address to the request.
     */
    HelixWebHooksAPI.prototype.subscribeToUserChanges = function (user, options, withEmail) {
        if (withEmail === void 0) { withEmail = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserChangeHubRequest('subscribe', user, options, withEmail)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user changing a public setting or their email address.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about changing a setting.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromUserChanges = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserChangeHubRequest('unsubscribe', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing the start or end of a channel subscription.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about subscriptions to their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToSubscriptionEvents = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendSubscriptionEventsHubRequest('subscribe', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing the start or end of a channel subscription.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about subscriptions and unsubscriptions to their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromSubscriptionEvents = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendSubscriptionEventsHubRequest('unsubscribe', user, options)];
            });
        });
    };
    /**
     * Subscribes to extension transactions.
     *
     * @expandParams
     *
     * @param extensionId The extension ID for which to get notifications about transactions.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToExtensionTransactions = function (extensionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendExtensionTransactionsHubRequest('subscribe', extensionId, options)];
            });
        });
    };
    /**
     * Unsubscribes from extension transactions.
     *
     * @expandParams
     *
     * @param extensionId The extension ID for which not to get any more notifications about transactions.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromExtensionTransactions = function (extensionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendExtensionTransactionsHubRequest('unsubscribe', extensionId, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about bans or unbans in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToBanEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('subscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about bans or unbans in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromBanEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('unsubscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about bans or unbans in their channel.
     * @param user The user that is being banned or unbanned.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToBanEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('subscribe', broadcaster, options, user)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about bans or unbans in their channel.
     * @param user The user that is being banned or unbanned.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromBanEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('unsubscribe', broadcaster, options, user)];
            });
        });
    };
    /**
     * Subscribes to events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about moderator changes in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToModeratorEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('subscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about moderator changes in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromModeratorEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('unsubscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about moderator changes in their channel.
     * @param user The user that is being modded or unmodded.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToModeratorEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('subscribe', broadcaster, options, user)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about moderator changes in their channel.
     * @param user The user that is being modded or unmodded.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromModeratorEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('unsubscribe', broadcaster, options, user)];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendUserFollowsHubRequest = function (mode, direction, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/users/follows?first=1&" + direction + "_id=" + userId }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendStreamChangeHubRequest = function (mode, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/streams?user_id=" + userId }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendUserChangeHubRequest = function (mode, user, options, withEmail) {
        if (withEmail === void 0) { withEmail = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/users?id=" + userId, scope: withEmail ? 'user:read:email' : undefined }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendSubscriptionEventsHubRequest = function (mode, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/subscriptions/events?broadcaster_id=" + userId + "&first=1", scope: 'channel:read:subscriptions' }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendExtensionTransactionsHubRequest = function (mode, extensionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/extensions/transactions?extension_id=" + extensionId + "&first=1" }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendBanEventsHubRequest = function (mode, broadcaster, options, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId, topicUrl;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = UserTools_1.extractUserId(broadcaster);
                topicUrl = "https://api.twitch.tv/helix/moderation/banned/events?broadcaster_id=" + broadcasterId + "&first=1";
                if (user) {
                    topicUrl += "&user_id=" + UserTools_1.extractUserId(user);
                }
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode,
                        topicUrl: topicUrl, scope: 'moderation:read' }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendModeratorEventsHubRequest = function (mode, broadcaster, options, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId, topicUrl;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = UserTools_1.extractUserId(broadcaster);
                topicUrl = "https://api.twitch.tv/helix/moderation/moderators/events?broadcaster_id=" + broadcasterId + "&first=1";
                if (user) {
                    topicUrl += "&user_id=" + UserTools_1.extractUserId(user);
                }
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode,
                        topicUrl: topicUrl, scope: 'moderation:read' }, options))];
            });
        });
    };
    return HelixWebHooksAPI;
}(BaseAPI_1.default));
exports.default = HelixWebHooksAPI;
module.exports = exports = HelixWebHooksAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixWebHooksAPI;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A subscription to a Twitch WebHook.
 */
var HelixWebHookSubscription = /** @class */ (function () {
    /** @private */
    function HelixWebHookSubscription(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixWebHookSubscription.prototype, "topicUrl", {
        /**
         * The topic the WebHook is listening to.
         */
        get: function () {
            return this._data.topic;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixWebHookSubscription.prototype, "callbackUrl", {
        /**
         * The URL that will be called for every subscribed event.
         */
        get: function () {
            return this._data.callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixWebHookSubscription.prototype, "expiryDate", {
        /**
         * The time when the subscription will expire.
         */
        get: function () {
            return new Date(this._data.expires_at);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Unsubscribe from the WebHook.
     */
    HelixWebHookSubscription.prototype.unsubscribe = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.webHooks.sendHubRequest({
                        mode: 'unsubscribe',
                        topicUrl: this.topicUrl,
                        callbackUrl: this.callbackUrl
                    })];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixWebHookSubscription.prototype, "_client", void 0);
    return HelixWebHookSubscription;
}());
exports.default = HelixWebHookSubscription;
module.exports = exports = HelixWebHookSubscription;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixWebHookSubscription;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var rate_limiter_1 = __webpack_require__(140);
var TwitchClient_1 = __webpack_require__(4);
var HelixRateLimiter = /** @class */ (function (_super) {
    tslib_1.__extends(HelixRateLimiter, _super);
    function HelixRateLimiter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HelixRateLimiter.prototype.doRequest = function (_a) {
        var options = _a.options, clientId = _a.clientId, accessToken = _a.accessToken;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_b) {
                return [2 /*return*/, TwitchClient_1.default._callAPIRaw(options, clientId, accessToken)];
            });
        });
    };
    HelixRateLimiter.prototype.needsToRetryAfter = function (res) {
        if (res.status === 429) {
            return +res.headers.get('ratelimit-reset') * 1000 - Date.now();
        }
        return null;
    };
    HelixRateLimiter.prototype.getParametersFromResponse = function (res) {
        var headers = res.headers;
        return {
            limit: +headers.get('ratelimit-limit'),
            remaining: +headers.get('ratelimit-remaining'),
            resetsAt: +headers.get('ratelimit-reset') * 1000
        };
    };
    return HelixRateLimiter;
}(rate_limiter_1.ResponseBasedRateLimiter));
exports.default = HelixRateLimiter;
module.exports = exports = HelixRateLimiter;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HelixRateLimiter;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ResponseBasedRateLimiter_1 = __webpack_require__(141);
exports.ResponseBasedRateLimiter = ResponseBasedRateLimiter_1.ResponseBasedRateLimiter;
var RetryAfterError_1 = __webpack_require__(87);
exports.RetryAfterError = RetryAfterError_1.RetryAfterError;
//# sourceMappingURL=index.js.map

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(33);
var logger_1 = __webpack_require__(142);
var promise_allsettled_1 = __webpack_require__(145);
var RetryAfterError_1 = __webpack_require__(87);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var ResponseBasedRateLimiter = /** @class */ (function () {
    function ResponseBasedRateLimiter(logLevel) {
        this._queue = [];
        this._batchRunning = false;
        this._logger = new logger_1.Logger({ name: 'rate-limiter', minLevel: logLevel, emoji: true });
    }
    ResponseBasedRateLimiter.prototype.request = function (req) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var reqSpec = {
                            req: req,
                            resolve: resolve,
                            reject: reject
                        };
                        if (_this._batchRunning || _this._nextBatchTimer) {
                            _this._queue.push(reqSpec);
                        }
                        else {
                            _this._runRequestBatch([reqSpec]);
                        }
                    })];
            });
        });
    };
    ResponseBasedRateLimiter.prototype._runRequestBatch = function (reqSpecs) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var promises, settledPromises, rejectedPromises, now, retryAt, retryAfter, params, delay;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._batchRunning = true;
                        if (this._parameters) {
                            this._logger.debug1("remaining requests: " + this._parameters.remaining);
                        }
                        this._logger.debug2("doing " + reqSpecs.length + " requests, new queue length is " + this._queue.length);
                        promises = reqSpecs.map(function (reqSpec) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var req, resolve, reject, result, retry, params, e_1;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        req = reqSpec.req, resolve = reqSpec.resolve, reject = reqSpec.reject;
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, this.doRequest(req)];
                                    case 2:
                                        result = _a.sent();
                                        retry = this.needsToRetryAfter(result);
                                        if (retry !== null) {
                                            this._queue.unshift(reqSpec);
                                            this._logger.info("Retrying after " + retry + " ms");
                                            throw new RetryAfterError_1.RetryAfterError(retry);
                                        }
                                        params = this.getParametersFromResponse(result);
                                        resolve(result);
                                        return [2 /*return*/, params];
                                    case 3:
                                        e_1 = _a.sent();
                                        if (e_1 instanceof RetryAfterError_1.RetryAfterError) {
                                            throw e_1;
                                        }
                                        reject(e_1);
                                        return [2 /*return*/, undefined];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); });
                        return [4 /*yield*/, (0, promise_allsettled_1.default)(promises)];
                    case 1:
                        settledPromises = _a.sent();
                        rejectedPromises = settledPromises.filter(function (p) { return p.status === 'rejected'; });
                        now = Date.now();
                        if (rejectedPromises.length) {
                            retryAt = Math.max.apply(Math, tslib_1.__spread([now], rejectedPromises.map(function (p) { return p.reason.retryAt; })));
                            retryAfter = retryAt - now;
                            this._logger.warn("waiting for " + retryAfter + " ms because the rate limit was exceeded");
                            this._nextBatchTimer = setTimeout(function () {
                                _this._parameters = undefined;
                                _this._runNextBatch();
                            }, retryAfter);
                        }
                        else {
                            params = settledPromises
                                .map(function (p) { return p.value; })
                                .filter(function (v) { return v !== undefined; })
                                .reduce(function (carry, v) {
                                if (!carry) {
                                    return v;
                                }
                                // return v.resetsAt > carry.resetsAt ? v : carry;
                                return v.remaining < carry.remaining ? v : carry;
                            }, undefined);
                            this._batchRunning = false;
                            if (params) {
                                this._parameters = params;
                                if (params.resetsAt < now || params.remaining > 0) {
                                    this._runNextBatch();
                                }
                                else {
                                    delay = params.resetsAt - now;
                                    this._logger.warn("Waiting for " + delay + " ms because the rate limit was reached");
                                    this._nextBatchTimer = setTimeout(function () {
                                        _this._parameters = undefined;
                                        _this._runNextBatch();
                                    }, delay);
                                }
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ResponseBasedRateLimiter.prototype._runNextBatch = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var amount, reqSpecs;
            return tslib_1.__generator(this, function (_a) {
                if (this._nextBatchTimer) {
                    clearTimeout(this._nextBatchTimer);
                    this._nextBatchTimer = undefined;
                }
                amount = this._parameters ? Math.min(this._parameters.remaining, this._parameters.limit / 10) : 1;
                reqSpecs = this._queue.splice(0, amount);
                if (reqSpecs.length) {
                    this._runRequestBatch(reqSpecs);
                }
                return [2 /*return*/];
            });
        });
    };
    return ResponseBasedRateLimiter;
}());
exports.ResponseBasedRateLimiter = ResponseBasedRateLimiter;
//# sourceMappingURL=ResponseBasedRateLimiter.js.map

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable filenames/match-exported */
var isNode = __webpack_require__(14);
var NodeLogger_1 = __webpack_require__(143);
var BrowserLogger_1 = __webpack_require__(144);
var Logger = isNode ? NodeLogger_1.NodeLogger : BrowserLogger_1.BrowserLogger;
exports.Logger = Logger;
var LogLevel_1 = __webpack_require__(22);
exports.LogLevel = LogLevel_1.LogLevel;
//# sourceMappingURL=index.js.map

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(65);
var LogLevel_1 = __webpack_require__(22);
var BaseLogger_1 = __webpack_require__(66);
exports.LogLevelToEmoji = (_a = {},
    _a[LogLevel_1.LogLevel.CRITICAL] = "\uD83D\uDED1",
    _a[LogLevel_1.LogLevel.ERROR] = "\u274C",
    // these following two need extra spaces at the end because somehow they consume less space in a terminal than they should...
    _a[LogLevel_1.LogLevel.WARNING] = "\u26A0\uFE0F ",
    _a[LogLevel_1.LogLevel.INFO] = "\u2139\uFE0F ",
    _a[LogLevel_1.LogLevel.DEBUG] = "\uD83D\uDC1E",
    _a[LogLevel_1.LogLevel.TRACE] = "\uD83D\uDC3E",
    _a);
var colors = {
    black: 30,
    red: 31,
    green: 32,
    yellow: 33,
    blue: 34,
    magenta: 35,
    cyan: 36,
    white: 37,
    blackBright: 90,
    redBright: 91,
    greenBright: 92,
    yellowBright: 93,
    blueBright: 94,
    magentaBright: 95,
    cyanBright: 96,
    whiteBright: 97
};
var bgColors = {
    bgBlack: 40,
    bgRed: 41,
    bgGreen: 42,
    bgYellow: 43,
    bgBlue: 44,
    bgMagenta: 45,
    bgCyan: 46,
    bgWhite: 47,
    bgBlackBright: 100,
    bgRedBright: 101,
    bgGreenBright: 102,
    bgYellowBright: 103,
    bgBlueBright: 104,
    bgMagentaBright: 105,
    bgCyanBright: 106,
    bgWhiteBright: 107
};
function createGenericWrapper(color, ending, inner) {
    return function (str) { return "\u001B[" + color + "m" + (inner ? inner(str) : str) + "\u001B[" + ending + "m"; };
}
function createColorWrapper(color) {
    return createGenericWrapper(colors[color], 39);
}
function createBgWrapper(color, fgWrapper) {
    return createGenericWrapper(bgColors[color], 49, fgWrapper);
}
exports.LogLevelToColor = (_b = {},
    _b[LogLevel_1.LogLevel.CRITICAL] = createColorWrapper('red'),
    _b[LogLevel_1.LogLevel.ERROR] = createColorWrapper('redBright'),
    _b[LogLevel_1.LogLevel.WARNING] = createColorWrapper('yellow'),
    _b[LogLevel_1.LogLevel.INFO] = createColorWrapper('blue'),
    _b[LogLevel_1.LogLevel.DEBUG] = createColorWrapper('magenta'),
    _b[LogLevel_1.LogLevel.TRACE] = createGenericWrapper(0, 0),
    _b);
exports.LogLevelToBackgroundColor = (_c = {},
    _c[LogLevel_1.LogLevel.CRITICAL] = createBgWrapper('bgRed', createColorWrapper('white')),
    _c[LogLevel_1.LogLevel.ERROR] = createBgWrapper('bgRedBright', createColorWrapper('white')),
    _c[LogLevel_1.LogLevel.WARNING] = createBgWrapper('bgYellow', createColorWrapper('black')),
    _c[LogLevel_1.LogLevel.INFO] = createBgWrapper('bgBlue', createColorWrapper('white')),
    _c[LogLevel_1.LogLevel.DEBUG] = createBgWrapper('bgMagenta', createColorWrapper('black')),
    _c[LogLevel_1.LogLevel.TRACE] = createGenericWrapper(7, 27),
    _c);
var NodeLogger = /** @class */ (function (_super) {
    tslib_1.__extends(NodeLogger, _super);
    function NodeLogger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeLogger.prototype.log = function (level, message) {
        if (level > this._minLevel) {
            return;
        }
        var logFn = LogLevel_1.LogLevelToConsoleFunction[level];
        var builtMessage = '';
        if (this._timestamps) {
            builtMessage += "[" + new Date().toISOString() + "] ";
        }
        if (this._emoji) {
            var emoji = exports.LogLevelToEmoji[level];
            builtMessage += emoji + " ";
        }
        if (this._colors) {
            builtMessage += exports.LogLevelToBackgroundColor[level](this._name) + " " + exports.LogLevelToBackgroundColor[level](LogLevel_1.LogLevel[level]) + " " + exports.LogLevelToColor[level](message);
        }
        else {
            builtMessage += "[" + this._name + ":" + LogLevel_1.LogLevel[level].toLowerCase() + "] " + message;
        }
        logFn(builtMessage);
    };
    return NodeLogger;
}(BaseLogger_1.BaseLogger));
exports.NodeLogger = NodeLogger;
//# sourceMappingURL=NodeLogger.js.map

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(65);
var LogLevel_1 = __webpack_require__(22);
var BaseLogger_1 = __webpack_require__(66);
var BrowserLogger = /** @class */ (function (_super) {
    tslib_1.__extends(BrowserLogger, _super);
    function BrowserLogger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BrowserLogger.prototype.log = function (level, message) {
        if (level > this._minLevel) {
            return;
        }
        var logFn = LogLevel_1.LogLevelToConsoleFunction[level];
        var formattedMessage = "[" + this._name + "] " + message;
        if (this._timestamps) {
            formattedMessage = "[" + new Date().toISOString() + "] " + message;
        }
        logFn(formattedMessage);
    };
    return BrowserLogger;
}(BaseLogger_1.BaseLogger));
exports.BrowserLogger = BrowserLogger;
//# sourceMappingURL=BrowserLogger.js.map

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var callBind = __webpack_require__(34);
var define = __webpack_require__(24);

var requirePromise = __webpack_require__(25);
var implementation = __webpack_require__(69);
var getPolyfill = __webpack_require__(86);
var shim = __webpack_require__(192);

requirePromise();
var bound = callBind(getPolyfill());

var rebindable = function allSettled(iterable) {
	// eslint-disable-next-line no-invalid-this
	return bound(typeof this === 'undefined' ? Promise : this, iterable);
};

define(rebindable, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = rebindable;
module.exports.default = rebindable;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),
/* 147 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(68);

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(149);

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(68); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var callBound = __webpack_require__(8);

var $PromiseResolve = callBound('Promise.resolve', true);

// https://ecma-international.org/ecma-262/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};



/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://www.ecma-international.org/ecma-262/5.1/#sec-8

module.exports = function Type(x) {
	if (x === null) {
		return 'Null';
	}
	if (typeof x === 'undefined') {
		return 'Undefined';
	}
	if (typeof x === 'function' || typeof x === 'object') {
		return 'Object';
	}
	if (typeof x === 'number') {
		return 'Number';
	}
	if (typeof x === 'boolean') {
		return 'Boolean';
	}
	if (typeof x === 'string') {
		return 'String';
	}
};


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getIterator = __webpack_require__(153);
var $TypeError = TypeError;
var iterate = __webpack_require__(159);

module.exports = function iterateValue(iterable) {
	var iterator = getIterator(iterable);
	if (!iterator) {
		throw new $TypeError('non-iterable value provided');
	}
	if (arguments.length > 1) {
		return iterate(iterator, arguments[1]);
	}
	return iterate(iterator);
};


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/* eslint global-require: 0 */
// the code is structured this way so that bundlers can
// alias out `has-symbols` to `() => true` or `() => false` if your target
// environments' Symbol capabilities are known, and then use
// dead code elimination on the rest of this module.
//
// Similarly, `isarray` can be aliased to `Array.isArray` if
// available in all target environments.

var isArguments = __webpack_require__(155);

if (__webpack_require__(23)() || __webpack_require__(67)()) {
	var $iterator = Symbol.iterator;
	// Symbol is available natively or shammed
	// natively:
	//  - Chrome >= 38
	//  - Edge 12-14?, Edge >= 15 for sure
	//  - FF >= 36
	//  - Safari >= 9
	//  - node >= 0.12
	module.exports = function getIterator(iterable) {
		// alternatively, `iterable[$iterator]?.()`
		if (iterable != null && typeof iterable[$iterator] !== 'undefined') {
			return iterable[$iterator]();
		}
		if (isArguments(iterable)) {
			// arguments objects lack Symbol.iterator
			// - node 0.12
			return Array.prototype[$iterator].call(iterable);
		}
	};
} else {
	// Symbol is not available, native or shammed
	var isArray = __webpack_require__(156);
	var isString = __webpack_require__(70);
	var GetIntrinsic = __webpack_require__(2);
	var $Map = GetIntrinsic('%Map%', true);
	var $Set = GetIntrinsic('%Set%', true);
	var callBound = __webpack_require__(8);
	var $arrayPush = callBound('Array.prototype.push');
	var $charCodeAt = callBound('String.prototype.charCodeAt');
	var $stringSlice = callBound('String.prototype.slice');

	var advanceStringIndex = function advanceStringIndex(S, index) {
		var length = S.length;
		if ((index + 1) >= length) {
			return index + 1;
		}

		var first = $charCodeAt(S, index);
		if (first < 0xD800 || first > 0xDBFF) {
			return index + 1;
		}

		var second = $charCodeAt(S, index + 1);
		if (second < 0xDC00 || second > 0xDFFF) {
			return index + 1;
		}

		return index + 2;
	};

	var getArrayIterator = function getArrayIterator(arraylike) {
		var i = 0;
		return {
			next: function next() {
				var done = i >= arraylike.length;
				var value;
				if (!done) {
					value = arraylike[i];
					i += 1;
				}
				return {
					done: done,
					value: value
				};
			}
		};
	};

	var getNonCollectionIterator = function getNonCollectionIterator(iterable) {
		if (isArray(iterable) || isArguments(iterable)) {
			return getArrayIterator(iterable);
		}
		if (isString(iterable)) {
			var i = 0;
			return {
				next: function next() {
					var nextIndex = advanceStringIndex(iterable, i);
					var value = $stringSlice(iterable, i, nextIndex);
					i = nextIndex;
					return {
						done: nextIndex > iterable.length,
						value: value
					};
				}
			};
		}
	};

	if (!$Map && !$Set) {
		// the only language iterables are Array, String, arguments
		// - Safari <= 6.0
		// - Chrome < 38
		// - node < 0.12
		// - FF < 13
		// - IE < 11
		// - Edge < 11

		module.exports = getNonCollectionIterator;
	} else {
		// either Map or Set are available, but Symbol is not
		// - es6-shim on an ES5 browser
		// - Safari 6.2 (maybe 6.1?)
		// - FF v[13, 36)
		// - IE 11
		// - Edge 11
		// - Safari v[6, 9)

		var isMap = __webpack_require__(157);
		var isSet = __webpack_require__(158);

		// Firefox >= 27, IE 11, Safari 6.2 - 9, Edge 11, es6-shim in older envs, all have forEach
		var $mapForEach = callBound('Map.prototype.forEach', true);
		var $setForEach = callBound('Set.prototype.forEach', true);
		if (typeof process === 'undefined' || !process.versions || !process.versions.node) { // "if is not node"

			// Firefox 17 - 26 has `.iterator()`, whose iterator `.next()` either
			// returns a value, or throws a StopIteration object. These browsers
			// do not have any other mechanism for iteration.
			var $mapIterator = callBound('Map.prototype.iterator', true);
			var $setIterator = callBound('Set.prototype.iterator', true);
			var getStopIterationIterator = function (iterator) {
				var done = false;
				return {
					next: function next() {
						try {
							return {
								done: done,
								value: done ? undefined : iterator.next()
							};
						} catch (e) {
							done = true;
							return {
								done: true,
								value: undefined
							};
						}
					}
				};
			};
		}
		// Firefox 27-35, and some older es6-shim versions, use a string "@@iterator" property
		// this returns a proper iterator object, so we should use it instead of forEach.
		// newer es6-shim versions use a string "_es6-shim iterator_" property.
		var $mapAtAtIterator = callBound('Map.prototype.@@iterator', true) || callBound('Map.prototype._es6-shim iterator_', true);
		var $setAtAtIterator = callBound('Set.prototype.@@iterator', true) || callBound('Set.prototype._es6-shim iterator_', true);

		var getCollectionIterator = function getCollectionIterator(iterable) {
			if (isMap(iterable)) {
				if ($mapIterator) {
					return getStopIterationIterator($mapIterator(iterable));
				}
				if ($mapAtAtIterator) {
					return $mapAtAtIterator(iterable);
				}
				if ($mapForEach) {
					var entries = [];
					$mapForEach(iterable, function (v, k) {
						$arrayPush(entries, [k, v]);
					});
					return getArrayIterator(entries);
				}
			}
			if (isSet(iterable)) {
				if ($setIterator) {
					return getStopIterationIterator($setIterator(iterable));
				}
				if ($setAtAtIterator) {
					return $setAtAtIterator(iterable);
				}
				if ($setForEach) {
					var values = [];
					$setForEach(iterable, function (v) {
						$arrayPush(values, v);
					});
					return getArrayIterator(values);
				}
			}
		};

		module.exports = function getIterator(iterable) {
			return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
		};
	}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(154)))

/***/ }),
/* 154 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr = Object.prototype.toString;

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return toStr.call(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		toStr.call(value) !== '[object Array]' &&
		toStr.call(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),
/* 156 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

var exported;

if (!$Map) {
	// eslint-disable-next-line no-unused-vars
	exported = function isMap(x) {
		// `Map` is not present in this environment.
		return false;
	};
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$mapHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isMap(x) {
		// `Map` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isMap(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$mapHas.call(x);
		if ($setHas) {
			try {
				$setHas.call(x);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $Map; // core-js workaround, pre-v2.5.0
	} catch (e) {}
	return false;
};


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

var exported;

if (!$Set) {
	// eslint-disable-next-line no-unused-vars
	exported = function isSet(x) {
		// `Set` is not present in this environment.
		return false;
	};
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$setHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isSet(x) {
		// `Set` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isSet(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$setHas.call(x);
		if ($mapHas) {
			try {
				$mapHas.call(x);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $Set; // core-js workaround, pre-v2.5.0
	} catch (e) {}
	return false;
};


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
module.exports = function iterateIterator(iterator) {
	if (!iterator || typeof iterator.next !== 'function') {
		throw new $TypeError('iterator must be an object with a `next` method');
	}
	if (arguments.length > 1) {
		var callback = arguments[1];
		if (typeof callback !== 'function') {
			throw new $TypeError('`callback`, if provided, must be a function');
		}
	}
	var values = callback || [];
	var result;
	while ((result = iterator.next()) && !result.done) {
		if (callback) {
			callback(result.value); // eslint-disable-line callback-return
		} else {
			values.push(result.value);
		}
	}
	if (!callback) {
		return values;
	}
};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(24);
var RequireObjectCoercible = __webpack_require__(71);
var callBound = __webpack_require__(8);

var implementation = __webpack_require__(72);
var getPolyfill = __webpack_require__(85);
var polyfill = getPolyfill();
var shim = __webpack_require__(191);

var $slice = callBound('Array.prototype.slice');

// eslint-disable-next-line no-unused-vars
var boundMapShim = function map(array, callbackfn) {
	RequireObjectCoercible(array);
	return polyfill.apply(array, $slice(arguments, 1));
};
define(boundMapShim, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = boundMapShim;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.10

module.exports = function CheckObjectCoercible(value, optMessage) {
	if (value == null) {
		throw new $TypeError(optMessage || ('Cannot call method on ' + value));
	}
	return value;
};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $Array = GetIntrinsic('%Array%');
var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = GetIntrinsic('%TypeError%');

var Get = __webpack_require__(73);
var IsArray = __webpack_require__(74);
var IsConstructor = __webpack_require__(165);
var IsInteger = __webpack_require__(169);
var Type = __webpack_require__(7);

// https://ecma-international.org/ecma-262/6.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!IsInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}
	var len = length === 0 ? 0 : length;
	var C;
	var isArray = IsArray(originalArray);
	if (isArray) {
		C = Get(originalArray, 'constructor');
		// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
		// if (IsConstructor(C)) {
		// 	if C is another realm's Array, C = undefined
		// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
		// }
		if ($species && Type(C) === 'Object') {
			C = Get(C, $species);
			if (C === null) {
				C = void 0;
			}
		}
	}
	if (typeof C === 'undefined') {
		return $Array(len);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(len); // Construct(C, len);
};



/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var match = String.prototype.match;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;

var inspectCustom = __webpack_require__(164).custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean') {
        throw new TypeError('option "customInspect", if provided, must be `true` or `false`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
    }

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        return String(obj);
    }
    if (typeof obj === 'bigint') { // eslint-disable-line valid-typeof
        return String(obj) + 'n';
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function') {
        var name = nameOf(obj);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']';
    }
    if (isSymbol(obj)) {
        var symString = Symbol.prototype.toString.call(obj);
        return typeof obj === 'object' ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + xs.join(', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
            return obj[inspectSymbol]();
        } else if (typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        if (ys.length === 0) { return '{}'; }
        if (indent) {
            return '{' + indentedJoin(ys, indent) + '}';
        }
        return '{ ' + ys.join(', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]'; }
function isDate(obj) { return toStr(obj) === '[object Date]'; }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]'; }
function isError(obj) { return toStr(obj) === '[object Error]'; }
function isSymbol(obj) { return toStr(obj) === '[object Symbol]'; }
function isString(obj) { return toStr(obj) === '[object String]'; }
function isNumber(obj) { return toStr(obj) === '[object Number]'; }
function isBigInt(obj) { return toStr(obj) === '[object BigInt]'; }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]'; }

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = Array(opts.indent + 1).join(' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: Array(depth + 1).join(baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + xs.join(',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if ((/[^\w$]/).test(key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    return xs;
}


/***/ }),
/* 164 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = __webpack_require__(166);
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://www.ecma-international.org/ecma-262/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var isPropertyDescriptor = __webpack_require__(167);
var DefineOwnProperty = __webpack_require__(75);

var FromPropertyDescriptor = __webpack_require__(76);
var IsAccessorDescriptor = __webpack_require__(168);
var IsDataDescriptor = __webpack_require__(77);
var IsPropertyKey = __webpack_require__(16);
var SameValue = __webpack_require__(78);
var ToPropertyDescriptor = __webpack_require__(80);
var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}

	var Desc = isPropertyDescriptor({
		Type: Type,
		IsDataDescriptor: IsDataDescriptor,
		IsAccessorDescriptor: IsAccessorDescriptor
	}, desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor({
		Type: Type,
		IsDataDescriptor: IsDataDescriptor,
		IsAccessorDescriptor: IsAccessorDescriptor
	}, Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var has = __webpack_require__(17);
var $TypeError = GetIntrinsic('%TypeError%');

module.exports = function IsPropertyDescriptor(ES, Desc) {
	if (ES.Type(Desc) !== 'Object') {
		return false;
	}
	var allowed = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Get]]': true,
		'[[Set]]': true,
		'[[Value]]': true,
		'[[Writable]]': true
	};

	for (var key in Desc) { // eslint-disable-line no-restricted-syntax
		if (has(Desc, key) && !allowed[key]) {
			return false;
		}
	}

	if (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {
		throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
	}
	return true;
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(17);

var assertRecord = __webpack_require__(36);

var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-isaccessordescriptor

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	if (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $Math = GetIntrinsic('%Math%');

var $floor = $Math.floor;
var $abs = $Math.abs;

var $isNaN = __webpack_require__(79);
var $isFinite = __webpack_require__(170);

// https://www.ecma-international.org/ecma-262/6.0/#sec-isinteger

module.exports = function IsInteger(argument) {
	if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
		return false;
	}
	var abs = $abs(argument);
	return $floor(abs) === abs;
};


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);
var callBound = __webpack_require__(8);

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('%Function.prototype.apply%');

// https://www.ecma-international.org/ecma-262/6.0/#sec-call

module.exports = function Call(F, V) {
	var args = arguments.length > 2 ? arguments[2] : [];
	return $apply(F, V, args);
};


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var CreateDataProperty = __webpack_require__(173);
var IsPropertyKey = __webpack_require__(16);
var Type = __webpack_require__(7);

// // https://ecma-international.org/ecma-262/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var DefineOwnProperty = __webpack_require__(75);

var FromPropertyDescriptor = __webpack_require__(76);
var OrdinaryGetOwnProperty = __webpack_require__(174);
var IsDataDescriptor = __webpack_require__(77);
var IsExtensible = __webpack_require__(178);
var IsPropertyKey = __webpack_require__(16);
var SameValue = __webpack_require__(78);
var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}
	var oldDesc = OrdinaryGetOwnProperty(O, P);
	var extensible = !oldDesc || IsExtensible(O);
	var immutable = oldDesc && (!oldDesc['[[Writable]]'] || !oldDesc['[[Configurable]]']);
	if (immutable || !extensible) {
		return false;
	}
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		{
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Value]]': V,
			'[[Writable]]': true
		}
	);
};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $gOPD = __webpack_require__(175);
var $TypeError = GetIntrinsic('%TypeError%');

var callBound = __webpack_require__(8);

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var has = __webpack_require__(17);

var IsArray = __webpack_require__(74);
var IsPropertyKey = __webpack_require__(16);
var IsRegExp = __webpack_require__(176);
var ToPropertyDescriptor = __webpack_require__(80);
var Type = __webpack_require__(7);

// https://www.ecma-international.org/ecma-262/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!has(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = __webpack_require__(177);

var ToBoolean = __webpack_require__(81);

// https://ecma-international.org/ecma-262/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!argument || typeof argument !== 'object') {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasSymbols = __webpack_require__(23)();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';
var hasOwnProperty;
var regexExec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag) {
	hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
	regexExec = Function.call.bind(RegExp.prototype.exec);
	isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}
}

var toStr = Object.prototype.toString;
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';

module.exports = hasToStringTag
	// eslint-disable-next-line consistent-return
	? function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		var descriptor = gOPD(value, 'lastIndex');
		var hasLastIndexDataProperty = descriptor && hasOwnProperty(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			regexExec(value, badStringifier);
		} catch (e) {
			return e === isRegexMarker;
		}
	}
	: function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return toStr.call(value) === regexClass;
	};


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $Object = GetIntrinsic('%Object%');

var isPrimitive = __webpack_require__(84);

var $preventExtensions = $Object.preventExtensions;
var $isExtensible = $Object.isExtensible;

// https://www.ecma-international.org/ecma-262/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');

var IsPropertyKey = __webpack_require__(16);
var Type = __webpack_require__(7);

// https://ecma-international.org/ecma-262/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ToNumber = __webpack_require__(181);

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $TypeError = GetIntrinsic('%TypeError%');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = __webpack_require__(8);
var regexTester = __webpack_require__(182);
var isPrimitive = __webpack_require__(84);

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

// whitespace from: https://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
var ws = [
	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	'\u2029\uFEFF'
].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var $replace = callBound('String.prototype.replace');
var $trim = function (value) {
	return $replace(value, trimRegex, '');
};

var ToPrimitive = __webpack_require__(183);

// https://www.ecma-international.org/ecma-262/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		} else {
			var trimmed = $trim(value);
			if (trimmed !== value) {
				return ToNumber(trimmed);
			}
		}
	}
	return $Number(value);
};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $test = GetIntrinsic('RegExp.prototype.test');

var callBind = __webpack_require__(34);

module.exports = function regexTester(regex) {
	return callBind($test, regex);
};


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toPrimitive = __webpack_require__(184);

// https://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = __webpack_require__(185);
var isCallable = __webpack_require__(83);
var isDate = __webpack_require__(186);
var isSymbol = __webpack_require__(187);

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
	return void 0;
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (arguments[1] === String) {
			hint = 'string';
		} else if (arguments[1] === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;
var hasSymbols = __webpack_require__(23)();

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isRealSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') {
			return false;
		}
		return symStringRegex.test(symToStr.call(value));
	};

	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') {
			return true;
		}
		if (toStr.call(value) !== '[object Symbol]') {
			return false;
		}
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {

	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return  false && false;
	};
}


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $Object = GetIntrinsic('%Object%');

var RequireObjectCoercible = __webpack_require__(71);

// https://www.ecma-international.org/ecma-262/6.0/#sec-toobject

module.exports = function ToObject(value) {
	RequireObjectCoercible(value);
	return $Object(value);
};


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(2);

var $String = GetIntrinsic('%String%');
var $TypeError = GetIntrinsic('%TypeError%');

// https://www.ecma-international.org/ecma-262/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};


/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports = function properlyBoxed(method) {
	// Check node 0.6.21 bug where third parameter is not boxed
	var properlyBoxesNonStrict = true;
	var properlyBoxesStrict = true;
	var threwException = false;
	if (typeof method === 'function') {
		try {
			// eslint-disable-next-line max-params
			method.call('f', function (_, __, O) {
				if (typeof O !== 'object') {
					properlyBoxesNonStrict = false;
				}
			});

			method.call(
				[null],
				function () {
					'use strict';

					properlyBoxesStrict = typeof this === 'string'; // eslint-disable-line no-invalid-this
				},
				'x'
			);
		} catch (e) {
			threwException = true;
		}
		return !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
	}
	return false;
};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(24);
var getPolyfill = __webpack_require__(85);

module.exports = function shimArrayPrototypeMap() {
	var polyfill = getPolyfill();
	define(
		Array.prototype,
		{ map: polyfill },
		{ map: function () { return Array.prototype.map !== polyfill; } }
	);
	return polyfill;
};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var requirePromise = __webpack_require__(25);

var getPolyfill = __webpack_require__(86);
var define = __webpack_require__(24);

module.exports = function shimAllSettled() {
	requirePromise();

	var polyfill = getPolyfill();
	define(Promise, { allSettled: polyfill }, {
		allSettled: function testAllSettled() {
			return Promise.allSettled !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(33);
/** @private */
var CustomError = /** @class */ (function (_super) {
    tslib_1.__extends(CustomError, _super);
    function CustomError() {
        var _newTarget = this.constructor;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var _this = _super.apply(this, tslib_1.__spread(params)) || this;
        // restore prototype chain
        var actualProto = _newTarget.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(_this, actualProto);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            _this.__proto__ = actualProto;
        }
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _newTarget.constructor);
        }
        return _this;
    }
    Object.defineProperty(CustomError.prototype, "name", {
        get: function () {
            return this.constructor.name;
        },
        enumerable: true,
        configurable: true
    });
    return CustomError;
}(Error));
exports.CustomError = CustomError;
//# sourceMappingURL=CustomError.js.map

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var BaseAPI_1 = __webpack_require__(3);
var BitsAPI_1 = __webpack_require__(195);
var ChannelAPI_1 = __webpack_require__(196);
var ChatAPI_1 = __webpack_require__(197);
var SearchAPI_1 = __webpack_require__(201);
var StreamAPI_1 = __webpack_require__(202);
var TeamAPI_1 = __webpack_require__(203);
var UserAPI_1 = __webpack_require__(205);
/**
 * Groups all API calls available in Kraken v5.
 *
 * Can be accessed using {@TwitchClient#kraken}.
 */
var KrakenAPIGroup = /** @class */ (function (_super) {
    tslib_1.__extends(KrakenAPIGroup, _super);
    function KrakenAPIGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(KrakenAPIGroup.prototype, "bits", {
        /**
         * The API methods that deal with bits.
         */
        get: function () {
            return new BitsAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "channels", {
        /**
         * The API methods that deal with channels.
         */
        get: function () {
            return new ChannelAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "chat", {
        /**
         * The API methods that deal with chat.
         */
        get: function () {
            return new ChatAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "search", {
        /**
         * The API methods that deal with searching.
         */
        get: function () {
            return new SearchAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "streams", {
        /**
         * The API methods that deal with streams.
         */
        get: function () {
            return new StreamAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "users", {
        /**
         * The API methods that deal with users.
         */
        get: function () {
            return new UserAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "teams", {
        /**
         * The API methods that deal with teams.
         */
        get: function () {
            return new TeamAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "bits", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "channels", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "chat", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "search", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "streams", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "users", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "teams", null);
    KrakenAPIGroup = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], KrakenAPIGroup);
    return KrakenAPIGroup;
}(BaseAPI_1.default));
exports.default = KrakenAPIGroup;
module.exports = exports = KrakenAPIGroup;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = KrakenAPIGroup;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var UserTools_1 = __webpack_require__(6);
var BaseAPI_1 = __webpack_require__(3);
var CheermoteList_1 = __webpack_require__(37);
/**
 * The API methods that deal with Bits/Cheermotes.
 *
 * Can be accessed using `client.kraken.bits` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const cheermotes = await client.kraken.bits.getCheermotes();
 * ```
 */
var BitsAPI = /** @class */ (function (_super) {
    tslib_1.__extends(BitsAPI, _super);
    function BitsAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves global and channel cheermotes.
     *
     * @param channel The channel you want to retrieve the available cheermotes for.
     * If not given, this method retrieves a list of globally available cheermotes.
     * @param includeSponsored Whether to include sponsored cheermotes in the list.
     */
    BitsAPI.prototype.getCheermotes = function (channel, includeSponsored) {
        if (includeSponsored === void 0) { includeSponsored = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = {};
                        if (channel) {
                            query.channel_id = UserTools_1.extractUserId(channel);
                        }
                        if (includeSponsored) {
                            query.include_sponsored = 'true';
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'bits/actions', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new CheermoteList_1.default(data.actions, this._client)];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], BitsAPI.prototype, "getCheermotes", null);
    BitsAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], BitsAPI);
    return BitsAPI;
}(BaseAPI_1.default));
exports.default = BitsAPI;
module.exports = exports = BitsAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BitsAPI;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var HTTPStatusCodeError_1 = __webpack_require__(19);
var NoSubscriptionProgramError_1 = __webpack_require__(15);
var UserTools_1 = __webpack_require__(6);
var BaseAPI_1 = __webpack_require__(3);
var User_1 = __webpack_require__(10);
var Channel_1 = __webpack_require__(13);
var ChannelFollow_1 = __webpack_require__(88);
var ChannelSubscription_1 = __webpack_require__(89);
var PrivilegedChannel_1 = __webpack_require__(90);
var Team_1 = __webpack_require__(40);
/**
 * The API methods that deal with channels.
 *
 * Can be accessed using `client.kraken.channels` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const channel = await client.kraken.channels.getMyChannel();
 * ```
 */
var ChannelAPI = /** @class */ (function (_super) {
    tslib_1.__extends(ChannelAPI, _super);
    function ChannelAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets the channel the client is logged in to.
     */
    ChannelAPI.prototype.getMyChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = PrivilegedChannel_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({ url: 'channel', scope: 'channel_read' })];
                    case 1: return [2 /*return*/, new (_a.apply(PrivilegedChannel_1.default, [void 0, _b.sent(),
                            this._client]))()];
                }
            });
        });
    };
    /**
     * Retrieves the channel for the given user.
     *
     * @param user The user you want to retrieve the channel for.
     */
    ChannelAPI.prototype.getChannel = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = Channel_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({ url: "channels/" + UserTools_1.extractUserId(user) })];
                    case 1: return [2 /*return*/, new (_a.apply(Channel_1.default, [void 0, _b.sent(), this._client]))()];
                }
            });
        });
    };
    /**
     * Updates the given channel with the given data.
     *
     * @param channel The channel you want to update.
     * @param data The updated channel data.
     */
    ChannelAPI.prototype.updateChannel = function (channel, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId,
                                method: 'PUT',
                                jsonBody: { channel: data },
                                scope: 'channel_editor'
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves the list of users that have editor rights to the given channel.
     *
     * @param channel The channel you want to retrieve the list of editors for.
     */
    ChannelAPI.prototype.getChannelEditors = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/editors",
                                scope: 'channel_read'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.users.map(function (userData) { return new User_1.default(userData, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the list of followers of the given channel.
     *
     * @param channel The channel you want to retrieve the list of followers of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    ChannelAPI.prototype.getChannelFollowers = function (channel, page, limit, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        query = { limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        if (orderDirection) {
                            query.direction = orderDirection;
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/follows",
                                query: query
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.follows.map(function (follow) { return new ChannelFollow_1.default(follow, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the list of subscribers of the given channel.
     *
     * @param channel The channel you want to retrieve the list of subscribers of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    ChannelAPI.prototype.getChannelSubscriptions = function (channel, page, limit, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getChannelSubscriptions(channel, page, limit, orderDirection)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.subscriptions.map(function (sub) { return new ChannelSubscription_1.default(sub, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the total number of subscribers for the given channel.
     *
     * @param channel The channel you want to retrieve the number of subscribers for.
     */
    ChannelAPI.prototype.getChannelSubscriptionCount = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getChannelSubscriptions(channel, 0, 1)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data._total];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for the given user to a given channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the channel. If you only have access to the user,
     * use {@UserAPI#getSubscriptionData} instead.
     *
     * @param channel The channel to check the subscription to.
     * @param byUser The user to check the subscription for.
     */
    ChannelAPI.prototype.getChannelSubscriptionByUser = function (channel, byUser) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, userId, _a, e_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        userId = UserTools_1.extractUserId(byUser);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        _a = ChannelSubscription_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/subscriptions/" + userId,
                                scope: 'channel_check_subscription'
                            })];
                    case 2: return [2 /*return*/, new (_a.apply(ChannelSubscription_1.default, [void 0, _b.sent(),
                            this._client]))()];
                    case 3:
                        e_1 = _b.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default) {
                            if (e_1.statusCode === 404) {
                                return [2 /*return*/, null];
                            }
                            else if (e_1.statusCode === 422) {
                                throw new NoSubscriptionProgramError_1.default(channelId);
                            }
                        }
                        throw e_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a list of teams of the given channel.
     *
     * @param channel The channel you want to retrieve the list of teams of.
     */
    ChannelAPI.prototype.getChannelTeams = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/teams",
                                method: 'GET'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.teams.map(function (team) { return new Team_1.default(team, _this._client); })];
                }
            });
        });
    };
    /**
     * Starts a commercial in the given channel.
     *
     * @param channel The channel to start the commercial in.
     * @param length The length of the commercial.
     */
    ChannelAPI.prototype.startChannelCommercial = function (channel, length) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId;
            return tslib_1.__generator(this, function (_a) {
                channelId = UserTools_1.extractUserId(channel);
                return [2 /*return*/, this._client.callAPI({
                        url: "channels/" + channelId + "/commercial",
                        method: 'POST',
                        jsonBody: { length: length },
                        scope: 'channel_commercial'
                    })];
            });
        });
    };
    /**
     * Resets the given channel's stream key.
     *
     * @param channel The channel to reset the stream key for.
     */
    ChannelAPI.prototype.resetChannelStreamKey = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId;
            return tslib_1.__generator(this, function (_a) {
                channelId = UserTools_1.extractUserId(channel);
                return [2 /*return*/, this._client.callAPI({
                        url: "channels/" + channelId + "/stream_key",
                        method: 'DELETE',
                        scope: 'channel_stream'
                    })];
            });
        });
    };
    ChannelAPI.prototype._getChannelSubscriptions = function (channel, page, limit, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, query, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        query = { limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        if (orderDirection) {
                            query.direction = orderDirection;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/subscriptions",
                                query: query,
                                scope: 'channel_subscriptions'
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_2 = _a.sent();
                        if (e_2 instanceof HTTPStatusCodeError_1.default && e_2.statusCode === 422) {
                            throw new NoSubscriptionProgramError_1.default(channelId);
                        }
                        throw e_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getMyChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getChannel', 1)
    ], ChannelAPI.prototype, "updateChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getChannelEditors", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelFollowers", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelSubscriptions", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelSubscriptionCount", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getChannelSubscriptionByUser", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelTeams", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getMyChannel')
    ], ChannelAPI.prototype, "resetChannelStreamKey", null);
    ChannelAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], ChannelAPI);
    return ChannelAPI;
}(BaseAPI_1.default));
exports.default = ChannelAPI;
module.exports = exports = ChannelAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChannelAPI;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var UserTools_1 = __webpack_require__(6);
var BaseAPI_1 = __webpack_require__(3);
var ChatEmoteList_1 = __webpack_require__(198);
var ChatRoom_1 = __webpack_require__(200);
/**
 * The API methods that deal with chat and chatrooms.
 *
 * Can be accessed using `client.kraken.chat` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const emotes = await client.kraken.chat.getEmotesBySets('1');
 * ```
 */
var ChatAPI = /** @class */ (function (_super) {
    tslib_1.__extends(ChatAPI, _super);
    function ChatAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of emotes for a given list of enote set IDs.
     *
     * @param emotesets The list of emote set IDs, either as array of strings or as a comma separated string.
     */
    ChatAPI.prototype.getEmotesBySets = function (emotesets) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof emotesets !== 'string') {
                            emotesets = emotesets.join(',');
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'chat/emoticon_images',
                                query: {
                                    emotesets: emotesets
                                }
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new ChatEmoteList_1.default(data.emoticons, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves a list of chat rooms for a given channel.
     *
     * @param channel The channel to retrieve the chat rooms of.
     */
    ChatAPI.prototype.getChatRoomsForChannel = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: "chat/" + UserTools_1.extractUserId(channel) + "/rooms"
                        })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.rooms.map(function (room) { return new ChatRoom_1.default(room, _this._client); })];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChatAPI.prototype, "getEmotesBySets", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChatAPI.prototype, "getChatRoomsForChannel", null);
    ChatAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], ChatAPI);
    return ChatAPI;
}(BaseAPI_1.default));
exports.default = ChatAPI;
module.exports = exports = ChatAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatAPI;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var shared_utils_1 = __webpack_require__(1);
var ChatEmote_1 = __webpack_require__(199);
/**
 * A list of emotes.
 */
var ChatEmoteList = /** @class */ (function () {
    /** @private */
    function ChatEmoteList(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatEmoteList.prototype, "emotes", {
        /**
         * A list of all emotes in the list.
         */
        get: function () {
            var _this = this;
            return this._data.map(function (emote) { return new ChatEmote_1.default(emote, _this._client); });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets all emotes from the list that are from a given emote set.
     *
     * @param setId
     */
    ChatEmoteList.prototype.getAllFromSet = function (setId) {
        var _this = this;
        return this._data
            .filter(function (emote) { return emote.emoticon_set === setId; })
            .map(function (emote) { return new ChatEmote_1.default(emote, _this._client); });
    };
    /**
     * Finds a single emote by its ID.
     *
     * @param id
     */
    ChatEmoteList.prototype.getById = function (id) {
        var data = this._data.find(function (emote) { return emote.id === id; });
        return data ? new ChatEmote_1.default(data, this._client) : null;
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatEmoteList.prototype, "_client", void 0);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], ChatEmoteList.prototype, "emotes", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached()
    ], ChatEmoteList.prototype, "getAllFromSet", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached()
    ], ChatEmoteList.prototype, "getById", null);
    ChatEmoteList = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], ChatEmoteList);
    return ChatEmoteList;
}());
exports.default = ChatEmoteList;
module.exports = exports = ChatEmoteList;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatEmoteList;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * A chat emote.
 */
var ChatEmote = /** @class */ (function () {
    /** @private */
    function ChatEmote(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatEmote.prototype, "id", {
        /**
         * The emote ID.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatEmote.prototype, "code", {
        /**
         * The emote code, i.e. how you write it in chat.
         */
        get: function () {
            return this._data.code;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatEmote.prototype, "setId", {
        /**
         * The ID of the emote set.
         */
        get: function () {
            return this._data.emoticon_set;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatEmote.prototype, "_client", void 0);
    return ChatEmote;
}());
exports.default = ChatEmote;
module.exports = exports = ChatEmote;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatEmote;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/** @private */
var shared_utils_1 = __webpack_require__(1);
var ChatRoom = /** @class */ (function () {
    /** @private */
    function ChatRoom(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatRoom.prototype, "id", {
        /**
         * The ID of the chat room.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "ownerId", {
        /**
         * The user ID of the chat room owner.
         */
        get: function () {
            return this._data.owner_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the user data of the chat room owner.
     */
    ChatRoom.prototype.getOwner = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getUser(this._data.owner_id)];
            });
        });
    };
    Object.defineProperty(ChatRoom.prototype, "name", {
        /**
         * The name of the chat room.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "topic", {
        /**
         * The topic of the chat room.
         */
        get: function () {
            return this._data.topic;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "isPreviewable", {
        /**
         * Whether the chat room is previewable.
         */
        get: function () {
            return this._data.is_previewable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "minRole", {
        /**
         * The minimum role allowed to enter this chat room.
         */
        get: function () {
            return this._data.minimum_allowed_role;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "ircName", {
        /**
         * The name of the IRC channel that corresponds to this chat room.
         */
        get: function () {
            return "#chatrooms:" + this._data.owner_id + ":" + this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatRoom.prototype, "_client", void 0);
    return ChatRoom;
}());
exports.default = ChatRoom;
module.exports = exports = ChatRoom;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChatRoom;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var BaseAPI_1 = __webpack_require__(3);
var Channel_1 = __webpack_require__(13);
var Stream_1 = __webpack_require__(41);
/**
 * The API methods that deal with searching.
 *
 * Can be accessed using `client.kraken.search` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const channel = await client.kraken.search.searchStreams('Hearthstone');
 * ```
 */
var SearchAPI = /** @class */ (function (_super) {
    tslib_1.__extends(SearchAPI, _super);
    function SearchAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of channels that match the given search term.
     *
     * @param term The term you want to search for.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    SearchAPI.prototype.searchChannels = function (term, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { query: term, limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'search/channels', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.channels.map(function (channelData) { return new Channel_1.default(channelData, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves a list of streams that match the given search term.
     *
     * @param term The term you want to search for.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param hls Whether you want only HLS or only non-HLS (RTMP) streams. If not set, finds both types of streams.
     */
    SearchAPI.prototype.searchStreams = function (term, page, limit, hls) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { query: term, limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        if (hls !== undefined) {
                            query.hls = hls.toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'search/streams', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.streams.map(function (streamData) { return new Stream_1.default(streamData, _this._client); })];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], SearchAPI.prototype, "searchChannels", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], SearchAPI.prototype, "searchStreams", null);
    SearchAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], SearchAPI);
    return SearchAPI;
}(BaseAPI_1.default));
exports.default = SearchAPI;
module.exports = exports = SearchAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SearchAPI;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var UserTools_1 = __webpack_require__(6);
var BaseAPI_1 = __webpack_require__(3);
var Stream_1 = __webpack_require__(41);
/**
 * The API methods that deal with streams.
 *
 * Can be accessed using `client.kraken.streams` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const stream = await client.kraken.streams.getStreamByChannel('125328655');
 * ```
 */
var StreamAPI = /** @class */ (function (_super) {
    tslib_1.__extends(StreamAPI, _super);
    function StreamAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the current stream on the given channel.
     *
     * @param channel
     */
    StreamAPI.prototype.getStreamByChannel = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({ url: "streams/" + channelId })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.stream ? new Stream_1.default(data.stream, this._client) : null];
                }
            });
        });
    };
    /**
     * Retrieves a list of streams.
     *
     * @param channels A channel ID or a list thereof.
     * @param game Show only streams playing a certain game.
     * @param languageCode Show only streams in a certain language.
     * @param type Show only streams of a certain type.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getStreams = function (channels, game, languageCode, type, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { limit: limit.toString() };
                        if (channels) {
                            query.channel = typeof channels === 'string' ? channels : channels.join(',');
                        }
                        if (game) {
                            query.game = game;
                        }
                        if (languageCode) {
                            query.language = languageCode;
                        }
                        if (type) {
                            query.stream_type = type;
                        }
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'streams', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.streams.map(function (streamData) { return new Stream_1.default(streamData, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves a list of all streams.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getAllStreams = function (page, limit) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getStreams(undefined, undefined, undefined, Stream_1.StreamType.All, page, limit)];
            });
        });
    };
    /**
     * Retrieves a list of all live streams.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getAllLiveStreams = function (page, limit) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getStreams(undefined, undefined, undefined, Stream_1.StreamType.Live, page, limit)];
            });
        });
    };
    /**
     * Retrieves a list of all streams on channels the currently authenticated user is following.
     *
     * @param type Show only streams of a certain type.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getFollowedStreams = function (type, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { limit: limit.toString() };
                        if (type) {
                            query.type = type;
                        }
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'streams/followed',
                                query: query,
                                scope: 'user_read'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.streams.map(function (streamData) { return new Stream_1.default(streamData, _this._client); })];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(60)
    ], StreamAPI.prototype, "getStreamByChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(60)
    ], StreamAPI.prototype, "getFollowedStreams", null);
    StreamAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], StreamAPI);
    return StreamAPI;
}(BaseAPI_1.default));
exports.default = StreamAPI;
module.exports = exports = StreamAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StreamAPI;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var BaseAPI_1 = __webpack_require__(3);
var Team_1 = __webpack_require__(40);
var TeamWithUsers_1 = __webpack_require__(204);
/**
 * The API methods that deal with teams.
 *
 * Can be accessed using `client.kraken.teams` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const team = await client.kraken.teams.getTeamByName('staff');
 * ```
 */
var TeamAPI = /** @class */ (function (_super) {
    tslib_1.__extends(TeamAPI, _super);
    function TeamAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get a list of teams.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    TeamAPI.prototype.getTeams = function (page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = {};
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        query.limit = limit.toString();
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'teams',
                                query: query
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.teams.map(function (team) { return new Team_1.default(team, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the team data for the given team name.
     *
     * @param team The team name you want to look up.
     */
    TeamAPI.prototype.getTeamByName = function (team) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var teamData;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({ url: "teams/" + team })];
                    case 1:
                        teamData = _a.sent();
                        return [2 /*return*/, new TeamWithUsers_1.default(teamData, this._client)];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], TeamAPI.prototype, "getTeams", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], TeamAPI.prototype, "getTeamByName", null);
    TeamAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], TeamAPI);
    return TeamAPI;
}(BaseAPI_1.default));
exports.default = TeamAPI;
module.exports = exports = TeamAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TeamAPI;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Team_1 = __webpack_require__(40);
var User_1 = __webpack_require__(10);
var TeamWithUsers = /** @class */ (function (_super) {
    tslib_1.__extends(TeamWithUsers, _super);
    function TeamWithUsers() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * The list of users in the team.
     */
    TeamWithUsers.prototype.getUsers = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._data.users.map(function (data) { return new User_1.default(data, _this._client); })];
            });
        });
    };
    return TeamWithUsers;
}(Team_1.default));
exports.default = TeamWithUsers;
module.exports = exports = TeamWithUsers;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TeamWithUsers;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var shared_utils_1 = __webpack_require__(1);
var HellFreezesOverError_1 = __webpack_require__(20);
var HTTPStatusCodeError_1 = __webpack_require__(19);
var NoSubscriptionProgramError_1 = __webpack_require__(15);
var UserTools_1 = __webpack_require__(6);
var BaseAPI_1 = __webpack_require__(3);
var EmoteSetList_1 = __webpack_require__(91);
var PrivilegedUser_1 = __webpack_require__(92);
var User_1 = __webpack_require__(10);
var UserBlock_1 = __webpack_require__(93);
var UserChatInfo_1 = __webpack_require__(206);
var UserFollow_1 = __webpack_require__(94);
var UserSubscription_1 = __webpack_require__(95);
/**
 * The API methods that deal with users.
 *
 * Can be accessed using `client.kraken.users` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const user = await client.kraken.users.getUser('125328655');
 * ```
 */
var UserAPI = /** @class */ (function (_super) {
    tslib_1.__extends(UserAPI, _super);
    function UserAPI() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._userByNameCache = new Map();
        return _this;
    }
    /**
     * Retrieves the user data of the currently authenticated user.
     */
    UserAPI.prototype.getMe = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = PrivilegedUser_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({ url: 'user', scope: 'user_read' })];
                    case 1: return [2 /*return*/, new (_a.apply(PrivilegedUser_1.default, [void 0, _b.sent(), this._client]))()];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user ID.
     *
     * @param userId The user ID you want to look up.
     */
    UserAPI.prototype.getUser = function (userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userData;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({ url: "users/" + UserTools_1.extractUserId(userId) })];
                    case 1:
                        userData = _a.sent();
                        if (!userData) {
                            throw new HellFreezesOverError_1.default('Could not get authenticated user');
                        }
                        return [2 /*return*/, new User_1.default(userData, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user name.
     *
     * @param userName The user name you want to look up.
     */
    UserAPI.prototype.getUserByName = function (userName) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var users, user;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // not using the decorator's cache here as users-by-name is slightly more complex to cache
                        this._cleanUserCache();
                        if (this._userByNameCache.has(userName)) {
                            return [2 /*return*/, this._userByNameCache.get(userName).value];
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'users', query: { login: userName } })];
                    case 1:
                        users = (_a.sent()).users;
                        if (users.length === 0) {
                            return [2 /*return*/, null];
                        }
                        user = new User_1.default(users[0], this._client);
                        this._userByNameCache.set(userName, {
                            value: user,
                            expires: Date.now() + 3600 * 1000
                        });
                        return [2 /*return*/, user];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user names.
     *
     * @param userNames The user names you want to look up.
     */
    UserAPI.prototype.getUsersByNames = function (userNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cachedEntries, cachedObject, cachedUsers, toFetch, usersData, usersArr, users;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._cleanUserCache();
                        userNames = userNames.map(function (name) { return name.toLowerCase(); });
                        cachedEntries = Array.from(this._userByNameCache.entries()).filter(function (_a) {
                            var _b = tslib_1.__read(_a, 1), key = _b[0];
                            return userNames.includes(key);
                        });
                        cachedObject = shared_utils_1.entriesToObject(cachedEntries);
                        cachedUsers = shared_utils_1.mapObject(cachedObject, function (entry) { return entry.value; });
                        toFetch = userNames.filter(function (name) { return !(name in cachedUsers); });
                        if (!toFetch.length) {
                            return [2 /*return*/, cachedUsers];
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'users', query: { login: toFetch.join(',') } })];
                    case 1:
                        usersData = _a.sent();
                        usersArr = usersData.users.map(function (data) { return new User_1.default(data, _this._client); });
                        usersArr.forEach(function (user) {
                            return _this._userByNameCache.set(user.name, {
                                value: user,
                                expires: Date.now() + 3600 * 1000
                            });
                        });
                        users = shared_utils_1.indexBy(usersArr, 'name');
                        return [2 /*return*/, tslib_1.__assign(tslib_1.__assign({}, cachedUsers), users)];
                }
            });
        });
    };
    /**
     * Retrieves information about the user's chat appearance and privileges.
     *
     * @param user The user you want to get chat info for.
     */
    UserAPI.prototype.getChatInfo = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this._client.callAPI({ url: "users/" + userId + "/chat" })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new UserChatInfo_1.default(data, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves the emotes a given user can use.
     *
     * @param user The user you want to get emotes for.
     */
    UserAPI.prototype.getUserEmotes = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this._client.callAPI({ url: "users/" + userId + "/emotes", scope: 'user_subscriptions' })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new EmoteSetList_1.default(data.emoticon_sets)];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for a given user to a given channel.
     *
     * @param user The user to retrieve the subscription data of.
     * @param toChannel The channel you want to retrieve the subscription data to.
     */
    UserAPI.prototype.getSubscriptionData = function (user, toChannel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId, _a, e_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(toChannel);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        _a = UserSubscription_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/subscriptions/" + channelId,
                                scope: 'user_subscriptions'
                            })];
                    case 2: return [2 /*return*/, new (_a.apply(UserSubscription_1.default, [void 0, _b.sent(),
                            this._client]))()];
                    case 3:
                        e_1 = _b.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default) {
                            if (e_1.statusCode === 404) {
                                return [2 /*return*/, null];
                            }
                            else if (e_1.statusCode === 422) {
                                throw new NoSubscriptionProgramError_1.default(channelId);
                            }
                        }
                        throw e_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a list of channels a given user follows.
     *
     * @param user The user you want to retrieve the follows of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderBy The field to order by.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    UserAPI.prototype.getFollowedChannels = function (user, page, limit, orderBy, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        query = {};
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        query.limit = limit.toString();
                        if (orderBy) {
                            query.sortby = orderBy;
                        }
                        if (orderDirection) {
                            query.direction = orderDirection;
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/follows/channels",
                                query: query
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.follows.map(function (follow) { return new UserFollow_1.default(follow, _this._client); })];
                }
            });
        });
    };
    /**
     * Get follow data for a given user to a given channel.
     *
     * @param user The user you want to retrieve follow data of.
     * @param channel The channel you want to retrieve follow data to.
     */
    UserAPI.prototype.getFollowedChannel = function (user, channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId, data, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(channel);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._client.callAPI({ url: "users/" + userId + "/follows/channels/" + channelId })];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, new UserFollow_1.default(data, this._client)];
                    case 3:
                        e_2 = _a.sent();
                        if (e_2 instanceof HTTPStatusCodeError_1.default) {
                            if (e_2.statusCode === 404) {
                                return [2 /*return*/, null];
                            }
                        }
                        throw e_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Follows a given channel with a given user.
     *
     * @param user The user you want to follow with.
     * @param channel The channel to follow.
     * @param notifications Whether the user will receive notifications.
     */
    UserAPI.prototype.followChannel = function (user, channel, notifications) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/follows/channels/" + channelId,
                                method: 'PUT',
                                scope: 'user_follows_edit',
                                body: { notifications: Boolean(notifications).toString() }
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new UserFollow_1.default(data, this._client)];
                }
            });
        });
    };
    /**
     * Unfollows a given channel with a given user.
     *
     * @param user The user you want to unfollow with.
     * @param channel The channel to unfollow.
     */
    UserAPI.prototype.unfollowChannel = function (user, channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/follows/channels/" + channelId,
                                scope: 'user_follows_edit',
                                method: 'DELETE'
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a list of users a given user has blocked.
     *
     * @param user The user you want to retrieve the block list of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    UserAPI.prototype.getBlockedUsers = function (user, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        query = { limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/blocks",
                                query: query,
                                scope: 'user_blocks_read'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.blocks.map(function (block) { return new UserBlock_1.default(block, _this._client); })];
                }
            });
        });
    };
    /**
     * Blocks a given user with another given user.
     *
     * @param user The user you want to block with.
     * @param userToBlock The user to block.
     */
    UserAPI.prototype.blockUser = function (user, userToBlock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, userIdToBlock, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        userIdToBlock = UserTools_1.extractUserId(userToBlock);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/blocks/" + userIdToBlock,
                                method: 'PUT',
                                scope: 'user_blocks_edit'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new UserBlock_1.default(data, this._client)];
                }
            });
        });
    };
    /**
     * Unblocks a given user with another given user.
     *
     * @param user The user you want to unblock with.
     * @param userToUnblock The user to unblock.
     */
    UserAPI.prototype.unblockUser = function (user, userToUnblock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, userIdToUnblock;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        userIdToUnblock = UserTools_1.extractUserId(userToUnblock);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/blocks/" + userIdToUnblock,
                                method: 'DELETE',
                                scope: 'user_blocks_edit'
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    UserAPI.prototype._cleanUserCache = function () {
        var _this = this;
        var now = Date.now();
        this._userByNameCache.forEach(function (val, key) {
            if (val.expires < now) {
                _this._userByNameCache.delete(key);
            }
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getMe", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getUser", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getChatInfo", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getUserEmotes", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getSubscriptionData", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], UserAPI.prototype, "getFollowedChannels", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], UserAPI.prototype, "getFollowedChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getFollowedChannels', 1),
        cache_decorators_1.ClearsCache('getFollowedChannel', 2)
    ], UserAPI.prototype, "followChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getFollowedChannels', 1),
        cache_decorators_1.ClearsCache('getFollowedChannel', 2)
    ], UserAPI.prototype, "unfollowChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getBlockedUsers", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getBlockedUsers', 1)
    ], UserAPI.prototype, "blockUser", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getBlockedUsers', 1)
    ], UserAPI.prototype, "unblockUser", null);
    UserAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], UserAPI);
    return UserAPI;
}(BaseAPI_1.default));
exports.default = UserAPI;
module.exports = exports = UserAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UserAPI;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
/**
 * Information about a user's chat appearance and privileges.
 */
var UserChatInfo = /** @class */ (function () {
    /** @private */
    function UserChatInfo(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(UserChatInfo.prototype, "userId", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the user.
     */
    UserChatInfo.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getUser(this._data._id)];
            });
        });
    };
    Object.defineProperty(UserChatInfo.prototype, "userName", {
        /**
         * The name of the user.
         */
        get: function () {
            return this._data.login;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "displayName", {
        /**
         * The display name of the user.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "color", {
        /**
         * The color that the user appears in in chat.
         */
        get: function () {
            return this._data.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "isKnownBot", {
        /**
         * Whether the user is a known bot.
         */
        get: function () {
            return this._data.is_known_bot;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "isVerifiedBot", {
        /**
         * Whether the user is a verified bot.
         */
        get: function () {
            return this._data.is_verified_bot;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "isAtLeastKnownBot", {
        /**
         * Whether the user is at least a known bot (i.e. known or verified).
         */
        get: function () {
            return this._data.is_known_bot || this._data.is_verified_bot;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks whether the user has access to a given global badge.
     *
     * @param id The ID of a badge.
     */
    UserChatInfo.prototype.hasBadge = function (id) {
        return this._data.badges.some(function (badge) { return badge.id === id; });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], UserChatInfo.prototype, "_client", void 0);
    return UserChatInfo;
}());
exports.default = UserChatInfo;
module.exports = exports = UserChatInfo;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UserChatInfo;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var cache_decorators_1 = __webpack_require__(5);
var UserTools_1 = __webpack_require__(6);
var TwitchClient_1 = __webpack_require__(4);
var BaseAPI_1 = __webpack_require__(3);
var ChattersList_1 = __webpack_require__(97);
/**
 * Different API methods that are not officially supported by Twitch.
 *
 * Can be accessed using `client.unsupported` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const events = await client.unsupported.getEvents('125328655');
 * ```
 */
var UnsupportedAPI = /** @class */ (function (_super) {
    tslib_1.__extends(UnsupportedAPI, _super);
    function UnsupportedAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of chatters in the Twitch chat of the given channel.
     *
     * **WARNING**: In contrast to most other methods, this takes a channel *name*, not a user ID.
     *
     * @param channel The channel to retrieve the chatters for.
     */
    UnsupportedAPI.prototype.getChatters = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelName, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelName = UserTools_1.extractUserName(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "https://tmi.twitch.tv/group/user/" + channelName + "/chatters",
                                type: TwitchClient_1.TwitchAPICallType.Custom
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new ChattersList_1.default(data)];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(60)
    ], UnsupportedAPI.prototype, "getChatters", null);
    UnsupportedAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], UnsupportedAPI);
    return UnsupportedAPI;
}(BaseAPI_1.default));
exports.default = UnsupportedAPI;
module.exports = exports = UnsupportedAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UnsupportedAPI;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var shared_utils_1 = __webpack_require__(1);
var TwitchClient_1 = __webpack_require__(4);
/**
 * An auth provider that retrieve tokens using client credentials.
 */
var ClientCredentialsAuthProvider = /** @class */ (function () {
    /**
     * Creates a new auth provider to receive an application token with using the client ID and secret.
     *
     * You don't usually have to create this manually. You should use `TwitchClient.withClientCredentials` instead.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     */
    function ClientCredentialsAuthProvider(clientId, clientSecret) {
        /**
         * The type of tokens this provider generates.
         *
         * This auth provider generates app tokens.
         */
        this.tokenType = 'app';
        this._clientId = clientId;
        this._clientSecret = clientSecret;
    }
    /**
     * Retrieves an access token.
     *
     * If any scopes are provided, this throws. The client credentials flow does not support scopes.
     *
     * @param scopes The requested scopes.
     */
    ClientCredentialsAuthProvider.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (scopes && scopes.length > 0) {
                    throw new Error("Scope " + (typeof scopes === 'string' ? scopes : scopes.join(',')) + " requested but the client credentials flow does not support scopes");
                }
                if (!this._token || this._token.isExpired) {
                    return [2 /*return*/, this.refresh()];
                }
                return [2 /*return*/, this._token];
            });
        });
    };
    /**
     * Retrieves a new app access token.
     */
    ClientCredentialsAuthProvider.prototype.refresh = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, TwitchClient_1.default.getAppAccessToken(this._clientId, this._clientSecret)];
                    case 1: return [2 /*return*/, (_a._token = _b.sent())];
                }
            });
        });
    };
    /** @private */
    ClientCredentialsAuthProvider.prototype.setAccessToken = function (token) {
        this._token = token;
    };
    Object.defineProperty(ClientCredentialsAuthProvider.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._clientId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientCredentialsAuthProvider.prototype, "currentScopes", {
        /**
         * The scopes that are currently available using the access token.
         */
        get: function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ClientCredentialsAuthProvider.prototype, "_clientId", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ClientCredentialsAuthProvider.prototype, "_clientSecret", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ClientCredentialsAuthProvider.prototype, "_token", void 0);
    return ClientCredentialsAuthProvider;
}());
exports.default = ClientCredentialsAuthProvider;
module.exports = exports = ClientCredentialsAuthProvider;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ClientCredentialsAuthProvider;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var CustomError_1 = __webpack_require__(12);
/**
 * Thrown whenever a different token type (user vs. app) is expected in the method you're calling.
 */
var InvalidTokenTypeError = /** @class */ (function (_super) {
    tslib_1.__extends(InvalidTokenTypeError, _super);
    function InvalidTokenTypeError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return InvalidTokenTypeError;
}(CustomError_1.default));
exports.default = InvalidTokenTypeError;
module.exports = exports = InvalidTokenTypeError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = InvalidTokenTypeError;


/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/twitch/lib/index.js
var lib = __webpack_require__(42);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// CONCATENATED MODULE: ./src/config.ts
const defaultClientId = "59x8jyaudw3pnyi722x3e2x9awh385";
class ConfigManager {
    static setUserClientId(clientId) {
        this.userClientId = clientId;
    }
    static getClientId() {
        if (this.userClientId) {
            return this.userClientId;
        }
        return defaultClientId;
    }
}

// CONCATENATED MODULE: ./src/downloader/config.ts
// File with config values and constants
const config_clientId = "ybum1fvursno4nf3ckzx56jmhqynjk"; // Add client ID here
const defaultHeaders = {
    "Client-ID": config_clientId,
    "Accept": "application/vnd.twitchtv.v5+json",
    "Authorization": "OAuth gcu9pd0kcn6x2x3drix6esbhlrfqfv",
};
// TypeScript does not allow parametrized string to be formatted in runtime,
// so this is the best way to get a formatted URL.
function getApiUrl(videoId, nextCursor) {
    if (nextCursor) {
        return `https://api.twitch.tv/v5/videos/${videoId}/comments?cursor=${nextCursor}`;
    }
    return `https://api.twitch.tv/v5/videos/${videoId}/comments`;
}

// CONCATENATED MODULE: ./src/downloader/chat.ts

const tooManyRequests = 429; // HTTP 429 too many requests response code
async function sleep(ms) {
    return new Promise(_ => setTimeout(_, ms));
}
class chat_ChatDownloader {
    addLoopEventListener(handler) {
        this.loopHandler = handler;
    }
    // Download chat of single Twitch video
    async downloadChat(videoId) {
        var _a, _b, _c, _d;
        const comments = [];
        let turn = 0;
        let nextCursor = null;
        do {
            const response = await this.callApi(videoId, nextCursor);
            if (response.text) { // response.text is null if status is not ok.
                try {
                    const jsonContent = JSON.parse(response.text);
                    for (let newComment of jsonContent["comments"]) {
                        comments.push(newComment);
                    }
                    nextCursor = jsonContent["_next"];
                    turn += 1;
                    (_a = this.loopHandler) === null || _a === void 0 ? void 0 : _a.call(this, turn, response.status, comments.length);
                }
                catch (err) {
                    console.error(`Error when parsing JSON response: ${response.text}`);
                    (_b = this.loopHandler) === null || _b === void 0 ? void 0 : _b.call(this, turn, response.status, comments.length);
                    return null;
                }
            }
            else if (response.status == tooManyRequests) {
                (_c = this.loopHandler) === null || _c === void 0 ? void 0 : _c.call(this, turn, response.status, comments.length);
                // As of 2020-07-25, Kraken API does not seem to use 429 response code at all.
                // This sleep is here only as an additional check
                await sleep(500); // Sleep for 1 second
            }
            else {
                console.error(`API call failed with error code: ${response.status}`);
                (_d = this.loopHandler) === null || _d === void 0 ? void 0 : _d.call(this, turn, response.status, comments.length);
                return null;
            }
        } while (nextCursor);
        return comments;
    }
    // Call Twitch API one time
    async callApi(videoId, cursor) {
        const url = getApiUrl(videoId, cursor);
        const response = await fetch(url, { headers: defaultHeaders });
        if (!response.ok) {
            return { status: response.status, text: null };
        }
        const content = await response.text();
        return { status: response.status, text: content };
    }
}

// CONCATENATED MODULE: ./src/downloader.ts



let twitchClient;
function getTwitchClient() {
    if (twitchClient !== null && twitchClient !== undefined) {
        return twitchClient;
    }
    // User not logged in
    const token = sessionStorage.getItem("twitch_chat_analyzer_access_token");
    if (!token) {
        return null;
    }
    const clientId = ConfigManager.getClientId();
    const client = lib_default.a.withCredentials(clientId, token);
    twitchClient = client;
    return client;
}
async function getStreamerInfo(username) {
    const token = sessionStorage.getItem("twitch_chat_analyzer_access_token");
    if (!token) {
        return null;
    }
    const clientId = ConfigManager.getClientId();
    const client = lib_default.a.withCredentials(clientId, token);
    const user = await client.helix.users.getUserByName(username);
    return user;
}
function addFollowerDownloaderListeners() {
    const streamerNameInputElem = document.getElementById("streamer-username-input");
    const streamerSearchButtomElem = document.getElementById("streamer-search-button");
    const streamerInfoElem = document.getElementById("streamer-info");
    const downloadButtonElem = document.getElementById("follower-list-download-button");
    streamerSearchButtomElem.addEventListener("click", async () => {
        const name = streamerNameInputElem.value;
        const client = getTwitchClient();
        client.helix.users.getUserByName(name).then((helixUser) => {
            if (!helixUser) {
                streamerInfoElem.textContent = `스트리머를 찾을 수 없습니다: ${name}`;
                return;
            }
            streamerInfoElem.textContent = `스트리머: ${helixUser.displayName}`;
            // Show download button
        });
    });
    downloadButtonElem.addEventListener("click", async () => {
        // Display download status
        // download
        // When finished downloading, download the file to local disk
    });
}
function addChatDownloaderListeners() {
    const videoIdInputElem = document.getElementById("video-id-input");
    const videoSearchButtomElem = document.getElementById("video-search-button");
    const videoInfoElem = document.getElementById("video-info");
    const downloadButtonElem = document.getElementById("video-chat-download-button");
    videoSearchButtomElem.addEventListener("click", async () => {
        const videoId = videoIdInputElem.value;
        const client = getTwitchClient();
        client.helix.videos.getVideoById(videoId).then((video) => {
            // Populate video info elem
            videoInfoElem.textContent = video.title + ", " + video.description;
        });
    });
    const loopHandler = (turn, status, downloadCount) => {
        // Display download status in some <div>
    };
    downloadButtonElem.addEventListener("click", async () => {
        const videoId = videoIdInputElem.value;
        const downloader = new chat_ChatDownloader();
        downloader.addLoopEventListener(loopHandler);
        const chats = await downloader.downloadChat(videoId);
        // Display download status
        // download
        // When finished downloading, download the file to local disk
    });
}
(function () {
    addFollowerDownloaderListeners();
    addChatDownloaderListeners();
})();
/*
function main() {

  //const input = "random filter name & Follow 1day | subscriber & aaaaa & (Bbbb)";
  //const input = "!(랜덤한 필터 이름) & 팔로우 1일 이하 | 비구독자 & 그냥 이것저것 & (아무거나 이것저것)";
  const input = "!(랜덤한 필터 이름) | 팔로우 1일 이하| (비구독자 |!그냥 이것저것) & 아무거나 이것저것";
  const f = getFilter(input);
  console.log("f: " + f);
  console.log("type f: " + Object.keys(f));
  console.log("toString: " + f.toString());

  return;

  const beforeFile = performance.now();
  const fileContent = fs.readFileSync(filePath, "utf8");
  const fileJson = JSON.parse(fileContent);
  const commentsData = fileJson["comments"] as Array<CommentData>;
  
  const repository = new CommentRepository(commentsData);
  console.log("User count: " + repository.userCount());
  console.log("Chat count: " + repository.commentCount());
  
  const group = new AndExpressionGroup();
  group.addRegex({type: "user", key: "username"}, "c");
  group.addRegex({type: "comment", key: "rawText"}, "heart");
  group.addGreaterThan({type: "comment", key: "relativeTime"}, 200);

  const beforeFilter = performance.now();
  console.log("Repository created in " + (beforeFilter - beforeFile) + " milliseconds");
  const filtered = repository.filter(group);
  //const filter = new RegexExpression({type: "comment", key: "rawText"}, "ㅋㅋㅋ");
  //const filter = new RegexExpression({type: "user", key: "username"}, "r");

  //const filtered = repository.filter(filter);
  
  const afterFilter = performance.now();
  console.log("Filtered complete in " + (afterFilter - beforeFilter) + " milliseconds");

  console.log(filtered.length);
  for(let i = 0; i < 10; i++) {
      console.log(filtered[i].toDisplayString());
  }
  for(let chat of filtered) {
      console.log(chat.toDisplayString());
  }
}


main();

*/ 


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9zaGFyZWQtdXRpbHMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9HZXRJbnRyaW5zaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0Jhc2VBUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvVHdpdGNoQ2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnMvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzL2VzL3V0aWxzL2NyZWF0ZUNhY2hlS2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnMvZXMvZGVjb3JhdG9ycy9DYWNoZWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9ycy9lcy9kZWNvcmF0b3JzL0NhY2hlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzL2VzL2RlY29yYXRvcnMvQ2FjaGVkR2V0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnMvZXMvZGVjb3JhdG9ycy9DbGVhcnNDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL1Rvb2xraXQvVXNlclRvb2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L1R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvY2FsbEJvdW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9IZWxpeFBhZ2luYXRlZFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9Vc2VyL1VzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L0hlbGl4UGFnaW5hdGVkUmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0Vycm9ycy9DdXN0b21FcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYW5uZWwvQ2hhbm5lbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV0ZWN0LW5vZGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9FcnJvcnMvTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvSXNQcm9wZXJ0eUtleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvSGVsaXhQYWdpbmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0Vycm9ycy9IVFRQU3RhdHVzQ29kZUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0Vycm9ycy9IZWxsRnJlZXplc092ZXJFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0xvZ0xldmVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3JhdGUtbGltaXRlci9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0xvZ0xldmVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcHJvbWlzZS5hbGxzZXR0bGVkL3JlcXVpcmVQcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3FzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvQWNjZXNzVG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvb2JqZWN0L2FycmF5VG9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L01vZGVyYXRpb24vSGVsaXhCYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L01vZGVyYXRpb24vSGVsaXhNb2RlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1N1YnNjcmlwdGlvbnMvSGVsaXhTdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1VzZXIvSGVsaXhVc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3JhdGUtbGltaXRlci9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2NhbGxCaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2Fzc2VydFJlY29yZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0JpdHMvQ2hlZXJtb3RlTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYW5uZWwvQ2hhbm5lbFBsYWNlaG9sZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9LcmFrZW4vU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9LcmFrZW4vVGVhbS9UZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9LcmFrZW4vU3RyZWFtL1N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0Jhc2VMb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcXMvbGliL2Zvcm1hdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvb2JqZWN0L3BpY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0JhZGdlcy9DaGF0QmFkZ2VMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9CYWRnZXMvQ2hhdEJhZGdlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9CYWRnZXMvQ2hhdEJhZGdlVmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvQml0cy9IZWxpeEJpdHNMZWFkZXJib2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvQml0cy9IZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9DbGlwL0hlbGl4Q2xpcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvRXh0ZW5zaW9ucy9IZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9HYW1lL0hlbGl4R2FtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvTW9kZXJhdGlvbi9IZWxpeEJhbkV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9Nb2RlcmF0aW9uL0hlbGl4TW9kZXJhdG9yRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvRXJyb3JzL1N0cmVhbU5vdExpdmVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvU3RyZWFtL0hlbGl4U3RyZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9TdHJlYW0vSGVsaXhTdHJlYW1NYXJrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1N1YnNjcmlwdGlvbnMvSGVsaXhTdWJzY3JpcHRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9Vc2VyL0hlbGl4Rm9sbG93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9Vc2VyL0hlbGl4UHJpdmlsZWdlZFVzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1ZpZGVvL0hlbGl4VmlkZW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcmF0ZS1saW1pdGVyL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2xvZ2dlci9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3JhdGUtbGltaXRlci9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0Jhc2VMb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9wcm9taXNlLmFsbHNldHRsZWQvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUubWFwL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0dldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9Jc0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL0RlZmluZU93blByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0Zyb21Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvSXNEYXRhRGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9TYW1lVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvaXNOYU4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvVG9Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvVG9Cb29sZWFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0lzQ2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLWNhbGxhYmxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUubWFwL3BvbHlmaWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3Byb21pc2UuYWxsc2V0dGxlZC9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXIvbGliL1JldHJ5QWZ0ZXJFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYW5uZWwvQ2hhbm5lbEZvbGxvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYW5uZWwvQ2hhbm5lbFN1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYW5uZWwvUHJpdmlsZWdlZENoYW5uZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9DaGFubmVsL0Vtb3RlU2V0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1VzZXIvUHJpdmlsZWdlZFVzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9Vc2VyL1VzZXJCbG9jay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1VzZXIvVXNlckZvbGxvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1VzZXIvVXNlclN1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvVG9rZW5JbmZvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9VbnN1cHBvcnRlZC9DaGF0dGVyc0xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQXV0aC9SZWZyZXNoYWJsZUF1dGhQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BdXRoL1N0YXRpY0F1dGhQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9FcnJvcnMvQ29uZmlnRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvRXJyb3JzL0ludmFsaWRUb2tlbkVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2Nyb3NzLWZldGNoL2Rpc3QvYnJvd3Nlci1wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL2xvZ2dlci9saWIvTm9kZUxvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0Jyb3dzZXJMb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcXMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3FzL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9CYWRnZXMvQmFkZ2VzQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3NoYXJlZC11dGlscy9saWIvZGVjb3JhdG9ycy9FbnVtZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3NoYXJlZC11dGlscy9saWIvZnVuY3Rpb25zL2FycmF5L2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvY29uZmlnL3Jlc29sdmVDb25maWdWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9zaGFyZWQtdXRpbHMvbGliL2Z1bmN0aW9ucy9kZXByZWNhdGUvZGVwcmVjYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvbWF0Y2gvbWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvb2JqZWN0L2VudHJpZXNUb09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9zaGFyZWQtdXRpbHMvbGliL2Z1bmN0aW9ucy9vYmplY3QvZm9yRWFjaE9iamVjdEVudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3NoYXJlZC11dGlscy9saWIvZnVuY3Rpb25zL29iamVjdC9pbmRleEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3NoYXJlZC11dGlscy9saWIvZnVuY3Rpb25zL29iamVjdC9tYXBPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvb2JqZWN0L29taXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvcHJvbWlzZS9kZWxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9zaGFyZWQtdXRpbHMvbGliL2Z1bmN0aW9ucy9zdHJpbmcvcGFkTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9zaGFyZWQtdXRpbHMvbGliL2Z1bmN0aW9ucy9zdHJpbmcvc3BsaXRXaXRoTGltaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvc3RyaW5nL3V0ZjhMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvc2hhcmVkLXV0aWxzL2xpYi9mdW5jdGlvbnMvc3RyaW5nL3V0ZjhTdWJzdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L0hlbGl4QVBJR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L0JpdHMvSGVsaXhCaXRzQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9DbGlwL0hlbGl4Q2xpcEFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvRXh0ZW5zaW9ucy9IZWxpeEV4dGVuc2lvbnNBUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L0dhbWUvSGVsaXhHYW1lQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9Nb2RlcmF0aW9uL0hlbGl4TW9kZXJhdGlvbkFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvSGVsaXgvU3RyZWFtL0hlbGl4U3RyZWFtQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9TdHJlYW0vSGVsaXhTdHJlYW1NYXJrZXJXaXRoVmlkZW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1N1YnNjcmlwdGlvbnMvSGVsaXhTdWJzY3JpcHRpb25BUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L1VzZXIvSGVsaXhVc2VyQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9WaWRlby9IZWxpeFZpZGVvQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9XZWJIb29rcy9IZWxpeFdlYkhvb2tzQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9IZWxpeC9XZWJIb29rcy9IZWxpeFdlYkhvb2tTdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0hlbGl4L0hlbGl4UmF0ZUxpbWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcmF0ZS1saW1pdGVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXIvbGliL1Jlc3BvbnNlQmFzZWRSYXRlTGltaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXIvbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvbG9nZ2VyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXIvbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvbG9nZ2VyL2xpYi9Ob2RlTG9nZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZC1maXNjaGVyL3JhdGUtbGltaXRlci9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9sb2dnZXIvbGliL0Jyb3dzZXJMb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkLWZpc2NoZXIvcHJvbWlzZS5hbGxzZXR0bGVkL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9Qcm9taXNlUmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvNS9UeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pdGVyYXRlLXZhbHVlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1nZXQtaXRlcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1hcmd1bWVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWdldC1pdGVyYXRvci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtbWFwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1zZXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2l0ZXJhdGUtaXRlcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzUvQ2hlY2tPYmplY3RDb2VyY2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvQXJyYXlTcGVjaWVzQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi91dGlsLmluc3BlY3QgKGlnbm9yZWQpIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0lzQ29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvRGVmaW5lUHJvcGVydHlPclRocm93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzUHJvcGVydHlEZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0lzQWNjZXNzb3JEZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0lzSW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9pc0Zpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9DYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0NyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvQ3JlYXRlRGF0YVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L09yZGluYXJ5R2V0T3duUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L0lzUmVnRXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAxOS9Jc0V4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvSGFzUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvVG9VaW50MzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvVG9OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvcmVnZXhUZXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMTkvVG9QcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLXRvLXByaW1pdGl2ZS9lczIwMTUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzLXRvLXByaW1pdGl2ZS9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1kYXRlLW9iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L1RvT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDE5L1RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcy1hcnJheS1tZXRob2QtYm94ZXMtcHJvcGVybHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5tYXAvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9wcm9taXNlLmFsbHNldHRsZWQvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXIvbGliL0N1c3RvbUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9LcmFrZW4vS3Jha2VuQVBJR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9CaXRzL0JpdHNBUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9DaGFubmVsL0NoYW5uZWxBUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9DaGF0L0NoYXRBUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9DaGF0L0NoYXRFbW90ZUxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9DaGF0L0NoYXRFbW90ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL0NoYXQvQ2hhdFJvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aXRjaC9saWIvQVBJL0tyYWtlbi9TZWFyY2gvU2VhcmNoQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9LcmFrZW4vU3RyZWFtL1N0cmVhbUFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1RlYW0vVGVhbUFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1RlYW0vVGVhbVdpdGhVc2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1VzZXIvVXNlckFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BUEkvS3Jha2VuL1VzZXIvVXNlckNoYXRJbmZvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0FQSS9VbnN1cHBvcnRlZC9VbnN1cHBvcnRlZEFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpdGNoL2xpYi9BdXRoL0NsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2l0Y2gvbGliL0Vycm9ycy9JbnZhbGlkVG9rZW5UeXBlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG93bmxvYWRlci9jb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Rvd25sb2FkZXIvY2hhdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG93bmxvYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFB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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGlFQUFpRTtBQUMzSTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7Ozs7Ozs7O0FDOVFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csK0JBQStCLEVBQUU7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsK0JBQStCLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxjQUFjLG1CQUFPLENBQUMsQ0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7Ozs7Ozs7O0FDdkNhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLENBQU87QUFDN0IsMkJBQTJCLG1CQUFPLENBQUMsRUFBc0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7Ozs7Ozs7QUMvT0E7Ozs7Ozs7OztBQ0FhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLENBQU87QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsRUFBZTtBQUMzQztBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEOzs7Ozs7OztBQ3BCYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTmE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLEVBQWU7O0FBRWxDOzs7Ozs7OztBQ0phO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNYYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyxDQUFPO0FBQzdCLG9CQUFvQixtQkFBTyxDQUFDLEVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7Ozs7Ozs7O0FDcENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLENBQU87QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsRUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDs7Ozs7Ozs7QUNuQmE7QUFDYjtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyxFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0IsRUFBRTtBQUN6RCxrQ0FBa0MsK0JBQStCLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ3hEYTtBQUNiO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsYUFBYSxtQkFBTyxDQUFDLEVBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QixFQUFFO0FBQ3pELGtDQUFrQywrQkFBK0IsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7OztBQ25EQSw4Q0FBYTs7QUFFYjtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLEVBQVM7O0FBRXJDO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQsb0NBQW9DLGNBQWM7QUFDbEQsNkNBQTZDLGNBQWM7QUFDM0QseUNBQXlDLGNBQWM7O0FBRXZEO0FBQ0E7Ozs7Ozs7OztBQ1phOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxHQUFhO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLFlBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7OztBQ3pEYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ05hOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxhQUFhO0FBQ3hGLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDs7Ozs7Ozs7QUM3RGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxjQUFjLG1CQUFPLENBQUMsQ0FBTztBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyxDQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7Ozs7Ozs7O0FDdkVhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLENBQU87QUFDN0IscUJBQXFCLG1CQUFPLENBQUMsQ0FBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FB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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVCQUF1QjtBQUNuRSxhQUFhO0FBQ2IseUNBQXlDLGNBQWMsRUFBRTtBQUN6RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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Q1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiwwQkFBMEIsZUFBZTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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SztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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LENBQUMsb0JBQW9CLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDN0MsTUFBTSxLQUFLLEdBQUcsTUFBTSxVQUFVLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3JELDBCQUEwQjtRQUMxQixXQUFXO1FBQ1gsNkRBQTZEO0lBQ2pFLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQztBQUVELENBQUM7SUFFRCw4QkFBOEIsRUFBRSxDQUFDO0lBQ2pDLDBCQUEwQixFQUFFLENBQUM7QUFJN0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUlMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWtERSIsImZpbGUiOiJkb3dubG9hZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwMik7XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRW51bWVyYWJsZV8xID0gcmVxdWlyZShcIi4vZGVjb3JhdG9ycy9FbnVtZXJhYmxlXCIpO1xudmFyIF9fZXhwb3J0X0VudW1lcmFibGUgPSBFbnVtZXJhYmxlXzEuRW51bWVyYWJsZTtcbmV4cG9ydHMuRW51bWVyYWJsZSA9IF9fZXhwb3J0X0VudW1lcmFibGU7XG52YXIgX19leHBvcnRfTm9uRW51bWVyYWJsZSA9IEVudW1lcmFibGVfMS5Ob25FbnVtZXJhYmxlO1xuZXhwb3J0cy5Ob25FbnVtZXJhYmxlID0gX19leHBvcnRfTm9uRW51bWVyYWJsZTtcbnZhciBmbGF0dGVuXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvYXJyYXkvZmxhdHRlblwiKTtcbnZhciBfX2V4cG9ydF9mbGF0dGVuID0gZmxhdHRlbl8xLmZsYXR0ZW47XG5leHBvcnRzLmZsYXR0ZW4gPSBfX2V4cG9ydF9mbGF0dGVuO1xudmFyIHJlc29sdmVDb25maWdWYWx1ZV8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL2NvbmZpZy9yZXNvbHZlQ29uZmlnVmFsdWVcIik7XG52YXIgX19leHBvcnRfcmVzb2x2ZUNvbmZpZ1ZhbHVlID0gcmVzb2x2ZUNvbmZpZ1ZhbHVlXzEucmVzb2x2ZUNvbmZpZ1ZhbHVlO1xuZXhwb3J0cy5yZXNvbHZlQ29uZmlnVmFsdWUgPSBfX2V4cG9ydF9yZXNvbHZlQ29uZmlnVmFsdWU7XG52YXIgZGVwcmVjYXRlQ2xhc3NfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9kZXByZWNhdGUvZGVwcmVjYXRlQ2xhc3NcIik7XG52YXIgX19leHBvcnRfZGVwcmVjYXRlQ2xhc3MgPSBkZXByZWNhdGVDbGFzc18xLmRlcHJlY2F0ZUNsYXNzO1xuZXhwb3J0cy5kZXByZWNhdGVDbGFzcyA9IF9fZXhwb3J0X2RlcHJlY2F0ZUNsYXNzO1xudmFyIG1hdGNoXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvbWF0Y2gvbWF0Y2hcIik7XG52YXIgX19leHBvcnRfbWF0Y2ggPSBtYXRjaF8xLm1hdGNoO1xuZXhwb3J0cy5tYXRjaCA9IF9fZXhwb3J0X21hdGNoO1xudmFyIF9fZXhwb3J0X2VxID0gbWF0Y2hfMS5lcTtcbmV4cG9ydHMuZXEgPSBfX2V4cG9ydF9lcTtcbnZhciBhcnJheVRvT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvb2JqZWN0L2FycmF5VG9PYmplY3RcIik7XG52YXIgX19leHBvcnRfYXJyYXlUb09iamVjdCA9IGFycmF5VG9PYmplY3RfMS5hcnJheVRvT2JqZWN0O1xuZXhwb3J0cy5hcnJheVRvT2JqZWN0ID0gX19leHBvcnRfYXJyYXlUb09iamVjdDtcbnZhciBlbnRyaWVzVG9PYmplY3RfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9vYmplY3QvZW50cmllc1RvT2JqZWN0XCIpO1xudmFyIF9fZXhwb3J0X2VudHJpZXNUb09iamVjdCA9IGVudHJpZXNUb09iamVjdF8xLmVudHJpZXNUb09iamVjdDtcbmV4cG9ydHMuZW50cmllc1RvT2JqZWN0ID0gX19leHBvcnRfZW50cmllc1RvT2JqZWN0O1xudmFyIGZvckVhY2hPYmplY3RFbnRyeV8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL29iamVjdC9mb3JFYWNoT2JqZWN0RW50cnlcIik7XG52YXIgX19leHBvcnRfZm9yRWFjaE9iamVjdEVudHJ5ID0gZm9yRWFjaE9iamVjdEVudHJ5XzEuZm9yRWFjaE9iamVjdEVudHJ5O1xuZXhwb3J0cy5mb3JFYWNoT2JqZWN0RW50cnkgPSBfX2V4cG9ydF9mb3JFYWNoT2JqZWN0RW50cnk7XG52YXIgaW5kZXhCeV8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL29iamVjdC9pbmRleEJ5XCIpO1xudmFyIF9fZXhwb3J0X2luZGV4QnkgPSBpbmRleEJ5XzEuaW5kZXhCeTtcbmV4cG9ydHMuaW5kZXhCeSA9IF9fZXhwb3J0X2luZGV4Qnk7XG52YXIgbWFwT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvb2JqZWN0L21hcE9iamVjdFwiKTtcbnZhciBfX2V4cG9ydF9tYXBPYmplY3QgPSBtYXBPYmplY3RfMS5tYXBPYmplY3Q7XG5leHBvcnRzLm1hcE9iamVjdCA9IF9fZXhwb3J0X21hcE9iamVjdDtcbnZhciBvbWl0XzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvb2JqZWN0L29taXRcIik7XG52YXIgX19leHBvcnRfb21pdCA9IG9taXRfMS5vbWl0O1xuZXhwb3J0cy5vbWl0ID0gX19leHBvcnRfb21pdDtcbnZhciBwaWNrXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvb2JqZWN0L3BpY2tcIik7XG52YXIgX19leHBvcnRfcGljayA9IHBpY2tfMS5waWNrO1xuZXhwb3J0cy5waWNrID0gX19leHBvcnRfcGljaztcbnZhciBkZWxheV8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25zL3Byb21pc2UvZGVsYXlcIik7XG52YXIgX19leHBvcnRfZGVsYXkgPSBkZWxheV8xLmRlbGF5O1xuZXhwb3J0cy5kZWxheSA9IF9fZXhwb3J0X2RlbGF5O1xudmFyIHBhZExlZnRfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9zdHJpbmcvcGFkTGVmdFwiKTtcbnZhciBfX2V4cG9ydF9wYWRMZWZ0ID0gcGFkTGVmdF8xLnBhZExlZnQ7XG5leHBvcnRzLnBhZExlZnQgPSBfX2V4cG9ydF9wYWRMZWZ0O1xudmFyIHNwbGl0V2l0aExpbWl0XzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvc3RyaW5nL3NwbGl0V2l0aExpbWl0XCIpO1xudmFyIF9fZXhwb3J0X3NwbGl0V2l0aExpbWl0ID0gc3BsaXRXaXRoTGltaXRfMS5zcGxpdFdpdGhMaW1pdDtcbmV4cG9ydHMuc3BsaXRXaXRoTGltaXQgPSBfX2V4cG9ydF9zcGxpdFdpdGhMaW1pdDtcbnZhciB1dGY4TGVuZ3RoXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvc3RyaW5nL3V0ZjhMZW5ndGhcIik7XG52YXIgX19leHBvcnRfdXRmOExlbmd0aCA9IHV0ZjhMZW5ndGhfMS51dGY4TGVuZ3RoO1xuZXhwb3J0cy51dGY4TGVuZ3RoID0gX19leHBvcnRfdXRmOExlbmd0aDtcbnZhciB1dGY4U3Vic3RyaW5nXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnMvc3RyaW5nL3V0ZjhTdWJzdHJpbmdcIik7XG52YXIgX19leHBvcnRfdXRmOFN1YnN0cmluZyA9IHV0ZjhTdWJzdHJpbmdfMS51dGY4U3Vic3RyaW5nO1xuZXhwb3J0cy51dGY4U3Vic3RyaW5nID0gX19leHBvcnRfdXRmOFN1YnN0cmluZztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW51bWVyYWJsZSA9IF9fZXhwb3J0X0VudW1lcmFibGU7XG5leHBvcnRzLk5vbkVudW1lcmFibGUgPSBfX2V4cG9ydF9Ob25FbnVtZXJhYmxlO1xuZXhwb3J0cy5mbGF0dGVuID0gX19leHBvcnRfZmxhdHRlbjtcbmV4cG9ydHMucmVzb2x2ZUNvbmZpZ1ZhbHVlID0gX19leHBvcnRfcmVzb2x2ZUNvbmZpZ1ZhbHVlO1xuZXhwb3J0cy5kZXByZWNhdGVDbGFzcyA9IF9fZXhwb3J0X2RlcHJlY2F0ZUNsYXNzO1xuZXhwb3J0cy5tYXRjaCA9IF9fZXhwb3J0X21hdGNoO1xuZXhwb3J0cy5lcSA9IF9fZXhwb3J0X2VxO1xuZXhwb3J0cy5hcnJheVRvT2JqZWN0ID0gX19leHBvcnRfYXJyYXlUb09iamVjdDtcbmV4cG9ydHMuZW50cmllc1RvT2JqZWN0ID0gX19leHBvcnRfZW50cmllc1RvT2JqZWN0O1xuZXhwb3J0cy5mb3JFYWNoT2JqZWN0RW50cnkgPSBfX2V4cG9ydF9mb3JFYWNoT2JqZWN0RW50cnk7XG5leHBvcnRzLmluZGV4QnkgPSBfX2V4cG9ydF9pbmRleEJ5O1xuZXhwb3J0cy5tYXBPYmplY3QgPSBfX2V4cG9ydF9tYXBPYmplY3Q7XG5leHBvcnRzLm9taXQgPSBfX2V4cG9ydF9vbWl0O1xuZXhwb3J0cy5waWNrID0gX19leHBvcnRfcGljaztcbmV4cG9ydHMuZGVsYXkgPSBfX2V4cG9ydF9kZWxheTtcbmV4cG9ydHMucGFkTGVmdCA9IF9fZXhwb3J0X3BhZExlZnQ7XG5leHBvcnRzLnNwbGl0V2l0aExpbWl0ID0gX19leHBvcnRfc3BsaXRXaXRoTGltaXQ7XG5leHBvcnRzLnV0ZjhMZW5ndGggPSBfX2V4cG9ydF91dGY4TGVuZ3RoO1xuZXhwb3J0cy51dGY4U3Vic3RyaW5nID0gX19leHBvcnRfdXRmOFN1YnN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsc1xuXHRBdG9taWNzLFxuXHRTaGFyZWRBcnJheUJ1ZmZlcixcbiovXG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3ICRUeXBlRXJyb3IoKTsgfTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbnZhciBnZW5lcmF0b3I7IC8vID0gZnVuY3Rpb24gKiAoKSB7fTtcbnZhciBnZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvciA/IGdldFByb3RvKGdlbmVyYXRvcikgOiB1bmRlZmluZWQ7XG52YXIgYXN5bmNGbjsgLy8gYXN5bmMgZnVuY3Rpb24oKSB7fTtcbnZhciBhc3luY0Z1bmN0aW9uID0gYXN5bmNGbiA/IGFzeW5jRm4uY29uc3RydWN0b3IgOiB1bmRlZmluZWQ7XG52YXIgYXN5bmNHZW47IC8vIGFzeW5jIGZ1bmN0aW9uICogKCkge307XG52YXIgYXN5bmNHZW5GdW5jdGlvbiA9IGFzeW5jR2VuID8gZ2V0UHJvdG8oYXN5bmNHZW4pIDogdW5kZWZpbmVkO1xudmFyIGFzeW5jR2VuSXRlcmF0b3IgPSBhc3luY0dlbiA/IGFzeW5jR2VuKCkgOiB1bmRlZmluZWQ7XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIucHJvdG90eXBlLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXJyYXlQcm90b3R5cGUlJzogQXJyYXkucHJvdG90eXBlLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBBcnJheS5wcm90b3R5cGUuZW50cmllcyxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogQXJyYXkucHJvdG90eXBlLmZvckVhY2gsXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IEFycmF5LnByb3RvdHlwZS5rZXlzLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IEFycmF5LnByb3RvdHlwZS52YWx1ZXMsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IGFzeW5jRnVuY3Rpb24sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBhc3luY0Z1bmN0aW9uID8gYXN5bmNGdW5jdGlvbi5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogYXN5bmNHZW4gPyBnZXRQcm90byhhc3luY0dlbkl0ZXJhdG9yKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IGFzeW5jR2VuRnVuY3Rpb24sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogYXN5bmNHZW5GdW5jdGlvbiA/IGFzeW5jR2VuRnVuY3Rpb24ucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogYXN5bmNHZW5JdGVyYXRvciAmJiBoYXNTeW1ib2xzICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yID8gYXN5bmNHZW5JdGVyYXRvcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSA6IHVuZGVmaW5lZCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogQm9vbGVhbi5wcm90b3R5cGUsXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldy5wcm90b3R5cGUsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJURhdGVQcm90b3R5cGUlJzogRGF0ZS5wcm90b3R5cGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVFcnJvclByb3RvdHlwZSUnOiBFcnJvci5wcm90b3R5cGUsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBFdmFsRXJyb3IucHJvdG90eXBlLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXkucHJvdG90eXBlLFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXkucHJvdG90eXBlLFxuXHQnJUZ1bmN0aW9uJSc6IEZ1bmN0aW9uLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IEZ1bmN0aW9uLnByb3RvdHlwZSxcblx0JyVHZW5lcmF0b3IlJzogZ2VuZXJhdG9yID8gZ2V0UHJvdG8oZ2VuZXJhdG9yKCkpIDogdW5kZWZpbmVkLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IGdlbmVyYXRvckZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBnZW5lcmF0b3JGdW5jdGlvbiA/IGdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LnByb3RvdHlwZSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXkucHJvdG90eXBlLFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXkucHJvdG90eXBlLFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclSlNPTlBhcnNlJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04ucGFyc2UgOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWFwUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLnByb3RvdHlwZSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogTnVtYmVyLnByb3RvdHlwZSxcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBPYmplY3QucHJvdG90eXBlLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UucHJvdG90eXBlLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UucHJvdG90eXBlLnRoZW4sXG5cdCclUHJvbWlzZV9hbGwlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZS5hbGwsXG5cdCclUHJvbWlzZV9yZWplY3QlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZS5yZWplY3QsXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UucmVzb2x2ZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogUmFuZ2VFcnJvci5wcm90b3R5cGUsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogUmVmZXJlbmNlRXJyb3IucHJvdG90eXBlLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBSZWdFeHAucHJvdG90eXBlLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNldFByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldC5wcm90b3R5cGUsXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlci5wcm90b3R5cGUsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogU3RyaW5nLnByb3RvdHlwZSxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogU3ludGF4RXJyb3IsXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogU3ludGF4RXJyb3IucHJvdG90eXBlLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFR5cGVkQXJyYXkgPyBUeXBlZEFycmF5LnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogJFR5cGVFcnJvci5wcm90b3R5cGUsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheS5wcm90b3R5cGUsXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheS5wcm90b3R5cGUsXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheS5wcm90b3R5cGUsXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheS5wcm90b3R5cGUsXG5cdCclVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogVVJJRXJyb3IucHJvdG90eXBlLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAucHJvdG90eXBlLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldCxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXQucHJvdG90eXBlXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKCEobmFtZSBpbiBJTlRSSU5TSUNTKSkge1xuXHRcdHRocm93IG5ldyBTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcblx0fVxuXG5cdC8vIGlzdGFuYnVsIGlnbm9yZSBpZiAvLyBob3BlZnVsbHkgdGhpcyBpcyBpbXBvc3NpYmxlIHRvIHRlc3QgOi0pXG5cdGlmICh0eXBlb2YgSU5UUklOU0lDU1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHR9XG5cblx0cmV0dXJuIElOVFJJTlNJQ1NbbmFtZV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblxuXHR2YXIgdmFsdWUgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIChwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJykgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdGZvciAodmFyIGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnRzW2ldKTtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcgJiYgIShwYXJ0c1tpXSBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IGRlc2MgPyAoZGVzYy5nZXQgfHwgZGVzYy52YWx1ZSkgOiB2YWx1ZVtwYXJ0c1tpXV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRzW2ldXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG4vKiogQHByaXZhdGUgKi9cbnZhciBCYXNlQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VBUEkoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIEJhc2VBUEkucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQmFzZUFQSTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQmFzZUFQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VBUEk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbnZhciBjYWNoZV9kZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzXCIpO1xudmFyIGNyb3NzX2ZldGNoXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jcm9zcy1mZXRjaFwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL2xvZ2dlclwiKTtcbnZhciBxc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvcXNcIik7XG52YXIgQWNjZXNzVG9rZW5fMSA9IHJlcXVpcmUoXCIuL0FQSS9BY2Nlc3NUb2tlblwiKTtcbnZhciBCYWRnZXNBUElfMSA9IHJlcXVpcmUoXCIuL0FQSS9CYWRnZXMvQmFkZ2VzQVBJXCIpO1xudmFyIEhlbGl4QVBJR3JvdXBfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9IZWxpeEFQSUdyb3VwXCIpO1xudmFyIEhlbGl4UmF0ZUxpbWl0ZXJfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9IZWxpeFJhdGVMaW1pdGVyXCIpO1xudmFyIENoZWVybW90ZUxpc3RfMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vQml0cy9DaGVlcm1vdGVMaXN0XCIpO1xudmFyIEtyYWtlbkFQSUdyb3VwXzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL0tyYWtlbkFQSUdyb3VwXCIpO1xudmFyIFRva2VuSW5mb18xID0gcmVxdWlyZShcIi4vQVBJL1Rva2VuSW5mb1wiKTtcbnZhciBVbnN1cHBvcnRlZEFQSV8xID0gcmVxdWlyZShcIi4vQVBJL1Vuc3VwcG9ydGVkL1Vuc3VwcG9ydGVkQVBJXCIpO1xudmFyIENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9BdXRoL0NsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyXCIpO1xudmFyIFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9BdXRoL1JlZnJlc2hhYmxlQXV0aFByb3ZpZGVyXCIpO1xudmFyIFN0YXRpY0F1dGhQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vQXV0aC9TdGF0aWNBdXRoUHJvdmlkZXJcIik7XG52YXIgQ29uZmlnRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0Vycm9ycy9Db25maWdFcnJvclwiKTtcbnZhciBIVFRQU3RhdHVzQ29kZUVycm9yXzEgPSByZXF1aXJlKFwiLi9FcnJvcnMvSFRUUFN0YXR1c0NvZGVFcnJvclwiKTtcbnZhciBJbnZhbGlkVG9rZW5FcnJvcl8xID0gcmVxdWlyZShcIi4vRXJyb3JzL0ludmFsaWRUb2tlbkVycm9yXCIpO1xuLyoqXG4gKiBUaGUgZW5kcG9pbnQgdG8gY2FsbCwgaS5lLiAva3Jha2VuLCAvaGVsaXggb3IgYSBjdXN0b20gKHBvdGVudGlhbGx5IHVuc3VwcG9ydGVkKSBlbmRwb2ludC5cbiAqL1xudmFyIFR3aXRjaEFQSUNhbGxUeXBlO1xuKGZ1bmN0aW9uIChUd2l0Y2hBUElDYWxsVHlwZSkge1xuICAgIC8qKlxuICAgICAqIENhbGwgYSBLcmFrZW4gQVBJIGVuZHBvaW50LlxuICAgICAqL1xuICAgIFR3aXRjaEFQSUNhbGxUeXBlW1R3aXRjaEFQSUNhbGxUeXBlW1wiS3Jha2VuXCJdID0gMF0gPSBcIktyYWtlblwiO1xuICAgIC8qKlxuICAgICAqIENhbGwgYSBIZWxpeCBBUEkgZW5kcG9pbnQuXG4gICAgICovXG4gICAgVHdpdGNoQVBJQ2FsbFR5cGVbVHdpdGNoQVBJQ2FsbFR5cGVbXCJIZWxpeFwiXSA9IDFdID0gXCJIZWxpeFwiO1xuICAgIC8qKlxuICAgICAqIENhbGwgYW4gYXV0aGVudGljYXRpb24gZW5kcG9pbnQuXG4gICAgICovXG4gICAgVHdpdGNoQVBJQ2FsbFR5cGVbVHdpdGNoQVBJQ2FsbFR5cGVbXCJBdXRoXCJdID0gMl0gPSBcIkF1dGhcIjtcbiAgICAvKipcbiAgICAgKiBDYWxsIGEgY3VzdG9tIChwb3RlbnRpYWxseSB1bnN1cHBvcnRlZCkgZW5kcG9pbnQuXG4gICAgICovXG4gICAgVHdpdGNoQVBJQ2FsbFR5cGVbVHdpdGNoQVBJQ2FsbFR5cGVbXCJDdXN0b21cIl0gPSAzXSA9IFwiQ3VzdG9tXCI7XG59KShUd2l0Y2hBUElDYWxsVHlwZSB8fCAoVHdpdGNoQVBJQ2FsbFR5cGUgPSB7fSkpO1xuZXhwb3J0cy5Ud2l0Y2hBUElDYWxsVHlwZSA9IFR3aXRjaEFQSUNhbGxUeXBlO1xuLyoqXG4gKiBUaGUgbWFpbiBlbnRyeSBwb2ludCBvZiB0aGlzIGxpYnJhcnkuIE1hbmFnZXMgQVBJIGNhbGxzIGFuZCB0aGUgdXNlIG9mIGFjY2VzcyB0b2tlbnMgaW4gdGhlc2UuXG4gKi9cbnZhciBUd2l0Y2hDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUd2l0Y2ggY2xpZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uIGZvciB0aGUgY2xpZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFR3aXRjaENsaWVudChjb25maWcpIHtcbiAgICAgICAgdmFyIGF1dGhQcm92aWRlciA9IGNvbmZpZy5hdXRoUHJvdmlkZXIsIHJlc3RDb25maWcgPSB0c2xpYl8xLl9fcmVzdChjb25maWcsIFtcImF1dGhQcm92aWRlclwiXSk7XG4gICAgICAgIGlmICghYXV0aFByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29uZmlnRXJyb3JfMS5kZWZhdWx0KCdObyBhdXRoIHByb3ZpZGVyIGdpdmVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVsaXhSYXRlTGltaXRlciA9IG5ldyBIZWxpeFJhdGVMaW1pdGVyXzEuZGVmYXVsdChjb25maWcubG9nTGV2ZWwgfHwgbG9nZ2VyXzEuTG9nTGV2ZWwuQ1JJVElDQUwpO1xuICAgICAgICB0aGlzLl9jb25maWcgPSB0c2xpYl8xLl9fYXNzaWduKHsgcHJlQXV0aDogZmFsc2UsIGNoZWVybW90ZXM6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QmFja2dyb3VuZDogQ2hlZXJtb3RlTGlzdF8xLkNoZWVybW90ZUJhY2tncm91bmQuZGFyayxcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGU6IENoZWVybW90ZUxpc3RfMS5DaGVlcm1vdGVTdGF0ZS5hbmltYXRlZCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0U2NhbGU6IENoZWVybW90ZUxpc3RfMS5DaGVlcm1vdGVTY2FsZS54MVxuICAgICAgICAgICAgfSwgYXV0aFByb3ZpZGVyOiBhdXRoUHJvdmlkZXIgfSwgcmVzdENvbmZpZyk7XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcucHJlQXV0aCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICBhdXRoUHJvdmlkZXIuZ2V0QWNjZXNzVG9rZW4odGhpcy5fY29uZmlnLmluaXRpYWxTY29wZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFR3aXRjaENsaWVudF8xID0gVHdpdGNoQ2xpZW50O1xuICAgIC8vIFRPRE8gNS4wOiBjb25maWcgb2JqZWN0IVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugd2l0aCBmaXhlZCBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnRJZCBUaGUgY2xpZW50IElEIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIFRoZSBhY2Nlc3MgdG9rZW4gdG8gY2FsbCB0aGUgQVBJIHdpdGguXG4gICAgICpcbiAgICAgKiBZb3UgbmVlZCB0byBvYnRhaW4gb25lIHVzaW5nIG9uZSBvZiB0aGUgW1R3aXRjaCBPQXV0aCBmbG93c10oaHR0cHM6Ly9kZXYudHdpdGNoLnR2L2RvY3MvYXV0aGVudGljYXRpb24vZ2V0dGluZy10b2tlbnMtb2F1dGgvKS5cbiAgICAgKiBAcGFyYW0gc2NvcGVzIFRoZSBzY29wZXMgeW91ciBzdXBwbGllZCB0b2tlbiBoYXMuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgc2NvcGVzIG5lZWQgdG8gYmUgY29ycmVjdCwgb3Igd2VpcmQgdGhpbmdzIG1pZ2h0IGhhcHBlbi4gSWYgaXQncyBub3QgKGkuZS4gaXQncyBgdW5kZWZpbmVkYCksIHdlIGZldGNoIHRoZSBjb3JyZWN0IHNjb3BlcyBmb3IgeW91LlxuICAgICAqXG4gICAgICogSWYgeW91IGNhbid0IGV4YWN0bHkgc2F5IHdoaWNoIHNjb3BlcyB5b3VyIHRva2VuIGhhcywgZG9uJ3QgdXNlIHRoaXMgcGFyYW1ldGVyL3NldCBpdCB0byBgdW5kZWZpbmVkYC5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaENvbmZpZyBDb25maWd1cmF0aW9uIHRvIGF1dG9tYXRpY2FsbHkgcmVmcmVzaCBleHBpcmVkIHRva2Vucy5cbiAgICAgKiBAcGFyYW0gY29uZmlnIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpZiB5b3UgcHJvdmlkZSBhIGN1c3RvbSBgYXV0aFByb3ZpZGVyYCwgdGhpcyBtZXRob2Qgd2lsbCBvdmVyd3JpdGUgaXQuIEluIHRoaXMgY2FzZSwgeW91IHNob3VsZCB1c2UgdGhlIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICAgICAqIEBwYXJhbSB0b2tlblR5cGUgVGhlIHR5cGUgb2YgdG9rZW4geW91IHBhc3NlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIGFsbW9zdCBhbHdheXMgYmUgJ3VzZXInICh3aGljaCBpcyB0aGUgZGVmYXVsdCkuXG4gICAgICpcbiAgICAgKiBJZiB5b3UncmUgcGFzc2luZyAnYXBwJyBoZXJlLCBwbGVhc2UgY29uc2lkZXIgdXNpbmcge0BUd2l0Y2hDbGllbnQud2l0aENsaWVudENyZWRlbnRpYWxzfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbiAoY2xpZW50SWQsIGFjY2Vzc1Rva2VuLCBzY29wZXMsIHJlZnJlc2hDb25maWcsIGNvbmZpZywgdG9rZW5UeXBlKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICBpZiAodG9rZW5UeXBlID09PSB2b2lkIDApIHsgdG9rZW5UeXBlID0gJ3VzZXInOyB9XG4gICAgICAgIHZhciBhdXRoUHJvdmlkZXIgPSByZWZyZXNoQ29uZmlnXG4gICAgICAgICAgICA/IG5ldyBSZWZyZXNoYWJsZUF1dGhQcm92aWRlcl8xLmRlZmF1bHQobmV3IFN0YXRpY0F1dGhQcm92aWRlcl8xLmRlZmF1bHQoY2xpZW50SWQsIGFjY2Vzc1Rva2VuLCBzY29wZXMsIHRva2VuVHlwZSksIHJlZnJlc2hDb25maWcpXG4gICAgICAgICAgICA6IG5ldyBTdGF0aWNBdXRoUHJvdmlkZXJfMS5kZWZhdWx0KGNsaWVudElkLCBhY2Nlc3NUb2tlbiwgc2NvcGVzLCB0b2tlblR5cGUpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXModHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBjb25maWcpLCB7IGF1dGhQcm92aWRlcjogYXV0aFByb3ZpZGVyIH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugd2l0aCBjbGllbnQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBjbGllbnRTZWNyZXQgVGhlIGNsaWVudCBzZWNyZXQgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gY29uZmlnIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpZiB5b3UgcHJvdmlkZSBhIGN1c3RvbSBgYXV0aFByb3ZpZGVyYCwgdGhpcyBtZXRob2Qgd2lsbCBvdmVyd3JpdGUgaXQuIEluIHRoaXMgY2FzZSwgeW91IHNob3VsZCB1c2UgdGhlIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIFR3aXRjaENsaWVudC53aXRoQ2xpZW50Q3JlZGVudGlhbHMgPSBmdW5jdGlvbiAoY2xpZW50SWQsIGNsaWVudFNlY3JldCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICB2YXIgYXV0aFByb3ZpZGVyID0gY2xpZW50U2VjcmV0XG4gICAgICAgICAgICA/IG5ldyBDbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlcl8xLmRlZmF1bHQoY2xpZW50SWQsIGNsaWVudFNlY3JldClcbiAgICAgICAgICAgIDogbmV3IFN0YXRpY0F1dGhQcm92aWRlcl8xLmRlZmF1bHQoY2xpZW50SWQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXModHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBjb25maWcpLCB7IGF1dGhQcm92aWRlcjogYXV0aFByb3ZpZGVyIH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgY2FsbCB0byB0aGUgVHdpdGNoIEFQSSB1c2luZyBnaXZlbiBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBjYWxsLlxuICAgICAqIEBwYXJhbSBjbGllbnRJZCBUaGUgY2xpZW50IElEIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIFRoZSBhY2Nlc3MgdG9rZW4gdG8gY2FsbCB0aGUgQVBJIHdpdGguXG4gICAgICpcbiAgICAgKiBZb3UgbmVlZCB0byBvYnRhaW4gb25lIHVzaW5nIG9uZSBvZiB0aGUgW1R3aXRjaCBPQXV0aCBmbG93c10oaHR0cHM6Ly9kZXYudHdpdGNoLnR2L2RvY3MvYXV0aGVudGljYXRpb24vZ2V0dGluZy10b2tlbnMtb2F1dGgvKS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIFR3aXRjaENsaWVudC5jYWxsQVBJID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNsaWVudElkLCBhY2Nlc3NUb2tlbikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jYWxsQVBJUmF3KG9wdGlvbnMsIGNsaWVudElkLCBhY2Nlc3NUb2tlbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl90cmFuc2Zvcm1SZXNwb25zZShyZXNwb25zZSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhY2Nlc3MgdG9rZW4gd2l0aCB5b3VyIGNsaWVudCBjcmVkZW50aWFscyBhbmQgYW4gYXV0aG9yaXphdGlvbiBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudElkIFRoZSBjbGllbnQgSUQgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gY2xpZW50U2VjcmV0IFRoZSBjbGllbnQgc2VjcmV0IG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIGNvZGUgVGhlIGF1dGhvcml6YXRpb24gY29kZS5cbiAgICAgKiBAcGFyYW0gcmVkaXJlY3RVcmkgVGhlIHJlZGlyZWN0IFVSSS4gVGhpcyBzZXJ2ZXMgbm8gcmVhbCBwdXJwb3NlIGhlcmUsIGJ1dCBtdXN0IHN0aWxsIG1hdGNoIHdpdGggdGhlIHJlZGlyZWN0IFVSSSB5b3UgY29uZmlndXJlZCBpbiB0aGUgVHdpdGNoIERldmVsb3BlciBkYXNoYm9hcmQuXG4gICAgICovXG4gICAgVHdpdGNoQ2xpZW50LmdldEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKGNsaWVudElkLCBjbGllbnRTZWNyZXQsIGNvZGUsIHJlZGlyZWN0VXJpKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IEFjY2Vzc1Rva2VuXzEuZGVmYXVsdC5iaW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQVBJQ2FsbFR5cGUuQXV0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAndG9rZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50X2lkOiBjbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IGNsaWVudFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdF91cmk6IHJlZGlyZWN0VXJpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyAoX2EuYXBwbHkoQWNjZXNzVG9rZW5fMS5kZWZhdWx0LCBbdm9pZCAwLCBfYi5zZW50KCldKSkoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFwcCBhY2Nlc3MgdG9rZW4gd2l0aCB5b3VyIGNsaWVudCBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnRJZCBUaGUgY2xpZW50IElEIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIGNsaWVudFNlY3JldCBUaGUgY2xpZW50IHNlY3JldCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBjbGllbnRTZWNyZXRcbiAgICAgKi9cbiAgICBUd2l0Y2hDbGllbnQuZ2V0QXBwQWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAoY2xpZW50SWQsIGNsaWVudFNlY3JldCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBBY2Nlc3NUb2tlbl8xLmRlZmF1bHQuYmluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaEFQSUNhbGxUeXBlLkF1dGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3Rva2VuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFudF90eXBlOiAnY2xpZW50X2NyZWRlbnRpYWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9pZDogY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiBjbGllbnRTZWNyZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IChfYS5hcHBseShBY2Nlc3NUb2tlbl8xLmRlZmF1bHQsIFt2b2lkIDAsIF9iLnNlbnQoKV0pKSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgYW4gZXhwaXJlZCBhY2Nlc3MgdG9rZW4gd2l0aCB5b3VyIGNsaWVudCBjcmVkZW50aWFscyBhbmQgdGhlIHJlZnJlc2ggdG9rZW4gdGhhdCB3YXMgZ2l2ZW4gYnkgdGhlIGluaXRpYWwgYXV0aGVudGljYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBjbGllbnRTZWNyZXQgVGhlIGNsaWVudCBzZWNyZXQgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIFRoZSByZWZyZXNoIHRva2VuLlxuICAgICAqL1xuICAgIFR3aXRjaENsaWVudC5yZWZyZXNoQWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAoY2xpZW50SWQsIGNsaWVudFNlY3JldCwgcmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IEFjY2Vzc1Rva2VuXzEuZGVmYXVsdC5iaW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQVBJQ2FsbFR5cGUuQXV0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAndG9rZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9pZDogY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiBjbGllbnRTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IChfYS5hcHBseShBY2Nlc3NUb2tlbl8xLmRlZmF1bHQsIFt2b2lkIDAsIF9iLnNlbnQoKV0pKSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgYW4gYWNjZXNzIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudElkIFRoZSBjbGllbnQgSUQgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gVGhlIGFjY2VzcyB0b2tlbiB0byBnZXQgdGhlIGluZm9ybWF0aW9uIG9mLlxuICAgICAqXG4gICAgICogWW91IG5lZWQgdG8gb2J0YWluIG9uZSB1c2luZyBvbmUgb2YgdGhlIFtUd2l0Y2ggT0F1dGggZmxvd3NdKGh0dHBzOi8vZGV2LnR3aXRjaC50di9kb2NzL2F1dGhlbnRpY2F0aW9uL2dldHRpbmctdG9rZW5zLW9hdXRoLykuXG4gICAgICovXG4gICAgVHdpdGNoQ2xpZW50LmdldFRva2VuSW5mbyA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgY2xpZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSwgZV8xO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsQVBJKHsgdHlwZTogVHdpdGNoQVBJQ2FsbFR5cGUuQXV0aCwgdXJsOiAndmFsaWRhdGUnIH0sIGNsaWVudElkLCBhY2Nlc3NUb2tlbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBUb2tlbkluZm9fMS5kZWZhdWx0KGRhdGEpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSBpbnN0YW5jZW9mIEhUVFBTdGF0dXNDb2RlRXJyb3JfMS5kZWZhdWx0ICYmIGVfMS5zdGF0dXNDb2RlID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuRXJyb3JfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXzE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHdpdGNoQ2xpZW50Ll9jYWxsQVBJUmF3ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNsaWVudElkLCBhY2Nlc3NUb2tlbikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlLCB1cmwsIHBhcmFtcywgaGVhZGVycywgYm9keSwgcmVxdWVzdE9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gb3B0aW9ucy50eXBlID09PSB1bmRlZmluZWQgPyBUd2l0Y2hBUElDYWxsVHlwZS5LcmFrZW4gOiBvcHRpb25zLnR5cGU7XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5fZ2V0VXJsKG9wdGlvbnMudXJsLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBxc18xLnN0cmluZ2lmeShvcHRpb25zLnF1ZXJ5LCB7IGFycmF5Rm9ybWF0OiAncmVwZWF0JyB9KTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gbmV3IGNyb3NzX2ZldGNoXzEuSGVhZGVycyh7XG4gICAgICAgICAgICAgICAgICAgIEFjY2VwdDogdHlwZSA9PT0gVHdpdGNoQVBJQ2FsbFR5cGUuS3Jha2VuXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiYXBwbGljYXRpb24vdm5kLnR3aXRjaHR2LnZcIiArIChvcHRpb25zLnZlcnNpb24gfHwgNSkgKyBcIitqc29uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gcXNfMS5zdHJpbmdpZnkob3B0aW9ucy5ib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5qc29uQm9keSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5qc29uQm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50SWQgJiYgdHlwZSAhPT0gVHdpdGNoQVBJQ2FsbFR5cGUuQXV0aCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZCgnQ2xpZW50LUlEJywgY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoJ0F1dGhvcml6YXRpb24nLCAodHlwZSA9PT0gVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXggPyAnQmVhcmVyJyA6ICdPQXV0aCcpICsgXCIgXCIgKyBhY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY3Jvc3NfZmV0Y2hfMS5kZWZhdWx0KHBhcmFtcyA/IHVybCArIFwiP1wiICsgcGFyYW1zIDogdXJsLCByZXF1ZXN0T3B0aW9ucyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IHlvdXIgYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIFR3aXRjaENsaWVudC5wcm90b3R5cGUuZ2V0VG9rZW5JbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBlXzI7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNhbGxBUEkoeyB0eXBlOiBUd2l0Y2hBUElDYWxsVHlwZS5BdXRoLCB1cmw6ICd2YWxpZGF0ZScgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBUb2tlbkluZm9fMS5kZWZhdWx0KGRhdGEpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8yID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMiBpbnN0YW5jZW9mIEhUVFBTdGF0dXNDb2RlRXJyb3JfMS5kZWZhdWx0ICYmIGVfMi5zdGF0dXNDb2RlID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuRXJyb3JfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXzI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhY2Nlc3MgdG9rZW4gZm9yIHRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY29wZXMgVGhlIHNjb3BlcyB0byByZXF1ZXN0LlxuICAgICAqL1xuICAgIFR3aXRjaENsaWVudC5wcm90b3R5cGUuZ2V0QWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAoc2NvcGVzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NvbmZpZy5hdXRoUHJvdmlkZXIuZ2V0QWNjZXNzVG9rZW4oc2NvcGVzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHRvIHJlZnJlc2ggdGhlIGFjY2VzcyB0b2tlbiwgaWYgcG9zc2libGUuXG4gICAgICovXG4gICAgVHdpdGNoQ2xpZW50LnByb3RvdHlwZS5yZWZyZXNoQWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NvbmZpZy5hdXRoUHJvdmlkZXIucmVmcmVzaCAmJiB0aGlzLl9jb25maWcuYXV0aFByb3ZpZGVyLnJlZnJlc2goKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpdGNoQ2xpZW50LnByb3RvdHlwZSwgXCJ0b2tlblR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdG9rZW4gdXNlZCBieSB0aGUgY2xpZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnLmF1dGhQcm92aWRlci50b2tlblR5cGUgfHwgJ3VzZXInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNhbGwgdG8gdGhlIFR3aXRjaCBBUEkgdXNpbmcgeW91ciBhY2Nlc3MgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgY2FsbC5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIFR3aXRjaENsaWVudC5wcm90b3R5cGUuY2FsbEFQSSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF1dGhQcm92aWRlciwgYWNjZXNzVG9rZW4sIHJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoUHJvdmlkZXIgPSB0aGlzLl9jb25maWcuYXV0aFByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYXV0aFByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKG9wdGlvbnMuc2NvcGUgPyBbb3B0aW9ucy5zY29wZV0gOiB1bmRlZmluZWQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFR3aXRjaENsaWVudF8xLmNhbGxBUEkob3B0aW9ucywgYXV0aFByb3ZpZGVyLmNsaWVudElkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhY2Nlc3NUb2tlbi5pc0V4cGlyZWQgJiYgYXV0aFByb3ZpZGVyLnJlZnJlc2gpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGF1dGhQcm92aWRlci5yZWZyZXNoKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jYWxsQVBJSW50ZXJuYWwob3B0aW9ucywgYXV0aFByb3ZpZGVyLmNsaWVudElkLCBhY2Nlc3NUb2tlbi5hY2Nlc3NUb2tlbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxICYmIGF1dGhQcm92aWRlci5yZWZyZXNoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBhdXRoUHJvdmlkZXIucmVmcmVzaCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYXV0aFByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKG9wdGlvbnMuc2NvcGUgPyBbb3B0aW9ucy5zY29wZV0gOiBbXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2FsbEFQSUludGVybmFsKG9wdGlvbnMsIGF1dGhQcm92aWRlci5jbGllbnRJZCwgYWNjZXNzVG9rZW4uYWNjZXNzVG9rZW4pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFR3aXRjaENsaWVudF8xLl90cmFuc2Zvcm1SZXNwb25zZShyZXNwb25zZSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2l0Y2hDbGllbnQucHJvdG90eXBlLCBcImNoZWVybW90ZURlZmF1bHRzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHNwZWNzIGZvciBjaGVlcm1vdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnLmNoZWVybW90ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2l0Y2hDbGllbnQucHJvdG90eXBlLCBcImtyYWtlblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGdyb3VwIG9mIEtyYWtlbiBBUEkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLcmFrZW5BUElHcm91cF8xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2l0Y2hDbGllbnQucHJvdG90eXBlLCBcImhlbGl4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZ3JvdXAgb2YgSGVsaXggQVBJIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVsaXhBUElHcm91cF8xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2l0Y2hDbGllbnQucHJvdG90eXBlLCBcImJhZGdlc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggYmFkZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJhZGdlc0FQSV8xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2l0Y2hDbGllbnQucHJvdG90eXBlLCBcInVuc3VwcG9ydGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhcmlvdXMgQVBJIG1ldGhvZHMgdGhhdCBhcmUgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkIGJ5IFR3aXRjaC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnN1cHBvcnRlZEFQSV8xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIFR3aXRjaENsaWVudC5wcm90b3R5cGUuX2dldEF1dGhQcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5hdXRoUHJvdmlkZXI7XG4gICAgfTtcbiAgICBUd2l0Y2hDbGllbnQucHJvdG90eXBlLl9jYWxsQVBJSW50ZXJuYWwgPSBmdW5jdGlvbiAob3B0aW9ucywgY2xpZW50SWQsIGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2hlbGl4UmF0ZUxpbWl0ZXIucmVxdWVzdCh7IG9wdGlvbnM6IG9wdGlvbnMsIGNsaWVudElkOiBjbGllbnRJZCwgYWNjZXNzVG9rZW46IGFjY2Vzc1Rva2VuIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFR3aXRjaENsaWVudF8xLl9jYWxsQVBJUmF3KG9wdGlvbnMsIGNsaWVudElkLCBhY2Nlc3NUb2tlbildO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHdpdGNoQ2xpZW50Ll9nZXRVcmwgPSBmdW5jdGlvbiAodXJsLCB0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUd2l0Y2hBUElDYWxsVHlwZS5LcmFrZW46XG4gICAgICAgICAgICBjYXNlIFR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4OlxuICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IHR5cGUgPT09IFR3aXRjaEFQSUNhbGxUeXBlLktyYWtlbiA/ICdrcmFrZW4nIDogJ2hlbGl4JztcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovL2FwaS50d2l0Y2gudHYvXCIgKyB0eXBlTmFtZSArIFwiL1wiICsgdXJsLnJlcGxhY2UoL15cXC8vLCAnJyk7XG4gICAgICAgICAgICBjYXNlIFR3aXRjaEFQSUNhbGxUeXBlLkF1dGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9pZC50d2l0Y2gudHYvb2F1dGgyL1wiICsgdXJsLnJlcGxhY2UoL15cXC8vLCAnJyk7XG4gICAgICAgICAgICBjYXNlIFR3aXRjaEFQSUNhbGxUeXBlLkN1c3RvbTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsOyAvLyB3YXRcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHdpdGNoQ2xpZW50Ll90cmFuc2Zvcm1SZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIHRleHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXJlc3BvbnNlLm9rKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gSFRUUFN0YXR1c0NvZGVFcnJvcl8xLmRlZmF1bHQuYmluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gW3ZvaWQgMCwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLmpzb24oKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogdGhyb3cgbmV3IChfYS5hcHBseShIVFRQU3RhdHVzQ29kZUVycm9yXzEuZGVmYXVsdCwgX2IuY29uY2F0KFtfYy5zZW50KCldKSkpKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07IC8vIG9vZlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UudGV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07IC8vIG1lZ2Egb29mIC0gdHdpdGNoIGRvZXNuJ3QgcmV0dXJuIGEgcmVzcG9uc2Ugd2hlbiBpdCBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBKU09OLnBhcnNlKHRleHQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgVHdpdGNoQ2xpZW50XzE7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgVHdpdGNoQ2xpZW50LnByb3RvdHlwZSwgXCJrcmFrZW5cIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgVHdpdGNoQ2xpZW50LnByb3RvdHlwZSwgXCJoZWxpeFwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBUd2l0Y2hDbGllbnQucHJvdG90eXBlLCBcImJhZGdlc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBUd2l0Y2hDbGllbnQucHJvdG90eXBlLCBcInVuc3VwcG9ydGVkXCIsIG51bGwpO1xuICAgIFR3aXRjaENsaWVudCA9IFR3aXRjaENsaWVudF8xID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIFR3aXRjaENsaWVudCk7XG4gICAgcmV0dXJuIFR3aXRjaENsaWVudDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUd2l0Y2hDbGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBUd2l0Y2hDbGllbnQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR3aXRjaEFQSUNhbGxUeXBlID0gVHdpdGNoQVBJQ2FsbFR5cGU7XG5leHBvcnRzLmRlZmF1bHQgPSBUd2l0Y2hDbGllbnQ7XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBfX3JlYWQsIF9fc3ByZWFkIH0gZnJvbSBcInRzbGliXCI7XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVDYWNoZUtleShwYXJhbSkge1xuICAgIC8vIG5vaW5zcGVjdGlvbiBGYWxsVGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICBzd2l0Y2ggKHR5cGVvZiBwYXJhbSkge1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOiB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICAgICAgaWYgKHBhcmFtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdjYWNoZUtleScgaW4gcGFyYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0uY2FjaGVLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2JqS2V5ID0gSlNPTi5zdHJpbmdpZnkocGFyYW0pO1xuICAgICAgICAgICAgaWYgKG9iaktleSAhPT0gJ3t9Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmpLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVDYWNoZUtleShwcm9wTmFtZSwgcGFyYW1zLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gX19zcHJlYWQoW3Byb3BOYW1lXSwgcGFyYW1zLm1hcChjcmVhdGVTaW5nbGVDYWNoZUtleSkpLmpvaW4oJy8nKSArIChwcmVmaXggPyAnLycgOiAnJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVDYWNoZUtleS5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBjcmVhdGVDYWNoZUtleSBmcm9tICcuLi91dGlscy9jcmVhdGVDYWNoZUtleSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDYWNoZWFibGUoY2xzKSB7XG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEZyb21DYWNoZSA9IGZ1bmN0aW9uIChjYWNoZUtleSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYW5DYWNoZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldENhY2hlID0gZnVuY3Rpb24gKGNhY2hlS2V5LCB2YWx1ZSwgdGltZUluU2Vjb25kcykge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoY2FjaGVLZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZXhwaXJlczogRGF0ZS5ub3coKSArIHRpbWVJblNlY29uZHMgKiAxMDAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUucmVtb3ZlRnJvbUNhY2hlID0gZnVuY3Rpb24gKGNhY2hlS2V5LCBwcmVmaXgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW50ZXJuYWxDYWNoZUtleTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FjaGVLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxDYWNoZUtleSA9IGNhY2hlS2V5O1xuICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxDYWNoZUtleS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsQ2FjaGVLZXkgKz0gJy8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IGNhY2hlS2V5LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxDYWNoZUtleSA9IGNyZWF0ZUNhY2hlS2V5KHByb3BOYW1lLCBjYWNoZUtleSwgcHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmZvckVhY2goZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChpbnRlcm5hbENhY2hlS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGludGVybmFsQ2FjaGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5fY2xlYW5DYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsLmV4cGlyZXMgPCBub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oY2xzKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZWFibGUuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IGNyZWF0ZUNhY2hlS2V5IGZyb20gJy4uL3V0aWxzL2NyZWF0ZUNhY2hlS2V5JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENhY2hlZCh0aW1lSW5TZWNvbmRzLCBjYWNoZUZhaWx1cmVzKSB7XG4gICAgaWYgKHRpbWVJblNlY29uZHMgPT09IHZvaWQgMCkgeyB0aW1lSW5TZWNvbmRzID0gSW5maW5pdHk7IH1cbiAgICBpZiAoY2FjaGVGYWlsdXJlcyA9PT0gdm9pZCAwKSB7IGNhY2hlRmFpbHVyZXMgPSBmYWxzZTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wTmFtZSwgZGVzY3JpcHRvcikge1xuICAgICAgICB2YXIgb3JpZ0ZuID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5LCBjYWNoZWRWYWx1ZSwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5ID0gY3JlYXRlQ2FjaGVLZXkocHJvcE5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkVmFsdWUgPSB0aGlzLmdldEZyb21DYWNoZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjYWNoZWRWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIG9yaWdGbi5hcHBseSh0aGlzLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsIHx8IGNhY2hlRmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDYWNoZShjYWNoZUtleSwgcmVzdWx0LCB0aW1lSW5TZWNvbmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGVkLmpzLm1hcCIsImltcG9ydCBjcmVhdGVDYWNoZUtleSBmcm9tICcuLi91dGlscy9jcmVhdGVDYWNoZUtleSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDYWNoZWRHZXR0ZXIodGltZUluU2Vjb25kcykge1xuICAgIGlmICh0aW1lSW5TZWNvbmRzID09PSB2b2lkIDApIHsgdGltZUluU2Vjb25kcyA9IEluZmluaXR5OyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3BOYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgICAgICAgdmFyIG9yaWdGbl8xID0gZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNyZWF0ZUNhY2hlS2V5KHByb3BOYW1lLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IHRoaXMuZ2V0RnJvbUNhY2hlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ0ZuXzEuYXBwbHkodGhpcywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENhY2hlKGNhY2hlS2V5LCByZXN1bHQsIHRpbWVJblNlY29uZHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZWRHZXR0ZXIuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciwgX19yZWFkLCBfX3NwcmVhZCB9IGZyb20gXCJ0c2xpYlwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2xlYXJzQ2FjaGUoY2FjaGVOYW1lLCBudW1iZXJPZkFyZ3VtZW50cykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wTmFtZSwgZGVzY3JpcHRvcikge1xuICAgICAgICB2YXIgb3JpZ0ZuID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCwgYXJncztcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgb3JpZ0ZuLmFwcGx5KHRoaXMsIHBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gbnVtYmVyT2ZBcmd1bWVudHMgPT09IHVuZGVmaW5lZCA/IHBhcmFtcy5zbGljZSgpIDogcGFyYW1zLnNsaWNlKDAsIG51bWJlck9mQXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21DYWNoZShfX3NwcmVhZChbY2FjaGVOYW1lXSwgYXJncyksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsZWFyc0NhY2hlLmpzLm1hcCIsImV4cG9ydCB7IGRlZmF1bHQgYXMgQ2FjaGVhYmxlIH0gZnJvbSAnLi9kZWNvcmF0b3JzL0NhY2hlYWJsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENhY2hlZCB9IGZyb20gJy4vZGVjb3JhdG9ycy9DYWNoZWQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYWNoZWRHZXR0ZXIgfSBmcm9tICcuL2RlY29yYXRvcnMvQ2FjaGVkR2V0dGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2xlYXJzQ2FjaGUgfSBmcm9tICcuL2RlY29yYXRvcnMvQ2xlYXJzQ2FjaGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjcmVhdGVDYWNoZUtleSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlQ2FjaGVLZXknO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEV4dHJhY3RzIHRoZSB1c2VyIElEIGZyb20gYW4gYXJndW1lbnQgdGhhdCBpcyBwb3NzaWJseSBhbiBvYmplY3QgY29udGFpbmluZyB0aGF0IElELlxuICpcbiAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIElEIG9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFVzZXJJZCh1c2VyKSB7XG4gICAgaWYgKHR5cGVvZiB1c2VyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHVzZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB1c2VyLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1c2VyLmlkO1xuICAgIH1cbn1cbmV4cG9ydHMuZXh0cmFjdFVzZXJJZCA9IGV4dHJhY3RVc2VySWQ7XG4vKipcbiAqIEV4dHJhY3RzIHRoZSB1c2VyIG5hbWUgZnJvbSBhbiBhcmd1bWVudCB0aGF0IGlzIHBvc3NpYmx5IGFuIG9iamVjdCBjb250YWluaW5nIHRoYXQgbmFtZS5cbiAqXG4gKiBAcGFyYW0gdXNlciBUaGUgdXNlciBuYW1lIG9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFVzZXJOYW1lKHVzZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHVzZXIgPT09ICdzdHJpbmcnID8gdXNlciA6IHVzZXIubmFtZTtcbn1cbmV4cG9ydHMuZXh0cmFjdFVzZXJOYW1lID0gZXh0cmFjdFVzZXJOYW1lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVM1VHlwZSA9IHJlcXVpcmUoJy4uLzUvVHlwZScpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZWNtYXNjcmlwdC1kYXRhLXR5cGVzLWFuZC12YWx1ZXNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUeXBlKHgpIHtcblx0aWYgKHR5cGVvZiB4ID09PSAnc3ltYm9sJykge1xuXHRcdHJldHVybiAnU3ltYm9sJztcblx0fVxuXHRyZXR1cm4gRVM1VHlwZSh4KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnLi9jYWxsQmluZCcpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSkge1xuXHRcdHJldHVybiBjYWxsQmluZChpbnRyaW5zaWMpO1xuXHR9XG5cdHJldHVybiBpbnRyaW5zaWM7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzbmV4dC5hc3luY2l0ZXJhYmxlXCIgLz5cbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9Ud2l0Y2hDbGllbnRcIik7XG5pZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChTeW1ib2wsICdhc3luY0l0ZXJhdG9yJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIFN5bWJvbC5hc3luY0l0ZXJhdG9yID0gU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgU3ltYm9sLmZvcignU3ltYm9sLmFzeW5jSXRlcmF0b3InKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlcXVlc3QgdG8gdGhlIG5ldyBUd2l0Y2ggQVBJIChIZWxpeCkgdGhhdCB1dGlsaXplcyBhIGN1cnNvciB0byBwYWdpbmF0ZSB0aHJvdWdoIGl0cyByZXN1bHRzLlxuICpcbiAqIEFzaWRlIGZyb20gdGhlIG1ldGhvZHMgZGVzY3JpYmVkIGJlbG93LCB5b3UgY2FuIGFsc28gdXRpbGl6ZSB0aGUgYXN5bmMgaXRlcmF0b3IgdXNpbmcgYGZvciBhd2FpdCAuLiBvZmA6XG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHJlc3VsdCA9IGNsaWVudC5oZWxpeC52aWRlb3MuZ2V0VmlkZW9zQnlVc2VyKCcxMjUzMjg2NTUnKTtcbiAqIGZvciBhd2FpdCAoY29uc3QgdmlkZW8gb2YgcmVzdWx0KSB7XG4gKiAgICAgY29uc29sZS5sb2codmlkZW8udGl0bGUpO1xuICogfVxuICogYGBgXG4gKi9cbnZhciBIZWxpeFBhZ2luYXRlZFJlcXVlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0KF9jYWxsT3B0aW9ucywgY2xpZW50LCBfbWFwcGVyKSB7XG4gICAgICAgIHRoaXMuX2NhbGxPcHRpb25zID0gX2NhbGxPcHRpb25zO1xuICAgICAgICB0aGlzLl9tYXBwZXIgPSBfbWFwcGVyO1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFBhZ2luYXRlZFJlcXVlc3QucHJvdG90eXBlLCBcImN1cnJlbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhc3QgcmV0cmlldmVkIHBhZ2Ugb2YgZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgd29ya3Mgd2l0aCB7QEhlbGl4UGFnaW5hdGVkUmVxdWVzdCNnZXROZXh0fSBhbmQgbm90IHdpdGggYW55IG90aGVyIG1ldGhvZHMgb2YgZGF0YSByZXRyaWV2YWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RGF0YSA/IHRoaXMuX2N1cnJlbnREYXRhLmRhdGEgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbmQgcmV0dXJucyB0aGUgbmV4dCBhdmFpbGFibGUgcGFnZSBvZiBkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIHJlcXVlc3RlZCByZXNvdXJjZSwgb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlcmUgYXJlIG5vIG1vcmUgYXZhaWxhYmxlIHBhZ2VzLlxuICAgICAqL1xuICAgIEhlbGl4UGFnaW5hdGVkUmVxdWVzdC5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9mZXRjaERhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9wcm9jZXNzUmVzdWx0KHJlc3VsdCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbmQgcmV0dXJucyBhbGwgZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IHRoaXMgbWFrZXMgbXVsdGlwbGUgY2FsbHMgdG8gdGhlIFR3aXRjaCBBUEkuIER1ZSB0byB0aGlzLCB5b3UgbWlnaHQgYmUgbW9yZSBzdXNwZWN0aWJsZSB0byByYXRlIGxpbWl0cy5cbiAgICAgKlxuICAgICAqIEFsc28gYmUgYXdhcmUgdGhhdCB0aGlzIHJlc2V0cyB0aGUgaW50ZXJuYWwgY3Vyc29yLCBzbyBhdm9pZCB1c2luZyB0aGlzIGFuZCB7QEhlbGl4UGFnaW5hdGVkUmVxdWVzdCNnZXROZXh0fSB0b2dldGhlci5cbiAgICAgKi9cbiAgICBIZWxpeFBhZ2luYXRlZFJlcXVlc3QucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5leHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHRzbGliXzEuX19zcHJlYWQoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEN1cnNvcikgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFBhZ2luYXRlZFJlcXVlc3QucHJvdG90eXBlLCBcImN1cnJlbnRDdXJzb3JcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IGN1cnNvci5cbiAgICAgICAgICpcbiAgICAgICAgICogT25seSB1c2VmdWwgaWYgeW91IHdhbnQgdG8gbWFrZSBtYW51YWwgcmVxdWVzdHMgdG8gdGhlIEFQSS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDdXJzb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgY3Vyc29yLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIG1ha2Uge0BIZWxpeFBhZ2luYXRlZFJlcXVlc3QjZ2V0TmV4dH0gc3RhcnQgZnJvbSB0aGUgZmlyc3QgcGFnZSBhZ2Fpbi5cbiAgICAgKi9cbiAgICBIZWxpeFBhZ2luYXRlZFJlcXVlc3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnREYXRhID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0LnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiBfYSgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJ1ZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0c2xpYl8xLl9fYXdhaXQodGhpcy5nZXROZXh0KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNSAvKnlpZWxkKiovLCB0c2xpYl8xLl9fdmFsdWVzKHRzbGliXzEuX19hc3luY0RlbGVnYXRvcih0c2xpYl8xLl9fYXN5bmNWYWx1ZXMoZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCkpKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRzbGliXzEuX19hd2FpdC5hcHBseSh2b2lkIDAsIFtfYi5zZW50KCldKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBIZWxpeFBhZ2luYXRlZFJlcXVlc3QucHJvdG90eXBlLl9mZXRjaERhdGEgPSBmdW5jdGlvbiAoYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxPcHRpb25zID09PSB2b2lkIDApIHsgYWRkaXRpb25hbE9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7IHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4IH0sIHRoaXMuX2NhbGxPcHRpb25zKSwgYWRkaXRpb25hbE9wdGlvbnMpLCB7IHF1ZXJ5OiB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5fY2FsbE9wdGlvbnMucXVlcnkpLCB7IGFmdGVyOiB0aGlzLl9jdXJyZW50Q3Vyc29yLCBmaXJzdDogJzEwMCcgfSksIGFkZGl0aW9uYWxPcHRpb25zLnF1ZXJ5KSB9KSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0LnByb3RvdHlwZS5fcHJvY2Vzc1Jlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY3VycmVudEN1cnNvciA9IHJlc3VsdC5wYWdpbmF0aW9uID8gcmVzdWx0LnBhZ2luYXRpb24uY3Vyc29yIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEN1cnNvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50RGF0YSA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBlbGVtKSB7XG4gICAgICAgICAgICB2YXIgbWFwcGVkID0gX3RoaXMuX21hcHBlcihlbGVtKTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG1hcHBlZCkgPyB0c2xpYl8xLl9fc3ByZWFkKGFjYywgbWFwcGVkKSA6IHRzbGliXzEuX19zcHJlYWQoYWNjLCBbbWFwcGVkXSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeFBhZ2luYXRlZFJlcXVlc3QucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4UGFnaW5hdGVkUmVxdWVzdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4UGFnaW5hdGVkUmVxdWVzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4UGFnaW5hdGVkUmVxdWVzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FcnJvcnMvTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JcIik7XG52YXIgQ2hhbm5lbFBsYWNlaG9sZGVyXzEgPSByZXF1aXJlKFwiLi4vQ2hhbm5lbC9DaGFubmVsUGxhY2Vob2xkZXJcIik7XG4vKipcbiAqIEEgVHdpdGNoIHVzZXIuXG4gKi9cbnZhciBVc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIFVzZXIoLyoqIEBwcml2YXRlICovIF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyLnByb3RvdHlwZSwgXCJjYWNoZUtleVwiLCB7XG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXIucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlci5wcm90b3R5cGUsIFwiYmlvXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiaW8gb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJpbztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXIucHJvdG90eXBlLCBcImNyZWF0aW9uRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSB3aGVuIHRoZSB1c2VyIHdhcyBjcmVhdGVkLCBpLmUuIHdoZW4gdGhleSByZWdpc3RlcmVkIG9uIFR3aXRjaC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEuY3JlYXRlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyLnByb3RvdHlwZSwgXCJ1cGRhdGVEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IGRhdGUgd2hlbiB0aGUgdXNlciBjaGFuZ2VkIGFueXRoaW5nIGluIHRoZWlyIHByb2ZpbGUsIGUuZy4gdGhlaXIgZGVzY3JpcHRpb24gb3IgdGhlaXIgcHJvZmlsZSBwaWN0dXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS51cGRhdGVkX2F0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXIucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgbmFtZSBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXIucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmRpc3BsYXlfbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXIucHJvdG90eXBlLCBcImxvZ29VcmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCB0byB0aGUgcHJvZmlsZSBwaWN0dXJlIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sb2dvO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlci5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjaGFubmVsIGRhdGEgb2YgdGhlIHVzZXIuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuZ2V0Q2hhbm5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmtyYWtlbi5jaGFubmVscy5nZXRDaGFubmVsKHRoaXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYSBjaGFubmVsIHBsYWNlaG9sZGVyIG9iamVjdCBmb3IgdGhlIHVzZXIsIHdoaWNoIGNhbiBkbyBhbnl0aGluZyB5b3UgY2FuIGRvIHRvIGEgY2hhbm5lbCB3aXRoIGp1c3QgdGhlIElELlxuICAgICAqL1xuICAgIFVzZXIucHJvdG90eXBlLmdldENoYW5uZWxQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFubmVsUGxhY2Vob2xkZXJfMS5kZWZhdWx0KHRoaXMuX2RhdGEuX2lkLCB0aGlzLl9jbGllbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50bHkgcnVubmluZyBzdHJlYW0gb2YgdGhlIHVzZXIuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuZ2V0U3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmdldENoYW5uZWxQbGFjZWhvbGRlcigpLmdldFN0cmVhbSgpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc3Vic2NyaXB0aW9uIGRhdGEgZm9yIHRoZSB1c2VyIHRvIHRoZSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogVGhyb3dzIGlmIHRoZSBjaGFubmVsIGRvZXNuJ3QgaGF2ZSBhIHN1YnNjcmlwdGlvbiBwcm9ncmFtIG9yIHRoZSB1c2VyIGlzIG5vdCBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmVxdWlyZXMgYWNjZXNzIHRvIHRoZSB1c2VyLiBJZiB5b3Ugb25seSBoYXZlIGFjY2VzcyB0byB0aGUgY2hhbm5lbCxcbiAgICAgKiB1c2Uge0BDaGFubmVsUGxhY2Vob2xkZXIjZ2V0U3Vic2NyaXB0aW9uQnl9IGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB5b3Ugd2FudCB0byBnZXQgdGhlIHN1YnNjcmlwdGlvbiBkYXRhIGZvci5cbiAgICAgKi9cbiAgICBVc2VyLnByb3RvdHlwZS5nZXRTdWJzY3JpcHRpb25UbyA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuZ2V0U3Vic2NyaXB0aW9uRGF0YSh0aGlzLCBjaGFubmVsKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBpcyBzdWJzY3JpYmVkIHRvIHRoZSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgeW91IHdhbnQgdG8gY2hlY2sgdGhlIHN1YnNjcmlwdGlvbiBmb3IuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuaXNTdWJzY3JpYmVkVG8gPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFN1YnNjcmlwdGlvblRvKGNoYW5uZWwpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSkgIT09IG51bGxdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xIGluc3RhbmNlb2YgTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBjaGFubmVscyBmb2xsb3dlZCBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSByZXN1bHQgcGFnZSB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgVGhlIG51bWJlciBvZiByZXN1bHRzIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBvcmRlckJ5IFRoZSBmaWVsZCB0byBvcmRlciBieS5cbiAgICAgKiBAcGFyYW0gb3JkZXJEaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0byBvcmRlciBpbiAtIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nLlxuICAgICAqL1xuICAgIFVzZXIucHJvdG90eXBlLmdldEZvbGxvd3MgPSBmdW5jdGlvbiAocGFnZSwgbGltaXQsIG9yZGVyQnksIG9yZGVyRGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuZ2V0Rm9sbG93ZWRDaGFubmVscyh0aGlzLCBwYWdlLCBsaW1pdCwgb3JkZXJCeSwgb3JkZXJEaXJlY3Rpb24pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZm9sbG93IGRhdGEgb2YgdGhlIHVzZXIgdG8gYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gcmV0cmlldmUgdGhlIGZvbGxvdyBkYXRhIGZvci5cbiAgICAgKi9cbiAgICBVc2VyLnByb3RvdHlwZS5nZXRGb2xsb3dUbyA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuZ2V0Rm9sbG93ZWRDaGFubmVsKHRoaXMsIGNoYW5uZWwpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGZvbGxvd2luZyB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIGNoZWNrIGZvciB0aGUgdXNlcidzIGZvbGxvdy5cbiAgICAgKi9cbiAgICBVc2VyLnByb3RvdHlwZS5mb2xsb3dzID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZV8yO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRGb2xsb3dUbyhjaGFubmVsKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpICE9PSBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8yID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8yO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2xsb3dzIHRoZSBjaGFubmVsIHdpdGggdGhlIGF1dGhlbnRpY2F0ZWQgdXNlci5cbiAgICAgKi9cbiAgICBVc2VyLnByb3RvdHlwZS5mb2xsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRVc2VyO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuZ2V0TWUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGN1cnJlbnRVc2VyLmZvbGxvd0NoYW5uZWwodGhpcyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuZm9sbG93cyB0aGUgY2hhbm5lbCB3aXRoIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUudW5mb2xsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRVc2VyO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuZ2V0TWUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGN1cnJlbnRVc2VyLnVuZm9sbG93Q2hhbm5lbCh0aGlzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBlbW90ZXMgdGhlIHVzZXIgY2FuIHVzZS5cbiAgICAgKi9cbiAgICBVc2VyLnByb3RvdHlwZS5nZXRFbW90ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuZ2V0VXNlckVtb3Rlcyh0aGlzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgVXNlci5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBVc2VyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVzZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBVc2VyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gVXNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBjcmVhdGVQYWdpbmF0ZWRSZXN1bHQocmVzcG9uc2UsIHR5cGUsIGNsaWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IChfYiA9IChfYSA9IHJlc3BvbnNlLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyB0eXBlKGRhdGEsIGNsaWVudCk7IH0pLCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pKSxcbiAgICAgICAgY3Vyc29yOiAoX2MgPSByZXNwb25zZS5wYWdpbmF0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY3Vyc29yXG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlUGFnaW5hdGVkUmVzdWx0ID0gY3JlYXRlUGFnaW5hdGVkUmVzdWx0O1xuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBjcmVhdGVQYWdpbmF0ZWRSZXN1bHRXaXRoVG90YWwocmVzcG9uc2UsIHR5cGUsIGNsaWVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlLmRhdGEubWFwKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgdHlwZShkYXRhLCBjbGllbnQpOyB9KSxcbiAgICAgICAgY3Vyc29yOiByZXNwb25zZS5wYWdpbmF0aW9uLmN1cnNvcixcbiAgICAgICAgdG90YWw6IHJlc3BvbnNlLnRvdGFsXG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlUGFnaW5hdGVkUmVzdWx0V2l0aFRvdGFsID0gY3JlYXRlUGFnaW5hdGVkUmVzdWx0V2l0aFRvdGFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8qKiBAcHJpdmF0ZSAqL1xudmFyIEN1c3RvbUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEN1c3RvbUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKCkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCB0c2xpYl8xLl9fc3ByZWFkKHBhcmFtcykpIHx8IHRoaXM7XG4gICAgICAgIC8vIHJlc3RvcmUgcHJvdG90eXBlIGNoYWluXG4gICAgICAgIHZhciBhY3R1YWxQcm90byA9IF9uZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcbiAgICAgICAgfVxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBfbmV3VGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21FcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ3VzdG9tRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDdXN0b21FcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEN1c3RvbUVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBDaGFubmVsUGxhY2Vob2xkZXJfMSA9IHJlcXVpcmUoXCIuL0NoYW5uZWxQbGFjZWhvbGRlclwiKTtcbi8qKlxuICogQSBUd2l0Y2ggQ2hhbm5lbC5cbiAqL1xudmFyIENoYW5uZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2hhbm5lbCwgX3N1cGVyKTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBDaGFubmVsKGRhdGEsIGNsaWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkYXRhLl9pZCwgY2xpZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gb3ZlcnJpZGUgcGFyZW50J3MgbWV0aG9kIHNvIHdlIGF2b2lkIHRoZSBBUEkvY2FjaGUgcmVxdWVzdCBoZXJlIGlmIHNvbWVvbmUgd3JvbmdseSBhc3N1bWVzIHRoaXMgaXMgYSBwbGFjZWhvbGRlclxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIENoYW5uZWwucHJvdG90eXBlLmdldENoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiB0aGUgdGVhbXMgb2YgdGhlIGNoYW5uZWwuXG4gICAgICovXG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuZ2V0VGVhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4uY2hhbm5lbHMuZ2V0Q2hhbm5lbFRlYW1zKHRoaXMuX2RhdGEuX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnYW1lLCB0aXRsZSBvciBkZWxheSBvZiBhIGNoYW5uZWwgb3IgdG9nZ2xlcyB0aGUgY2hhbm5lbCBmZWVkLlxuICAgICAqL1xuICAgIENoYW5uZWwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4uY2hhbm5lbHMudXBkYXRlQ2hhbm5lbCh0aGlzLCBkYXRhKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIGNoYW5uZWwsIHdpdGggcHJvcGVyIGNhcGl0YWxpemF0aW9uIG9yIGFzIEFzaWFuIHNjcmlwdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZGlzcGxheV9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwiYnJvYWRjYXN0ZXJMYW5ndWFnZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYnJvYWRjYXN0ZXIncyBsYW5ndWFnZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuYnJvYWRjYXN0ZXJfbGFuZ3VhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJicm9hZGNhc3RlclR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJyb2FkY2FzdGVyJ3MgdHlwZSwgaS5lLiBcInBhcnRuZXJcIiwgXCJhZmZpbGlhdGVcIiBvciBcIlwiIChlbXB0eSBzdHJpbmcsIHNvIG5laXRoZXIgb2YgdGhlbSkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJyb2FkY2FzdGVyX3R5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJjcmVhdGlvbkRhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgd2hlbiB0aGUgY2hhbm5lbCB3YXMgY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEuY3JlYXRlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJkZXNjcmlwdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmRlc2NyaXB0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwiZm9sbG93ZXJzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgcGVvcGxlIGZvbGxvd2luZyB0aGUgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZm9sbG93ZXJzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwiZ2FtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZ2FtZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBwbGF5ZWQgb24gdGhlIGNoYW5uZWwgKG9yIHdhcyBwbGF5ZWQgd2hlbiBpdCB3YXMgbGFzdCBvbmxpbmUpLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwibGFuZ3VhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhbmd1YWdlIG9mIHRoZSBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sYW5ndWFnZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcImxvZ29cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCB0byB0aGUgbG9nbyBvZiB0aGUgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubG9nbztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcImlzTWF0dXJlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNoYW5uZWwgaXMgZmxhZ2dlZCBhcyBzdWl0YWJsZSBmb3IgbWF0dXJlIGF1ZGllbmNlcyBvbmx5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5tYXR1cmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJpc1BhcnRuZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2hhbm5lbCBpcyBwYXJ0bmVyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnBhcnRuZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJwcm9maWxlQmFubmVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgdG8gdGhlIHByb2ZpbGUncyBiYW5uZXIgaW1hZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnByb2ZpbGVfYmFubmVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwicHJvZmlsZUJhbm5lckJhY2tncm91bmRDb2xvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgcHJvZmlsZSdzIGJhbm5lci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEucHJvZmlsZV9iYW5uZXJfYmFja2dyb3VuZF9jb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWwucHJvdG90eXBlLCBcInN0YXR1c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBzdGF0dXMgbWVzc2FnZSAoaS5lLiB0aGUgdGl0bGUpIG9mIHRoZSBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zdGF0dXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJ1cGRhdGVEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIHdoZW4gdGhlIGNoYW5uZWwgd2FzIGxhc3QgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEudXBkYXRlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCB0byB0aGUgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXJsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwidmlkZW9CYW5uZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCB0byB0aGUgY2hhbm5lbCdzIHZpZGVvIGJhbm5lciwgaS5lLiB0aGUgb2ZmbGluZSBpbWFnZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudmlkZW9fYmFubmVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbC5wcm90b3R5cGUsIFwidmlld3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvdGFsIG51bWJlciBvZiB2aWV3cyBvZiB0aGUgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudmlld3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDaGFubmVsO1xufShDaGFubmVsUGxhY2Vob2xkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFubmVsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ2hhbm5lbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYW5uZWw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEN1c3RvbUVycm9yXzEgPSByZXF1aXJlKFwiLi9DdXN0b21FcnJvclwiKTtcbi8qKlxuICogVGhyb3duIHdoZW5ldmVyIHlvdSB0cnkgYWNjZXNzaW5nIGEgc3Vic2NyaXB0aW9uLXJlbGF0ZWQgcmVzb3VyY2VcbiAqIChmb3IgZXhhbXBsZSB7QENoYW5uZWxBUEkjZ2V0Q2hhbm5lbFN1YnNjcmlwdGlvbnN9KVxuICogYW5kIHRoZSBnaXZlbiBjaGFubmVsIGRvZXMgbm90IGhhdmUgYSBzdWJzY3JpcHRpb24gcHJvZ3JhbS5cbiAqL1xudmFyIE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yLCBfc3VwZXIpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yKGNoYW5uZWxJZCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJDaGFubmVsIFwiICsgY2hhbm5lbElkICsgXCIgZG9lcyBub3QgaGF2ZSBhIHN1YnNjcmlwdGlvbiBwcm9ncmFtXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvcjtcbn0oQ3VzdG9tRXJyb3JfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNwcm9wZXJ0eWtleVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIElzUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcblx0cmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFyZ3VtZW50ID09PSAnc3ltYm9sJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBtYWtlUGFnaW5hdGlvblF1ZXJ5KF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGFmdGVyID0gX2IuYWZ0ZXIsIGJlZm9yZSA9IF9iLmJlZm9yZSwgbGltaXQgPSBfYi5saW1pdDtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZnRlcjogYWZ0ZXIsXG4gICAgICAgIGJlZm9yZTogYmVmb3JlLFxuICAgICAgICBmaXJzdDogbGltaXRcbiAgICB9O1xufVxuZXhwb3J0cy5tYWtlUGFnaW5hdGlvblF1ZXJ5ID0gbWFrZVBhZ2luYXRpb25RdWVyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQ3VzdG9tRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0N1c3RvbUVycm9yXCIpO1xuLyoqXG4gKiBUaHJvd24gd2hlbmV2ZXIgYSBIVFRQIGVycm9yIG9jY3Vycy4gU29tZSBIVFRQIGVycm9ycyBhcmUgaGFuZGxlZCBpbiB0aGUgbGlicmFyeSB3aGVuIHRoZXkncmUgZXhwZWN0ZWQuXG4gKi9cbnZhciBIVFRQU3RhdHVzQ29kZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhUVFBTdGF0dXNDb2RlRXJyb3IsIF9zdXBlcik7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBmdW5jdGlvbiBIVFRQU3RhdHVzQ29kZUVycm9yKHN0YXR1c0NvZGUsIHN0YXR1c1RleHQsIGJvZHkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJFbmNvdW50ZXJlZCBIVFRQIHN0YXR1cyBjb2RlIFwiICsgc3RhdHVzQ29kZSArIFwiOiBcIiArIHN0YXR1c1RleHQgKyBcIlxcblxcbkJvZHk6XFxuXCIgKyBKU09OLnN0cmluZ2lmeShib2R5LCBudWxsLCAyKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3N0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICBfdGhpcy5fYm9keSA9IGJvZHk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUVFBTdGF0dXNDb2RlRXJyb3IucHJvdG90eXBlLCBcInN0YXR1c0NvZGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXNDb2RlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRUUFN0YXR1c0NvZGVFcnJvci5wcm90b3R5cGUsIFwiYm9keVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBIVFRQU3RhdHVzQ29kZUVycm9yO1xufShDdXN0b21FcnJvcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhUVFBTdGF0dXNDb2RlRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIVFRQU3RhdHVzQ29kZUVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSFRUUFN0YXR1c0NvZGVFcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQ3VzdG9tRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0N1c3RvbUVycm9yXCIpO1xuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIGtpbmQgb2YgZXJyb3JzIHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAqXG4gKiBJZiB5b3Ugc2VlIG9uZSB0aHJvd24sIHBsZWFzZSBmaWxlIGEgYnVnIGluIHRoZSBHaXRIdWIgaXNzdWUgdHJhY2tlci5cbiAqL1xudmFyIEhlbGxGcmVlemVzT3ZlckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGxGcmVlemVzT3ZlckVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlbGxGcmVlemVzT3ZlckVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UgKyBcIiAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgcGxlYXNlIGZpbGUgYSBidWcgaW4gdGhlIEdpdEh1YiBpc3N1ZSB0cmFja2VyXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWxsRnJlZXplc092ZXJFcnJvcjtcbn0oQ3VzdG9tRXJyb3JfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxsRnJlZXplc092ZXJFcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGxGcmVlemVzT3ZlckVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsbEZyZWV6ZXNPdmVyRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc05vZGUgPSByZXF1aXJlKFwiZGV0ZWN0LW5vZGVcIik7XG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJDUklUSUNBTFwiXSA9IDBdID0gXCJDUklUSUNBTFwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRVJST1JcIl0gPSAxXSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSAyXSA9IFwiV0FSTklOR1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSU5GT1wiXSA9IDNdID0gXCJJTkZPXCI7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBERUJVRyBpbnN0ZWFkICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVRzFcIl0gPSA0XSA9IFwiREVCVUcxXCI7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBERUJVRyBpbnN0ZWFkICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVRzJcIl0gPSA0XSA9IFwiREVCVUcyXCI7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBERUJVRyBpbnN0ZWFkICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVRzNcIl0gPSA0XSA9IFwiREVCVUczXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVR1wiXSA9IDRdID0gXCJERUJVR1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiVFJBQ0VcIl0gPSA3XSA9IFwiVFJBQ0VcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBMb2dMZXZlbDtcbmZ1bmN0aW9uIHJlc29sdmVMb2dMZXZlbChsZXZlbCkge1xuICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTG9nTGV2ZWwsIGxldmVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGlnaWJsZUxldmVscyA9IE9iamVjdC5rZXlzKExvZ0xldmVsKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gcGFyc2VJbnQoaywgMTApOyB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gIWlzTmFOKGspICYmIGsgPCBsZXZlbDsgfSk7XG4gICAgICAgIGlmICghZWxpZ2libGVMZXZlbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2dMZXZlbC5XQVJOSU5HO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBlbGlnaWJsZUxldmVscyk7XG4gICAgfVxuICAgIHZhciBzdHJMZXZlbCA9IGxldmVsLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTG9nTGV2ZWwsIHN0ckxldmVsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGxvZyBsZXZlbCBzdHJpbmc6IFwiICsgc3RyTGV2ZWwpO1xuICAgIH1cbiAgICByZXR1cm4gTG9nTGV2ZWxbc3RyTGV2ZWxdO1xufVxuZXhwb3J0cy5yZXNvbHZlTG9nTGV2ZWwgPSByZXNvbHZlTG9nTGV2ZWw7XG4vLyBOb2RlIDgrIGRlZmluZXMgY29uc29sZS5kZWJ1ZyBhcyBub29wLCBhbmQgZWFybGllciB2ZXJzaW9ucyBkb24ndCBkZWZpbmUgaXQgYXQgYWxsXG52YXIgZGVidWdGdW5jdGlvbiA9IGlzTm9kZSA/IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkgOiBjb25zb2xlLmRlYnVnLmJpbmQoY29uc29sZSk7XG52YXIgX19leHBvcnRfTG9nTGV2ZWxUb0NvbnNvbGVGdW5jdGlvbiA9IChfYSA9IHt9LFxuICAgIF9hW0xvZ0xldmVsLkNSSVRJQ0FMXSA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxcbiAgICBfYVtMb2dMZXZlbC5FUlJPUl0gPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgX2FbTG9nTGV2ZWwuV0FSTklOR10gPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKSxcbiAgICBfYVtMb2dMZXZlbC5JTkZPXSA9IGNvbnNvbGUuaW5mby5iaW5kKGNvbnNvbGUpLFxuICAgIF9hW0xvZ0xldmVsLkRFQlVHXSA9IGRlYnVnRnVuY3Rpb24uYmluZChjb25zb2xlKSxcbiAgICBfYVtMb2dMZXZlbC5UUkFDRV0gPSBjb25zb2xlLnRyYWNlLmJpbmQoY29uc29sZSksXG4gICAgX2EpO1xuZXhwb3J0cy5Mb2dMZXZlbFRvQ29uc29sZUZ1bmN0aW9uID0gX19leHBvcnRfTG9nTGV2ZWxUb0NvbnNvbGVGdW5jdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IExvZ0xldmVsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gTG9nTGV2ZWw7XG5leHBvcnRzLnJlc29sdmVMb2dMZXZlbCA9IHJlc29sdmVMb2dMZXZlbDtcbmV4cG9ydHMuTG9nTGV2ZWxUb0NvbnNvbGVGdW5jdGlvbiA9IF9fZXhwb3J0X0xvZ0xldmVsVG9Db25zb2xlRnVuY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dMZXZlbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc05vZGUgPSByZXF1aXJlKFwiZGV0ZWN0LW5vZGVcIik7XG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJDUklUSUNBTFwiXSA9IDBdID0gXCJDUklUSUNBTFwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRVJST1JcIl0gPSAxXSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSAyXSA9IFwiV0FSTklOR1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSU5GT1wiXSA9IDNdID0gXCJJTkZPXCI7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBERUJVRyBpbnN0ZWFkICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVRzFcIl0gPSA0XSA9IFwiREVCVUcxXCI7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBERUJVRyBpbnN0ZWFkICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVRzJcIl0gPSA0XSA9IFwiREVCVUcyXCI7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBERUJVRyBpbnN0ZWFkICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVRzNcIl0gPSA0XSA9IFwiREVCVUczXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVR1wiXSA9IDRdID0gXCJERUJVR1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiVFJBQ0VcIl0gPSA3XSA9IFwiVFJBQ0VcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG5leHBvcnRzLkxvZ0xldmVsID0gTG9nTGV2ZWw7XG5mdW5jdGlvbiByZXNvbHZlTG9nTGV2ZWwobGV2ZWwpIHtcbiAgICBpZiAodHlwZW9mIGxldmVsID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKExvZ0xldmVsLCBsZXZlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsZXZlbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxpZ2libGVMZXZlbHMgPSBPYmplY3Qua2V5cyhMb2dMZXZlbClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHBhcnNlSW50KGssIDEwKTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuICFpc05hTihrKSAmJiBrIDwgbGV2ZWw7IH0pO1xuICAgICAgICBpZiAoIWVsaWdpYmxlTGV2ZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9nTGV2ZWwuV0FSTklORztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgZWxpZ2libGVMZXZlbHMpO1xuICAgIH1cbiAgICB2YXIgc3RyTGV2ZWwgPSBsZXZlbC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKExvZ0xldmVsLCBzdHJMZXZlbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBsb2cgbGV2ZWwgc3RyaW5nOiBcIiArIHN0ckxldmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIExvZ0xldmVsW3N0ckxldmVsXTtcbn1cbmV4cG9ydHMucmVzb2x2ZUxvZ0xldmVsID0gcmVzb2x2ZUxvZ0xldmVsO1xuLy8gTm9kZSA4KyBkZWZpbmVzIGNvbnNvbGUuZGVidWcgYXMgbm9vcCwgYW5kIGVhcmxpZXIgdmVyc2lvbnMgZG9uJ3QgZGVmaW5lIGl0IGF0IGFsbFxudmFyIGRlYnVnRnVuY3Rpb24gPSBpc05vZGUgPyBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpIDogY29uc29sZS5kZWJ1Zy5iaW5kKGNvbnNvbGUpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydHMuTG9nTGV2ZWxUb0NvbnNvbGVGdW5jdGlvbiA9IChfYSA9IHt9LFxuICAgIF9hW0xvZ0xldmVsLkNSSVRJQ0FMXSA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxcbiAgICBfYVtMb2dMZXZlbC5FUlJPUl0gPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgX2FbTG9nTGV2ZWwuV0FSTklOR10gPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKSxcbiAgICBfYVtMb2dMZXZlbC5JTkZPXSA9IGNvbnNvbGUuaW5mby5iaW5kKGNvbnNvbGUpLFxuICAgIF9hW0xvZ0xldmVsLkRFQlVHXSA9IGRlYnVnRnVuY3Rpb24uYmluZChjb25zb2xlKSxcbiAgICBfYVtMb2dMZXZlbC5UUkFDRV0gPSBjb25zb2xlLnRyYWNlLmJpbmQoY29uc29sZSksXG4gICAgX2EpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nTGV2ZWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woJ2ZvbycpID09PSAnc3ltYm9sJztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyIG9yaWdEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgb2JqID0ge307XG5cdHRyeSB7XG5cdFx0b3JpZ0RlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb2JqIH0pO1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycywgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0XHRmb3IgKHZhciBfIGluIG9iaikgeyAvLyBqc2NzOmlnbm9yZSBkaXNhbGxvd1VudXNlZFZhcmlhYmxlc1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqLnggPT09IG9iajtcblx0fSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIElFIDguICovXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBvcmlnRGVmaW5lUHJvcGVydHkgJiYgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCgpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdGlmIChuYW1lIGluIG9iamVjdCAmJiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0b3JpZ0RlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuXHR9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xuXHR2YXIgcHJlZGljYXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDoge307XG5cdHZhciBwcm9wcyA9IGtleXMobWFwKTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRwcm9wcyA9IGNvbmNhdC5jYWxsKHByb3BzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1hcCkpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BzW2ldLCBtYXBbcHJvcHNbaV1dLCBwcmVkaWNhdGVzW3Byb3BzW2ldXSk7XG5cdH1cbn07XG5cbmRlZmluZVByb3BlcnRpZXMuc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhc3VwcG9ydHNEZXNjcmlwdG9ycztcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVQcm9taXNlKCkge1xuXHRpZiAodHlwZW9mIFByb21pc2UgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdgUHJvbWlzZS5hbGxTZXR0bGVkYCByZXF1aXJlcyBhIGdsb2JhbCBgUHJvbWlzZWAgYmUgYXZhaWxhYmxlLicpO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGhleFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufSgpKTtcblxudmFyIGNvbXBhY3RRdWV1ZSA9IGZ1bmN0aW9uIGNvbXBhY3RRdWV1ZShxdWV1ZSkge1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgICAgIHZhciBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmoubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0ub2JqW2l0ZW0ucHJvcF0gPSBjb21wYWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgYXJyYXlUb09iamVjdCA9IGZ1bmN0aW9uIGFycmF5VG9PYmplY3Qoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAvKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IDAgKi9cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKChvcHRpb25zICYmIChvcHRpb25zLnBsYWluT2JqZWN0cyB8fCBvcHRpb25zLmFsbG93UHJvdG90eXBlcykpIHx8ICFoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt0YXJnZXQsIHNvdXJjZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VUYXJnZXQgPSB0YXJnZXQ7XG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiAhaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIG1lcmdlVGFyZ2V0ID0gYXJyYXlUb09iamVjdCh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwodGFyZ2V0LCBpKSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJdGVtID0gdGFyZ2V0W2ldO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtICYmIHR5cGVvZiB0YXJnZXRJdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBtZXJnZSh0YXJnZXRJdGVtLCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKGFjYywga2V5KSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBtZXJnZShhY2Nba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG1lcmdlVGFyZ2V0KTtcbn07XG5cbnZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ25TaW5nbGVTb3VyY2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gc291cmNlW2tleV07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdGFyZ2V0KTtcbn07XG5cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiAoc3RyLCBkZWNvZGVyLCBjaGFyc2V0KSB7XG4gICAgdmFyIHN0cldpdGhvdXRQbHVzID0gc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgLy8gdW5lc2NhcGUgbmV2ZXIgdGhyb3dzLCBubyB0cnkuLi5jYXRjaCBuZWVkZWQ6XG4gICAgICAgIHJldHVybiBzdHJXaXRob3V0UGx1cy5yZXBsYWNlKC8lWzAtOWEtZl17Mn0vZ2ksIHVuZXNjYXBlKTtcbiAgICB9XG4gICAgLy8gdXRmLThcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cldpdGhvdXRQbHVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHJXaXRob3V0UGx1cztcbiAgICB9XG59O1xuXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHN0ciwgZGVmYXVsdEVuY29kZXIsIGNoYXJzZXQpIHtcbiAgICAvLyBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBCcmlhbiBXaGl0ZSAobXNjZGV4KSBmb3IgdGhlIGlvLmpzIGNvcmUgcXVlcnlzdHJpbmcgbGlicmFyeS5cbiAgICAvLyBJdCBoYXMgYmVlbiBhZGFwdGVkIGhlcmUgZm9yIHN0cmljdGVyIGFkaGVyZW5jZSB0byBSRkMgMzk4NlxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9IHN0cjtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgc3RyaW5nID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN0cik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICBzdHJpbmcgPSBTdHJpbmcoc3RyKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGUoc3RyaW5nKS5yZXBsYWNlKC8ldVswLTlhLWZdezR9L2dpLCBmdW5jdGlvbiAoJDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJTI2JTIzJyArIHBhcnNlSW50KCQwLnNsaWNlKDIpLCAxNikgKyAnJTNCJztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgYyA9PT0gMHgyRCAvLyAtXG4gICAgICAgICAgICB8fCBjID09PSAweDJFIC8vIC5cbiAgICAgICAgICAgIHx8IGMgPT09IDB4NUYgLy8gX1xuICAgICAgICAgICAgfHwgYyA9PT0gMHg3RSAvLyB+XG4gICAgICAgICAgICB8fCAoYyA+PSAweDMwICYmIGMgPD0gMHgzOSkgLy8gMC05XG4gICAgICAgICAgICB8fCAoYyA+PSAweDQxICYmIGMgPD0gMHg1QSkgLy8gYS16XG4gICAgICAgICAgICB8fCAoYyA+PSAweDYxICYmIGMgPD0gMHg3QSkgLy8gQS1aXG4gICAgICAgICkge1xuICAgICAgICAgICAgb3V0ICs9IHN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgaGV4VGFibGVbY107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEMwIHwgKGMgPj4gNildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweEQ4MDAgfHwgYyA+PSAweEUwMDApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEUwIHwgKGMgPj4gMTIpXSArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgJiAweDNGRikpO1xuICAgICAgICBvdXQgKz0gaGV4VGFibGVbMHhGMCB8IChjID4+IDE4KV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZhciBjb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xuICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gICAgdmFyIHJlZnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG5cbnZhciBjb21iaW5lID0gZnVuY3Rpb24gY29tYmluZShhLCBiKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhLCBiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFycmF5VG9PYmplY3Q6IGFycmF5VG9PYmplY3QsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgY29tYmluZTogY29tYmluZSxcbiAgICBjb21wYWN0OiBjb21wYWN0LFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgICBpc1JlZ0V4cDogaXNSZWdFeHAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRhdGEgb2YgYW4gT0F1dGggYWNjZXNzIHRva2VuIHJldHVybmVkIGJ5IFR3aXRjaC5cbiAqL1xudmFyIEFjY2Vzc1Rva2VuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEFjY2Vzc1Rva2VuKF9kYXRhLCBvYnRhaW5tZW50RGF0ZSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX29idGFpbm1lbnREYXRlID0gb2J0YWlubWVudERhdGUgfHwgbmV3IERhdGUoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjY2Vzc1Rva2VuLnByb3RvdHlwZSwgXCJhY2Nlc3NUb2tlblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWNjZXNzIHRva2VuIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgZXZlcnkgcmVxdWVzdCB0byB0aGUgVHdpdGNoIEFQSS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuYWNjZXNzX3Rva2VuO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWNjZXNzVG9rZW4ucHJvdG90eXBlLCBcInJlZnJlc2hUb2tlblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVmcmVzaCB0b2tlbiB3aGljaCBpcyBuZWNlc3NhcnkgdG8gcmVmcmVzaCB0aGUgYWNjZXNzIHRva2VuIG9uY2UgaXQgZXhwaXJlcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEucmVmcmVzaF90b2tlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjY2Vzc1Rva2VuLnByb3RvdHlwZSwgXCJleHBpcnlEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHdoZW4gdGhlIGFjY2VzcyB0b2tlbiB3aWxsIGV4cGlyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogTWF5IGJlIGBudWxsYCwgaW4gd2hpY2ggY2FzZSB0aGUgdG9rZW4gZG9lcyBub3QgZXhwaXJlLlxuICAgICAgICAgKiBUaGlzIGNhbiBvbmx5IGJlIHRoZSBjYXNlIHdpdGggdmVyeSBvbGQgQ2xpZW50IElEcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kYXRhLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9vYnRhaW5tZW50RGF0ZS5nZXRUaW1lKCkgKyB0aGlzLl9kYXRhLmV4cGlyZXNfaW4gKiAxMDAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjY2Vzc1Rva2VuLnByb3RvdHlwZSwgXCJpc0V4cGlyZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGF0YS5leHBpcmVzX2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCkgPiB0aGlzLl9vYnRhaW5tZW50RGF0ZS5nZXRUaW1lKCkgKyB0aGlzLl9kYXRhLmV4cGlyZXNfaW4gKiAxMDAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWNjZXNzVG9rZW4ucHJvdG90eXBlLCBcInNjb3BlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY29wZSB0aGUgYWNjZXNzIHRva2VuIGlzIHZhbGlkIGZvciwgaS5lLiB3aGF0IHRoaXMgdG9rZW4gZW5hYmxlcyB5b3UgdG8gZG8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnNjb3BlIHx8IFtdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQWNjZXNzVG9rZW47XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWNjZXNzVG9rZW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBBY2Nlc3NUb2tlbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFjY2Vzc1Rva2VuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyLCBmbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgdHNsaWJfMS5fX3NwcmVhZChbe31dLCBhcnIubWFwKGZuKSkpO1xufVxuZXhwb3J0cy5hcnJheVRvT2JqZWN0ID0gYXJyYXlUb09iamVjdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXJyYXlUb09iamVjdCA9IGFycmF5VG9PYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheVRvT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBiYW4gb2YgYSB1c2VyLlxuICovXG52YXIgSGVsaXhCYW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhCYW4oX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QmFuLnByb3RvdHlwZSwgXCJ1c2VySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgbW9yZSBkYXRhIGFib3V0IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIEhlbGl4QmFuLnByb3RvdHlwZS5nZXRVc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy5fZGF0YS51c2VyX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCYW4ucHJvdG90eXBlLCBcInVzZXJOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEJhbi5wcm90b3R5cGUsIFwiZXhwaXJ5RGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSB3aGVuIHRoZSBiYW4gd2lsbCBleHBpcmU7IG51bGwgZm9yIHBlcm1hbmVudCBiYW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5leHBpcmVzX2F0ID8gbmV3IERhdGUodGhpcy5fZGF0YS5leHBpcmVzX2F0KSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeEJhbi5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWxpeEJhbjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEJhbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4QmFuO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhCYW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgbW9kZXJhdG9yIHN0YXR1cyBvZiBhIHVzZXIuXG4gKi9cbnZhciBIZWxpeE1vZGVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeE1vZGVyYXRvcihfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhNb2RlcmF0b3IucHJvdG90eXBlLCBcInVzZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVzZXJfaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBtb3JlIGRhdGEgYWJvdXQgdGhlIHVzZXIuXG4gICAgICovXG4gICAgSGVsaXhNb2RlcmF0b3IucHJvdG90eXBlLmdldFVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCh0aGlzLl9kYXRhLnVzZXJfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeE1vZGVyYXRvci5wcm90b3R5cGUsIFwidXNlck5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVzZXJfbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIEhlbGl4TW9kZXJhdG9yLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEhlbGl4TW9kZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4TW9kZXJhdG9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhNb2RlcmF0b3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeE1vZGVyYXRvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG4vKipcbiAqIEEgKHBhaWQpIHN1YnNjcmlwdGlvbiBvZiBhIHVzZXIgdG8gYSBicm9hZGNhc3Rlci5cbiAqL1xudmFyIEhlbGl4U3Vic2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4U3Vic2NyaXB0aW9uKF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwiYnJvYWRjYXN0ZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlciBJRCBvZiB0aGUgYnJvYWRjYXN0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJyb2FkY2FzdGVyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcImJyb2FkY2FzdGVyRGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgYnJvYWRjYXN0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJyb2FkY2FzdGVyX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBtb3JlIGRhdGEgYWJvdXQgdGhlIGJyb2FkY2FzdGVyLlxuICAgICAqL1xuICAgIEhlbGl4U3Vic2NyaXB0aW9uLnByb3RvdHlwZS5nZXRCcm9hZGNhc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeUlkKHRoaXMuYnJvYWRjYXN0ZXJJZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJpc0dpZnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIGhhcyBiZWVuIGdpZnRlZCBieSBhbm90aGVyIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlzX2dpZnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwidGllclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGllciBvZiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50aWVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcInVzZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlciBJRCBvZiB0aGUgc3Vic2NyaWJlZCB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcInVzZXJEaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBzdWJzY3JpYmVkIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVzZXJfbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG1vcmUgZGF0YSBhYm91dCB0aGUgc3Vic2NyaWJlZCB1c2VyLlxuICAgICAqL1xuICAgIEhlbGl4U3Vic2NyaXB0aW9uLnByb3RvdHlwZS5nZXRVc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy51c2VySWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeFN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWxpeFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFN1YnNjcmlwdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4U3Vic2NyaXB0aW9uO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdWJzY3JpcHRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRXJyb3JzL05vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXCIpO1xuLyoqXG4gKiBUaGUgdHlwZSBvZiBhIGJyb2FkY2FzdGVyLlxuICovXG52YXIgSGVsaXhCcm9hZGNhc3RlclR5cGU7XG4oZnVuY3Rpb24gKEhlbGl4QnJvYWRjYXN0ZXJUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQSBUd2l0Y2ggUGFydG5lci5cbiAgICAgKi9cbiAgICBIZWxpeEJyb2FkY2FzdGVyVHlwZVtcIlBhcnRuZXJcIl0gPSBcInBhcnRuZXJcIjtcbiAgICAvKipcbiAgICAgKiBBIFR3aXRjaCBBZmZpbGlhdGUuXG4gICAgICovXG4gICAgSGVsaXhCcm9hZGNhc3RlclR5cGVbXCJBZmZpbGlhdGVcIl0gPSBcImFmZmlsaWF0ZVwiO1xuICAgIC8qKlxuICAgICAqIEEgdXNlciB0aGF0J3MgbmVpdGhlciBhIHBhcnRuZXIgbm9yIGFuIGFmZmlsaWF0ZS5cbiAgICAgKi9cbiAgICBIZWxpeEJyb2FkY2FzdGVyVHlwZVtcIk5vbmVcIl0gPSBcIlwiO1xufSkoSGVsaXhCcm9hZGNhc3RlclR5cGUgfHwgKEhlbGl4QnJvYWRjYXN0ZXJUeXBlID0ge30pKTtcbmV4cG9ydHMuSGVsaXhCcm9hZGNhc3RlclR5cGUgPSBIZWxpeEJyb2FkY2FzdGVyVHlwZTtcbi8qKlxuICogVGhlIHR5cGUgb2YgYSB1c2VyLlxuICovXG52YXIgSGVsaXhVc2VyVHlwZTtcbihmdW5jdGlvbiAoSGVsaXhVc2VyVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEEgVHdpdGNoIHN0YWZmIG1lbWJlci5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXJUeXBlW1wiU3RhZmZcIl0gPSBcInN0YWZmXCI7XG4gICAgLyoqXG4gICAgICogQSBUd2l0Y2ggYWRtaW5pc3RyYXRvci5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXJUeXBlW1wiQWRtaW5cIl0gPSBcImFkbWluXCI7XG4gICAgLyoqXG4gICAgICogQSBnbG9iYWwgbW9kZXJhdG9yLlxuICAgICAqL1xuICAgIEhlbGl4VXNlclR5cGVbXCJHbG9iYWxNb2RcIl0gPSBcImdsb2JhbF9tb2RcIjtcbiAgICAvKipcbiAgICAgKiBBIHVzZXIgd2l0aCBubyBzcGVjaWFsIHBlcm1pc3Npb25zIGFjcm9zcyBUd2l0Y2guXG4gICAgICovXG4gICAgSGVsaXhVc2VyVHlwZVtcIk5vbmVcIl0gPSBcIlwiO1xufSkoSGVsaXhVc2VyVHlwZSB8fCAoSGVsaXhVc2VyVHlwZSA9IHt9KSk7XG5leHBvcnRzLkhlbGl4VXNlclR5cGUgPSBIZWxpeFVzZXJUeXBlO1xuLyoqXG4gKiBBIFR3aXRjaCB1c2VyLlxuICovXG52YXIgSGVsaXhVc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4VXNlcigvKiogQHByaXZhdGUgKi8gX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VXNlci5wcm90b3R5cGUsIFwiY2FjaGVLZXlcIiwge1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VXNlci5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VXNlci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlciBuYW1lIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sb2dpbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VXNlci5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZGlzcGxheV9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhVc2VyLnByb3RvdHlwZSwgXCJkZXNjcmlwdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmRlc2NyaXB0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhVc2VyLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhVc2VyLnByb3RvdHlwZSwgXCJicm9hZGNhc3RlclR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJyb2FkY2FzdGVyX3R5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFVzZXIucHJvdG90eXBlLCBcInByb2ZpbGVQaWN0dXJlVXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgdG8gdGhlIHByb2ZpbGUgcGljdHVyZSBvZiB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEucHJvZmlsZV9pbWFnZV91cmw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFVzZXIucHJvdG90eXBlLCBcIm9mZmxpbmVQbGFjZWhvbGRlclVybFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIHRvIHRoZSBvZmZsaW5lIHZpZGVvIHBsYWNlaG9sZGVyIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5vZmZsaW5lX2ltYWdlX3VybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VXNlci5wcm90b3R5cGUsIFwidmlld3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvdGFsIG51bWJlciBvZiB2aWV3cyBvZiB0aGUgdXNlcidzIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnZpZXdfY291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2hhbm5lbCdzIHN0cmVhbSBkYXRhLlxuICAgICAqL1xuICAgIEhlbGl4VXNlci5wcm90b3R5cGUuZ2V0U3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXguc3RyZWFtcy5nZXRTdHJlYW1CeVVzZXJJZCh0aGlzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGJyb2FkY2FzdGVycyB0aGUgdXNlciBmb2xsb3dzLlxuICAgICAqL1xuICAgIEhlbGl4VXNlci5wcm90b3R5cGUuZ2V0Rm9sbG93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldEZvbGxvd3MoeyB1c2VyOiB0aGlzIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZm9sbG93IGRhdGEgb2YgdGhlIHVzZXIgdG8gdGhlIGdpdmVuIGJyb2FkY2FzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciB0byBjaGVjayB0aGUgZm9sbG93IHRvLlxuICAgICAqL1xuICAgIEhlbGl4VXNlci5wcm90b3R5cGUuZ2V0Rm9sbG93VG8gPSBmdW5jdGlvbiAoYnJvYWRjYXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbGxvd2VkVXNlcjogYnJvYWRjYXN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0Rm9sbG93cyhwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKF9hLnNlbnQoKSkuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQubGVuZ3RoID8gcmVzdWx0WzBdIDogbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgaXMgZm9sbG93aW5nIHRoZSBnaXZlbiBicm9hZGNhc3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBicm9hZGNhc3RlciBUaGUgYnJvYWRjYXN0ZXIgdG8gY2hlY2sgdGhlIHVzZXIncyBmb2xsb3cgdG8uXG4gICAgICovXG4gICAgSGVsaXhVc2VyLnByb3RvdHlwZS5mb2xsb3dzID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0Rm9sbG93VG8oYnJvYWRjYXN0ZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSkgIT09IG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvbGxvd3MgdGhlIGJyb2FkY2FzdGVyLlxuICAgICAqL1xuICAgIEhlbGl4VXNlci5wcm90b3R5cGUuZm9sbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VXNlcjtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQua3Jha2VuLnVzZXJzLmdldE1lKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjdXJyZW50VXNlci5mb2xsb3dDaGFubmVsKHRoaXMpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmZvbGxvd3MgdGhlIGJyb2FkY2FzdGVyLlxuICAgICAqL1xuICAgIEhlbGl4VXNlci5wcm90b3R5cGUudW5mb2xsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRVc2VyO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuZ2V0TWUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGN1cnJlbnRVc2VyLnVuZm9sbG93Q2hhbm5lbCh0aGlzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBzdWJzY3JpcHRpb24gZGF0YSBmb3IgdGhlIHVzZXIgdG8gdGhlIGdpdmVuIGJyb2FkY2FzdGVyLCBvciBgbnVsbGAgaWYgdGhlIHVzZXIgaXMgbm90IHN1YnNjcmliZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIHlvdSB3YW50IHRvIGdldCB0aGUgc3Vic2NyaXB0aW9uIGRhdGEgZm9yLlxuICAgICAqL1xuICAgIEhlbGl4VXNlci5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9uVG8gPSBmdW5jdGlvbiAoYnJvYWRjYXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnN1YnNjcmlwdGlvbnMuZ2V0U3Vic2NyaXB0aW9uRm9yVXNlcihicm9hZGNhc3RlciwgdGhpcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgaXMgc3Vic2NyaWJlZCB0byB0aGUgZ2l2ZW4gYnJvYWRjYXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIHlvdSB3YW50IHRvIGNoZWNrIHRoZSBzdWJzY3JpcHRpb24gZm9yLlxuICAgICAqL1xuICAgIEhlbGl4VXNlci5wcm90b3R5cGUuaXNTdWJzY3JpYmVkVG8gPSBmdW5jdGlvbiAoYnJvYWRjYXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZV8xO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRTdWJzY3JpcHRpb25Ubyhicm9hZGNhc3RlcildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKSAhPT0gbnVsbF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEgaW5zdGFuY2VvZiBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgSGVsaXhVc2VyLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEhlbGl4VXNlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFVzZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFVzZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhlbGl4QnJvYWRjYXN0ZXJUeXBlID0gSGVsaXhCcm9hZGNhc3RlclR5cGU7XG5leHBvcnRzLkhlbGl4VXNlclR5cGUgPSBIZWxpeFVzZXJUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhVc2VyO1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY3JlYXRlQmluZGluZyhvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG52YXIgJFN5bnRheEVycm9yID0gR2V0SW50cmluc2ljKCclU3ludGF4RXJyb3IlJyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcblxudmFyIHByZWRpY2F0ZXMgPSB7XG5cdC8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wcm9wZXJ0eS1kZXNjcmlwdG9yLXNwZWNpZmljYXRpb24tdHlwZVxuXHQnUHJvcGVydHkgRGVzY3JpcHRvcic6IGZ1bmN0aW9uIGlzUHJvcGVydHlEZXNjcmlwdG9yKFR5cGUsIERlc2MpIHtcblx0XHRpZiAoVHlwZShEZXNjKSAhPT0gJ09iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dmFyIGFsbG93ZWQgPSB7XG5cdFx0XHQnW1tDb25maWd1cmFibGVdXSc6IHRydWUsXG5cdFx0XHQnW1tFbnVtZXJhYmxlXV0nOiB0cnVlLFxuXHRcdFx0J1tbR2V0XV0nOiB0cnVlLFxuXHRcdFx0J1tbU2V0XV0nOiB0cnVlLFxuXHRcdFx0J1tbVmFsdWVdXSc6IHRydWUsXG5cdFx0XHQnW1tXcml0YWJsZV1dJzogdHJ1ZVxuXHRcdH07XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gRGVzYykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0XHRpZiAoaGFzKERlc2MsIGtleSkgJiYgIWFsbG93ZWRba2V5XSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGlzRGF0YSA9IGhhcyhEZXNjLCAnW1tWYWx1ZV1dJyk7XG5cdFx0dmFyIElzQWNjZXNzb3IgPSBoYXMoRGVzYywgJ1tbR2V0XV0nKSB8fCBoYXMoRGVzYywgJ1tbU2V0XV0nKTtcblx0XHRpZiAoaXNEYXRhICYmIElzQWNjZXNzb3IpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdQcm9wZXJ0eSBEZXNjcmlwdG9ycyBtYXkgbm90IGJlIGJvdGggYWNjZXNzb3IgYW5kIGRhdGEgZGVzY3JpcHRvcnMnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXNzZXJ0UmVjb3JkKFR5cGUsIHJlY29yZFR5cGUsIGFyZ3VtZW50TmFtZSwgdmFsdWUpIHtcblx0dmFyIHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNbcmVjb3JkVHlwZV07XG5cdGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigndW5rbm93biByZWNvcmQgdHlwZTogJyArIHJlY29yZFR5cGUpO1xuXHR9XG5cdGlmICghcHJlZGljYXRlKFR5cGUsIHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKGFyZ3VtZW50TmFtZSArICcgbXVzdCBiZSBhICcgKyByZWNvcmRUeXBlKTtcblx0fVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FcnJvcnMvSGVsbEZyZWV6ZXNPdmVyRXJyb3JcIik7XG4vKipcbiAqIFRoZSB0eXBlIG9mIGJhY2tncm91bmQgYSBjaGVlcm1vdGUgaXMgc3VwcG9zZWQgdG8gYXBwZWFyIG9uLlxuICpcbiAqIFdlIHdpbGwgc3VwcGx5IGEgZml0dGluZyBncmFwaGljIHRoYXQgZG9lcyBub3Qgc2hvdyBhbnkgYXJ0aWZhY3RzXG4gKiBvbiB0aGUgZ2l2ZW4gdHlwZSBvZiBiYWNrZ3JvdW5kLlxuICovXG52YXIgQ2hlZXJtb3RlQmFja2dyb3VuZDtcbihmdW5jdGlvbiAoQ2hlZXJtb3RlQmFja2dyb3VuZCkge1xuICAgIC8qKlxuICAgICAqIEEgZGFyayBiYWNrZ3JvdW5kLlxuICAgICAqXG4gICAgICogQ2hlZXJtb3RlcyBtaWdodCBzaG93IGFydGlmYWN0cyBvbiBicmlnaHQgYmFja2dyb3VuZHMuXG4gICAgICovXG4gICAgQ2hlZXJtb3RlQmFja2dyb3VuZFtcImRhcmtcIl0gPSBcImRhcmtcIjtcbiAgICAvKipcbiAgICAgKiBBIGJyaWdodCBiYWNrZ3JvdW5kLlxuICAgICAqXG4gICAgICogQ2hlZXJtb3RlcyBtaWdodCBzaG93IGFydGlmYWN0cyBvbiBkYXJrIGJhY2tncm91bmRzLlxuICAgICAqL1xuICAgIENoZWVybW90ZUJhY2tncm91bmRbXCJsaWdodFwiXSA9IFwibGlnaHRcIjtcbn0pKENoZWVybW90ZUJhY2tncm91bmQgfHwgKENoZWVybW90ZUJhY2tncm91bmQgPSB7fSkpO1xuZXhwb3J0cy5DaGVlcm1vdGVCYWNrZ3JvdW5kID0gQ2hlZXJtb3RlQmFja2dyb3VuZDtcbi8qKlxuICogVGhlIHN0YXRlIG9mIGEgY2hlZXJtb3RlLCBpLmUuIHdoZXRoZXIgaXQncyBhbmltYXRlZCBvciBub3QuXG4gKi9cbnZhciBDaGVlcm1vdGVTdGF0ZTtcbihmdW5jdGlvbiAoQ2hlZXJtb3RlU3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hlZXJtb3RlIHNob3VsZCBiZSBhbmltYXRlZC5cbiAgICAgKi9cbiAgICBDaGVlcm1vdGVTdGF0ZVtcImFuaW1hdGVkXCJdID0gXCJhbmltYXRlZFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGVlcm1vdGUgc2hvdWxkIG5vdCBiZSBhbmltYXRlZC5cbiAgICAgKi9cbiAgICBDaGVlcm1vdGVTdGF0ZVtcInN0YXRpY1wiXSA9IFwic3RhdGljXCI7XG59KShDaGVlcm1vdGVTdGF0ZSB8fCAoQ2hlZXJtb3RlU3RhdGUgPSB7fSkpO1xuZXhwb3J0cy5DaGVlcm1vdGVTdGF0ZSA9IENoZWVybW90ZVN0YXRlO1xuLyoqXG4gKiBUaGUgc2NhbGUgb2YgdGhlIGNoZWVybW90ZSwgd2hpY2ggdXN1YWxseSByZWxhdGVzIHRvIHRoZSBwaXhlbCBkZW5zaXR5IG9mIHRoZSBkZXZpY2UgaW4gdXNlLlxuICovXG52YXIgQ2hlZXJtb3RlU2NhbGU7XG4oZnVuY3Rpb24gKENoZWVybW90ZVNjYWxlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNoZWVybW90ZSBzaG91bGQgbm90IGJlIHNjYWxlZC5cbiAgICAgKi9cbiAgICBDaGVlcm1vdGVTY2FsZVtcIngxXCJdID0gXCIxXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNoZWVybW90ZSBzaG91bGQgYmUgc2NhbGVkIDEuNXguXG4gICAgICovXG4gICAgQ2hlZXJtb3RlU2NhbGVbXCJ4MV81XCJdID0gXCIxLjVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hlZXJtb3RlIHNob3VsZCBiZSBzY2FsZWQgMnguXG4gICAgICovXG4gICAgQ2hlZXJtb3RlU2NhbGVbXCJ4MlwiXSA9IFwiMlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGVlcm1vdGUgc2hvdWxkIGJlIHNjYWxlZCAzeC5cbiAgICAgKi9cbiAgICBDaGVlcm1vdGVTY2FsZVtcIngzXCJdID0gXCIzXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNoZWVybW90ZSBzaG91bGQgYmUgc2NhbGVkIDR4LlxuICAgICAqL1xuICAgIENoZWVybW90ZVNjYWxlW1wieDRcIl0gPSBcIjRcIjtcbn0pKENoZWVybW90ZVNjYWxlIHx8IChDaGVlcm1vdGVTY2FsZSA9IHt9KSk7XG5leHBvcnRzLkNoZWVybW90ZVNjYWxlID0gQ2hlZXJtb3RlU2NhbGU7XG4vKipcbiAqIEEgbGlzdCBvZiBjaGVlcm1vdGVzIHlvdSBjYW4gdXNlIGdsb2JhbGx5IG9yIGluIGEgc3BlY2lmaWMgY2hhbm5lbCwgZGVwZW5kaW5nIG9uIGhvdyB5b3UgZmV0Y2hlZCB0aGUgbGlzdC5cbiAqL1xudmFyIENoZWVybW90ZUxpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gQ2hlZXJtb3RlTGlzdChkYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLl9kYXRhID0gc2hhcmVkX3V0aWxzXzEuaW5kZXhCeShkYXRhLCBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBhY3Rpb24ucHJlZml4LnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBVUkwgYW5kIGNvbG9yIG5lZWRlZCB0byBwcm9wZXJseSByZXByZXNlbnQgYSBjaGVlciBvZiB0aGUgZ2l2ZW4gYW1vdW50IG9mIGJpdHMgd2l0aCB0aGUgZ2l2ZW4gcHJlZml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUvcHJlZml4IG9mIHRoZSBjaGVlcm1vdGUuXG4gICAgICogQHBhcmFtIGJpdHMgVGhlIGFtb3VudCBvZiBiaXRzIGNoZWVyZWQuXG4gICAgICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IG9mIHRoZSBjaGVlcm1vdGUgeW91IHdhbnQgdG8gcmVxdWVzdC5cbiAgICAgKi9cbiAgICBDaGVlcm1vdGVMaXN0LnByb3RvdHlwZS5nZXRDaGVlcm1vdGVEaXNwbGF5SW5mbyA9IGZ1bmN0aW9uIChuYW1lLCBiaXRzLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7IGZvcm1hdCA9IHt9OyB9XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBjaGVlcm1vdGVEZWZhdWx0cyA9IHRoaXMuX2NsaWVudC5jaGVlcm1vdGVEZWZhdWx0cztcbiAgICAgICAgdmFyIGZ1bGxPcHRpb25zID0gdHNsaWJfMS5fX2Fzc2lnbih7IGJhY2tncm91bmQ6IGNoZWVybW90ZURlZmF1bHRzLmRlZmF1bHRCYWNrZ3JvdW5kLCBzdGF0ZTogY2hlZXJtb3RlRGVmYXVsdHMuZGVmYXVsdFN0YXRlLCBzY2FsZTogY2hlZXJtb3RlRGVmYXVsdHMuZGVmYXVsdFNjYWxlIH0sIGZvcm1hdCk7XG4gICAgICAgIHZhciB0aWVycyA9IHRoaXMuX2RhdGFbbmFtZV0udGllcnM7XG4gICAgICAgIHZhciBjb3JyZWN0VGllciA9IHRpZXJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIubWluX2JpdHMgLSBhLm1pbl9iaXRzOyB9KS5maW5kKGZ1bmN0aW9uICh0aWVyKSB7IHJldHVybiB0aWVyLm1pbl9iaXRzIDw9IGJpdHM7IH0pO1xuICAgICAgICBpZiAoIWNvcnJlY3RUaWVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMS5kZWZhdWx0KFwiQ2hlZXJtb3RlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZG9lcyBub3QgaGF2ZSBhbiBhcHBsaWNhYmxlIHRpZXIgZm9yIFwiICsgYml0cyArIFwiIGJpdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybDogY29ycmVjdFRpZXIuaW1hZ2VzW2Z1bGxPcHRpb25zLmJhY2tncm91bmRdW2Z1bGxPcHRpb25zLnN0YXRlXVtmdWxsT3B0aW9ucy5zY2FsZV0sXG4gICAgICAgICAgICBjb2xvcjogY29ycmVjdFRpZXIuY29sb3JcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHBvc3NpYmxlIGNoZWVybW90ZSBuYW1lcy5cbiAgICAgKi9cbiAgICBDaGVlcm1vdGVMaXN0LnByb3RvdHlwZS5nZXRQb3NzaWJsZU5hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYWxsIHRoZSBjaGVlcm1vdGVzIG91dCBvZiBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBDaGVlcm1vdGVMaXN0LnByb3RvdHlwZS5wYXJzZU1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBuYW1lcyA9IHRoaXMuZ2V0UG9zc2libGVOYW1lcygpO1xuICAgICAgICAvLyBUT0RPIGZpeCB0aGlzIHJlZ2V4IHNvIGl0IHdvcmtzIGluIGZpcmVmb3gsIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgbG9va2JlaGluZFxuICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCcoPzw9XnxcXFxccykoW2EtejAtOV0rPykoXFxcXGQrKSg/PVxcXFxzfCQpJywgJ2dpJyk7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMobWVzc2FnZSkpKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChuYW1lcy5pbmNsdWRlcyhuYW1lXzEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFtb3VudCA9IE51bWJlcihtYXRjaFsyXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXzEsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc2hhcmVkX3V0aWxzXzEudXRmOExlbmd0aChtZXNzYWdlLnN1YnN0cigwLCBtYXRjaC5pbmRleCkpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IG1hdGNoWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUluZm86IHRoaXMuZ2V0Q2hlZXJtb3RlRGlzcGxheUluZm8obmFtZV8xLCBhbW91bnQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYWxsIHRoZSBjaGVlcm1vdGVzIGluIGEgbWVzc2FnZSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIG1lc3NhZ2UgcGFydHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtZXIgQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgYSBtZXNzYWdlIHBhcnQgaW50byBhbiBhcmJpdHJhcnkgc3RydWN0dXJlLlxuICAgICAqL1xuICAgIENoZWVybW90ZUxpc3QucHJvdG90eXBlLnRyYW5zZm9ybUNoZWVyTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCB0cmFuc2Zvcm1lcikge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gdHNsaWJfMS5fX3ZhbHVlcyh0aGlzLnBhcnNlTWVzc2FnZShtZXNzYWdlKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRDaGVlcm1vdGUgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uIDwgZm91bmRDaGVlcm1vdGUucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWVzc2FnZS5zdWJzdHJpbmcoY3VycmVudFBvc2l0aW9uLCBmb3VuZENoZWVybW90ZS5wb3NpdGlvbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0cmFuc2Zvcm1lcihmb3VuZENoZWVybW90ZSkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IGZvdW5kQ2hlZXJtb3RlLnBvc2l0aW9uICsgZm91bmRDaGVlcm1vdGUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA8IG1lc3NhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChtZXNzYWdlLnN1YnN0cihjdXJyZW50UG9zaXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIENoZWVybW90ZUxpc3QucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQ2hlZXJtb3RlTGlzdDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGVlcm1vdGVMaXN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ2hlZXJtb3RlTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hlZXJtb3RlQmFja2dyb3VuZCA9IENoZWVybW90ZUJhY2tncm91bmQ7XG5leHBvcnRzLkNoZWVybW90ZVN0YXRlID0gQ2hlZXJtb3RlU3RhdGU7XG5leHBvcnRzLkNoZWVybW90ZVNjYWxlID0gQ2hlZXJtb3RlU2NhbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGVlcm1vdGVMaXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0Vycm9ycy9Ob1N1YnNjcmlwdGlvblByb2dyYW1FcnJvclwiKTtcbi8qKlxuICogQSBwbGFjZWhvbGRlciBmb3IgYSBjaGFubmVsLlxuICpcbiAqIFRoaXMgaXMgdXNlZCBmb3IgZXhhbXBsZSB3aGVuIHlvdSBvbmx5IGhhdmUgcmV0cmlldmVkIHVzZXIgZGF0YSwgYnV0IG5vdCBjaGFubmVsIGRhdGEuXG4gKiBUaGlzIGNhbiBkbyBhbnl0aGluZyB5b3UgY2FuIGRvIHdpdGggb25seSBhIGNoYW5uZWwgSUQsIGFzIGl0J3MgZXF1aXZhbGVudCB0byB0aGUgdXNlciBJRC5cbiAqL1xudmFyIENoYW5uZWxQbGFjZWhvbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBDaGFubmVsUGxhY2Vob2xkZXIoaWQsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0geyBfaWQ6IGlkIH07XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWxQbGFjZWhvbGRlci5wcm90b3R5cGUsIFwiY2FjaGVLZXlcIiwge1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFubmVsUGxhY2Vob2xkZXIucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgY2hlZXJtb3RlcyB5b3UgY2FuIHVzZSBpbiB0aGUgY2hhbm5lbC5cbiAgICAgKi9cbiAgICBDaGFubmVsUGxhY2Vob2xkZXIucHJvdG90eXBlLmdldENoZWVybW90ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4uYml0cy5nZXRDaGVlcm1vdGVzKHRoaXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2hhbm5lbCBkYXRhLlxuICAgICAqL1xuICAgIENoYW5uZWxQbGFjZWhvbGRlci5wcm90b3R5cGUuZ2V0Q2hhbm5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmtyYWtlbi5jaGFubmVscy5nZXRDaGFubmVsKHRoaXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2hhbm5lbCdzIHN0cmVhbSBkYXRhLlxuICAgICAqL1xuICAgIENoYW5uZWxQbGFjZWhvbGRlci5wcm90b3R5cGUuZ2V0U3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLnN0cmVhbXMuZ2V0U3RyZWFtQnlDaGFubmVsKHRoaXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2hhbm5lbCdzIGZvbGxvd2Vycy5cbiAgICAgKi9cbiAgICBDaGFubmVsUGxhY2Vob2xkZXIucHJvdG90eXBlLmdldEZvbGxvd2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmtyYWtlbi5jaGFubmVscy5nZXRDaGFubmVsRm9sbG93ZXJzKHRoaXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2hhbm5lbCdzIHN1YnNjcmliZXJzLlxuICAgICAqL1xuICAgIENoYW5uZWxQbGFjZWhvbGRlci5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmtyYWtlbi5jaGFubmVscy5nZXRDaGFubmVsU3Vic2NyaXB0aW9ucyh0aGlzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHN1YnNjcmlwdGlvbiBkYXRhIGZvciB0aGUgZ2l2ZW4gdXNlciB0byB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIFRocm93cyBpZiB0aGUgY2hhbm5lbCBkb2Vzbid0IGhhdmUgYSBzdWJzY3JpcHRpb24gcHJvZ3JhbSBvciB0aGUgdXNlciBpcyBub3Qgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlcXVpcmVzIGFjY2VzcyB0byB0aGUgY2hhbm5lbC4gSWYgeW91IG9ubHkgaGF2ZSBhY2Nlc3MgdG8gdGhlIHVzZXIsXG4gICAgICogdXNlIHtAVXNlciNnZXRTdWJzY3JpcHRpb25Ub30gaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIGdldCB0aGUgc3Vic2NyaXB0aW9uIGRhdGEgZm9yLlxuICAgICAqL1xuICAgIENoYW5uZWxQbGFjZWhvbGRlci5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9uQnkgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQua3Jha2VuLmNoYW5uZWxzLmdldENoYW5uZWxTdWJzY3JpcHRpb25CeVVzZXIodGhpcywgdXNlcildO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHVzZXIgaXMgc3Vic2NyaWJlZCB0byB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIGNoZWNrIHRoZSBzdWJzY3JpcHRpb24gZm9yLlxuICAgICAqL1xuICAgIENoYW5uZWxQbGFjZWhvbGRlci5wcm90b3R5cGUuaGFzU3Vic2NyaWJlciA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVfMTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0U3Vic2NyaXB0aW9uQnkodXNlcildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKSAhPT0gbnVsbF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEgaW5zdGFuY2VvZiBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgQ2hhbm5lbFBsYWNlaG9sZGVyLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIENoYW5uZWxQbGFjZWhvbGRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFubmVsUGxhY2Vob2xkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDaGFubmVsUGxhY2Vob2xkZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFubmVsUGxhY2Vob2xkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBBIHN1YnNjcmlwdGlvbiB0byBhIFR3aXRjaCBjaGFubmVsLlxuICovXG52YXIgU3Vic2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbigvKiogQHByaXZhdGUgKi8gX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwic3ViUGxhblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgc3Vic2NyaXB0aW9uIHBsYW4uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnN1Yl9wbGFuO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJzdWJQbGFuTmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc3Vic2NyaXB0aW9uIHBsYW4uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnN1Yl9wbGFuX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcInN0YXJ0RGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSB3aGVuIHRoZSBzdWJzY3JpcHRpb24gd2FzIHN0YXJ0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmNyZWF0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgU3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdWJzY3JpcHRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTdWJzY3JpcHRpb247XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdWJzY3JpcHRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBBIFR3aXRjaCB0ZWFtLlxuICovXG52YXIgVGVhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBUZWFtKC8qKiBAcHJpdmF0ZSAqLyBfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVhbS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB0ZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZWFtLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYWNrZ3JvdW5kIHVybCBvZiB0aGUgdGVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuYmFja2dyb3VuZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlYW0ucHJvdG90eXBlLCBcImJhbm5lclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmFubmVyIHVybCBvZiB0aGUgdGVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuYmFubmVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVhbS5wcm90b3R5cGUsIFwiY3JlYXRpb25EYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIHdoZW4gdGhlIHRlYW0gd2FzIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmNyZWF0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVhbS5wcm90b3R5cGUsIFwidXBkYXRlRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFzdCBkYXRlIHdoZW4gdGhlIHRlYW0gY2hhbmdlZCBhbnl0aGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEudXBkYXRlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZWFtLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB0ZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVhbS5wcm90b3R5cGUsIFwiaW5mb1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5mbyBvZiB0aGUgdGVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaW5mbztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlYW0ucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHRlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmRpc3BsYXlfbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlYW0ucHJvdG90eXBlLCBcImxvZ29VcmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCB0byB0aGUgcHJvZmlsZSBwaWN0dXJlIG9mIHRoZSB0ZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sb2dvO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZWFtLnByb3RvdHlwZS5nZXRVc2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGVhbTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQua3Jha2VuLnRlYW1zLmdldFRlYW1CeU5hbWUodGhpcy5uYW1lKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYW0gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGVhbS5nZXRVc2VycygpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgVGVhbS5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBUZWFtO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRlYW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBUZWFtO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gVGVhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgQ2hhbm5lbF8xID0gcmVxdWlyZShcIi4uL0NoYW5uZWwvQ2hhbm5lbFwiKTtcbi8qKlxuICogVGhlIHR5cGUgb2YgYSBzdHJlYW0uXG4gKi9cbnZhciBTdHJlYW1UeXBlO1xuKGZ1bmN0aW9uIChTdHJlYW1UeXBlKSB7XG4gICAgLyoqXG4gICAgICogQSBsaXZlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBTdHJlYW1UeXBlW1wiTGl2ZVwiXSA9IFwibGl2ZVwiO1xuICAgIC8qKlxuICAgICAqIEFuIHVwbG9hZCB0byB0aGUgY2hhbm5lbCAoVm9EKSB0aGF0IGlzIHN0cmVhbWVkIGxpdmUgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgICAqL1xuICAgIFN0cmVhbVR5cGVbXCJQcmVtaWVyZVwiXSA9IFwicHJlbWllcmVcIjtcbiAgICAvKipcbiAgICAgKiBBIHJlcnVuIG9mIGEgcGFzdCBsaXZlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBTdHJlYW1UeXBlW1wiUmVSdW5cIl0gPSBcInJlcnVuXCI7XG4gICAgLyoqXG4gICAgICogQWxsIHR5cGVzIG9mIHN0cmVhbXMuIFVzZWQgZm9yIGZpbHRlcmluZy5cbiAgICAgKi9cbiAgICBTdHJlYW1UeXBlW1wiQWxsXCJdID0gXCJhbGxcIjtcbn0pKFN0cmVhbVR5cGUgfHwgKFN0cmVhbVR5cGUgPSB7fSkpO1xuZXhwb3J0cy5TdHJlYW1UeXBlID0gU3RyZWFtVHlwZTtcbi8qKlxuICogQSBUd2l0Y2ggc3RyZWFtLlxuICovXG52YXIgU3RyZWFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIFN0cmVhbShfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyZWFtLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuX2lkLnRvU3RyaW5nKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW0ucHJvdG90eXBlLCBcImdhbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGdhbWUgcGxheWVkIG9uIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdhbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW0ucHJvdG90eXBlLCBcInZpZXdlcnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGNvbmN1cnJlbnQgdmlld2Vycy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudmlld2VycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmVhbS5wcm90b3R5cGUsIFwidmlkZW9IZWlnaHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3RyZWFtIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS52aWRlb19oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW0ucHJvdG90eXBlLCBcImF2ZXJhZ2VGUFNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGF2ZXJhZ2UgRlBTIChmcmFtZXMgcGVyIHNlY29uZCkgdGhhdCBhcmUgc2hvd24gb24gdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuYXZlcmFnZV9mcHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW0ucHJvdG90eXBlLCBcImRlbGF5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWxheSBvZiB0aGUgc3RyZWFtLCBpbiBzZWNvbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5kZWxheTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmVhbS5wcm90b3R5cGUsIFwic3RhcnREYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHdoZW4gdGhlIHN0cmVhbSBzdGFydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS5jcmVhdGVkX2F0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmVhbS5wcm90b3R5cGUsIFwiaXNQbGF5bGlzdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzdHJlYW0gaXMgcnVubmluZyBhIHBsYXlsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pc19wbGF5bGlzdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmVhbS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zdHJlYW1fdHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgVVJMIG9mIGEgcHJldmlldyBpbWFnZSBmb3IgdGhlIHN0cmVhbVxuICAgICAqXG4gICAgICogQHBhcmFtIHNpemUgVGhlIHNpemUgb2YgdGhlIGltYWdlLlxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUuZ2V0UHJldmlld1VybCA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnByZXZpZXdbc2l6ZV07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyZWFtLnByb3RvdHlwZSwgXCJjaGFubmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGFubmVsIHdoZXJlIHRoZSBzdHJlYW0gaXMgc2hvd24uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhbm5lbF8xLmRlZmF1bHQodGhpcy5fZGF0YS5jaGFubmVsLCB0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgU3RyZWFtLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFN0cmVhbTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdHJlYW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTdHJlYW07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmVhbVR5cGUgPSBTdHJlYW1UeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RyZWFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBmaWxlbmFtZXMvbWF0Y2gtZXhwb3J0ZWQgKi9cbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuL1R3aXRjaENsaWVudFwiKTtcbmV4cG9ydHMuVHdpdGNoQVBJQ2FsbFR5cGUgPSBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZTtcbmV4cG9ydHMuZGVmYXVsdCA9IFR3aXRjaENsaWVudF8xLmRlZmF1bHQ7XG52YXIgQ29uZmlnRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0Vycm9ycy9Db25maWdFcnJvclwiKTtcbmV4cG9ydHMuQ29uZmlnRXJyb3IgPSBDb25maWdFcnJvcl8xLmRlZmF1bHQ7XG52YXIgSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0Vycm9ycy9IZWxsRnJlZXplc092ZXJFcnJvclwiKTtcbmV4cG9ydHMuSGVsbEZyZWV6ZXNPdmVyRXJyb3IgPSBIZWxsRnJlZXplc092ZXJFcnJvcl8xLmRlZmF1bHQ7XG52YXIgSFRUUFN0YXR1c0NvZGVFcnJvcl8xID0gcmVxdWlyZShcIi4vRXJyb3JzL0hUVFBTdGF0dXNDb2RlRXJyb3JcIik7XG5leHBvcnRzLkhUVFBTdGF0dXNDb2RlRXJyb3IgPSBIVFRQU3RhdHVzQ29kZUVycm9yXzEuZGVmYXVsdDtcbnZhciBJbnZhbGlkVG9rZW5FcnJvcl8xID0gcmVxdWlyZShcIi4vRXJyb3JzL0ludmFsaWRUb2tlbkVycm9yXCIpO1xuZXhwb3J0cy5JbnZhbGlkVG9rZW5FcnJvciA9IEludmFsaWRUb2tlbkVycm9yXzEuZGVmYXVsdDtcbnZhciBJbnZhbGlkVG9rZW5UeXBlRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0Vycm9ycy9JbnZhbGlkVG9rZW5UeXBlRXJyb3JcIik7XG5leHBvcnRzLkludmFsaWRUb2tlblR5cGVFcnJvciA9IEludmFsaWRUb2tlblR5cGVFcnJvcl8xLmRlZmF1bHQ7XG52YXIgTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0Vycm9ycy9Ob1N1YnNjcmlwdGlvblByb2dyYW1FcnJvclwiKTtcbmV4cG9ydHMuTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3IgPSBOb1N1YnNjcmlwdGlvblByb2dyYW1FcnJvcl8xLmRlZmF1bHQ7XG52YXIgU3RyZWFtTm90TGl2ZUVycm9yXzEgPSByZXF1aXJlKFwiLi9FcnJvcnMvU3RyZWFtTm90TGl2ZUVycm9yXCIpO1xuZXhwb3J0cy5TdHJlYW1Ob3RMaXZlRXJyb3IgPSBTdHJlYW1Ob3RMaXZlRXJyb3JfMS5kZWZhdWx0O1xudmFyIFN0YXRpY0F1dGhQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vQXV0aC9TdGF0aWNBdXRoUHJvdmlkZXJcIik7XG5leHBvcnRzLlN0YXRpY0F1dGhQcm92aWRlciA9IFN0YXRpY0F1dGhQcm92aWRlcl8xLmRlZmF1bHQ7XG52YXIgUmVmcmVzaGFibGVBdXRoUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL0F1dGgvUmVmcmVzaGFibGVBdXRoUHJvdmlkZXJcIik7XG5leHBvcnRzLlJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyID0gUmVmcmVzaGFibGVBdXRoUHJvdmlkZXJfMS5kZWZhdWx0O1xudmFyIEFjY2Vzc1Rva2VuXzEgPSByZXF1aXJlKFwiLi9BUEkvQWNjZXNzVG9rZW5cIik7XG5leHBvcnRzLkFjY2Vzc1Rva2VuID0gQWNjZXNzVG9rZW5fMS5kZWZhdWx0O1xudmFyIFRva2VuSW5mb18xID0gcmVxdWlyZShcIi4vQVBJL1Rva2VuSW5mb1wiKTtcbmV4cG9ydHMuVG9rZW5JbmZvID0gVG9rZW5JbmZvXzEuZGVmYXVsdDtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vU3Vic2NyaXB0aW9uXCIpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb25fMS5kZWZhdWx0O1xudmFyIENoZWVybW90ZUxpc3RfMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vQml0cy9DaGVlcm1vdGVMaXN0XCIpO1xuZXhwb3J0cy5DaGVlcm1vdGVMaXN0ID0gQ2hlZXJtb3RlTGlzdF8xLmRlZmF1bHQ7XG5leHBvcnRzLkNoZWVybW90ZUJhY2tncm91bmQgPSBDaGVlcm1vdGVMaXN0XzEuQ2hlZXJtb3RlQmFja2dyb3VuZDtcbmV4cG9ydHMuQ2hlZXJtb3RlU2NhbGUgPSBDaGVlcm1vdGVMaXN0XzEuQ2hlZXJtb3RlU2NhbGU7XG5leHBvcnRzLkNoZWVybW90ZVN0YXRlID0gQ2hlZXJtb3RlTGlzdF8xLkNoZWVybW90ZVN0YXRlO1xudmFyIENoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vQ2hhbm5lbC9DaGFubmVsXCIpO1xuZXhwb3J0cy5DaGFubmVsID0gQ2hhbm5lbF8xLmRlZmF1bHQ7XG52YXIgQ2hhbm5lbEZvbGxvd18xID0gcmVxdWlyZShcIi4vQVBJL0tyYWtlbi9DaGFubmVsL0NoYW5uZWxGb2xsb3dcIik7XG5leHBvcnRzLkNoYW5uZWxGb2xsb3cgPSBDaGFubmVsRm9sbG93XzEuZGVmYXVsdDtcbnZhciBDaGFubmVsUGxhY2Vob2xkZXJfMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vQ2hhbm5lbC9DaGFubmVsUGxhY2Vob2xkZXJcIik7XG5leHBvcnRzLkNoYW5uZWxQbGFjZWhvbGRlciA9IENoYW5uZWxQbGFjZWhvbGRlcl8xLmRlZmF1bHQ7XG52YXIgQ2hhbm5lbFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vQVBJL0tyYWtlbi9DaGFubmVsL0NoYW5uZWxTdWJzY3JpcHRpb25cIik7XG5leHBvcnRzLkNoYW5uZWxTdWJzY3JpcHRpb24gPSBDaGFubmVsU3Vic2NyaXB0aW9uXzEuZGVmYXVsdDtcbnZhciBFbW90ZVNldExpc3RfMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vQ2hhbm5lbC9FbW90ZVNldExpc3RcIik7XG5leHBvcnRzLkVtb3RlU2V0TGlzdCA9IEVtb3RlU2V0TGlzdF8xLmRlZmF1bHQ7XG52YXIgUHJpdmlsZWdlZENoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vQ2hhbm5lbC9Qcml2aWxlZ2VkQ2hhbm5lbFwiKTtcbmV4cG9ydHMuUHJpdmlsZWdlZENoYW5uZWwgPSBQcml2aWxlZ2VkQ2hhbm5lbF8xLmRlZmF1bHQ7XG52YXIgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL1N0cmVhbS9TdHJlYW1cIik7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbV8xLmRlZmF1bHQ7XG5leHBvcnRzLlN0cmVhbVR5cGUgPSBTdHJlYW1fMS5TdHJlYW1UeXBlO1xudmFyIENoYXR0ZXJzTGlzdF8xID0gcmVxdWlyZShcIi4vQVBJL1Vuc3VwcG9ydGVkL0NoYXR0ZXJzTGlzdFwiKTtcbmV4cG9ydHMuQ2hhdHRlcnNMaXN0ID0gQ2hhdHRlcnNMaXN0XzEuZGVmYXVsdDtcbnZhciBQcml2aWxlZ2VkVXNlcl8xID0gcmVxdWlyZShcIi4vQVBJL0tyYWtlbi9Vc2VyL1ByaXZpbGVnZWRVc2VyXCIpO1xuZXhwb3J0cy5Qcml2aWxlZ2VkVXNlciA9IFByaXZpbGVnZWRVc2VyXzEuZGVmYXVsdDtcbnZhciBVc2VyXzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL1VzZXIvVXNlclwiKTtcbmV4cG9ydHMuVXNlciA9IFVzZXJfMS5kZWZhdWx0O1xudmFyIFVzZXJCbG9ja18xID0gcmVxdWlyZShcIi4vQVBJL0tyYWtlbi9Vc2VyL1VzZXJCbG9ja1wiKTtcbmV4cG9ydHMuVXNlckJsb2NrID0gVXNlckJsb2NrXzEuZGVmYXVsdDtcbnZhciBVc2VyRm9sbG93XzEgPSByZXF1aXJlKFwiLi9BUEkvS3Jha2VuL1VzZXIvVXNlckZvbGxvd1wiKTtcbmV4cG9ydHMuVXNlckZvbGxvdyA9IFVzZXJGb2xsb3dfMS5kZWZhdWx0O1xudmFyIFVzZXJTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuL0FQSS9LcmFrZW4vVXNlci9Vc2VyU3Vic2NyaXB0aW9uXCIpO1xuZXhwb3J0cy5Vc2VyU3Vic2NyaXB0aW9uID0gVXNlclN1YnNjcmlwdGlvbl8xLmRlZmF1bHQ7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XCIpO1xuZXhwb3J0cy5IZWxpeFBhZ2luYXRlZFJlcXVlc3QgPSBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0O1xudmFyIEhlbGl4Qml0c0xlYWRlcmJvYXJkXzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvQml0cy9IZWxpeEJpdHNMZWFkZXJib2FyZFwiKTtcbmV4cG9ydHMuSGVsaXhCaXRzTGVhZGVyYm9hcmQgPSBIZWxpeEJpdHNMZWFkZXJib2FyZF8xLmRlZmF1bHQ7XG52YXIgSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeV8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L0JpdHMvSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeVwiKTtcbmV4cG9ydHMuSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeSA9IEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnlfMS5kZWZhdWx0O1xudmFyIEhlbGl4Q2xpcF8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L0NsaXAvSGVsaXhDbGlwXCIpO1xuZXhwb3J0cy5IZWxpeENsaXAgPSBIZWxpeENsaXBfMS5kZWZhdWx0O1xudmFyIEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9FeHRlbnNpb25zL0hlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb25cIik7XG5leHBvcnRzLkhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb24gPSBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uXzEuZGVmYXVsdDtcbnZhciBIZWxpeEdhbWVfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9HYW1lL0hlbGl4R2FtZVwiKTtcbmV4cG9ydHMuSGVsaXhHYW1lID0gSGVsaXhHYW1lXzEuZGVmYXVsdDtcbnZhciBIZWxpeEJhbl8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L01vZGVyYXRpb24vSGVsaXhCYW5cIik7XG5leHBvcnRzLkhlbGl4QmFuID0gSGVsaXhCYW5fMS5kZWZhdWx0O1xudmFyIEhlbGl4QmFuRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9Nb2RlcmF0aW9uL0hlbGl4QmFuRXZlbnRcIik7XG5leHBvcnRzLkhlbGl4QmFuRXZlbnQgPSBIZWxpeEJhbkV2ZW50XzEuZGVmYXVsdDtcbnZhciBIZWxpeE1vZGVyYXRvcl8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L01vZGVyYXRpb24vSGVsaXhNb2RlcmF0b3JcIik7XG5leHBvcnRzLkhlbGl4TW9kZXJhdG9yID0gSGVsaXhNb2RlcmF0b3JfMS5kZWZhdWx0O1xudmFyIEhlbGl4TW9kZXJhdG9yRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0FQSS9IZWxpeC9Nb2RlcmF0aW9uL0hlbGl4TW9kZXJhdG9yRXZlbnRcIik7XG5leHBvcnRzLkhlbGl4TW9kZXJhdG9yRXZlbnQgPSBIZWxpeE1vZGVyYXRvckV2ZW50XzEuZGVmYXVsdDtcbnZhciBIZWxpeFN0cmVhbV8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L1N0cmVhbS9IZWxpeFN0cmVhbVwiKTtcbmV4cG9ydHMuSGVsaXhTdHJlYW0gPSBIZWxpeFN0cmVhbV8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4U3RyZWFtVHlwZSA9IEhlbGl4U3RyZWFtXzEuSGVsaXhTdHJlYW1UeXBlO1xudmFyIEhlbGl4Rm9sbG93XzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvVXNlci9IZWxpeEZvbGxvd1wiKTtcbmV4cG9ydHMuSGVsaXhGb2xsb3cgPSBIZWxpeEZvbGxvd18xLmRlZmF1bHQ7XG52YXIgSGVsaXhQcml2aWxlZ2VkVXNlcl8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L1VzZXIvSGVsaXhQcml2aWxlZ2VkVXNlclwiKTtcbmV4cG9ydHMuSGVsaXhQcml2aWxlZ2VkVXNlciA9IEhlbGl4UHJpdmlsZWdlZFVzZXJfMS5kZWZhdWx0O1xudmFyIEhlbGl4VXNlcl8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L1VzZXIvSGVsaXhVc2VyXCIpO1xuZXhwb3J0cy5IZWxpeFVzZXIgPSBIZWxpeFVzZXJfMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeEJyb2FkY2FzdGVyVHlwZSA9IEhlbGl4VXNlcl8xLkhlbGl4QnJvYWRjYXN0ZXJUeXBlO1xuZXhwb3J0cy5IZWxpeFVzZXJUeXBlID0gSGVsaXhVc2VyXzEuSGVsaXhVc2VyVHlwZTtcbnZhciBIZWxpeFZpZGVvXzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvVmlkZW8vSGVsaXhWaWRlb1wiKTtcbmV4cG9ydHMuSGVsaXhWaWRlbyA9IEhlbGl4VmlkZW9fMS5kZWZhdWx0O1xudmFyIEhlbGl4U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9BUEkvSGVsaXgvU3Vic2NyaXB0aW9ucy9IZWxpeFN1YnNjcmlwdGlvblwiKTtcbmV4cG9ydHMuSGVsaXhTdWJzY3JpcHRpb24gPSBIZWxpeFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQ7XG52YXIgSGVsaXhTdWJzY3JpcHRpb25FdmVudF8xID0gcmVxdWlyZShcIi4vQVBJL0hlbGl4L1N1YnNjcmlwdGlvbnMvSGVsaXhTdWJzY3JpcHRpb25FdmVudFwiKTtcbmV4cG9ydHMuSGVsaXhTdWJzY3JpcHRpb25FdmVudCA9IEhlbGl4U3Vic2NyaXB0aW9uRXZlbnRfMS5kZWZhdWx0O1xudmFyIENoYXRCYWRnZUxpc3RfMSA9IHJlcXVpcmUoXCIuL0FQSS9CYWRnZXMvQ2hhdEJhZGdlTGlzdFwiKTtcbmV4cG9ydHMuQ2hhdEJhZGdlTGlzdCA9IENoYXRCYWRnZUxpc3RfMS5kZWZhdWx0O1xudmFyIENoYXRCYWRnZVNldF8xID0gcmVxdWlyZShcIi4vQVBJL0JhZGdlcy9DaGF0QmFkZ2VTZXRcIik7XG5leHBvcnRzLkNoYXRCYWRnZVNldCA9IENoYXRCYWRnZVNldF8xLmRlZmF1bHQ7XG52YXIgQ2hhdEJhZGdlVmVyc2lvbl8xID0gcmVxdWlyZShcIi4vQVBJL0JhZGdlcy9DaGF0QmFkZ2VWZXJzaW9uXCIpO1xuZXhwb3J0cy5DaGF0QmFkZ2VWZXJzaW9uID0gQ2hhdEJhZGdlVmVyc2lvbl8xLmRlZmF1bHQ7XG52YXIgVXNlclRvb2xzXzEgPSByZXF1aXJlKFwiLi9Ub29sa2l0L1VzZXJUb29sc1wiKTtcbmV4cG9ydHMuZXh0cmFjdFVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQ7XG5leHBvcnRzLmV4dHJhY3RVc2VyTmFtZSA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VyTmFtZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFR3aXRjaENsaWVudF8xLmRlZmF1bHQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR3aXRjaEFQSUNhbGxUeXBlID0gVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGU7XG5leHBvcnRzLmRlZmF1bHQgPSBUd2l0Y2hDbGllbnRfMS5kZWZhdWx0O1xuZXhwb3J0cy5Db25maWdFcnJvciA9IENvbmZpZ0Vycm9yXzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsbEZyZWV6ZXNPdmVyRXJyb3IgPSBIZWxsRnJlZXplc092ZXJFcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLkhUVFBTdGF0dXNDb2RlRXJyb3IgPSBIVFRQU3RhdHVzQ29kZUVycm9yXzEuZGVmYXVsdDtcbmV4cG9ydHMuSW52YWxpZFRva2VuRXJyb3IgPSBJbnZhbGlkVG9rZW5FcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLkludmFsaWRUb2tlblR5cGVFcnJvciA9IEludmFsaWRUb2tlblR5cGVFcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLk5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yID0gTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMS5kZWZhdWx0O1xuZXhwb3J0cy5TdHJlYW1Ob3RMaXZlRXJyb3IgPSBTdHJlYW1Ob3RMaXZlRXJyb3JfMS5kZWZhdWx0O1xuZXhwb3J0cy5TdGF0aWNBdXRoUHJvdmlkZXIgPSBTdGF0aWNBdXRoUHJvdmlkZXJfMS5kZWZhdWx0O1xuZXhwb3J0cy5SZWZyZXNoYWJsZUF1dGhQcm92aWRlciA9IFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyXzEuZGVmYXVsdDtcbmV4cG9ydHMuQWNjZXNzVG9rZW4gPSBBY2Nlc3NUb2tlbl8xLmRlZmF1bHQ7XG5leHBvcnRzLlRva2VuSW5mbyA9IFRva2VuSW5mb18xLmRlZmF1bHQ7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQ7XG5leHBvcnRzLkNoZWVybW90ZUxpc3QgPSBDaGVlcm1vdGVMaXN0XzEuZGVmYXVsdDtcbmV4cG9ydHMuQ2hlZXJtb3RlQmFja2dyb3VuZCA9IENoZWVybW90ZUxpc3RfMS5DaGVlcm1vdGVCYWNrZ3JvdW5kO1xuZXhwb3J0cy5DaGVlcm1vdGVTY2FsZSA9IENoZWVybW90ZUxpc3RfMS5DaGVlcm1vdGVTY2FsZTtcbmV4cG9ydHMuQ2hlZXJtb3RlU3RhdGUgPSBDaGVlcm1vdGVMaXN0XzEuQ2hlZXJtb3RlU3RhdGU7XG5leHBvcnRzLkNoYW5uZWwgPSBDaGFubmVsXzEuZGVmYXVsdDtcbmV4cG9ydHMuQ2hhbm5lbEZvbGxvdyA9IENoYW5uZWxGb2xsb3dfMS5kZWZhdWx0O1xuZXhwb3J0cy5DaGFubmVsUGxhY2Vob2xkZXIgPSBDaGFubmVsUGxhY2Vob2xkZXJfMS5kZWZhdWx0O1xuZXhwb3J0cy5DaGFubmVsU3Vic2NyaXB0aW9uID0gQ2hhbm5lbFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQ7XG5leHBvcnRzLkVtb3RlU2V0TGlzdCA9IEVtb3RlU2V0TGlzdF8xLmRlZmF1bHQ7XG5leHBvcnRzLlByaXZpbGVnZWRDaGFubmVsID0gUHJpdmlsZWdlZENoYW5uZWxfMS5kZWZhdWx0O1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW1fMS5kZWZhdWx0O1xuZXhwb3J0cy5TdHJlYW1UeXBlID0gU3RyZWFtXzEuU3RyZWFtVHlwZTtcbmV4cG9ydHMuQ2hhdHRlcnNMaXN0ID0gQ2hhdHRlcnNMaXN0XzEuZGVmYXVsdDtcbmV4cG9ydHMuUHJpdmlsZWdlZFVzZXIgPSBQcml2aWxlZ2VkVXNlcl8xLmRlZmF1bHQ7XG5leHBvcnRzLlVzZXIgPSBVc2VyXzEuZGVmYXVsdDtcbmV4cG9ydHMuVXNlckJsb2NrID0gVXNlckJsb2NrXzEuZGVmYXVsdDtcbmV4cG9ydHMuVXNlckZvbGxvdyA9IFVzZXJGb2xsb3dfMS5kZWZhdWx0O1xuZXhwb3J0cy5Vc2VyU3Vic2NyaXB0aW9uID0gVXNlclN1YnNjcmlwdGlvbl8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4UGFnaW5hdGVkUmVxdWVzdCA9IEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4Qml0c0xlYWRlcmJvYXJkID0gSGVsaXhCaXRzTGVhZGVyYm9hcmRfMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5ID0gSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeV8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4Q2xpcCA9IEhlbGl4Q2xpcF8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb24gPSBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uXzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhHYW1lID0gSGVsaXhHYW1lXzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhCYW4gPSBIZWxpeEJhbl8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4QmFuRXZlbnQgPSBIZWxpeEJhbkV2ZW50XzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhNb2RlcmF0b3IgPSBIZWxpeE1vZGVyYXRvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4TW9kZXJhdG9yRXZlbnQgPSBIZWxpeE1vZGVyYXRvckV2ZW50XzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhTdHJlYW0gPSBIZWxpeFN0cmVhbV8xLmRlZmF1bHQ7XG5leHBvcnRzLkhlbGl4U3RyZWFtVHlwZSA9IEhlbGl4U3RyZWFtXzEuSGVsaXhTdHJlYW1UeXBlO1xuZXhwb3J0cy5IZWxpeEZvbGxvdyA9IEhlbGl4Rm9sbG93XzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhQcml2aWxlZ2VkVXNlciA9IEhlbGl4UHJpdmlsZWdlZFVzZXJfMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeFVzZXIgPSBIZWxpeFVzZXJfMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeEJyb2FkY2FzdGVyVHlwZSA9IEhlbGl4VXNlcl8xLkhlbGl4QnJvYWRjYXN0ZXJUeXBlO1xuZXhwb3J0cy5IZWxpeFVzZXJUeXBlID0gSGVsaXhVc2VyXzEuSGVsaXhVc2VyVHlwZTtcbmV4cG9ydHMuSGVsaXhWaWRlbyA9IEhlbGl4VmlkZW9fMS5kZWZhdWx0O1xuZXhwb3J0cy5IZWxpeFN1YnNjcmlwdGlvbiA9IEhlbGl4U3Vic2NyaXB0aW9uXzEuZGVmYXVsdDtcbmV4cG9ydHMuSGVsaXhTdWJzY3JpcHRpb25FdmVudCA9IEhlbGl4U3Vic2NyaXB0aW9uRXZlbnRfMS5kZWZhdWx0O1xuZXhwb3J0cy5DaGF0QmFkZ2VMaXN0ID0gQ2hhdEJhZGdlTGlzdF8xLmRlZmF1bHQ7XG5leHBvcnRzLkNoYXRCYWRnZVNldCA9IENoYXRCYWRnZVNldF8xLmRlZmF1bHQ7XG5leHBvcnRzLkNoYXRCYWRnZVZlcnNpb24gPSBDaGF0QmFkZ2VWZXJzaW9uXzEuZGVmYXVsdDtcbmV4cG9ydHMuZXh0cmFjdFVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQ7XG5leHBvcnRzLmV4dHJhY3RVc2VyTmFtZSA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VyTmFtZTtcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NyZWF0ZUJpbmRpbmcobywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ0xldmVsXzEgPSByZXF1aXJlKFwiLi9Mb2dMZXZlbFwiKTtcbnZhciBpc05vZGUgPSByZXF1aXJlKFwiZGV0ZWN0LW5vZGVcIik7XG52YXIgQmFzZUxvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlTG9nZ2VyKF9hKSB7XG4gICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgX2IgPSBfYS5taW5MZXZlbCwgbWluTGV2ZWwgPSBfYiA9PT0gdm9pZCAwID8gTG9nTGV2ZWxfMS5kZWZhdWx0LldBUk5JTkcgOiBfYiwgX2MgPSBfYS5lbW9qaSwgZW1vamkgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgX2QgPSBfYS5jb2xvcnMsIGNvbG9ycyA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsIF9lID0gX2EudGltZXN0YW1wcywgdGltZXN0YW1wcyA9IF9lID09PSB2b2lkIDAgPyBpc05vZGUgOiBfZTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX21pbkxldmVsID0gTG9nTGV2ZWxfMS5yZXNvbHZlTG9nTGV2ZWwobWluTGV2ZWwpO1xuICAgICAgICB0aGlzLl9lbW9qaSA9IGVtb2ppO1xuICAgICAgICB0aGlzLl9jb2xvcnMgPSBjb2xvcnM7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcHMgPSB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICAvLyByZWdpb24gY29udmVuaWVuY2UgbWV0aG9kc1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmNyaXQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLmRlZmF1bHQuQ1JJVElDQUwsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUuY3JpdGljYWwgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLmRlZmF1bHQuQ1JJVElDQUwsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUuZXJyID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5kZWZhdWx0LkVSUk9SLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5kZWZhdWx0LkVSUk9SLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLmRlZmF1bHQuV0FSTklORywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS53YXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5kZWZhdWx0LldBUk5JTkcsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuZGVmYXVsdC5JTkZPLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5kZWZhdWx0LkRFQlVHLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgZGVidWcgaW5zdGVhZCAqL1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmRlYnVnMSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuZGVmYXVsdC5ERUJVRywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGRlYnVnIGluc3RlYWQgKi9cbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZzIgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLmRlZmF1bHQuREVCVUcsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBkZWJ1ZyBpbnN0ZWFkICovXG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUuZGVidWczID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5kZWZhdWx0LkRFQlVHLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5kZWZhdWx0LlRSQUNFLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlTG9nZ2VyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VMb2dnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBCYXNlTG9nZ2VyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZUxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VMb2dnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcbnZhciBwZXJjZW50VHdlbnRpZXMgPSAvJTIwL2c7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgRm9ybWF0ID0ge1xuICAgIFJGQzE3Mzg6ICdSRkMxNzM4JyxcbiAgICBSRkMzOTg2OiAnUkZDMzk4Nidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbC5hc3NpZ24oXG4gICAge1xuICAgICAgICAnZGVmYXVsdCc6IEZvcm1hdC5SRkMzOTg2LFxuICAgICAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgICAgICBSRkMxNzM4OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZS5jYWxsKHZhbHVlLCBwZXJjZW50VHdlbnRpZXMsICcrJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUkZDMzk4NjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIEZvcm1hdFxuKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5mdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgdHNsaWJfMS5fX3NwcmVhZChbe31dLCBPYmplY3QuZW50cmllcyhvYmopXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKF9hLCAxKSwga2V5ID0gX2JbMF07XG4gICAgICAgIHJldHVybiBrZXlzLmluY2x1ZGVzKGtleSk7XG4gICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgX2MgPSB0c2xpYl8xLl9fcmVhZChfYSwgMiksIGtleSA9IF9jWzBdLCB2YWx1ZSA9IF9jWzFdO1xuICAgICAgICByZXR1cm4gKF9iID0ge30sIF9iW2tleV0gPSB2YWx1ZSwgX2IpO1xuICAgIH0pKSk7XG59XG5leHBvcnRzLnBpY2sgPSBwaWNrO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5waWNrID0gcGljaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBDaGF0QmFkZ2VTZXRfMSA9IHJlcXVpcmUoXCIuL0NoYXRCYWRnZVNldFwiKTtcbi8qKlxuICogQSBsaXN0IG9mIGJhZGdlIHNldHMuXG4gKi9cbnZhciBDaGF0QmFkZ2VMaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIENoYXRCYWRnZUxpc3QoX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRCYWRnZUxpc3QucHJvdG90eXBlLCBcImJhZGdlU2V0TmFtZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZXMgb2YgYWxsIGJhZGdlIHNldHMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHNwZWNpZmljIGJhZGdlIHNldCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGJhZGdlIHNldC5cbiAgICAgKi9cbiAgICBDaGF0QmFkZ2VMaXN0LnByb3RvdHlwZS5nZXRCYWRnZVNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdEJhZGdlU2V0XzEuZGVmYXVsdCh0aGlzLl9kYXRhW25hbWVdLCB0aGlzLl9jbGllbnQpO1xuICAgIH07XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgQ2hhdEJhZGdlTGlzdC5wcm90b3R5cGUuX21lcmdlID0gZnVuY3Rpb24gKGFkZGl0aW9uYWxEYXRhKSB7XG4gICAgICAgIGlmIChhZGRpdGlvbmFsRGF0YSBpbnN0YW5jZW9mIENoYXRCYWRnZUxpc3QpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxEYXRhID0gYWRkaXRpb25hbERhdGEuX2RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0QmFkZ2VMaXN0KHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5fZGF0YSksIGFkZGl0aW9uYWxEYXRhKSwgdGhpcy5fY2xpZW50KTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBDaGF0QmFkZ2VMaXN0LnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIENoYXRCYWRnZUxpc3Q7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEJhZGdlTGlzdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENoYXRCYWRnZUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGF0QmFkZ2VMaXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBDaGF0QmFkZ2VWZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9DaGF0QmFkZ2VWZXJzaW9uXCIpO1xuLyoqXG4gKiBBIHNldCBvZiBiYWRnZXMuXG4gKi9cbnZhciBDaGF0QmFkZ2VTZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gQ2hhdEJhZGdlU2V0KF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0QmFkZ2VTZXQucHJvdG90eXBlLCBcInZlcnNpb25OYW1lc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lcyBvZiBhbGwgdmVyc2lvbnMgb2YgdGhlIGJhZGdlIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2RhdGEudmVyc2lvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc3BlY2lmaWMgdmVyc2lvbiBvZiBhIGJhZGdlIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBDaGF0QmFkZ2VTZXQucHJvdG90eXBlLmdldFZlcnNpb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IENoYXRCYWRnZVZlcnNpb25fMS5kZWZhdWx0KHRoaXMuX2RhdGEudmVyc2lvbnNbbmFtZV0sIHRoaXMuX2NsaWVudCk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgQ2hhdEJhZGdlU2V0LnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIENoYXRCYWRnZVNldDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGF0QmFkZ2VTZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDaGF0QmFkZ2VTZXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGF0QmFkZ2VTZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBBIHZlcnNpb24gb2YgYSBiYWRnZS5cbiAqL1xudmFyIENoYXRCYWRnZVZlcnNpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gQ2hhdEJhZGdlVmVyc2lvbihfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdEJhZGdlVmVyc2lvbi5wcm90b3R5cGUsIFwiY2xpY2tBY3Rpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGJhZGdlIGlzIGNsaWNrZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmNsaWNrX2FjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRCYWRnZVZlcnNpb24ucHJvdG90eXBlLCBcImNsaWNrVXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgdG8gdmlzaXQgd2hlbiB0aGUgYmFkZ2UgaXMgY2xpY2tlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogT25seSBhcHBsaWVzIGlmIGNsaWNrQWN0aW9uID09PSAndmlzaXRfdXJsJy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuY2xpY2tfdXJsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdEJhZGdlVmVyc2lvbi5wcm90b3R5cGUsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBiYWRnZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZGVzY3JpcHRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gaW1hZ2UgVVJMIGZvciB0aGUgZ2l2ZW4gc2NhbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlIG9mIHRoZSBiYWRnZSBpbWFnZS5cbiAgICAgKi9cbiAgICBDaGF0QmFkZ2VWZXJzaW9uLnByb3RvdHlwZS5nZXRJbWFnZVVybCA9IGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtcImltYWdlX3VybF9cIiArIHNjYWxlICsgXCJ4XCJdO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRCYWRnZVZlcnNpb24ucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aXRsZSBvZiB0aGUgYmFkZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnRpdGxlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgQ2hhdEJhZGdlVmVyc2lvbi5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBDaGF0QmFkZ2VWZXJzaW9uO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYXRCYWRnZVZlcnNpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDaGF0QmFkZ2VWZXJzaW9uO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEJhZGdlVmVyc2lvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBIZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5XzEgPSByZXF1aXJlKFwiLi9IZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5XCIpO1xuLyoqXG4gKiBBIGxlYWRlcmJvYXJkIHdoZXJlIHRoZSB1c2VycyB3aG8gdXNlZCB0aGUgbW9zdCBiaXRzIHRvIGEgYnJvYWRjYXN0ZXIgYXJlIGxpc3RlZC5cbiAqL1xudmFyIEhlbGl4Qml0c0xlYWRlcmJvYXJkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4Qml0c0xlYWRlcmJvYXJkKF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEJpdHNMZWFkZXJib2FyZC5wcm90b3R5cGUsIFwiZW50cmllc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZW50cmllcyBvZiB0aGUgbGVhZGVyYm9hcmQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5kYXRhLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIG5ldyBIZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5XzEuZGVmYXVsdChlbnRyeSwgX3RoaXMuX2NsaWVudCk7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCaXRzTGVhZGVyYm9hcmQucHJvdG90eXBlLCBcInRvdGFsQ291bnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvdGFsIGFtb3VudCBvZiBwZW9wbGUgb24gdGhlIHJlcXVlc3RlZCBsZWFkZXJib2FyZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudG90YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeEJpdHNMZWFkZXJib2FyZC5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEhlbGl4Qml0c0xlYWRlcmJvYXJkLnByb3RvdHlwZSwgXCJlbnRyaWVzXCIsIG51bGwpO1xuICAgIEhlbGl4Qml0c0xlYWRlcmJvYXJkID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIEhlbGl4Qml0c0xlYWRlcmJvYXJkKTtcbiAgICByZXR1cm4gSGVsaXhCaXRzTGVhZGVyYm9hcmQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhCaXRzTGVhZGVyYm9hcmQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeEJpdHNMZWFkZXJib2FyZDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4Qml0c0xlYWRlcmJvYXJkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogQSBCaXRzIGxlYWRlcmJvYXJkIGVudHJ5LlxuICovXG52YXIgSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5KF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5LnByb3RvdHlwZSwgXCJ1c2VySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB1c2VyIG9uIHRoZSBsZWFkZXJib2FyZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnkucHJvdG90eXBlLCBcInVzZXJEaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSB1c2VyIG9uIHRoZSBsZWFkZXJib2FyZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeS5wcm90b3R5cGUsIFwicmFua1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIHVzZXIgb24gdGhlIGxlYWRlcmJvYXJkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5yYW5rO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeS5wcm90b3R5cGUsIFwiYW1vdW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgYml0cyB1c2VkIGluIHRoZSBnaXZlbiBwZXJpb2Qgb2YgdGltZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc2NvcmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdXNlciB0aGF0J3Mgb24gdGhpcyBwbGFjZSBvbiB0aGUgbGVhZGVyYm9hcmQuXG4gICAgICovXG4gICAgSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeS5wcm90b3R5cGUuZ2V0VXNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeUlkKHRoaXMuX2RhdGEudXNlcl9pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnkucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEJpdHNMZWFkZXJib2FyZEVudHJ5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhCaXRzTGVhZGVyYm9hcmRFbnRyeTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4Qml0c0xlYWRlcmJvYXJkRW50cnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIEhlbGl4Q2xpcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeENsaXAoX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsaXAgSUQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgY2xpcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXJsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJlbWJlZFVybFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZW1iZWQgVVJMIG9mIHRoZSBjbGlwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5lbWJlZF91cmw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeENsaXAucHJvdG90eXBlLCBcImJyb2FkY2FzdGVySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgSUQgb2YgdGhlIGJyb2FkY2FzdGVyIG9mIHRoZSBzdHJlYW0gd2hlcmUgdGhlIGNsaXAgd2FzIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJyb2FkY2FzdGVyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJicm9hZGNhc3RlckRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIGJyb2FkY2FzdGVyIG9mIHRoZSBzdHJlYW0gd2hlcmUgdGhlIGNsaXAgd2FzIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJyb2FkY2FzdGVyX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYnJvYWRjYXN0ZXIgb2YgdGhlIHN0cmVhbSB3aGVyZSB0aGUgY2xpcCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBIZWxpeENsaXAucHJvdG90eXBlLmdldEJyb2FkY2FzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy5fZGF0YS5icm9hZGNhc3Rlcl9pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwiY3JlYXRvcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1c2VyIElEIG9mIHRoZSBjcmVhdG9yIG9mIHRoZSBjbGlwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5jcmVhdG9yX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJjcmVhdG9yRGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgY3JlYXRvciBvZiB0aGUgY2xpcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuY3JlYXRvcl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNyZWF0b3Igb2YgdGhlIGNsaXAuXG4gICAgICovXG4gICAgSGVsaXhDbGlwLnByb3RvdHlwZS5nZXRDcmVhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy5fZGF0YS5jcmVhdG9yX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJ2aWRlb0lkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdmlkZW8gdGhlIGNsaXAgaXMgdGFrZW4gZnJvbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudmlkZW9faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmlkZW8gdGhlIGNsaXAgaXMgdGFrZW4gZnJvbS5cbiAgICAgKi9cbiAgICBIZWxpeENsaXAucHJvdG90eXBlLmdldFZpZGVvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudmlkZW9zLmdldFZpZGVvQnlJZCh0aGlzLl9kYXRhLnZpZGVvX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJnYW1lSWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBnYW1lIHRoYXQgd2FzIGJlaW5nIHBsYXllZCB3aGVuIHRoZSBjbGlwIHdhcyBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nYW1lX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGdhbWUgdGhhdCB3YXMgYmVpbmcgcGxheWVkIHdoZW4gdGhlIGNsaXAgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgSGVsaXhDbGlwLnByb3RvdHlwZS5nZXRHYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXguZ2FtZXMuZ2V0R2FtZUJ5SWQodGhpcy5fZGF0YS5nYW1lX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhDbGlwLnByb3RvdHlwZSwgXCJsYW5ndWFnZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFuZ3VhZ2Ugb2YgdGhlIHN0cmVhbSB3aGVyZSB0aGUgY2xpcCB3YXMgY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubGFuZ3VhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeENsaXAucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aXRsZSBvZiB0aGUgY2xpcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudGl0bGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeENsaXAucHJvdG90eXBlLCBcInZpZXdzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2Ygdmlld3Mgb2YgdGhlIGNsaXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnZpZXdfY291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeENsaXAucHJvdG90eXBlLCBcImNyZWF0aW9uRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSB3aGVuIHRoZSBjbGlwIHdhcyBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZGF0YS5jcmVhdGVkX2F0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwidGh1bWJuYWlsVXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgb2YgdGhlIHRodW1ibmFpbCBvZiB0aGUgY2xpcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudGh1bWJuYWlsX3VybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIEhlbGl4Q2xpcC5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWxpeENsaXA7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhDbGlwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhDbGlwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhDbGlwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogQSBiaXRzIHRyYW5zYWN0aW9uIG1hZGUgaW5zaWRlIGFuIGV4dGVuc2lvbi5cbiAqL1xudmFyIEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbihfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJ0cmFuc2FjdGlvbkRhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgd2hlbiB0aGUgdHJhbnNhY3Rpb24gd2FzIG1hZGUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLnRpbWVzdGFtcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJicm9hZGNhc3RlcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgYnJvYWRjYXN0ZXIgdGhhdCBydW5zIHRoZSBleHRlbnNpb24gb24gdGhlaXIgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuYnJvYWRjYXN0ZXJfaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJicm9hZGNhc3RlckRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIGJyb2FkY2FzdGVyIHRoYXQgcnVucyB0aGUgZXh0ZW5zaW9uIG9uIHRoZWlyIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJyb2FkY2FzdGVyX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYnJvYWRjYXN0ZXIgdGhhdCBydW5zIHRoZSBleHRlbnNpb24gb24gdGhlaXIgY2hhbm5lbC5cbiAgICAgKi9cbiAgICBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZS5nZXRCcm9hZGNhc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeUlkKHRoaXMuX2RhdGEuYnJvYWRjYXN0ZXJfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJ1c2VySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB1c2VyIHRoYXQgbWFkZSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVzZXJfaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJ1c2VyRGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgdXNlciB0aGF0IG1hZGUgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlciB0aGF0IG1hZGUgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldFVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCh0aGlzLl9kYXRhLnVzZXJfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJwcm9kdWN0VHlwZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcHJvZHVjdCB0eXBlLiBDdXJyZW50bHkgYWx3YXlzIEJJVFNfSU5fRVhURU5TSU9OLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5wcm9kdWN0X3R5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJwcm9kdWN0U0tVXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcm9kdWN0IFNLVS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEucHJvZHVjdF9kYXRhLnNrdTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcInByb2R1Y3RDb3N0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb3N0IG9mIHRoZSBwcm9kdWN0LCBpbiBiaXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5wcm9kdWN0X2RhdGEuY29zdC5hbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJwcm9kdWN0RGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcHJvZHVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEucHJvZHVjdF9kYXRhLmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwicHJvZHVjdEluRGV2ZWxvcG1lbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgcHJvZHVjdCBpcyBpbiBkZXZlbG9wbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEucHJvZHVjdF9kYXRhLmluRGV2ZWxvcG1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb247XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4RXh0ZW5zaW9uVHJhbnNhY3Rpb247XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogQSBnYW1lIGFzIGRpc3BsYXllZCBvbiBUd2l0Y2guXG4gKi9cbnZhciBIZWxpeEdhbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhHYW1lKF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEdhbWUucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgZ2FtZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEdhbWUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGdhbWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEdhbWUucHJvdG90eXBlLCBcImJveEFydFVybFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSBib3ggYXJ0IG9mIHRoZSBnYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5ib3hfYXJ0X3VybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIEhlbGl4R2FtZS5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWxpeEdhbWU7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhHYW1lO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhHYW1lO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhHYW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBIZWxpeEJhbl8xID0gcmVxdWlyZShcIi4vSGVsaXhCYW5cIik7XG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgdHlwZXMgYSBiYW4gZXZlbnQgY2FuIGhhdmUuXG4gKi9cbnZhciBIZWxpeEJhbkV2ZW50VHlwZTtcbihmdW5jdGlvbiAoSGVsaXhCYW5FdmVudFR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBTZW50IHdoZW4gYSB1c2VyIGdldHMgYmFubmVkLlxuICAgICAqL1xuICAgIEhlbGl4QmFuRXZlbnRUeXBlW1wiQmFuXCJdID0gXCJtb2RlcmF0aW9uLnVzZXIuYmFuXCI7XG4gICAgLyoqXG4gICAgICogU2VudCB3aGVuIGEgdXNlciBnZXRzIHVuYmFubmVkLlxuICAgICAqL1xuICAgIEhlbGl4QmFuRXZlbnRUeXBlW1wiVW5iYW5cIl0gPSBcIm1vZGVyYXRpb24udXNlci51bmJhblwiO1xufSkoSGVsaXhCYW5FdmVudFR5cGUgfHwgKEhlbGl4QmFuRXZlbnRUeXBlID0ge30pKTtcbmV4cG9ydHMuSGVsaXhCYW5FdmVudFR5cGUgPSBIZWxpeEJhbkV2ZW50VHlwZTtcbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpbmRpY2F0ZXMgdGhlIGNoYW5nZSBvZiBhIGJhbiBzdGF0dXMsIGkuZS4gYmFubmluZyBvciB1bmJhbm5pbmcgYSB1c2VyLlxuICovXG52YXIgSGVsaXhCYW5FdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeEJhbkV2ZW50LCBfc3VwZXIpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4QmFuRXZlbnQoX2V2ZW50RGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9ldmVudERhdGEuZXZlbnRfZGF0YSwgY2xpZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZXZlbnREYXRhID0gX2V2ZW50RGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCYW5FdmVudC5wcm90b3R5cGUsIFwiZXZlbnRJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBiYW4gZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudERhdGEuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEJhbkV2ZW50LnByb3RvdHlwZSwgXCJldmVudFR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIGJhbiBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RGF0YS5ldmVudF90eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhCYW5FdmVudC5wcm90b3R5cGUsIFwiZXZlbnREYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIG9mIHRoZSBiYW4gZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9ldmVudERhdGEuZXZlbnRfdGltZXN0YW1wKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QmFuRXZlbnQucHJvdG90eXBlLCBcImV2ZW50VmVyc2lvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgYmFuIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnREYXRhLnZlcnNpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEJhbkV2ZW50LnByb3RvdHlwZSwgXCJicm9hZGNhc3RlcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgYnJvYWRjYXN0ZXIgZnJvbSB3aG9zZSBjaGF0IHRoZSB1c2VyIHdhcyBiYW5uZWQvdW5iYW5uZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudERhdGEuZXZlbnRfZGF0YS5icm9hZGNhc3Rlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG1vcmUgZGF0YSBhYm91dCB0aGUgYnJvYWRjYXN0ZXIuXG4gICAgICovXG4gICAgSGVsaXhCYW5FdmVudC5wcm90b3R5cGUuZ2V0QnJvYWRjYXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCh0aGlzLl9ldmVudERhdGEuZXZlbnRfZGF0YS5icm9hZGNhc3Rlcl9pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QmFuRXZlbnQucHJvdG90eXBlLCBcImJyb2FkY2FzdGVyTmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnJvYWRjYXN0ZXIgZnJvbSB3aG9zZSBjaGF0IHRoZSB1c2VyIHdhcyBiYW5uZWQvdW5iYW5uZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudERhdGEuZXZlbnRfZGF0YS5icm9hZGNhc3Rlcl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEhlbGl4QmFuRXZlbnQ7XG59KEhlbGl4QmFuXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhCYW5FdmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4QmFuRXZlbnQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhlbGl4QmFuRXZlbnRUeXBlID0gSGVsaXhCYW5FdmVudFR5cGU7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEJhbkV2ZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBIZWxpeE1vZGVyYXRvcl8xID0gcmVxdWlyZShcIi4vSGVsaXhNb2RlcmF0b3JcIik7XG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgdHlwZXMgYSBtb2RlcmF0b3IgZXZlbnQgY2FuIGhhdmUuXG4gKi9cbnZhciBIZWxpeE1vZGVyYXRvckV2ZW50VHlwZTtcbihmdW5jdGlvbiAoSGVsaXhNb2RlcmF0b3JFdmVudFR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBTZW50IHdoZW4gYSB1c2VyIGdhaW5zIG1vZGVyYXRpb24gcHJpdmlsZWdlcy5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRvckV2ZW50VHlwZVtcIkFkZFwiXSA9IFwibW9kZXJhdGlvbi5tb2RlcmF0b3IuYWRkXCI7XG4gICAgLyoqXG4gICAgICogU2VudCB3aGVuIGEgdXNlciBsb3NlcyBtb2RlcmF0aW9uIHByaXZpbGVnZXMuXG4gICAgICovXG4gICAgSGVsaXhNb2RlcmF0b3JFdmVudFR5cGVbXCJSZW1vdmVcIl0gPSBcIm1vZGVyYXRpb24ubW9kZXJhdG9yLnJlbW92ZVwiO1xufSkoSGVsaXhNb2RlcmF0b3JFdmVudFR5cGUgfHwgKEhlbGl4TW9kZXJhdG9yRXZlbnRUeXBlID0ge30pKTtcbmV4cG9ydHMuSGVsaXhNb2RlcmF0b3JFdmVudFR5cGUgPSBIZWxpeE1vZGVyYXRvckV2ZW50VHlwZTtcbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpbmRpY2F0ZXMgdGhlIGNoYW5nZSBvZiBhIG1vZGVyYXRvciBzdGF0dXMsIGkuZS4gZ2FpbmluZyBvciBsb3NpbmcgbW9kZXJhdGlvbiBwcml2aWxlZ2VzLlxuICovXG52YXIgSGVsaXhNb2RlcmF0b3JFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeE1vZGVyYXRvckV2ZW50LCBfc3VwZXIpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4TW9kZXJhdG9yRXZlbnQoX2V2ZW50RGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9ldmVudERhdGEuZXZlbnRfZGF0YSwgY2xpZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZXZlbnREYXRhID0gX2V2ZW50RGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhNb2RlcmF0b3JFdmVudC5wcm90b3R5cGUsIFwiZXZlbnRJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBtb2RlcmF0b3IgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudERhdGEuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeE1vZGVyYXRvckV2ZW50LnByb3RvdHlwZSwgXCJldmVudFR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG1vZGVyYXRvciBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RGF0YS5ldmVudF90eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhNb2RlcmF0b3JFdmVudC5wcm90b3R5cGUsIFwiZXZlbnREYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIG9mIHRoZSBtb2RlcmF0b3IgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9ldmVudERhdGEuZXZlbnRfdGltZXN0YW1wKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4TW9kZXJhdG9yRXZlbnQucHJvdG90eXBlLCBcImV2ZW50VmVyc2lvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgbW9kZXJhdG9yIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnREYXRhLnZlcnNpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeE1vZGVyYXRvckV2ZW50LnByb3RvdHlwZSwgXCJicm9hZGNhc3RlcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgYnJvYWRjYXN0ZXIgd2hlcmUgdGhlIHVzZXIgZ2FpbmVkL2xvc3QgbW9kZXJhdGlvbiBwcml2aWxlZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnREYXRhLmV2ZW50X2RhdGEuYnJvYWRjYXN0ZXJfaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBtb3JlIGRhdGEgYWJvdXQgdGhlIGJyb2FkY2FzdGVyLlxuICAgICAqL1xuICAgIEhlbGl4TW9kZXJhdG9yRXZlbnQucHJvdG90eXBlLmdldEJyb2FkY2FzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5SWQodGhpcy5fZXZlbnREYXRhLmV2ZW50X2RhdGEuYnJvYWRjYXN0ZXJfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeE1vZGVyYXRvckV2ZW50LnByb3RvdHlwZSwgXCJicm9hZGNhc3Rlck5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGJyb2FkY2FzdGVyIHdoZXJlIHRoZSB1c2VyIGdhaW5lZC9sb3N0IG1vZGVyYXRpb24gcHJpdmlsZWdlcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RGF0YS5ldmVudF9kYXRhLmJyb2FkY2FzdGVyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gSGVsaXhNb2RlcmF0b3JFdmVudDtcbn0oSGVsaXhNb2RlcmF0b3JfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeE1vZGVyYXRvckV2ZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhNb2RlcmF0b3JFdmVudDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGVsaXhNb2RlcmF0b3JFdmVudFR5cGUgPSBIZWxpeE1vZGVyYXRvckV2ZW50VHlwZTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4TW9kZXJhdG9yRXZlbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEN1c3RvbUVycm9yXzEgPSByZXF1aXJlKFwiLi9DdXN0b21FcnJvclwiKTtcbi8qKlxuICogVGhyb3duIHdoZW5ldmVyIHlvdSB0cnkgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgeW91ciBvd24gc3RyZWFtIHRvIGJlIGxpdmUuXG4gKi9cbnZhciBTdHJlYW1Ob3RMaXZlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3RyZWFtTm90TGl2ZUVycm9yLCBfc3VwZXIpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIFN0cmVhbU5vdExpdmVFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdZb3VyIHN0cmVhbSBuZWVkcyB0byBiZSBsaXZlIHRvIGRvIHRoaXMnKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3RyZWFtTm90TGl2ZUVycm9yO1xufShDdXN0b21FcnJvcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmVhbU5vdExpdmVFcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFN0cmVhbU5vdExpdmVFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmVhbU5vdExpdmVFcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG4vKipcbiAqIFRoZSB0eXBlIG9mIGEgc3RyZWFtLlxuICovXG52YXIgSGVsaXhTdHJlYW1UeXBlO1xuKGZ1bmN0aW9uIChIZWxpeFN0cmVhbVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCBieSBUd2l0Y2ggaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbVR5cGVbXCJOb25lXCJdID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBBIGxpdmUgc3RyZWFtLlxuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtVHlwZVtcIkxpdmVcIl0gPSBcImxpdmVcIjtcbiAgICAvKipcbiAgICAgKiBBIHZvZGNhc3QuXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHkgbm90IHN1cHBvcnRlZCBieSBUd2l0Y2ggLSBidXQgb25lIGNhbiBvbmx5IGhvcGUgYW5kIGxlYXZlIGl0IGluIGhlcmUuXG4gICAgICovXG4gICAgSGVsaXhTdHJlYW1UeXBlW1wiVm9kY2FzdFwiXSA9IFwidm9kY2FzdFwiO1xufSkoSGVsaXhTdHJlYW1UeXBlIHx8IChIZWxpeFN0cmVhbVR5cGUgPSB7fSkpO1xuZXhwb3J0cy5IZWxpeFN0cmVhbVR5cGUgPSBIZWxpeFN0cmVhbVR5cGU7XG4vKipcbiAqIEEgVHdpdGNoIHN0cmVhbS5cbiAqL1xudmFyIEhlbGl4U3RyZWFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4U3RyZWFtKF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0cmVhbSBJRC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbS5wcm90b3R5cGUsIFwidXNlcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1c2VyIElELlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdHJlYW0ucHJvdG90eXBlLCBcInVzZXJEaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlcidzIGRpc3BsYXkgbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXNlcl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHVzZXIgYnJvYWRjYXN0aW5nIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgSGVsaXhTdHJlYW0ucHJvdG90eXBlLmdldFVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCh0aGlzLl9kYXRhLnVzZXJfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbS5wcm90b3R5cGUsIFwiZ2FtZUlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBnYW1lIElELlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nYW1lX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGdhbWUgdGhhdCBpcyBiZWluZyBwbGF5ZWQgb24gdGhpcyBzdHJlYW0uXG4gICAgICovXG4gICAgSGVsaXhTdHJlYW0ucHJvdG90eXBlLmdldEdhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC5nYW1lcy5nZXRHYW1lQnlJZCh0aGlzLl9kYXRhLmdhbWVfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdHJlYW0ucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aXRsZSBvZiB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50aXRsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtLnByb3RvdHlwZSwgXCJ2aWV3ZXJzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2Ygdmlld2VycyB0aGUgc3RyZWFtIGN1cnJlbnRseSBoYXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnZpZXdlcl9jb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtLnByb3RvdHlwZSwgXCJzdGFydERhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgd2hlbiB0aGUgc3RyZWFtIHN0YXJ0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLnN0YXJ0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdHJlYW0ucHJvdG90eXBlLCBcImxhbmd1YWdlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYW5ndWFnZSBvZiB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sYW5ndWFnZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtLnByb3RvdHlwZSwgXCJ0aHVtYm5haWxVcmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgdGh1bWJuYWlsIG9mIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnRodW1ibmFpbF91cmw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeFN0cmVhbS5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWxpeFN0cmVhbTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFN0cmVhbTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4U3RyZWFtO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IZWxpeFN0cmVhbVR5cGUgPSBIZWxpeFN0cmVhbVR5cGU7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFN0cmVhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgSGVsaXhTdHJlYW1NYXJrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhTdHJlYW1NYXJrZXIoLyoqIEBwcml2YXRlICovIF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN0cmVhbU1hcmtlci5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBtYXJrZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdHJlYW1NYXJrZXIucHJvdG90eXBlLCBcImNyZWF0aW9uRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSBhbmQgdGltZSB3aGVuIHRoZSBtYXJrZXIgd2FzIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmNyZWF0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdHJlYW1NYXJrZXIucHJvdG90eXBlLCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbWFya2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtTWFya2VyLnByb3RvdHlwZSwgXCJwb3NpdGlvbkluU2Vjb25kc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcG9zaXRpb24gaW4gdGhlIHN0cmVhbSB3aGVuIHRoZSBtYXJrZXIgd2FzIGNyZWF0ZWQsIGluIHNlY29uZHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnBvc2l0aW9uX3NlY29uZHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeFN0cmVhbU1hcmtlci5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIZWxpeFN0cmVhbU1hcmtlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFN0cmVhbU1hcmtlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4U3RyZWFtTWFya2VyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdHJlYW1NYXJrZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEhlbGl4U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9IZWxpeFN1YnNjcmlwdGlvblwiKTtcbi8qKlxuICogVGhlIGRpZmZlcmVudCB0eXBlcyBhIHN1YnNjcmlwdGlvbiBldmVudCBjYW4gaGF2ZS5cbiAqL1xudmFyIEhlbGl4U3Vic2NyaXB0aW9uRXZlbnRUeXBlO1xuKGZ1bmN0aW9uIChIZWxpeFN1YnNjcmlwdGlvbkV2ZW50VHlwZSkge1xuICAgIC8qKlxuICAgICAqIFNlbnQgd2hlbiBhIG5ldyB1c2VyIHN1YnNjcmliZXMuXG4gICAgICovXG4gICAgSGVsaXhTdWJzY3JpcHRpb25FdmVudFR5cGVbXCJTdWJzY3JpYmVcIl0gPSBcInN1YnNjcmlwdGlvbnMuc3Vic2NyaWJlXCI7XG4gICAgLyoqXG4gICAgICogU2VudCB3aGVuIGEgcHJldmlvdXMgc3Vic2NyaWJlciBzdG9wcyBzdWJzY3JpYmluZy5cbiAgICAgKi9cbiAgICBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50VHlwZVtcIlVuc3Vic2NyaWJlXCJdID0gXCJzdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlXCI7XG4gICAgLyoqXG4gICAgICogU2VudCB3aGVuIGEgbmV3IG9yIHJlY3VycmluZyBzdWJzY3JpYmVyIHNlbmRzIHRoZWlyIG1vbnRobHkgbm90aWZpY2F0aW9uLlxuICAgICAqL1xuICAgIEhlbGl4U3Vic2NyaXB0aW9uRXZlbnRUeXBlW1wiTm90aWZpY2F0aW9uXCJdID0gXCJzdWJzY3JpcHRpb25zLm5vdGlmaWNhdGlvblwiO1xufSkoSGVsaXhTdWJzY3JpcHRpb25FdmVudFR5cGUgfHwgKEhlbGl4U3Vic2NyaXB0aW9uRXZlbnRUeXBlID0ge30pKTtcbmV4cG9ydHMuSGVsaXhTdWJzY3JpcHRpb25FdmVudFR5cGUgPSBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50VHlwZTtcbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpbmRpY2F0ZXMgdGhlIGNoYW5nZSBvZiBhIHN1YnNjcmlwdGlvbiBzdGF0dXMsIGkuZS4gc3Vic2NyaWJpbmcsIHVuc3Vic2NyaWJpbmcgb3Igc2VuZGluZyB0aGUgbW9udGhseSBub3RpZmljYXRpb24uXG4gKi9cbnZhciBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4U3Vic2NyaXB0aW9uRXZlbnQsIF9zdXBlcik7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhTdWJzY3JpcHRpb25FdmVudChfZXZlbnREYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX2V2ZW50RGF0YS5ldmVudF9kYXRhLCBjbGllbnQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9ldmVudERhdGEgPSBfZXZlbnREYXRhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN1YnNjcmlwdGlvbkV2ZW50LnByb3RvdHlwZSwgXCJldmVudElkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHN1YnNjcmlwdGlvbiBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RGF0YS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3Vic2NyaXB0aW9uRXZlbnQucHJvdG90eXBlLCBcImV2ZW50VHlwZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc3Vic2NyaXB0aW9uIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnREYXRhLmV2ZW50X3R5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFN1YnNjcmlwdGlvbkV2ZW50LnByb3RvdHlwZSwgXCJldmVudERhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgb2YgdGhlIHN1YnNjcmlwdGlvbiBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2V2ZW50RGF0YS5ldmVudF90aW1lc3RhbXApO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhTdWJzY3JpcHRpb25FdmVudC5wcm90b3R5cGUsIFwiZXZlbnRWZXJzaW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzdWJzY3JpcHRpb24gZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudERhdGEudmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3Vic2NyaXB0aW9uRXZlbnQucHJvdG90eXBlLCBcImV2ZW50TWVzc2FnZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWVzc2FnZSBzZW50IHdpdGggdGhlIHN1YnNjcmlwdGlvbiBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RGF0YS5ldmVudF9kYXRhLm1lc3NhZ2UgfHwgJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50O1xufShIZWxpeFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4U3Vic2NyaXB0aW9uRXZlbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IZWxpeFN1YnNjcmlwdGlvbkV2ZW50VHlwZSA9IEhlbGl4U3Vic2NyaXB0aW9uRXZlbnRUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdWJzY3JpcHRpb25FdmVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi9IZWxpeFBhZ2luYXRlZFJlcXVlc3RcIik7XG4vKipcbiAqIEEgc3BlY2lhbCBjYXNlIG9mIHtASGVsaXhQYWdpbmF0ZWRSZXF1ZXN0fSB3aXRoIHN1cHBvcnQgZm9yIGZldGNoaW5nIHRoZSB0b3RhbCBudW1iZXIgb2YgZW50aXRpZXMsIHdoZW5ldmVyIGFuIGVuZHBvaW50IHN1cHBvcnRzIGl0LlxuICovXG52YXIgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4UGFnaW5hdGVkUmVxdWVzdFdpdGhUb3RhbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxpeFBhZ2luYXRlZFJlcXVlc3RXaXRoVG90YWwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuZCByZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgZW50aXRpZXMgZXhpc3RpbmcgaW4gdGhlIHF1ZXJpZWQgcmVzdWx0IHNldC5cbiAgICAgKi9cbiAgICBIZWxpeFBhZ2luYXRlZFJlcXVlc3RXaXRoVG90YWwucHJvdG90eXBlLmdldFRvdGFsQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEsIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuX2N1cnJlbnREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9hKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2ZldGNoRGF0YSh7IHF1ZXJ5OiB7IGFmdGVyOiB1bmRlZmluZWQgfSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gKF9iLnNlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhLnRvdGFsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsO1xufShIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFBhZ2luYXRlZFJlcXVlc3RXaXRoVG90YWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFBhZ2luYXRlZFJlcXVlc3RXaXRoVG90YWw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFBhZ2luYXRlZFJlcXVlc3RXaXRoVG90YWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBBIHJlbGF0aW9uIG9mIGEgdXNlciBmb2xsb3dpbmcgYSBicm9hZGNhc3Rlci5cbiAqL1xudmFyIEhlbGl4Rm9sbG93ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEhlbGl4Rm9sbG93KC8qKiBAcHJpdmF0ZSAqLyBfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhGb2xsb3cucHJvdG90eXBlLCBcInVzZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlciBJRCBvZiB0aGUgZm9sbG93aW5nIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmZyb21faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEZvbGxvdy5wcm90b3R5cGUsIFwidXNlckRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIGZvbGxvd2luZyB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5mcm9tX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGF0YSBvZiB0aGUgZm9sbG93aW5nIHVzZXIuXG4gICAgICovXG4gICAgSGVsaXhGb2xsb3cucHJvdG90eXBlLmdldFVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCh0aGlzLl9kYXRhLmZyb21faWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEZvbGxvdy5wcm90b3R5cGUsIFwiZm9sbG93ZWRVc2VySWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgSUQgb2YgdGhlIGZvbGxvd2VkIGJyb2FkY2FzdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50b19pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4Rm9sbG93LnByb3RvdHlwZSwgXCJmb2xsb3dlZFVzZXJEaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBmb2xsb3dlZCB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50b19uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGRhdGEgb2YgdGhlIGZvbGxvd2VkIGJyb2FkY2FzdGVyLlxuICAgICAqL1xuICAgIEhlbGl4Rm9sbG93LnByb3RvdHlwZS5nZXRGb2xsb3dlZFVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy5nZXRVc2VyQnlJZCh0aGlzLl9kYXRhLnRvX2lkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhGb2xsb3cucHJvdG90eXBlLCBcImZvbGxvd0RhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgd2hlbiB0aGUgdXNlciBmb2xsb3dlZCB0aGUgYnJvYWRjYXN0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmZvbGxvd2VkX2F0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIEhlbGl4Rm9sbG93LnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEhlbGl4Rm9sbG93O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4Rm9sbG93O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhGb2xsb3c7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEZvbGxvdztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgSGVsaXhVc2VyXzEgPSByZXF1aXJlKFwiLi9IZWxpeFVzZXJcIik7XG4vKipcbiAqIEEgdXNlciB5b3UgaGF2ZSBleHRlbmRlZCBwcml2aWxnZXMgZm9yLCBpLmUuIHlvdXJzZWxmLlxuICpcbiAqIEBpbmhlcml0RG9jXG4gKi9cbnZhciBIZWxpeFByaXZpbGVnZWRVc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4UHJpdmlsZWdlZFVzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhQcml2aWxlZ2VkVXNlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhQcml2aWxlZ2VkVXNlci5wcm90b3R5cGUsIFwiZW1haWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmVtYWlsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBUaGUgbmV3IGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIEhlbGl4UHJpdmlsZWdlZFVzZXIucHJvdG90eXBlLnNldERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC51c2Vycy51cGRhdGVVc2VyKHsgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIZWxpeFByaXZpbGVnZWRVc2VyO1xufShIZWxpeFVzZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFByaXZpbGVnZWRVc2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhQcml2aWxlZ2VkVXNlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4UHJpdmlsZWdlZFVzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNhY2hlX2RlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnNcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FcnJvcnMvSGVsbEZyZWV6ZXNPdmVyRXJyb3JcIik7XG4vKipcbiAqIEEgdmlkZW8gb24gVHdpdGNoLlxuICovXG52YXIgSGVsaXhWaWRlbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBIZWxpeFZpZGVvKF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcInVzZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIgd2hvIGNyZWF0ZWQgdGhlIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhWaWRlby5wcm90b3R5cGUsIFwidXNlckRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHVzZXIgd2hvIGNyZWF0ZWQgdGhlIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlciB3aG8gY3JlYXRlZCB0aGUgdmlkZW8uXG4gICAgICovXG4gICAgSGVsaXhWaWRlby5wcm90b3R5cGUuZ2V0VXNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeUlkKHRoaXMuX2RhdGEudXNlcl9pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aXRsZSBvZiB0aGUgdmlkZW8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnRpdGxlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhWaWRlby5wcm90b3R5cGUsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSB2aWRlby5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZGVzY3JpcHRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJjcmVhdGlvbkRhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgd2hlbiB0aGUgdmlkZW8gd2FzIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmNyZWF0ZWRfYXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhWaWRlby5wcm90b3R5cGUsIFwicHVibGlzaERhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgd2hlbiB0aGUgdmlkZW8gd2FzIHB1Ymxpc2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEucHVibGlzaGVkX2F0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSB2aWRlby5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudXJsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhWaWRlby5wcm90b3R5cGUsIFwidGh1bWJuYWlsVXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgb2YgdGhlIHRodW1ibmFpbCBvZiB0aGUgdmlkZW8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnRodW1ibmFpbF91cmw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJpc1B1YmxpY1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB2aWRlbyBpcyBwdWJsaWMgb3Igbm90LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS52aWV3YWJsZSA9PT0gJ3B1YmxpYyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJ2aWV3c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHZpZXdzIG9mIHRoZSB2aWRlby5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudmlld19jb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcImxhbmd1YWdlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYW5ndWFnZSBvZiB0aGUgdmlkZW8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmxhbmd1YWdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhWaWRlby5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdmlkZW8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJkdXJhdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvLCBhcyBmb3JtYXR0ZWQgYnkgVHdpdGNoLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5kdXJhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4VmlkZW8ucHJvdG90eXBlLCBcImR1cmF0aW9uSW5TZWNvbmRzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgdmlkZW8sIGluIHNlY29uZHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHRoaXMuX2RhdGEuZHVyYXRpb24ubWF0Y2goL1xcZCtbaG1zXS9nKTtcbiAgICAgICAgICAgIGlmICghcGFydHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMS5kZWZhdWx0KFwiQ291bGQgbm90IHBhcnNlIGR1cmF0aW9uIHN0cmluZzogXCIgKyB0aGlzLl9kYXRhLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJ0c1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydGlhbE1hdGNoID0gcGFydC5tYXRjaCgvKFxcZCspKFtobXNdKS8pO1xuICAgICAgICAgICAgICAgIGlmICghcGFydGlhbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBIZWxsRnJlZXplc092ZXJFcnJvcl8xLmRlZmF1bHQoXCJDb3VsZCBub3QgcGFyc2UgcGFydGlhbCBkdXJhdGlvbiBzdHJpbmc6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKHBhcnRpYWxNYXRjaCwgMyksIG51bSA9IF9hWzFdLCB1bml0ID0gX2FbMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bSwgMTApICogeyBoOiAzNjAwLCBtOiA2MCwgczogMSB9W3VuaXRdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYjsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeFZpZGVvLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgSGVsaXhWaWRlby5wcm90b3R5cGUsIFwiZHVyYXRpb25JblNlY29uZHNcIiwgbnVsbCk7XG4gICAgSGVsaXhWaWRlbyA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBIZWxpeFZpZGVvKTtcbiAgICByZXR1cm4gSGVsaXhWaWRlbztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFZpZGVvO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhWaWRlbztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4VmlkZW87XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTG9nTGV2ZWxfMSA9IHJlcXVpcmUoXCIuL0xvZ0xldmVsXCIpO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoXCJkZXRlY3Qtbm9kZVwiKTtcbnZhciBCYXNlTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VMb2dnZXIoX2EpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCBfYiA9IF9hLm1pbkxldmVsLCBtaW5MZXZlbCA9IF9iID09PSB2b2lkIDAgPyBMb2dMZXZlbF8xLkxvZ0xldmVsLldBUk5JTkcgOiBfYiwgX2MgPSBfYS5lbW9qaSwgZW1vamkgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgX2QgPSBfYS5jb2xvcnMsIGNvbG9ycyA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsIF9lID0gX2EudGltZXN0YW1wcywgdGltZXN0YW1wcyA9IF9lID09PSB2b2lkIDAgPyBpc05vZGUgOiBfZTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX21pbkxldmVsID0gTG9nTGV2ZWxfMS5yZXNvbHZlTG9nTGV2ZWwobWluTGV2ZWwpO1xuICAgICAgICB0aGlzLl9lbW9qaSA9IGVtb2ppO1xuICAgICAgICB0aGlzLl9jb2xvcnMgPSBjb2xvcnM7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcHMgPSB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICAvLyByZWdpb24gY29udmVuaWVuY2UgbWV0aG9kc1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmNyaXQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLkxvZ0xldmVsLkNSSVRJQ0FMLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmNyaXRpY2FsID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5Mb2dMZXZlbC5DUklUSUNBTCwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5lcnIgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLkxvZ0xldmVsLkVSUk9SLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5Mb2dMZXZlbC5FUlJPUiwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5Mb2dMZXZlbC5XQVJOSU5HLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLndhcm5pbmcgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLkxvZ0xldmVsLldBUk5JTkcsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuTG9nTGV2ZWwuSU5GTywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuTG9nTGV2ZWwuREVCVUcsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBkZWJ1ZyBpbnN0ZWFkICovXG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUuZGVidWcxID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coTG9nTGV2ZWxfMS5Mb2dMZXZlbC5ERUJVRywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGRlYnVnIGluc3RlYWQgKi9cbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZzIgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLkxvZ0xldmVsLkRFQlVHLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgZGVidWcgaW5zdGVhZCAqL1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLmRlYnVnMyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nKExvZ0xldmVsXzEuTG9nTGV2ZWwuREVCVUcsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZyhMb2dMZXZlbF8xLkxvZ0xldmVsLlRSQUNFLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlTG9nZ2VyO1xufSgpKTtcbmV4cG9ydHMuQmFzZUxvZ2dlciA9IEJhc2VMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlTG9nZ2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlUHJvbWlzZSA9IHJlcXVpcmUoJy4vcmVxdWlyZVByb21pc2UnKTtcblxucmVxdWlyZVByb21pc2UoKTtcblxudmFyIFByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9Qcm9taXNlUmVzb2x2ZScpO1xudmFyIFR5cGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDE5L1R5cGUnKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnaXRlcmF0ZS12YWx1ZScpO1xudmFyIG1hcCA9IHJlcXVpcmUoJ2FycmF5LnByb3RvdHlwZS5tYXAnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2NhbGxCb3VuZCcpO1xuXG52YXIgYWxsID0gY2FsbEJvdW5kKCdQcm9taXNlLmFsbCcpO1xudmFyIHJlamVjdCA9IGNhbGxCb3VuZCgnUHJvbWlzZS5yZWplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhbGxTZXR0bGVkKGl0ZXJhYmxlKSB7XG5cdHZhciBDID0gdGhpcztcblx0aWYgKFR5cGUoQykgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYHRoaXNgIHZhbHVlIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cdH1cblx0dmFyIHZhbHVlcyA9IGl0ZXJhdGUoaXRlcmFibGUpO1xuXHRyZXR1cm4gYWxsKEMsIG1hcCh2YWx1ZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIG9uRnVsZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHsgc3RhdHVzOiAnZnVsZmlsbGVkJywgdmFsdWU6IHZhbHVlIH07XG5cdFx0fTtcblx0XHR2YXIgb25SZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRyZXR1cm4geyBzdGF0dXM6ICdyZWplY3RlZCcsIHJlYXNvbjogcmVhc29uIH07XG5cdFx0fTtcblx0XHR2YXIgaXRlbVByb21pc2UgPSBQcm9taXNlUmVzb2x2ZShDLCBpdGVtKTtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGl0ZW1Qcm9taXNlLnRoZW4ob25GdWxmaWxsLCBvblJlamVjdCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIHJlamVjdChDLCBlKTtcblx0XHR9XG5cdH0pKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJWYWx1ZSA9IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZjtcbnZhciB0cnlTdHJpbmdPYmplY3QgPSBmdW5jdGlvbiB0cnlTdHJpbmdPYmplY3QodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRzdHJWYWx1ZS5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgc3RyQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlTdHJpbmdPYmplY3QodmFsdWUpIDogdG9TdHIuY2FsbCh2YWx1ZSkgPT09IHN0ckNsYXNzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi81L0NoZWNrT2JqZWN0Q29lcmNpYmxlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDE5L0FycmF5U3BlY2llc0NyZWF0ZScpO1xudmFyIENhbGwgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDE5L0NhbGwnKTtcbnZhciBDcmVhdGVEYXRhUHJvcGVydHlPclRocm93ID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9DcmVhdGVEYXRhUHJvcGVydHlPclRocm93Jyk7XG52YXIgR2V0ID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9HZXQnKTtcbnZhciBIYXNQcm9wZXJ0eSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMTkvSGFzUHJvcGVydHknKTtcbnZhciBJc0NhbGxhYmxlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAxOS9Jc0NhbGxhYmxlJyk7XG52YXIgVG9VaW50MzIgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDE5L1RvVWludDMyJyk7XG52YXIgVG9PYmplY3QgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDE5L1RvT2JqZWN0Jyk7XG52YXIgVG9TdHJpbmcgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDE5L1RvU3RyaW5nJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9jYWxsQm91bmQnKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJ2lzLXN0cmluZycpO1xuXG4vLyBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KSBhbmQgZmFpbHVyZSBvZiBgMCBpbiBib3hlZFN0cmluZ2AgKFJoaW5vKVxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBzdHJTcGxpdCA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zcGxpdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuKSB7XG5cdHZhciBPID0gVG9PYmplY3QodGhpcyk7XG5cdHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcoTykgPyBzdHJTcGxpdChPLCAnJykgOiBPO1xuXHR2YXIgbGVuID0gVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG5cdC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG5cdGlmICghSXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5tYXAgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHR2YXIgVDtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0VCA9IGFyZ3VtZW50c1sxXTtcblx0fVxuXG5cdHZhciBBID0gQXJyYXlTcGVjaWVzQ3JlYXRlKE8sIGxlbik7XG5cdHZhciBrID0gMDtcblx0d2hpbGUgKGsgPCBsZW4pIHtcblx0XHR2YXIgUGsgPSBUb1N0cmluZyhrKTtcblx0XHR2YXIga1ByZXNlbnQgPSBIYXNQcm9wZXJ0eShPLCBQayk7XG5cdFx0aWYgKGtQcmVzZW50KSB7XG5cdFx0XHR2YXIga1ZhbHVlID0gR2V0KE8sIFBrKTtcblx0XHRcdHZhciBtYXBwZWRWYWx1ZSA9IENhbGwoY2FsbGJhY2tmbiwgVCwgW2tWYWx1ZSwgaywgT10pO1xuXHRcdFx0Q3JlYXRlRGF0YVByb3BlcnR5T3JUaHJvdyhBLCBQaywgbWFwcGVkVmFsdWUpO1xuXHRcdH1cblx0XHRrICs9IDE7XG5cdH1cblxuXHRyZXR1cm4gQTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWluc3BlY3QnKTtcblxudmFyIElzUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuL0lzUHJvcGVydHlLZXknKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8qKlxuICogNy4zLjEgR2V0IChPLCBQKSAtIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1nZXQtby1wXG4gKiAxLiBBc3NlcnQ6IFR5cGUoTykgaXMgT2JqZWN0LlxuICogMi4gQXNzZXJ0OiBJc1Byb3BlcnR5S2V5KFApIGlzIHRydWUuXG4gKiAzLiBSZXR1cm4gTy5bW0dldF1dKFAsIE8pLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0KE8sIFApIHtcblx0Ly8gNy4zLjEuMVxuXHRpZiAoVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogVHlwZShPKSBpcyBub3QgT2JqZWN0Jyk7XG5cdH1cblx0Ly8gNy4zLjEuMlxuXHRpZiAoIUlzUHJvcGVydHlLZXkoUCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogSXNQcm9wZXJ0eUtleShQKSBpcyBub3QgdHJ1ZSwgZ290ICcgKyBpbnNwZWN0KFApKTtcblx0fVxuXHQvLyA3LjMuMS4zXG5cdHJldHVybiBPW1BdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJEFycmF5ID0gR2V0SW50cmluc2ljKCclQXJyYXklJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxudmFyIHRvU3RyID0gISRBcnJheS5pc0FycmF5ICYmIHJlcXVpcmUoJy4uL2hlbHBlcnMvY2FsbEJvdW5kJykoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pc2FycmF5XG5cbm1vZHVsZS5leHBvcnRzID0gJEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gSXNBcnJheShhcmd1bWVudCkge1xuXHRyZXR1cm4gdG9TdHIoYXJndW1lbnQpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2FsbEJvdW5kJyk7XG5cbnZhciAkaXNFbnVtZXJhYmxlID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIERlZmluZU93blByb3BlcnR5KElzRGF0YURlc2NyaXB0b3IsIFNhbWVWYWx1ZSwgRnJvbVByb3BlcnR5RGVzY3JpcHRvciwgTywgUCwgZGVzYykge1xuXHRpZiAoISRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdGlmICghSXNEYXRhRGVzY3JpcHRvcihkZXNjKSkge1xuXHRcdFx0Ly8gRVMzIGRvZXMgbm90IHN1cHBvcnQgZ2V0dGVycy9zZXR0ZXJzXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghZGVzY1snW1tDb25maWd1cmFibGVdXSddIHx8ICFkZXNjWydbW1dyaXRhYmxlXV0nXSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGZhbGxiYWNrIGZvciBFUzNcblx0XHRpZiAoUCBpbiBPICYmICRpc0VudW1lcmFibGUoTywgUCkgIT09ICEhZGVzY1snW1tFbnVtZXJhYmxlXV0nXSkge1xuXHRcdFx0Ly8gYSBub24tZW51bWVyYWJsZSBleGlzdGluZyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIHByb3BlcnR5IGRvZXMgbm90IGV4aXN0IGF0IGFsbCwgb3IgZXhpc3RzIGJ1dCBpcyBlbnVtZXJhYmxlXG5cdFx0dmFyIFYgPSBkZXNjWydbW1ZhbHVlXV0nXTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0XHRPW1BdID0gVjsgLy8gd2lsbCB1c2UgW1tEZWZpbmVdXVxuXHRcdHJldHVybiBTYW1lVmFsdWUoT1tQXSwgVik7XG5cdH1cblx0JGRlZmluZVByb3BlcnR5KE8sIFAsIEZyb21Qcm9wZXJ0eURlc2NyaXB0b3IoZGVzYykpO1xuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnRSZWNvcmQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Fzc2VydFJlY29yZCcpO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWZyb21wcm9wZXJ0eWRlc2NyaXB0b3JcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGcm9tUHJvcGVydHlEZXNjcmlwdG9yKERlc2MpIHtcblx0aWYgKHR5cGVvZiBEZXNjID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBEZXNjO1xuXHR9XG5cblx0YXNzZXJ0UmVjb3JkKFR5cGUsICdQcm9wZXJ0eSBEZXNjcmlwdG9yJywgJ0Rlc2MnLCBEZXNjKTtcblxuXHR2YXIgb2JqID0ge307XG5cdGlmICgnW1tWYWx1ZV1dJyBpbiBEZXNjKSB7XG5cdFx0b2JqLnZhbHVlID0gRGVzY1snW1tWYWx1ZV1dJ107XG5cdH1cblx0aWYgKCdbW1dyaXRhYmxlXV0nIGluIERlc2MpIHtcblx0XHRvYmoud3JpdGFibGUgPSBEZXNjWydbW1dyaXRhYmxlXV0nXTtcblx0fVxuXHRpZiAoJ1tbR2V0XV0nIGluIERlc2MpIHtcblx0XHRvYmouZ2V0ID0gRGVzY1snW1tHZXRdXSddO1xuXHR9XG5cdGlmICgnW1tTZXRdXScgaW4gRGVzYykge1xuXHRcdG9iai5zZXQgPSBEZXNjWydbW1NldF1dJ107XG5cdH1cblx0aWYgKCdbW0VudW1lcmFibGVdXScgaW4gRGVzYykge1xuXHRcdG9iai5lbnVtZXJhYmxlID0gRGVzY1snW1tFbnVtZXJhYmxlXV0nXTtcblx0fVxuXHRpZiAoJ1tbQ29uZmlndXJhYmxlXV0nIGluIERlc2MpIHtcblx0XHRvYmouY29uZmlndXJhYmxlID0gRGVzY1snW1tDb25maWd1cmFibGVdXSddO1xuXHR9XG5cdHJldHVybiBvYmo7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG5cbnZhciBhc3NlcnRSZWNvcmQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Fzc2VydFJlY29yZCcpO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzZGF0YWRlc2NyaXB0b3JcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJc0RhdGFEZXNjcmlwdG9yKERlc2MpIHtcblx0aWYgKHR5cGVvZiBEZXNjID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGFzc2VydFJlY29yZChUeXBlLCAnUHJvcGVydHkgRGVzY3JpcHRvcicsICdEZXNjJywgRGVzYyk7XG5cblx0aWYgKCFoYXMoRGVzYywgJ1tbVmFsdWVdXScpICYmICFoYXMoRGVzYywgJ1tbV3JpdGFibGVdXScpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGlzTmFOID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc05hTicpO1xuXG4vLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOS4xMlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFNhbWVWYWx1ZSh4LCB5KSB7XG5cdGlmICh4ID09PSB5KSB7IC8vIDAgPT09IC0wLCBidXQgdGhleSBhcmUgbm90IGlkZW50aWNhbC5cblx0XHRpZiAoeCA9PT0gMCkgeyByZXR1cm4gMSAvIHggPT09IDEgLyB5OyB9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuICRpc05hTih4KSAmJiAkaXNOYU4oeSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBpc05hTihhKSB7XG5cdHJldHVybiBhICE9PSBhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcycpO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xudmFyIFRvQm9vbGVhbiA9IHJlcXVpcmUoJy4vVG9Cb29sZWFuJyk7XG52YXIgSXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4vSXNDYWxsYWJsZScpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOC4xMC41XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqKSB7XG5cdGlmIChUeXBlKE9iaikgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1RvUHJvcGVydHlEZXNjcmlwdG9yIHJlcXVpcmVzIGFuIG9iamVjdCcpO1xuXHR9XG5cblx0dmFyIGRlc2MgPSB7fTtcblx0aWYgKGhhcyhPYmosICdlbnVtZXJhYmxlJykpIHtcblx0XHRkZXNjWydbW0VudW1lcmFibGVdXSddID0gVG9Cb29sZWFuKE9iai5lbnVtZXJhYmxlKTtcblx0fVxuXHRpZiAoaGFzKE9iaiwgJ2NvbmZpZ3VyYWJsZScpKSB7XG5cdFx0ZGVzY1snW1tDb25maWd1cmFibGVdXSddID0gVG9Cb29sZWFuKE9iai5jb25maWd1cmFibGUpO1xuXHR9XG5cdGlmIChoYXMoT2JqLCAndmFsdWUnKSkge1xuXHRcdGRlc2NbJ1tbVmFsdWVdXSddID0gT2JqLnZhbHVlO1xuXHR9XG5cdGlmIChoYXMoT2JqLCAnd3JpdGFibGUnKSkge1xuXHRcdGRlc2NbJ1tbV3JpdGFibGVdXSddID0gVG9Cb29sZWFuKE9iai53cml0YWJsZSk7XG5cdH1cblx0aWYgKGhhcyhPYmosICdnZXQnKSkge1xuXHRcdHZhciBnZXR0ZXIgPSBPYmouZ2V0O1xuXHRcdGlmICh0eXBlb2YgZ2V0dGVyICE9PSAndW5kZWZpbmVkJyAmJiAhSXNDYWxsYWJsZShnZXR0ZXIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0fVxuXHRcdGRlc2NbJ1tbR2V0XV0nXSA9IGdldHRlcjtcblx0fVxuXHRpZiAoaGFzKE9iaiwgJ3NldCcpKSB7XG5cdFx0dmFyIHNldHRlciA9IE9iai5zZXQ7XG5cdFx0aWYgKHR5cGVvZiBzZXR0ZXIgIT09ICd1bmRlZmluZWQnICYmICFJc0NhbGxhYmxlKHNldHRlcikpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdzZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0fVxuXHRcdGRlc2NbJ1tbU2V0XV0nXSA9IHNldHRlcjtcblx0fVxuXG5cdGlmICgoaGFzKGRlc2MsICdbW0dldF1dJykgfHwgaGFzKGRlc2MsICdbW1NldF1dJykpICYmIChoYXMoZGVzYywgJ1tbVmFsdWVdXScpIHx8IGhhcyhkZXNjLCAnW1tXcml0YWJsZV1dJykpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgZGVzY3JpcHRvci4gQ2Fubm90IGJvdGggc3BlY2lmeSBhY2Nlc3NvcnMgYW5kIGEgdmFsdWUgb3Igd3JpdGFibGUgYXR0cmlidXRlJyk7XG5cdH1cblx0cmV0dXJuIGRlc2M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOS4yXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9Cb29sZWFuKHZhbHVlKSB7IHJldHVybiAhIXZhbHVlOyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOS4xMVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2lzLWNhbGxhYmxlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHJlZmxlY3RBcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0ICE9PSBudWxsICYmIFJlZmxlY3QuYXBwbHk7XG52YXIgYmFkQXJyYXlMaWtlO1xudmFyIGlzQ2FsbGFibGVNYXJrZXI7XG5pZiAodHlwZW9mIHJlZmxlY3RBcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG5cdHRyeSB7XG5cdFx0YmFkQXJyYXlMaWtlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnbGVuZ3RoJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRocm93IGlzQ2FsbGFibGVNYXJrZXI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aXNDYWxsYWJsZU1hcmtlciA9IHt9O1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcblx0fVxufSBlbHNlIHtcblx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcbn1cblxudmFyIGNvbnN0cnVjdG9yUmVnZXggPSAvXlxccypjbGFzc1xcYi87XG52YXIgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0Z1bmN0aW9uKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KGZuU3RyKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTsgLy8gbm90IGEgZnVuY3Rpb25cblx0fVxufTtcblxudmFyIHRyeUZ1bmN0aW9uT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RnVuY3Rpb25Ub1N0cih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdEFwcGx5XG5cdD8gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIXZhbHVlLnByb3RvdHlwZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRyeSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkodmFsdWUsIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKGUgIT09IGlzQ2FsbGFibGVNYXJrZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiAhaXNFUzZDbGFzc0ZuKHZhbHVlKTtcblx0fVxuXHQ6IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmICF2YWx1ZS5wcm90b3R5cGUpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfVxuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciBzdHJDbGFzcyA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBzdHJDbGFzcyA9PT0gZm5DbGFzcyB8fCBzdHJDbGFzcyA9PT0gZ2VuQ2xhc3M7XG5cdH07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXJyYXlNZXRob2RCb3hlc1Byb3Blcmx5ID0gcmVxdWlyZSgnZXMtYXJyYXktbWV0aG9kLWJveGVzLXByb3Blcmx5Jyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0dmFyIG1ldGhvZCA9IEFycmF5LnByb3RvdHlwZS5tYXA7XG5cdHJldHVybiBhcnJheU1ldGhvZEJveGVzUHJvcGVybHkobWV0aG9kKSA/IG1ldGhvZCA6IGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVQcm9taXNlID0gcmVxdWlyZSgnLi9yZXF1aXJlUHJvbWlzZScpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJlcXVpcmVQcm9taXNlKCk7XG5cdHJldHVybiB0eXBlb2YgUHJvbWlzZS5hbGxTZXR0bGVkID09PSAnZnVuY3Rpb24nID8gUHJvbWlzZS5hbGxTZXR0bGVkIDogaW1wbGVtZW50YXRpb247XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBDdXN0b21FcnJvcl8xID0gcmVxdWlyZShcIi4vQ3VzdG9tRXJyb3JcIik7XG52YXIgUmV0cnlBZnRlckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJldHJ5QWZ0ZXJFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXRyeUFmdGVyRXJyb3IoYWZ0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJOZWVkIHRvIHJldHJ5IGFmdGVyIFwiICsgYWZ0ZXIgKyBcIiBtc1wiKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcmV0cnlBdCA9IERhdGUubm93KCkgKyBhZnRlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmV0cnlBZnRlckVycm9yLnByb3RvdHlwZSwgXCJyZXRyeUF0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0cnlBdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFJldHJ5QWZ0ZXJFcnJvcjtcbn0oQ3VzdG9tRXJyb3JfMS5DdXN0b21FcnJvcikpO1xuZXhwb3J0cy5SZXRyeUFmdGVyRXJyb3IgPSBSZXRyeUFmdGVyRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXRyeUFmdGVyRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBVc2VyXzEgPSByZXF1aXJlKFwiLi4vVXNlci9Vc2VyXCIpO1xuLyoqXG4gKiBBIHJlbGF0aW9uIG9mIGEgdXNlciBmb2xsb3dpbmcgYSBwcmV2aW91c2x5IGdpdmVuIGNoYW5uZWwuXG4gKi9cbnZhciBDaGFubmVsRm9sbG93ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIENoYW5uZWxGb2xsb3coX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWxGb2xsb3cucHJvdG90eXBlLCBcInVzZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgZm9sbG93aW5nIHRoZSBnaXZlbiBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVzZXJfMS5kZWZhdWx0KHRoaXMuX2RhdGEudXNlciwgdGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWxGb2xsb3cucHJvdG90eXBlLCBcImhhc05vdGlmaWNhdGlvbnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdXNlciBoYXMgbm90aWZpY2F0aW9ucyBlbmFibGVkIGZvciB0aGUgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubm90aWZpY2F0aW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYW5uZWxGb2xsb3cucHJvdG90eXBlLCBcImZvbGxvd0RhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgd2hlbiB0aGUgdXNlciBmb2xsb3dlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEuY3JlYXRlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBDaGFubmVsRm9sbG93LnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIENoYW5uZWxGb2xsb3c7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbEZvbGxvdztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENoYW5uZWxGb2xsb3c7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFubmVsRm9sbG93O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9TdWJzY3JpcHRpb25cIik7XG52YXIgVXNlcl8xID0gcmVxdWlyZShcIi4uL1VzZXIvVXNlclwiKTtcbi8qKlxuICogQSByZWxhdGlvbiBvZiBhIHVzZXIgc3Vic2NyaWJpbmcgdG8gYSBwcmV2aW91c2x5IGdpdmVuIGNoYW5uZWwuXG4gKi9cbnZhciBDaGFubmVsU3Vic2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENoYW5uZWxTdWJzY3JpcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbFN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbm5lbFN1YnNjcmlwdGlvbi5wcm90b3R5cGUsIFwidXNlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlciBzdWJzY3JpYmluZyB0byB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVc2VyXzEuZGVmYXVsdCh0aGlzLl9kYXRhLnVzZXIsIHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDaGFubmVsU3Vic2NyaXB0aW9uO1xufShTdWJzY3JpcHRpb25fMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFubmVsU3Vic2NyaXB0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ2hhbm5lbFN1YnNjcmlwdGlvbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYW5uZWxTdWJzY3JpcHRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIENoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL0NoYW5uZWxcIik7XG4vKipcbiAqIEEgY2hhbm5lbCB5b3UgaGF2ZSBleHRlbmRlZCBwcml2aWxlZ2VzIGZvciwgaS5lLiB0aGUgY2hhbm5lbCBvZiB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqL1xudmFyIFByaXZpbGVnZWRDaGFubmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFByaXZpbGVnZWRDaGFubmVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByaXZpbGVnZWRDaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcml2aWxlZ2VkQ2hhbm5lbC5wcm90b3R5cGUsIFwic3RyZWFtS2V5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGFubmVsJ3Mgc3RyZWFtIGtleS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc3RyZWFtX2tleTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXZpbGVnZWRDaGFubmVsLnByb3RvdHlwZSwgXCJlbWFpbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2hhbm5lbCdzIGVtYWlsIGFkZHJlc3MuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmVtYWlsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgZWRpdG9ycyBvZiB0aGUgY2hhbm5lbC5cbiAgICAgKi9cbiAgICBQcml2aWxlZ2VkQ2hhbm5lbC5wcm90b3R5cGUuZ2V0RWRpdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmtyYWtlbi5jaGFubmVscy5nZXRDaGFubmVsRWRpdG9ycyh0aGlzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBjb21tZXJjaWFsIGluIHRoZSBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBjb21tZXJjaWFsLlxuICAgICAqL1xuICAgIFByaXZpbGVnZWRDaGFubmVsLnByb3RvdHlwZS5zdGFydENvbW1lcmNpYWwgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4uY2hhbm5lbHMuc3RhcnRDaGFubmVsQ29tbWVyY2lhbCh0aGlzLCBsZW5ndGgpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgZ2l2ZW4gY2hhbm5lbCdzIHN0cmVhbSBrZXkuXG4gICAgICovXG4gICAgUHJpdmlsZWdlZENoYW5uZWwucHJvdG90eXBlLnJlc2V0U3RyZWFtS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsRGF0YSwgc3RyZWFtS2V5O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4uY2hhbm5lbHMucmVzZXRDaGFubmVsU3RyZWFtS2V5KHRoaXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbERhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1LZXkgPSBjaGFubmVsRGF0YS5zdHJlYW1fa2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YS5zdHJlYW1fa2V5ID0gc3RyZWFtS2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHN0cmVhbUtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFByaXZpbGVnZWRDaGFubmVsO1xufShDaGFubmVsXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHJpdmlsZWdlZENoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBQcml2aWxlZ2VkQ2hhbm5lbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByaXZpbGVnZWRDaGFubmVsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjYWNoZV9kZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzXCIpO1xuLyoqXG4gKiBBIGxpc3Qgb2YgZW1vdGVzLCBncm91cGVkIGludG8gZW1vdGUgc2V0cywgdGhhdCBhIHVzZXIgY2FuIHVzZS5cbiAqL1xudmFyIEVtb3RlU2V0TGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBFbW90ZVNldExpc3QoX2RhdGEpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZW1vdGUgSUQgZm9yIHRoZSBnaXZlbiBlbW90ZSBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVtb3RlQ29kZSBUaGUgZW1vdGUgY29kZSB0byBjaGVjayBmb3IuXG4gICAgICovXG4gICAgRW1vdGVTZXRMaXN0LnByb3RvdHlwZS5maW5kRW1vdGVJZCA9IGZ1bmN0aW9uIChlbW90ZUNvZGUpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IHRzbGliXzEuX192YWx1ZXMoT2JqZWN0LnZhbHVlcyh0aGlzLl9kYXRhKSksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW1vdGVTZXQgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlbW90ZVNldF8xID0gKGVfMiA9IHZvaWQgMCwgdHNsaWJfMS5fX3ZhbHVlcyhlbW90ZVNldCkpLCBlbW90ZVNldF8xXzEgPSBlbW90ZVNldF8xLm5leHQoKTsgIWVtb3RlU2V0XzFfMS5kb25lOyBlbW90ZVNldF8xXzEgPSBlbW90ZVNldF8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtb3RlID0gZW1vdGVTZXRfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAoZW1vdGUuY29kZSkudGVzdChlbW90ZUNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtb3RlLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1vdGVTZXRfMV8xICYmICFlbW90ZVNldF8xXzEuZG9uZSAmJiAoX2IgPSBlbW90ZVNldF8xLnJldHVybikpIF9iLmNhbGwoZW1vdGVTZXRfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKEluZmluaXR5LCB0cnVlKVxuICAgIF0sIEVtb3RlU2V0TGlzdC5wcm90b3R5cGUsIFwiZmluZEVtb3RlSWRcIiwgbnVsbCk7XG4gICAgRW1vdGVTZXRMaXN0ID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIEVtb3RlU2V0TGlzdCk7XG4gICAgcmV0dXJuIEVtb3RlU2V0TGlzdDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFbW90ZVNldExpc3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBFbW90ZVNldExpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFbW90ZVNldExpc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIFVzZXJfMSA9IHJlcXVpcmUoXCIuL1VzZXJcIik7XG4vKipcbiAqIEEgdXNlciB5b3UgaGF2ZSBleHRlbmRlZCBwcml2aWxlZ2VzIGZvciwgaS5lLiB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqXG4gKiBAaW5oZXJpdERvY1xuICovXG52YXIgUHJpdmlsZWdlZFVzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUHJpdmlsZWdlZFVzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJpdmlsZWdlZFVzZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXZpbGVnZWRVc2VyLnByb3RvdHlwZSwgXCJlbWFpbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmVtYWlsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpdmlsZWdlZFVzZXIucHJvdG90eXBlLCBcImlzRW1haWxWZXJpZmllZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcyBpcyB2ZXJpZmllZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZW1haWxfdmVyaWZpZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcml2aWxlZ2VkVXNlci5wcm90b3R5cGUsIFwiaGFzRW1haWxOb3RpZmljYXRpb25zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgaGFzIGVtYWlsIG5vdGlmaWNhdGlvbnMgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubm90aWZpY2F0aW9ucy5lbWFpbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXZpbGVnZWRVc2VyLnByb3RvdHlwZSwgXCJoYXNQdXNoTm90aWZpY2F0aW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIGhhcyBwdXNoIG5vdGlmaWNhdGlvbnMgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubm90aWZpY2F0aW9ucy5wdXNoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpdmlsZWdlZFVzZXIucHJvdG90eXBlLCBcImlzUGFydG5lcmVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgaXMgcGFydG5lcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5wYXJ0bmVyZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcml2aWxlZ2VkVXNlci5wcm90b3R5cGUsIFwiaGFzVHdpdHRlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIGhhcyBhIFR3aXR0ZXIgYWNjb3VudCBjb25uZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnR3aXR0ZXJfY29ubmVjdGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGb2xsb3dzIGEgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIGZvbGxvdy5cbiAgICAgKiBAcGFyYW0gbm90aWZpY2F0aW9ucyBXaGV0aGVyIHRoZSB1c2VyIHdpbGwgcmVjZWl2ZSBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIFByaXZpbGVnZWRVc2VyLnByb3RvdHlwZS5mb2xsb3dDaGFubmVsID0gZnVuY3Rpb24gKGNoYW5uZWwsIG5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmtyYWtlbi51c2Vycy5mb2xsb3dDaGFubmVsKHRoaXMsIGNoYW5uZWwsIG5vdGlmaWNhdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuZm9sbG93cyBhIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byB1bmZvbGxvdy5cbiAgICAgKi9cbiAgICBQcml2aWxlZ2VkVXNlci5wcm90b3R5cGUudW5mb2xsb3dDaGFubmVsID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmtyYWtlbi51c2Vycy51bmZvbGxvd0NoYW5uZWwodGhpcywgY2hhbm5lbCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmxvY2tzIGEgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyVG9CbG9jayBUaGUgdXNlciB0byBibG9jay5cbiAgICAgKi9cbiAgICBQcml2aWxlZ2VkVXNlci5wcm90b3R5cGUuYmxvY2tVc2VyID0gZnVuY3Rpb24gKHVzZXJUb0Jsb2NrKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuYmxvY2tVc2VyKHRoaXMsIHVzZXJUb0Jsb2NrKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmJsb2NrcyBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlclRvVW5ibG9jayBUaGUgdXNlciB0byB1bmJsb2NrLlxuICAgICAqL1xuICAgIFByaXZpbGVnZWRVc2VyLnByb3RvdHlwZS51bmJsb2NrVXNlciA9IGZ1bmN0aW9uICh1c2VyVG9VbmJsb2NrKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMudW5ibG9ja1VzZXIodGhpcywgdXNlclRvVW5ibG9jayldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFByaXZpbGVnZWRVc2VyO1xufShVc2VyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHJpdmlsZWdlZFVzZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBQcml2aWxlZ2VkVXNlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByaXZpbGVnZWRVc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBVc2VyXzEgPSByZXF1aXJlKFwiLi9Vc2VyXCIpO1xuLyoqXG4gKiBBIHJlbGF0aW9uIG9mIGEgcHJldmlvdXNseSBnaXZuIHVzZXIgYmxvY2tpbmcgYW5vdGhlciB1c2VyLlxuICovXG52YXIgVXNlckJsb2NrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIFVzZXJCbG9jayhfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckJsb2NrLnByb3RvdHlwZSwgXCJibG9ja2VkVXNlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmxvY2tlZCB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVzZXJfMS5kZWZhdWx0KHRoaXMuX2RhdGEudXNlciwgdGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIFVzZXJCbG9jay5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBVc2VyQmxvY2s7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVXNlckJsb2NrO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVXNlckJsb2NrO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gVXNlckJsb2NrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBDaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vQ2hhbm5lbC9DaGFubmVsXCIpO1xuLyoqXG4gKiBBIHJlbGF0aW9uIG9mIGEgcHJldmlvdXNseSBnaXZlbiB1c2VyIGZvbGxvd2luZyBhIGNoYW5uZWwuXG4gKi9cbnZhciBVc2VyRm9sbG93ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIFVzZXJGb2xsb3coX2RhdGEsIGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJGb2xsb3cucHJvdG90eXBlLCBcImZvbGxvd0RhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgd2hlbiB0aGUgdXNlciBmb2xsb3dlZCB0aGUgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEuY3JlYXRlZF9hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyRm9sbG93LnByb3RvdHlwZSwgXCJoYXNOb3RpZmljYXRpb25zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgaGFzIG5vdGlmaWNhdGlvbnMgZW5hYmxlZCBmb3IgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLm5vdGlmaWNhdGlvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyRm9sbG93LnByb3RvdHlwZSwgXCJjaGFubmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmb2xsb3dlZCBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYW5uZWxfMS5kZWZhdWx0KHRoaXMuX2RhdGEuY2hhbm5lbCwgdGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIFVzZXJGb2xsb3cucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gVXNlckZvbGxvdztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVc2VyRm9sbG93O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVXNlckZvbGxvdztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVzZXJGb2xsb3c7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4uL1N1YnNjcmlwdGlvblwiKTtcbnZhciBDaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vQ2hhbm5lbC9DaGFubmVsXCIpO1xuLyoqXG4gKiBBIHJlbGF0aW9uIG9mIGEgcHJldmlvdXNseSBnaXZlbiB1c2VyIHN1YnNjcmliaW5nIHRvIGEgY2hhbm5lbC5cbiAqL1xudmFyIFVzZXJTdWJzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVXNlclN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVc2VyU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyU3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJjaGFubmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdWJzY3JpYmVkIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhbm5lbF8xLmRlZmF1bHQodGhpcy5fZGF0YS5jaGFubmVsLCB0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVXNlclN1YnNjcmlwdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVXNlclN1YnNjcmlwdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFVzZXJTdWJzY3JpcHRpb247XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVc2VyU3Vic2NyaXB0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IGFuIGFjY2VzcyB0b2tlbi5cbiAqL1xudmFyIFRva2VuSW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBUb2tlbkluZm8oX2RhdGEpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9vYnRhaW5tZW50RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb2tlbkluZm8ucHJvdG90eXBlLCBcImNsaWVudElkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgSUQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmNsaWVudF9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRva2VuSW5mby5wcm90b3R5cGUsIFwidXNlcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgYXV0aGVudGljYXRlZCB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9rZW5JbmZvLnByb3RvdHlwZSwgXCJ1c2VyTmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlciBuYW1lIG9mIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmxvZ2luO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9rZW5JbmZvLnByb3RvdHlwZSwgXCJzY29wZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjb3BlcyBmb3Igd2hpY2ggdGhpcyB0b2tlbiBpcyB2YWxpZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc2NvcGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9rZW5JbmZvLnByb3RvdHlwZSwgXCJleHBpcnlEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHdoZW4gdGhlIHRva2VuIHdpbGwgZXhwaXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGlzIHJldHVybnMgbnVsbCwgaXQgbWVhbnMgdGhhdCB0aGUgdG9rZW4gaXMgZWl0aGVyIGludmFsaWQgb3IgbmV2ZXIgZXhwaXJlcyAoaGFwcGVucyB3aXRoIG9sZCBjbGllbnQgSURzKS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kYXRhLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9vYnRhaW5tZW50RGF0ZS5nZXRUaW1lKCkgKyB0aGlzLl9kYXRhLmV4cGlyZXNfaW4gKiAxMDAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRva2VuSW5mbztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlbkluZm87XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBUb2tlbkluZm87XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlbkluZm87XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBBIGxpc3Qgb2YgY2hhdHRlcnMgaW4gYSBUd2l0Y2ggY2hhdC5cbiAqL1xudmFyIENoYXR0ZXJzTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBDaGF0dGVyc0xpc3QoX2RhdGEpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdHRlcnNMaXN0LnByb3RvdHlwZSwgXCJhbGxDaGF0dGVyc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgdXNlciBuYW1lcyBvZiBhbGwgY2hhdHRlcnMgaW4gdGhlIGNoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzaGFyZWRfdXRpbHNfMS5mbGF0dGVuKE9iamVjdC52YWx1ZXModGhpcy5fZGF0YS5jaGF0dGVycykpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdHRlcnNMaXN0LnByb3RvdHlwZSwgXCJhbGxDaGF0dGVyc1dpdGhTdGF0dXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgdXNlciBuYW1lcyBvZiBhbGwgY2hhdHRlcnMgaW4gdGhlIGNoYXQsIG1hcHBlZCB0byB0aGVpciBzdGF0dXMgaW4gdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKHNoYXJlZF91dGlsc18xLmZsYXR0ZW4oT2JqZWN0LmVudHJpZXModGhpcy5fZGF0YS5jaGF0dGVycykubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKF9hLCAyKSwgc3RhdHVzID0gX2JbMF0sIG5hbWVzID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW25hbWUsIHN0YXR1c107IH0pO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENoYXR0ZXJzTGlzdDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGF0dGVyc0xpc3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDaGF0dGVyc0xpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGF0dGVyc0xpc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uL1R3aXRjaENsaWVudFwiKTtcbi8qKlxuICogRW5oYW5jZXMgYW5vdGhlciBhdXRoIHByb3ZpZGVyIHdpdGggdGhlIGFiaWxpdHkgdG8gbWFrZSB1c2Ugb2YgcmVmcmVzaFxuICogdG9rZW5zLCBhdXRvbWF0aWNhbGx5IHJlZnJlc2hpbmcgdGhlIGFjY2VzcyB0b2tlbiB3aGVuZXZlciBuZWNlc3NhcnkuXG4gKi9cbnZhciBSZWZyZXNoYWJsZUF1dGhQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGF1dGggcHJvdmlkZXIgYmFzZWQgb24gdGhlIGdpdmVuIG9uZSB0aGF0IGNhbiBhdXRvbWF0aWNhbGx5XG4gICAgICogcmVmcmVzaCBhY2Nlc3MgdG9rZW5zLlxuICAgICAqXG4gICAgICogWW91IGRvbid0IHVzdWFsbHkgaGF2ZSB0byBjcmVhdGUgdGhpcyBtYW51YWxseS4gWW91IHNob3VsZCB1c2UgYFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHNgXG4gICAgICogd2l0aCB0aGUgYHJlZnJlc2hDb25maWdgIHBhcmFtZXRlciBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoaWxkUHJvdmlkZXIgVGhlIGJhc2UgYXV0aCBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaENvbmZpZyBUaGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGF1dG9tYXRpY2FsbHkgcmVmcmVzaCBhbiBhY2Nlc3MgdG9rZW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmcmVzaGFibGVBdXRoUHJvdmlkZXIoY2hpbGRQcm92aWRlciwgcmVmcmVzaENvbmZpZykge1xuICAgICAgICB0aGlzLl9jbGllbnRTZWNyZXQgPSByZWZyZXNoQ29uZmlnLmNsaWVudFNlY3JldDtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFRva2VuID0gcmVmcmVzaENvbmZpZy5yZWZyZXNoVG9rZW47XG4gICAgICAgIHRoaXMuX2NoaWxkUHJvdmlkZXIgPSBjaGlsZFByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9pbml0aWFsRXhwaXJ5ID0gcmVmcmVzaENvbmZpZy5leHBpcnk7XG4gICAgICAgIHRoaXMuX29uUmVmcmVzaCA9IHJlZnJlc2hDb25maWcub25SZWZyZXNoO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmcmVzaGFibGVBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcInRva2VuVHlwZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0b2tlbnMgdGhpcyBwcm92aWRlciBnZW5lcmF0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IGlzIHRoZSBzYW1lIGFzIHRoZSB1bmRlcmx5aW5nIGJhc2UgYXV0aCBwcm92aWRlcidzIHRva2VuIHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZFByb3ZpZGVyLnRva2VuVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFjY2VzcyB0b2tlbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjdXJyZW50IGFjY2VzcyB0b2tlbiBkb2VzIG5vdCBoYXZlIHRoZSByZXF1ZXN0ZWQgc2NvcGVzLCB0aGUgYmFzZSBhdXRoXG4gICAgICogcHJvdmlkZXIgaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIGN1cnJlbnQgYWNjZXNzIHRva2VuIGlzIGV4cGlyZWQsIGF1dG9tYXRpY2FsbHkgcmVuZXcgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NvcGVzIFRoZSByZXF1ZXN0ZWQgc2NvcGVzLlxuICAgICAqL1xuICAgIFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyLnByb3RvdHlwZS5nZXRBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uIChzY29wZXMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2xkVG9rZW4sIG5ld1Rva2VuLCBub3csIHJlZnJlc2hlZFRva2VuO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY29wZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVzID0gc2NvcGVzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jaGlsZFByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRUb2tlbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG9sZFRva2VuICYmIHNjb3BlcyAmJiBzY29wZXMuc29tZShmdW5jdGlvbiAoc2NvcGUpIHsgcmV0dXJuICFfdGhpcy5jdXJyZW50U2NvcGVzLmluY2x1ZGVzKHNjb3BlKTsgfSkpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NoaWxkUHJvdmlkZXIuZ2V0QWNjZXNzVG9rZW4oc2NvcGVzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Rva2VuID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IGlmIHRoZSB0b2tlbiBkb2Vzbid0IGNoYW5nZSwgY2Fycnkgb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdUb2tlbiAhPT0gb2xkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3VG9rZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGEgY3VycmVudCB0b2tlbiwgd2UganVzdCBwYXNzIHRoaXMgYW5kIHJlZnJlc2ggcmlnaHQgYXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxFeHBpcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyA8IHRoaXMuX2luaXRpYWxFeHBpcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBvbGRUb2tlbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW9sZFRva2VuLmlzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgb2xkVG9rZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVmcmVzaCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaGVkVG9rZW4gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVmcmVzaGVkVG9rZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjaGVjayBhZ2FpbiBmb3Igc2NvcGVzIGFmdGVyIHJlZnJlc2hpbmcsIGluIGNhc2UgYSByZWZyZXNoIHRva2VuIHdhcyBwYXNzZWQgd2l0aG91dCBhbiBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jaGlsZFByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKHNjb3BlcyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvcmNlIGEgcmVmcmVzaCBvZiB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbkRhdGE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgVHdpdGNoQ2xpZW50XzEuZGVmYXVsdC5yZWZyZXNoQWNjZXNzVG9rZW4odGhpcy5jbGllbnRJZCwgdGhpcy5fY2xpZW50U2VjcmV0LCB0aGlzLl9yZWZyZXNoVG9rZW4pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5EYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBY2Nlc3NUb2tlbih0b2tlbkRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFRva2VuID0gdG9rZW5EYXRhLnJlZnJlc2hUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxFeHBpcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25SZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25SZWZyZXNoKHRva2VuRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdG9rZW5EYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBSZWZyZXNoYWJsZUF1dGhQcm92aWRlci5wcm90b3R5cGUuc2V0QWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdGhpcy5fY2hpbGRQcm92aWRlci5zZXRBY2Nlc3NUb2tlbih0b2tlbik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmcmVzaGFibGVBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcImNsaWVudElkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgSUQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZFByb3ZpZGVyLmNsaWVudElkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmcmVzaGFibGVBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcImN1cnJlbnRTY29wZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjb3BlcyB0aGF0IGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlIHVzaW5nIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZFByb3ZpZGVyLmN1cnJlbnRTY29wZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBSZWZyZXNoYWJsZUF1dGhQcm92aWRlci5wcm90b3R5cGUsIFwiX2NsaWVudFNlY3JldFwiLCB2b2lkIDApO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBSZWZyZXNoYWJsZUF1dGhQcm92aWRlci5wcm90b3R5cGUsIFwiX3JlZnJlc2hUb2tlblwiLCB2b2lkIDApO1xuICAgIHJldHVybiBSZWZyZXNoYWJsZUF1dGhQcm92aWRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWZyZXNoYWJsZUF1dGhQcm92aWRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFJlZnJlc2hhYmxlQXV0aFByb3ZpZGVyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVmcmVzaGFibGVBdXRoUHJvdmlkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIEFjY2Vzc1Rva2VuXzEgPSByZXF1aXJlKFwiLi4vQVBJL0FjY2Vzc1Rva2VuXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uL1R3aXRjaENsaWVudFwiKTtcbi8qKlxuICogQW4gYXV0aCBwcm92aWRlciB0aGF0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIGluaXRpYWxseSBnaXZlbiBjcmVkZW50aWFscy5cbiAqXG4gKiBZb3UgYXJlIGFkdmlzZWQgdG8gcm9sbCB5b3VyIG93biBhdXRoIHByb3ZpZGVyIHRoYXQgY2FuIGhhbmRsZSBzY29wZSB1cGdyYWRlcyxcbiAqIG9yIHRvIHBsYW4gYWhlYWQgYW5kIHN1cHBseSBvbmx5IGFjY2VzcyB0b2tlbnMgdGhhdCBhY2NvdW50IGZvciBhbGwgc2NvcGVzXG4gKiB5b3Ugd2lsbCBldmVyIG5lZWQuXG4gKi9cbnZhciBTdGF0aWNBdXRoUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhdXRoIHByb3ZpZGVyIHdpdGggc3RhdGljIGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogWW91IGRvbid0IHVzdWFsbHkgaGF2ZSB0byBjcmVhdGUgdGhpcyBtYW51YWxseS4gWW91IHNob3VsZCB1c2UgYFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHNgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBJRC5cbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gVGhlIGFjY2VzcyB0b2tlbiB0byBwcm92aWRlLlxuICAgICAqXG4gICAgICogWW91IG5lZWQgdG8gb2J0YWluIG9uZSB1c2luZyBvbmUgb2YgdGhlIFtUd2l0Y2ggT0F1dGggZmxvd3NdKGh0dHBzOi8vZGV2LnR3aXRjaC50di9kb2NzL2F1dGhlbnRpY2F0aW9uL2dldHRpbmctdG9rZW5zLW9hdXRoLykuXG4gICAgICogQHBhcmFtIHNjb3BlcyBUaGUgc2NvcGVzIHRoaXMgdG9rZW4gaGFzLlxuICAgICAqIEBwYXJhbSB0b2tlblR5cGUgVGhlIHR5cGUgb2YgdGhlIHN1cHBsaWVkIHRva2VuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YXRpY0F1dGhQcm92aWRlcihjbGllbnRJZCwgYWNjZXNzVG9rZW4sIHNjb3BlcywgdG9rZW5UeXBlKSB7XG4gICAgICAgIGlmICh0b2tlblR5cGUgPT09IHZvaWQgMCkgeyB0b2tlblR5cGUgPSAndXNlcic7IH1cbiAgICAgICAgdGhpcy5fY2xpZW50SWQgPSBjbGllbnRJZCB8fCAnJztcbiAgICAgICAgdGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5fYWNjZXNzVG9rZW4gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBhY2Nlc3NUb2tlbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgQWNjZXNzVG9rZW5fMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogc2NvcGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogJydcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBhY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIHRoaXMuX3Njb3BlcyA9IHNjb3BlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYWNjZXNzIHRva2VuLlxuICAgICAqXG4gICAgICogSWYgdGhlIGN1cnJlbnQgYWNjZXNzIHRva2VuIGRvZXMgbm90IGhhdmUgdGhlIHJlcXVlc3RlZCBzY29wZXMsIHRoaXMgbWV0aG9kIHRocm93cy5cbiAgICAgKiBUaGlzIG1ha2VzIHN1cHBseWluZyBhbiBhY2Nlc3MgdG9rZW4gd2l0aCB0aGUgY29ycmVjdCBzY29wZXMgZnJvbSB0aGUgYmVnaW5uaW5nIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY29wZXMgVGhlIHJlcXVlc3RlZCBzY29wZXMuXG4gICAgICovXG4gICAgU3RhdGljQXV0aFByb3ZpZGVyLnByb3RvdHlwZS5nZXRBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uIChzY29wZXMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5JbmZvO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2NvcGVzICYmIHNjb3Blcy5sZW5ndGggPiAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISF0aGlzLl9zY29wZXMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aCBwcm92aWRlciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIHlldCBhbmQgaXMgcmVxdWVzdGluZyBzY29wZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFR3aXRjaENsaWVudF8xLmRlZmF1bHQuZ2V0VG9rZW5JbmZvKHRoaXMuX2FjY2Vzc1Rva2VuLmFjY2Vzc1Rva2VuLCB0aGlzLl9jbGllbnRJZCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkluZm8gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY29wZXMgPSB0b2tlbkluZm8uc2NvcGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjb3BlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZXMgPSBzY29wZXMuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZXMuc29tZShmdW5jdGlvbiAoc2NvcGUpIHsgcmV0dXJuICFfdGhpcy5fc2NvcGVzLmluY2x1ZGVzKHNjb3BlKTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHRva2VuIGRvZXMgbm90IGhhdmUgdGhlIHJlcXVlc3RlZCBzY29wZXMgKFwiICsgc2NvcGVzLmpvaW4oJywgJykgKyBcIikgYW5kIGNhbiBub3QgYmUgdXBncmFkZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2FjY2Vzc1Rva2VuIHx8IG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIFN0YXRpY0F1dGhQcm92aWRlci5wcm90b3R5cGUuc2V0QWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdGhpcy5fYWNjZXNzVG9rZW4gPSB0b2tlbjtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0aWNBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcImNsaWVudElkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgSUQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGllbnRJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRpY0F1dGhQcm92aWRlci5wcm90b3R5cGUsIFwiY3VycmVudFNjb3Blc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NvcGVzIHRoYXQgYXJlIGN1cnJlbnRseSBhdmFpbGFibGUgdXNpbmcgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlcyB8fCBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIFN0YXRpY0F1dGhQcm92aWRlci5wcm90b3R5cGUsIFwiX2NsaWVudElkXCIsIHZvaWQgMCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIFN0YXRpY0F1dGhQcm92aWRlci5wcm90b3R5cGUsIFwiX2FjY2Vzc1Rva2VuXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFN0YXRpY0F1dGhQcm92aWRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdGF0aWNBdXRoUHJvdmlkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTdGF0aWNBdXRoUHJvdmlkZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdGF0aWNBdXRoUHJvdmlkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEN1c3RvbUVycm9yXzEgPSByZXF1aXJlKFwiLi9DdXN0b21FcnJvclwiKTtcbi8qKlxuICogVGhyb3duIHdoZW5ldmVyIHlvdSB0cnkgdXNpbmcgaW52YWxpZCB2YWx1ZXMgaW4gdGhlIGNsaWVudCBjb25maWd1cmF0aW9uLlxuICovXG52YXIgQ29uZmlnRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29uZmlnRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uZmlnRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbmZpZ0Vycm9yO1xufShDdXN0b21FcnJvcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbmZpZ0Vycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ29uZmlnRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb25maWdFcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQ3VzdG9tRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0N1c3RvbUVycm9yXCIpO1xuLyoqXG4gKiBUaHJvd24gd2hlbmV2ZXIgYW4gaW52YWxpZCB0b2tlbiBpcyBzdXBwbGllZC5cbiAqL1xudmFyIEludmFsaWRUb2tlbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEludmFsaWRUb2tlbkVycm9yLCBfc3VwZXIpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEludmFsaWRUb2tlbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ0ludmFsaWQgdG9rZW4gc3VwcGxpZWQnKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW52YWxpZFRva2VuRXJyb3I7XG59KEN1c3RvbUVycm9yXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSW52YWxpZFRva2VuRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBJbnZhbGlkVG9rZW5FcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEludmFsaWRUb2tlbkVycm9yO1xuIiwidmFyIF9fc2VsZl9fID0gKGZ1bmN0aW9uIChyb290KSB7XG5mdW5jdGlvbiBGKCkge1xudGhpcy5mZXRjaCA9IGZhbHNlO1xudGhpcy5ET01FeGNlcHRpb24gPSByb290LkRPTUV4Y2VwdGlvblxufVxuRi5wcm90b3R5cGUgPSByb290O1xucmV0dXJuIG5ldyBGKCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG4oZnVuY3Rpb24oc2VsZikge1xuXG52YXIgaXJyZWxldmFudCA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjpcbiAgICAgICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmXG4gICAgICAnQmxvYicgaW4gc2VsZiAmJlxuICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF07XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPVxuICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV07XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcik7XG4gICAgICB9O1xuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpO1xuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKTtcbiAgICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ107XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5O1xuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybDtcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFscztcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2Q7XG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlO1xuICAgICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWw7XG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDtcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nO1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpO1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbDtcbiAgICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsO1xuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsO1xuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KTtcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG4gIH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGJvZHlcbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdCgnJicpXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICAgIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpO1xuICAgIHByZVByb2Nlc3NlZEhlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXM7XG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSyc7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnO1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KTtcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH07XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJztcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfTtcblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfTtcblxuICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IHNlbGYuRE9NRXhjZXB0aW9uO1xuICB0cnkge1xuICAgIG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgfTtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZXhwb3J0cy5ET01FeGNlcHRpb247XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpO1xuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKTtcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKTtcblxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICB9KVxuICB9XG5cbiAgZmV0Y2gucG9seWZpbGwgPSB0cnVlO1xuXG4gIGlmICghc2VsZi5mZXRjaCkge1xuICAgIHNlbGYuZmV0Y2ggPSBmZXRjaDtcbiAgICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzO1xuICAgIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICB9XG5cbiAgZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbiAgZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICBleHBvcnRzLmZldGNoID0gZmV0Y2g7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oe30pKTtcbn0pKF9fc2VsZl9fKTtcbmRlbGV0ZSBfX3NlbGZfXy5mZXRjaC5wb2x5ZmlsbFxuZXhwb3J0cyA9IF9fc2VsZl9fLmZldGNoIC8vIFRvIGVuYWJsZTogaW1wb3J0IGZldGNoIGZyb20gJ2Nyb3NzLWZldGNoJ1xuZXhwb3J0cy5kZWZhdWx0ID0gX19zZWxmX18uZmV0Y2ggLy8gRm9yIFR5cGVTY3JpcHQgY29uc3VtZXJzIHdpdGhvdXQgZXNNb2R1bGVJbnRlcm9wLlxuZXhwb3J0cy5mZXRjaCA9IF9fc2VsZl9fLmZldGNoIC8vIFRvIGVuYWJsZTogaW1wb3J0IHtmZXRjaH0gZnJvbSAnY3Jvc3MtZmV0Y2gnXG5leHBvcnRzLkhlYWRlcnMgPSBfX3NlbGZfXy5IZWFkZXJzXG5leHBvcnRzLlJlcXVlc3QgPSBfX3NlbGZfXy5SZXF1ZXN0XG5leHBvcnRzLlJlc3BvbnNlID0gX19zZWxmX18uUmVzcG9uc2Vcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBmaWxlbmFtZXMvbWF0Y2gtZXhwb3J0ZWQgKi9cbnZhciBpc05vZGUgPSByZXF1aXJlKFwiZGV0ZWN0LW5vZGVcIik7XG52YXIgTm9kZUxvZ2dlcl8xID0gcmVxdWlyZShcIi4vTm9kZUxvZ2dlclwiKTtcbnZhciBCcm93c2VyTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Ccm93c2VyTG9nZ2VyXCIpO1xudmFyIExvZ2dlciA9IGlzTm9kZSA/IE5vZGVMb2dnZXJfMS5kZWZhdWx0IDogQnJvd3NlckxvZ2dlcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBMb2dnZXI7XG52YXIgTG9nTGV2ZWxfMSA9IHJlcXVpcmUoXCIuL0xvZ0xldmVsXCIpO1xudmFyIF9fZXhwb3J0X0xvZ0xldmVsID0gTG9nTGV2ZWxfMS5kZWZhdWx0O1xuZXhwb3J0cy5Mb2dMZXZlbCA9IF9fZXhwb3J0X0xvZ0xldmVsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTG9nZ2VyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gTG9nZ2VyO1xuZXhwb3J0cy5Mb2dMZXZlbCA9IF9fZXhwb3J0X0xvZ0xldmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2EsIF9iLCBfYztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIExvZ0xldmVsXzEgPSByZXF1aXJlKFwiLi9Mb2dMZXZlbFwiKTtcbnZhciBCYXNlTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9CYXNlTG9nZ2VyXCIpO1xudmFyIF9fZXhwb3J0X0xvZ0xldmVsVG9FbW9qaSA9IChfYSA9IHt9LFxuICAgIF9hW0xvZ0xldmVsXzEuZGVmYXVsdC5DUklUSUNBTF0gPSBcIlxcdUQ4M0RcXHVERUQxXCIsXG4gICAgX2FbTG9nTGV2ZWxfMS5kZWZhdWx0LkVSUk9SXSA9IFwiXFx1Mjc0Q1wiLFxuICAgIC8vIHRoZXNlIGZvbGxvd2luZyB0d28gbmVlZCBleHRyYSBzcGFjZXMgYXQgdGhlIGVuZCBiZWNhdXNlIHNvbWVob3cgdGhleSBjb25zdW1lIGxlc3Mgc3BhY2UgaW4gYSB0ZXJtaW5hbCB0aGFuIHRoZXkgc2hvdWxkLi4uXG4gICAgX2FbTG9nTGV2ZWxfMS5kZWZhdWx0LldBUk5JTkddID0gXCJcXHUyNkEwXFx1RkUwRiBcIixcbiAgICBfYVtMb2dMZXZlbF8xLmRlZmF1bHQuSU5GT10gPSBcIlxcdTIxMzlcXHVGRTBGIFwiLFxuICAgIF9hW0xvZ0xldmVsXzEuZGVmYXVsdC5ERUJVR10gPSBcIlxcdUQ4M0RcXHVEQzFFXCIsXG4gICAgX2FbTG9nTGV2ZWxfMS5kZWZhdWx0LlRSQUNFXSA9IFwiXFx1RDgzRFxcdURDM0VcIixcbiAgICBfYSk7XG5leHBvcnRzLkxvZ0xldmVsVG9FbW9qaSA9IF9fZXhwb3J0X0xvZ0xldmVsVG9FbW9qaTtcbnZhciBjb2xvcnMgPSB7XG4gICAgYmxhY2s6IDMwLFxuICAgIHJlZDogMzEsXG4gICAgZ3JlZW46IDMyLFxuICAgIHllbGxvdzogMzMsXG4gICAgYmx1ZTogMzQsXG4gICAgbWFnZW50YTogMzUsXG4gICAgY3lhbjogMzYsXG4gICAgd2hpdGU6IDM3LFxuICAgIGJsYWNrQnJpZ2h0OiA5MCxcbiAgICByZWRCcmlnaHQ6IDkxLFxuICAgIGdyZWVuQnJpZ2h0OiA5MixcbiAgICB5ZWxsb3dCcmlnaHQ6IDkzLFxuICAgIGJsdWVCcmlnaHQ6IDk0LFxuICAgIG1hZ2VudGFCcmlnaHQ6IDk1LFxuICAgIGN5YW5CcmlnaHQ6IDk2LFxuICAgIHdoaXRlQnJpZ2h0OiA5N1xufTtcbnZhciBiZ0NvbG9ycyA9IHtcbiAgICBiZ0JsYWNrOiA0MCxcbiAgICBiZ1JlZDogNDEsXG4gICAgYmdHcmVlbjogNDIsXG4gICAgYmdZZWxsb3c6IDQzLFxuICAgIGJnQmx1ZTogNDQsXG4gICAgYmdNYWdlbnRhOiA0NSxcbiAgICBiZ0N5YW46IDQ2LFxuICAgIGJnV2hpdGU6IDQ3LFxuICAgIGJnQmxhY2tCcmlnaHQ6IDEwMCxcbiAgICBiZ1JlZEJyaWdodDogMTAxLFxuICAgIGJnR3JlZW5CcmlnaHQ6IDEwMixcbiAgICBiZ1llbGxvd0JyaWdodDogMTAzLFxuICAgIGJnQmx1ZUJyaWdodDogMTA0LFxuICAgIGJnTWFnZW50YUJyaWdodDogMTA1LFxuICAgIGJnQ3lhbkJyaWdodDogMTA2LFxuICAgIGJnV2hpdGVCcmlnaHQ6IDEwN1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUdlbmVyaWNXcmFwcGVyKGNvbG9yLCBlbmRpbmcsIGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFwiXFx1MDAxQltcIiArIGNvbG9yICsgXCJtXCIgKyAoaW5uZXIgPyBpbm5lcihzdHIpIDogc3RyKSArIFwiXFx1MDAxQltcIiArIGVuZGluZyArIFwibVwiOyB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29sb3JXcmFwcGVyKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUdlbmVyaWNXcmFwcGVyKGNvbG9yc1tjb2xvcl0sIDM5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJnV3JhcHBlcihjb2xvciwgZmdXcmFwcGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUdlbmVyaWNXcmFwcGVyKGJnQ29sb3JzW2NvbG9yXSwgNDksIGZnV3JhcHBlcik7XG59XG52YXIgX19leHBvcnRfTG9nTGV2ZWxUb0NvbG9yID0gKF9iID0ge30sXG4gICAgX2JbTG9nTGV2ZWxfMS5kZWZhdWx0LkNSSVRJQ0FMXSA9IGNyZWF0ZUNvbG9yV3JhcHBlcigncmVkJyksXG4gICAgX2JbTG9nTGV2ZWxfMS5kZWZhdWx0LkVSUk9SXSA9IGNyZWF0ZUNvbG9yV3JhcHBlcigncmVkQnJpZ2h0JyksXG4gICAgX2JbTG9nTGV2ZWxfMS5kZWZhdWx0LldBUk5JTkddID0gY3JlYXRlQ29sb3JXcmFwcGVyKCd5ZWxsb3cnKSxcbiAgICBfYltMb2dMZXZlbF8xLmRlZmF1bHQuSU5GT10gPSBjcmVhdGVDb2xvcldyYXBwZXIoJ2JsdWUnKSxcbiAgICBfYltMb2dMZXZlbF8xLmRlZmF1bHQuREVCVUddID0gY3JlYXRlQ29sb3JXcmFwcGVyKCdtYWdlbnRhJyksXG4gICAgX2JbTG9nTGV2ZWxfMS5kZWZhdWx0LlRSQUNFXSA9IGNyZWF0ZUdlbmVyaWNXcmFwcGVyKDAsIDApLFxuICAgIF9iKTtcbmV4cG9ydHMuTG9nTGV2ZWxUb0NvbG9yID0gX19leHBvcnRfTG9nTGV2ZWxUb0NvbG9yO1xudmFyIF9fZXhwb3J0X0xvZ0xldmVsVG9CYWNrZ3JvdW5kQ29sb3IgPSAoX2MgPSB7fSxcbiAgICBfY1tMb2dMZXZlbF8xLmRlZmF1bHQuQ1JJVElDQUxdID0gY3JlYXRlQmdXcmFwcGVyKCdiZ1JlZCcsIGNyZWF0ZUNvbG9yV3JhcHBlcignd2hpdGUnKSksXG4gICAgX2NbTG9nTGV2ZWxfMS5kZWZhdWx0LkVSUk9SXSA9IGNyZWF0ZUJnV3JhcHBlcignYmdSZWRCcmlnaHQnLCBjcmVhdGVDb2xvcldyYXBwZXIoJ3doaXRlJykpLFxuICAgIF9jW0xvZ0xldmVsXzEuZGVmYXVsdC5XQVJOSU5HXSA9IGNyZWF0ZUJnV3JhcHBlcignYmdZZWxsb3cnLCBjcmVhdGVDb2xvcldyYXBwZXIoJ2JsYWNrJykpLFxuICAgIF9jW0xvZ0xldmVsXzEuZGVmYXVsdC5JTkZPXSA9IGNyZWF0ZUJnV3JhcHBlcignYmdCbHVlJywgY3JlYXRlQ29sb3JXcmFwcGVyKCd3aGl0ZScpKSxcbiAgICBfY1tMb2dMZXZlbF8xLmRlZmF1bHQuREVCVUddID0gY3JlYXRlQmdXcmFwcGVyKCdiZ01hZ2VudGEnLCBjcmVhdGVDb2xvcldyYXBwZXIoJ2JsYWNrJykpLFxuICAgIF9jW0xvZ0xldmVsXzEuZGVmYXVsdC5UUkFDRV0gPSBjcmVhdGVHZW5lcmljV3JhcHBlcig3LCAyNyksXG4gICAgX2MpO1xuZXhwb3J0cy5Mb2dMZXZlbFRvQmFja2dyb3VuZENvbG9yID0gX19leHBvcnRfTG9nTGV2ZWxUb0JhY2tncm91bmRDb2xvcjtcbnZhciBOb2RlTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE5vZGVMb2dnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9kZUxvZ2dlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOb2RlTG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGxldmVsID4gdGhpcy5fbWluTGV2ZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nRm4gPSBMb2dMZXZlbF8xLkxvZ0xldmVsVG9Db25zb2xlRnVuY3Rpb25bbGV2ZWxdO1xuICAgICAgICB2YXIgYnVpbHRNZXNzYWdlID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICBidWlsdE1lc3NhZ2UgKz0gXCJbXCIgKyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyBcIl0gXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Vtb2ppKSB7XG4gICAgICAgICAgICB2YXIgZW1vamkgPSBleHBvcnRzLkxvZ0xldmVsVG9FbW9qaVtsZXZlbF07XG4gICAgICAgICAgICBidWlsdE1lc3NhZ2UgKz0gZW1vamkgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29sb3JzKSB7XG4gICAgICAgICAgICBidWlsdE1lc3NhZ2UgKz0gZXhwb3J0cy5Mb2dMZXZlbFRvQmFja2dyb3VuZENvbG9yW2xldmVsXSh0aGlzLl9uYW1lKSArIFwiIFwiICsgZXhwb3J0cy5Mb2dMZXZlbFRvQmFja2dyb3VuZENvbG9yW2xldmVsXShMb2dMZXZlbF8xLmRlZmF1bHRbbGV2ZWxdKSArIFwiIFwiICsgZXhwb3J0cy5Mb2dMZXZlbFRvQ29sb3JbbGV2ZWxdKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVpbHRNZXNzYWdlICs9IFwiW1wiICsgdGhpcy5fbmFtZSArIFwiOlwiICsgTG9nTGV2ZWxfMS5kZWZhdWx0W2xldmVsXS50b0xvd2VyQ2FzZSgpICsgXCJdIFwiICsgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBsb2dGbihidWlsdE1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vZGVMb2dnZXI7XG59KEJhc2VMb2dnZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBOb2RlTG9nZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTm9kZUxvZ2dlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9nTGV2ZWxUb0Vtb2ppID0gX19leHBvcnRfTG9nTGV2ZWxUb0Vtb2ppO1xuZXhwb3J0cy5Mb2dMZXZlbFRvQ29sb3IgPSBfX2V4cG9ydF9Mb2dMZXZlbFRvQ29sb3I7XG5leHBvcnRzLkxvZ0xldmVsVG9CYWNrZ3JvdW5kQ29sb3IgPSBfX2V4cG9ydF9Mb2dMZXZlbFRvQmFja2dyb3VuZENvbG9yO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm9kZUxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vZGVMb2dnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBMb2dMZXZlbF8xID0gcmVxdWlyZShcIi4vTG9nTGV2ZWxcIik7XG52YXIgQmFzZUxvZ2dlcl8xID0gcmVxdWlyZShcIi4vQmFzZUxvZ2dlclwiKTtcbnZhciBCcm93c2VyTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEJyb3dzZXJMb2dnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnJvd3NlckxvZ2dlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCcm93c2VyTG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGxldmVsID4gdGhpcy5fbWluTGV2ZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nRm4gPSBMb2dMZXZlbF8xLkxvZ0xldmVsVG9Db25zb2xlRnVuY3Rpb25bbGV2ZWxdO1xuICAgICAgICB2YXIgZm9ybWF0dGVkTWVzc2FnZSA9IFwiW1wiICsgdGhpcy5fbmFtZSArIFwiXSBcIiArIG1lc3NhZ2U7XG4gICAgICAgIGlmICh0aGlzLl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRNZXNzYWdlID0gXCJbXCIgKyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyBcIl0gXCIgKyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGxvZ0ZuKGZvcm1hdHRlZE1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIEJyb3dzZXJMb2dnZXI7XG59KEJhc2VMb2dnZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCcm93c2VyTG9nZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQnJvd3NlckxvZ2dlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJyb3dzZXJMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2VyTG9nZ2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Jyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmb3JtYXRzOiBmb3JtYXRzLFxuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXJyYXlQcmVmaXhHZW5lcmF0b3JzID0ge1xuICAgIGJyYWNrZXRzOiBmdW5jdGlvbiBicmFja2V0cyhwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgfSxcbiAgICBjb21tYTogJ2NvbW1hJyxcbiAgICBpbmRpY2VzOiBmdW5jdGlvbiBpbmRpY2VzKHByZWZpeCwga2V5KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnWycgKyBrZXkgKyAnXSc7XG4gICAgfSxcbiAgICByZXBlYXQ6IGZ1bmN0aW9uIHJlcGVhdChwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xudmFyIHB1c2hUb0FycmF5ID0gZnVuY3Rpb24gKGFyciwgdmFsdWVPckFycmF5KSB7XG4gICAgcHVzaC5hcHBseShhcnIsIGlzQXJyYXkodmFsdWVPckFycmF5KSA/IHZhbHVlT3JBcnJheSA6IFt2YWx1ZU9yQXJyYXldKTtcbn07XG5cbnZhciB0b0lTTyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG52YXIgZGVmYXVsdEZvcm1hdCA9IGZvcm1hdHNbJ2RlZmF1bHQnXTtcbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhZGRRdWVyeVByZWZpeDogZmFsc2UsXG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBjaGFyc2V0OiAndXRmLTgnLFxuICAgIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZW5jb2RlOiB0cnVlLFxuICAgIGVuY29kZXI6IHV0aWxzLmVuY29kZSxcbiAgICBlbmNvZGVWYWx1ZXNPbmx5OiBmYWxzZSxcbiAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXQsXG4gICAgZm9ybWF0dGVyOiBmb3JtYXRzLmZvcm1hdHRlcnNbZGVmYXVsdEZvcm1hdF0sXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGluZGljZXM6IGZhbHNlLFxuICAgIHNlcmlhbGl6ZURhdGU6IGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdG9JU08uY2FsbChkYXRlKTtcbiAgICB9LFxuICAgIHNraXBOdWxsczogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIGlzTm9uTnVsbGlzaFByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzTm9uTnVsbGlzaFByaW1pdGl2ZSh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcidcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdib29sZWFuJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ3N5bWJvbCdcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdiaWdpbnQnO1xufTtcblxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShcbiAgICBvYmplY3QsXG4gICAgcHJlZml4LFxuICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgIHNraXBOdWxscyxcbiAgICBlbmNvZGVyLFxuICAgIGZpbHRlcixcbiAgICBzb3J0LFxuICAgIGFsbG93RG90cyxcbiAgICBzZXJpYWxpemVEYXRlLFxuICAgIGZvcm1hdHRlcixcbiAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgIGNoYXJzZXRcbikge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xuICAgIH0gZWxzZSBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgb2JqID0gb2JqLmpvaW4oJywnKTtcbiAgICB9XG5cbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIGlmIChzdHJpY3ROdWxsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVyICYmICFlbmNvZGVWYWx1ZXNPbmx5ID8gZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknKSA6IHByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9ICcnO1xuICAgIH1cblxuICAgIGlmIChpc05vbk51bGxpc2hQcmltaXRpdmUob2JqKSB8fCB1dGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4IDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybWF0dGVyKGtleVZhbHVlKSArICc9JyArIGZvcm1hdHRlcihlbmNvZGVyKG9iaiwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ3ZhbHVlJykpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihwcmVmaXgpICsgJz0nICsgZm9ybWF0dGVyKFN0cmluZyhvYmopKV07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgdmFyIG9iaktleXM7XG4gICAgaWYgKGlzQXJyYXkoZmlsdGVyKSkge1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgb2JqS2V5cyA9IHNvcnQgPyBrZXlzLnNvcnQoc29ydCkgOiBrZXlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAoc2tpcE51bGxzICYmIG9ialtrZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHB1c2hUb0FycmF5KHZhbHVlcywgc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAgICAgIHR5cGVvZiBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnZnVuY3Rpb24nID8gZ2VuZXJhdGVBcnJheVByZWZpeChwcmVmaXgsIGtleSkgOiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgICAgIGVuY29kZXIsXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHksXG4gICAgICAgICAgICAgICAgY2hhcnNldFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdXNoVG9BcnJheSh2YWx1ZXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgICAgICBwcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsga2V5IDogJ1snICsga2V5ICsgJ10nKSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICAgICAgZW5jb2RlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seSxcbiAgICAgICAgICAgICAgICBjaGFyc2V0XG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuXG52YXIgbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZW5jb2RlciAhPT0gbnVsbCAmJiBvcHRzLmVuY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRzLmNoYXJzZXQgfHwgZGVmYXVsdHMuY2hhcnNldDtcbiAgICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjaGFyc2V0IG9wdGlvbiBtdXN0IGJlIGVpdGhlciB1dGYtOCwgaXNvLTg4NTktMSwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdCA9IGZvcm1hdHNbJ2RlZmF1bHQnXTtcbiAgICBpZiAodHlwZW9mIG9wdHMuZm9ybWF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIWhhcy5jYWxsKGZvcm1hdHMuZm9ybWF0dGVycywgb3B0cy5mb3JtYXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGZvcm1hdCBvcHRpb24gcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0ID0gb3B0cy5mb3JtYXQ7XG4gICAgfVxuICAgIHZhciBmb3JtYXR0ZXIgPSBmb3JtYXRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgIHZhciBmaWx0ZXIgPSBkZWZhdWx0cy5maWx0ZXI7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0FycmF5KG9wdHMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRzLmZpbHRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRRdWVyeVByZWZpeDogdHlwZW9mIG9wdHMuYWRkUXVlcnlQcmVmaXggPT09ICdib29sZWFuJyA/IG9wdHMuYWRkUXVlcnlQcmVmaXggOiBkZWZhdWx0cy5hZGRRdWVyeVByZWZpeCxcbiAgICAgICAgYWxsb3dEb3RzOiB0eXBlb2Ygb3B0cy5hbGxvd0RvdHMgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuYWxsb3dEb3RzIDogISFvcHRzLmFsbG93RG90cyxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kZWxpbWl0ZXIgOiBvcHRzLmRlbGltaXRlcixcbiAgICAgICAgZW5jb2RlOiB0eXBlb2Ygb3B0cy5lbmNvZGUgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlIDogZGVmYXVsdHMuZW5jb2RlLFxuICAgICAgICBlbmNvZGVyOiB0eXBlb2Ygb3B0cy5lbmNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0cy5lbmNvZGVyIDogZGVmYXVsdHMuZW5jb2RlcixcbiAgICAgICAgZW5jb2RlVmFsdWVzT25seTogdHlwZW9mIG9wdHMuZW5jb2RlVmFsdWVzT25seSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGVWYWx1ZXNPbmx5IDogZGVmYXVsdHMuZW5jb2RlVmFsdWVzT25seSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIGZvcm1hdHRlcjogZm9ybWF0dGVyLFxuICAgICAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgc2tpcE51bGxzOiB0eXBlb2Ygb3B0cy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdHMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzLFxuICAgICAgICBzb3J0OiB0eXBlb2Ygb3B0cy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0cy5zb3J0IDogbnVsbCxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiB0eXBlb2Ygb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0cykge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpO1xuXG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5hcnJheUZvcm1hdCBpbiBhcnJheVByZWZpeEdlbmVyYXRvcnMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmFycmF5Rm9ybWF0O1xuICAgIH0gZWxzZSBpZiAob3B0cyAmJiAnaW5kaWNlcycgaW4gb3B0cykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdHMuaW5kaWNlcyA/ICdpbmRpY2VzJyA6ICdyZXBlYXQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gJ2luZGljZXMnO1xuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZUFycmF5UHJlZml4ID0gYXJyYXlQcmVmaXhHZW5lcmF0b3JzW2FycmF5Rm9ybWF0XTtcblxuICAgIGlmICghb2JqS2V5cykge1xuICAgICAgICBvYmpLZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgICAgIG9iaktleXMuc29ydChvcHRpb25zLnNvcnQpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAob3B0aW9ucy5za2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hUb0FycmF5KGtleXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgb3B0aW9ucy5za2lwTnVsbHMsXG4gICAgICAgICAgICBvcHRpb25zLmVuY29kZSA/IG9wdGlvbnMuZW5jb2RlciA6IG51bGwsXG4gICAgICAgICAgICBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgICAgIG9wdGlvbnMuc29ydCxcbiAgICAgICAgICAgIG9wdGlvbnMuYWxsb3dEb3RzLFxuICAgICAgICAgICAgb3B0aW9ucy5zZXJpYWxpemVEYXRlLFxuICAgICAgICAgICAgb3B0aW9ucy5mb3JtYXR0ZXIsXG4gICAgICAgICAgICBvcHRpb25zLmVuY29kZVZhbHVlc09ubHksXG4gICAgICAgICAgICBvcHRpb25zLmNoYXJzZXRcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMuYWRkUXVlcnlQcmVmaXggPT09IHRydWUgPyAnPycgOiAnJztcblxuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKSwgdGhlIFwibnVtZXJpYyBlbnRpdHlcIiByZXByZXNlbnRhdGlvbiBvZiBhIGNoZWNrbWFya1xuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXG4gICAgICAgICAgICBwcmVmaXggKz0gJ3V0Zjg9JUUyJTlDJTkzJic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGFsbG93UHJvdG90eXBlczogZmFsc2UsXG4gICAgYXJyYXlMaW1pdDogMjAsXG4gICAgY2hhcnNldDogJ3V0Zi04JyxcbiAgICBjaGFyc2V0U2VudGluZWw6IGZhbHNlLFxuICAgIGNvbW1hOiBmYWxzZSxcbiAgICBkZWNvZGVyOiB1dGlscy5kZWNvZGUsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgaWdub3JlUXVlcnlQcmVmaXg6IGZhbHNlLFxuICAgIGludGVycHJldE51bWVyaWNFbnRpdGllczogZmFsc2UsXG4gICAgcGFyYW1ldGVyTGltaXQ6IDEwMDAsXG4gICAgcGFyc2VBcnJheXM6IHRydWUsXG4gICAgcGxhaW5PYmplY3RzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiMoXFxkKyk7L2csIGZ1bmN0aW9uICgkMCwgbnVtYmVyU3RyKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG51bWJlclN0ciwgMTApKTtcbiAgICB9KTtcbn07XG5cbnZhciBwYXJzZUFycmF5VmFsdWUgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmNvbW1hICYmIHZhbC5pbmRleE9mKCcsJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdmFsLnNwbGl0KCcsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbnZhciBtYXliZU1hcCA9IGZ1bmN0aW9uIG1heWJlTWFwKHZhbCwgZm4pIHtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbih2YWwpO1xufTtcblxuLy8gVGhpcyBpcyB3aGF0IGJyb3dzZXJzIHdpbGwgc3VibWl0IHdoZW4gdGhlIOKckyBjaGFyYWN0ZXIgb2NjdXJzIGluIGFuXG4vLyBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgYm9keSBhbmQgdGhlIGVuY29kaW5nIG9mIHRoZSBwYWdlIGNvbnRhaW5pbmdcbi8vIHRoZSBmb3JtIGlzIGlzby04ODU5LTEsIG9yIHdoZW4gdGhlIHN1Ym1pdHRlZCBmb3JtIGhhcyBhbiBhY2NlcHQtY2hhcnNldFxuLy8gYXR0cmlidXRlIG9mIGlzby04ODU5LTEuIFByZXN1bWFibHkgYWxzbyB3aXRoIG90aGVyIGNoYXJzZXRzIHRoYXQgZG8gbm90IGNvbnRhaW5cbi8vIHRoZSDinJMgY2hhcmFjdGVyLCBzdWNoIGFzIHVzLWFzY2lpLlxudmFyIGlzb1NlbnRpbmVsID0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0InOyAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JylcblxuLy8gVGhlc2UgYXJlIHRoZSBwZXJjZW50LWVuY29kZWQgdXRmLTggb2N0ZXRzIHJlcHJlc2VudGluZyBhIGNoZWNrbWFyaywgaW5kaWNhdGluZyB0aGF0IHRoZSByZXF1ZXN0IGFjdHVhbGx5IGlzIHV0Zi04IGVuY29kZWQuXG52YXIgY2hhcnNldFNlbnRpbmVsID0gJ3V0Zjg9JUUyJTlDJTkzJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxuXG52YXIgcGFyc2VWYWx1ZXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nVmFsdWVzKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgY2xlYW5TdHIgPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID8gc3RyLnJlcGxhY2UoL15cXD8vLCAnJykgOiBzdHI7XG4gICAgdmFyIGxpbWl0ID0gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBvcHRpb25zLnBhcmFtZXRlckxpbWl0O1xuICAgIHZhciBwYXJ0cyA9IGNsZWFuU3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBsaW1pdCk7XG4gICAgdmFyIHNraXBJbmRleCA9IC0xOyAvLyBLZWVwIHRyYWNrIG9mIHdoZXJlIHRoZSB1dGY4IHNlbnRpbmVsIHdhcyBmb3VuZFxuICAgIHZhciBpO1xuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQ7XG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzW2ldLmluZGV4T2YoJ3V0Zjg9JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV0gPT09IGNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ3V0Zi04JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldID09PSBpc29TZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ2lzby04ODU5LTEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGkgPSBwYXJ0cy5sZW5ndGg7IC8vIFRoZSBlc2xpbnQgc2V0dGluZ3MgZG8gbm90IGFsbG93IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpID09PSBza2lwSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XG4gICAgICAgIHZhciBwb3MgPSBicmFja2V0RXF1YWxzUG9zID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogYnJhY2tldEVxdWFsc1BvcyArIDE7XG5cbiAgICAgICAgdmFyIGtleSwgdmFsO1xuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQsIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID8gbnVsbCA6ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UoMCwgcG9zKSwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xuICAgICAgICAgICAgdmFsID0gbWF5YmVNYXAoXG4gICAgICAgICAgICAgICAgcGFyc2VBcnJheVZhbHVlKHBhcnQuc2xpY2UocG9zICsgMSksIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbmNvZGVkVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRlY29kZXIoZW5jb2RlZFZhbCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ3ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgJiYgb3B0aW9ucy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgJiYgY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICB2YWwgPSBpbnRlcnByZXROdW1lcmljRW50aXRpZXModmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0LmluZGV4T2YoJ1tdPScpID4gLTEpIHtcbiAgICAgICAgICAgIHZhbCA9IGlzQXJyYXkodmFsKSA/IFt2YWxdIDogdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB1dGlscy5jb21iaW5lKG9ialtrZXldLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKGNoYWluLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIHZhciBsZWFmID0gdmFsdWVzUGFyc2VkID8gdmFsIDogcGFyc2VBcnJheVZhbHVlKHZhbCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBpID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJyAmJiBvcHRpb25zLnBhcnNlQXJyYXlzKSB7XG4gICAgICAgICAgICBvYmogPSBbXS5jb25jYXQobGVhZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICAgIHZhciBjbGVhblJvb3QgPSByb290LmNoYXJBdCgwKSA9PT0gJ1snICYmIHJvb3QuY2hhckF0KHJvb3QubGVuZ3RoIC0gMSkgPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgLTEpIDogcm9vdDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBhcnNlQXJyYXlzICYmIGNsZWFuUm9vdCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBvYmogPSB7IDA6IGxlYWYgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxuICAgICAgICAgICAgICAgICYmIHJvb3QgIT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIFN0cmluZyhpbmRleCkgPT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIGluZGV4ID49IDBcbiAgICAgICAgICAgICAgICAmJiAob3B0aW9ucy5wYXJzZUFycmF5cyAmJiBpbmRleCA8PSBvcHRpb25zLmFycmF5TGltaXQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICAgICAgICBvYmpbaW5kZXhdID0gbGVhZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2NsZWFuUm9vdF0gPSBsZWFmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZiA9IG9iajsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIH1cblxuICAgIHJldHVybiBsZWFmO1xufTtcblxudmFyIHBhcnNlS2V5cyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdLZXlzKGdpdmVuS2V5LCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIGlmICghZ2l2ZW5LZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRyYW5zZm9ybSBkb3Qgbm90YXRpb24gdG8gYnJhY2tldCBub3RhdGlvblxuICAgIHZhciBrZXkgPSBvcHRpb25zLmFsbG93RG90cyA/IGdpdmVuS2V5LnJlcGxhY2UoL1xcLihbXi5bXSspL2csICdbJDFdJykgOiBnaXZlbktleTtcblxuICAgIC8vIFRoZSByZWdleCBjaHVua3NcblxuICAgIHZhciBicmFja2V0cyA9IC8oXFxbW15bXFxdXSpdKS87XG4gICAgdmFyIGNoaWxkID0gLyhcXFtbXltcXF1dKl0pL2c7XG5cbiAgICAvLyBHZXQgdGhlIHBhcmVudFxuXG4gICAgdmFyIHNlZ21lbnQgPSBvcHRpb25zLmRlcHRoID4gMCAmJiBicmFja2V0cy5leGVjKGtleSk7XG4gICAgdmFyIHBhcmVudCA9IHNlZ21lbnQgPyBrZXkuc2xpY2UoMCwgc2VnbWVudC5pbmRleCkgOiBrZXk7XG5cbiAgICAvLyBTdGFzaCB0aGUgcGFyZW50IGlmIGl0IGV4aXN0c1xuXG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBwbGFpbiBvYmplY3RzLCBvcHRpb25hbGx5IHByZWZpeCBrZXlzIHRoYXQgd291bGQgb3ZlcndyaXRlIG9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllc1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLnB1c2gocGFyZW50KTtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYXBwZW5kaW5nIHRvIHRoZSBhcnJheSB1bnRpbCB3ZSBoaXQgZGVwdGhcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAob3B0aW9ucy5kZXB0aCA+IDAgJiYgKHNlZ21lbnQgPSBjaGlsZC5leGVjKGtleSkpICE9PSBudWxsICYmIGkgPCBvcHRpb25zLmRlcHRoKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzZWdtZW50WzFdLnNsaWNlKDEsIC0xKSkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlJ3MgYSByZW1haW5kZXIsIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCk7XG59O1xuXG52YXIgbm9ybWFsaXplUGFyc2VPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplUGFyc2VPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmRlY29kZXIgIT09IG51bGwgJiYgb3B0cy5kZWNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgdmFyIGNoYXJzZXQgPSB0eXBlb2Ygb3B0cy5jaGFyc2V0ID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmNoYXJzZXQgOiBvcHRzLmNoYXJzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd0RvdHM6IHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzLFxuICAgICAgICBhbGxvd1Byb3RvdHlwZXM6IHR5cGVvZiBvcHRzLmFsbG93UHJvdG90eXBlcyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hbGxvd1Byb3RvdHlwZXMgOiBkZWZhdWx0cy5hbGxvd1Byb3RvdHlwZXMsXG4gICAgICAgIGFycmF5TGltaXQ6IHR5cGVvZiBvcHRzLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0cy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdCxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBjb21tYTogdHlwZW9mIG9wdHMuY29tbWEgPT09ICdib29sZWFuJyA/IG9wdHMuY29tbWEgOiBkZWZhdWx0cy5jb21tYSxcbiAgICAgICAgZGVjb2RlcjogdHlwZW9mIG9wdHMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXIsXG4gICAgICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRzLmRlbGltaXRlcikgPyBvcHRzLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcixcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uLCBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgZGVwdGg6ICh0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ251bWJlcicgfHwgb3B0cy5kZXB0aCA9PT0gZmFsc2UpID8gK29wdHMuZGVwdGggOiBkZWZhdWx0cy5kZXB0aCxcbiAgICAgICAgaWdub3JlUXVlcnlQcmVmaXg6IG9wdHMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWUsXG4gICAgICAgIGludGVycHJldE51bWVyaWNFbnRpdGllczogdHlwZW9mIG9wdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID09PSAnYm9vbGVhbicgPyBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA6IGRlZmF1bHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyxcbiAgICAgICAgcGFyYW1ldGVyTGltaXQ6IHR5cGVvZiBvcHRzLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdCxcbiAgICAgICAgcGFyc2VBcnJheXM6IG9wdHMucGFyc2VBcnJheXMgIT09IGZhbHNlLFxuICAgICAgICBwbGFpbk9iamVjdHM6IHR5cGVvZiBvcHRzLnBsYWluT2JqZWN0cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5wbGFpbk9iamVjdHMgOiBkZWZhdWx0cy5wbGFpbk9iamVjdHMsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKTtcblxuICAgIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBwYXJzZUtleXMoa2V5LCB0ZW1wT2JqW2tleV0sIG9wdGlvbnMsIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgb2JqID0gdXRpbHMubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5jb21wYWN0KG9iaik7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjYWNoZV9kZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzXCIpO1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4uLy4uL1Rvb2xraXQvVXNlclRvb2xzXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uLy4uL1R3aXRjaENsaWVudFwiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vQmFzZUFQSVwiKTtcbnZhciBDaGF0QmFkZ2VMaXN0XzEgPSByZXF1aXJlKFwiLi9DaGF0QmFkZ2VMaXN0XCIpO1xuLyoqXG4gKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggYmFkZ2VzLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmJhZGdlc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IGNoZWVybW90ZXMgPSBhd2FpdCBjbGllbnQuYmFkZ2VzLmdldEdsb2JhbEJhZGdlcygpO1xuICogYGBgXG4gKi9cbnZhciBCYWRnZXNBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmFkZ2VzQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhZGdlc0FQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGdsb2JhbGx5IGFwcGxpY2FibGUgY2hhdCBiYWRnZXMuXG4gICAgICovXG4gICAgQmFkZ2VzQVBJLnByb3RvdHlwZS5nZXRHbG9iYWxCYWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vYmFkZ2VzLnR3aXRjaC50di92MS9iYWRnZXMvZ2xvYmFsL2Rpc3BsYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkN1c3RvbVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBDaGF0QmFkZ2VMaXN0XzEuZGVmYXVsdChkYXRhLmJhZGdlX3NldHMsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgYXBwbGljYWJsZSBjaGF0IGJhZGdlcyBmb3IgYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gcmV0cmlldmUgdGhlIGNoYXQgYmFkZ2VzIGZvci5cbiAgICAgKiBAcGFyYW0gaW5jbHVkZUdsb2JhbCBXaGV0aGVyIHRvIGluY2x1ZGUgZ2xvYmFsIGJhZGdlcyBpbiB0aGUgcmVzdWx0IGxpc3QuXG4gICAgICovXG4gICAgQmFkZ2VzQVBJLnByb3RvdHlwZS5nZXRDaGFubmVsQmFkZ2VzID0gZnVuY3Rpb24gKGNoYW5uZWwsIGluY2x1ZGVHbG9iYWwpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVHbG9iYWwgPT09IHZvaWQgMCkgeyBpbmNsdWRlR2xvYmFsID0gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBjaGFubmVsQmFkZ2VzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiaHR0cHM6Ly9iYWRnZXMudHdpdGNoLnR2L3YxL2JhZGdlcy9jaGFubmVscy9cIiArIFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbCkgKyBcIi9kaXNwbGF5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuQ3VzdG9tXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQmFkZ2VzID0gbmV3IENoYXRCYWRnZUxpc3RfMS5kZWZhdWx0KGRhdGEuYmFkZ2Vfc2V0cywgdGhpcy5fY2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5jbHVkZUdsb2JhbCkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEdsb2JhbEJhZGdlcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSkuX21lcmdlKGNoYW5uZWxCYWRnZXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgY2hhbm5lbEJhZGdlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIEJhZGdlc0FQSS5wcm90b3R5cGUsIFwiZ2V0R2xvYmFsQmFkZ2VzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBCYWRnZXNBUEkucHJvdG90eXBlLCBcImdldENoYW5uZWxCYWRnZXNcIiwgbnVsbCk7XG4gICAgQmFkZ2VzQVBJID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIEJhZGdlc0FQSSk7XG4gICAgcmV0dXJuIEJhZGdlc0FQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhZGdlc0FQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEJhZGdlc0FQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhZGdlc0FQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5mdW5jdGlvbiBFbnVtZXJhYmxlKGVudW1lcmFibGUpIHtcbiAgICBpZiAoZW51bWVyYWJsZSA9PT0gdm9pZCAwKSB7IGVudW1lcmFibGUgPSB0cnVlOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICAvLyBmaXJzdCBwcm9wZXJ0eSBkZWZpbmVkIGluIHByb3RvdHlwZSwgdGhhdCdzIHdoeSB3ZSB1c2UgZ2V0dGVycy9zZXR0ZXJzXG4gICAgICAgIC8vIChvdGhlcndpc2UgYXNzaWdubWVudCBpbiBvYmplY3Qgd2lsbCBvdmVycmlkZSBwcm9wZXJ0eSBpbiBwcm90b3R5cGUpXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIGFuZCBjYW4gc2V0IHByb3BlcnR5IGRpcmVjdGx5IHRvIGl0XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZW51bWVyYWJsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGVcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuRW51bWVyYWJsZSA9IEVudW1lcmFibGU7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIEVudW1lcmFibGUoZmFsc2UpIGluc3RlYWQgKi9cbmZ1bmN0aW9uIE5vbkVudW1lcmFibGUodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gRW51bWVyYWJsZShmYWxzZSkodGFyZ2V0LCBrZXkpO1xufVxuZXhwb3J0cy5Ob25FbnVtZXJhYmxlID0gTm9uRW51bWVyYWJsZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW51bWVyYWJsZSA9IEVudW1lcmFibGU7XG5leHBvcnRzLk5vbkVudW1lcmFibGUgPSBOb25FbnVtZXJhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW51bWVyYWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuZnVuY3Rpb24gZmxhdHRlbihhcnIpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IFtdKS5jb25jYXQuYXBwbHkoX2EsIHRzbGliXzEuX19zcHJlYWQoYXJyKSk7XG59XG5leHBvcnRzLmZsYXR0ZW4gPSBmbGF0dGVuO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZsYXR0ZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmZ1bmN0aW9uIHJlc29sdmVDb25maWdWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsdWUoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsdWVdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVzb2x2ZUNvbmZpZ1ZhbHVlID0gcmVzb2x2ZUNvbmZpZ1ZhbHVlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlQ29uZmlnVmFsdWUgPSByZXNvbHZlQ29uZmlnVmFsdWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlQ29uZmlnVmFsdWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZnVuY3Rpb24gZGVwcmVjYXRlQ2xhc3MoQmFzZSwgbXNnKSB7XG4gICAgdmFyIGRlcHJlY2F0ZU5vdGljZVNob3duID0gZmFsc2U7XG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWRlcHJlY2F0ZU5vdGljZVNob3duKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbZGVwcmVjYXRlZF0gXCIgKyBtc2cpO1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZU5vdGljZVNob3duID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIHRzbGliXzEuX19zcHJlYWQoYXJncykpIHx8IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgfShCYXNlKSk7XG59XG5leHBvcnRzLmRlcHJlY2F0ZUNsYXNzID0gZGVwcmVjYXRlQ2xhc3M7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlcHJlY2F0ZUNsYXNzID0gZGVwcmVjYXRlQ2xhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXByZWNhdGVDbGFzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtYXRjaGVkID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuICh7XG4gICAgb3RoZXJ3aXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9LFxuICAgIG9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRjaGVkKHgpOyB9XG59KTsgfTtcbnZhciBtYXRjaCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoe1xuICAgIG9uOiBmdW5jdGlvbiAocHJlZGljYXRlLCBmbikgeyByZXR1cm4gKHByZWRpY2F0ZSh4KSA/IG1hdGNoZWQoZm4oeCkpIDogbWF0Y2goeCkpOyB9LFxuICAgIG90aGVyd2lzZTogZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbih4KTsgfVxufSk7IH07XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG52YXIgX19leHBvcnRfZXEgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gZnVuY3Rpb24gKHkpIHsgcmV0dXJuIHggPT09IHk7IH07IH07XG5leHBvcnRzLmVxID0gX19leHBvcnRfZXE7XG5tYXRjaC5lcSA9IGV4cG9ydHMuZXE7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG5leHBvcnRzLmVxID0gX19leHBvcnRfZXE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGFycmF5VG9PYmplY3RfMSA9IHJlcXVpcmUoXCIuL2FycmF5VG9PYmplY3RcIik7XG5mdW5jdGlvbiBlbnRyaWVzVG9PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIGFycmF5VG9PYmplY3RfMS5hcnJheVRvT2JqZWN0KG9iaiwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIF9jID0gdHNsaWJfMS5fX3JlYWQoX2EsIDIpLCBrZXkgPSBfY1swXSwgdmFsID0gX2NbMV07XG4gICAgICAgIHJldHVybiAoX2IgPSB7fSwgX2Jba2V5XSA9IHZhbCwgX2IpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5lbnRyaWVzVG9PYmplY3QgPSBlbnRyaWVzVG9PYmplY3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVudHJpZXNUb09iamVjdCA9IGVudHJpZXNUb09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudHJpZXNUb09iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuZnVuY3Rpb24gZm9yRWFjaE9iamVjdEVudHJ5KG9iaiwgZm4pIHtcbiAgICBPYmplY3QuZW50cmllcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKF9hLCAyKSwga2V5ID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICAgIHJldHVybiBmbih2YWx1ZSwga2V5KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZm9yRWFjaE9iamVjdEVudHJ5ID0gZm9yRWFjaE9iamVjdEVudHJ5O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JFYWNoT2JqZWN0RW50cnkgPSBmb3JFYWNoT2JqZWN0RW50cnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JFYWNoT2JqZWN0RW50cnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXJyYXlUb09iamVjdF8xID0gcmVxdWlyZShcIi4vYXJyYXlUb09iamVjdFwiKTtcbmZ1bmN0aW9uIGluZGV4QnkoYXJyLCBrZXlGbikge1xuICAgIGlmICh0eXBlb2Yga2V5Rm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGtleV8xID0ga2V5Rm47XG4gICAgICAgIGtleUZuID0gKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWVba2V5XzFdLnRvU3RyaW5nKCk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlUb09iamVjdF8xLmFycmF5VG9PYmplY3QoYXJyLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHt9LCBfYVtrZXlGbih2YWwpXSA9IHZhbCwgX2EpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5pbmRleEJ5ID0gaW5kZXhCeTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5kZXhCeSA9IGluZGV4Qnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleEJ5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5mdW5jdGlvbiBtYXBPYmplY3Qob2JqLCBmbikge1xuICAgIHZhciBtYXBwZWQgPSBPYmplY3QuZW50cmllcyhvYmopLm1hcChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zXG4gICAgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIF9jID0gdHNsaWJfMS5fX3JlYWQoX2EsIDIpLCBrZXkgPSBfY1swXSwgdmFsdWUgPSBfY1sxXTtcbiAgICAgICAgcmV0dXJuIChfYiA9IHt9LCBfYltrZXldID0gZm4odmFsdWUsIGtleSksIF9iKTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIHRzbGliXzEuX19zcHJlYWQoW3t9XSwgbWFwcGVkKSk7XG59XG5leHBvcnRzLm1hcE9iamVjdCA9IG1hcE9iamVjdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFwT2JqZWN0ID0gbWFwT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBpY2tfMSA9IHJlcXVpcmUoXCIuL3BpY2tcIik7XG5mdW5jdGlvbiBvbWl0KG9iaiwga2V5cykge1xuICAgIHJldHVybiBwaWNrXzEucGljayhvYmosIE9iamVjdC5rZXlzKG9iaikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFrZXlzLmluY2x1ZGVzKGtleSk7IH0pKTtcbn1cbmV4cG9ydHMub21pdCA9IG9taXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9taXQgPSBvbWl0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b21pdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuZnVuY3Rpb24gZGVsYXkobXMpIHtcbiAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpOyB9KV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWxheSA9IGRlbGF5O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWxheSA9IGRlbGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBwYWRMZWZ0KHN0ciwgbGVuZ3RoLCBwYWRkaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0ciA9IHN0ci50b1N0cmluZygpO1xuICAgIH1cbiAgICBsZW5ndGggPSBsZW5ndGggLSBzdHIubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPD0gMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBpZiAocGFkZGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhZGRpbmcgPSAnICc7XG4gICAgfVxuICAgIHZhciBwYWRkaW5nU3RyID0gJyc7XG4gICAgZG8ge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgICAgIGlmICgobGVuZ3RoICYgMSkgPT09IDEpIHtcbiAgICAgICAgICAgIHBhZGRpbmdTdHIgKz0gcGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPj49IDE7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHBhZGRpbmcgKz0gcGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbiAgICB9IHdoaWxlIChsZW5ndGgpO1xuICAgIHJldHVybiBwYWRkaW5nU3RyICsgc3RyO1xufVxuZXhwb3J0cy5wYWRMZWZ0ID0gcGFkTGVmdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFkTGVmdCA9IHBhZExlZnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWRMZWZ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5mdW5jdGlvbiBzcGxpdFdpdGhMaW1pdChzdHIsIGRlbGltLCBjb3VudCkge1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdChkZWxpbSk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA8PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICAgIHJldHVybiB0c2xpYl8xLl9fc3ByZWFkKHBhcnRzLnNsaWNlKDAsIGNvdW50IC0gMSksIFtwYXJ0cy5zbGljZShjb3VudCAtIDEpLmpvaW4oZGVsaW0pXSk7XG59XG5leHBvcnRzLnNwbGl0V2l0aExpbWl0ID0gc3BsaXRXaXRoTGltaXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNwbGl0V2l0aExpbWl0ID0gc3BsaXRXaXRoTGltaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGxpdFdpdGhMaW1pdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuZnVuY3Rpb24gdXRmOExlbmd0aChzdHIpIHtcbiAgICByZXR1cm4gdHNsaWJfMS5fX3NwcmVhZChzdHIpLmxlbmd0aDtcbn1cbmV4cG9ydHMudXRmOExlbmd0aCA9IHV0ZjhMZW5ndGg7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV0ZjhMZW5ndGggPSB1dGY4TGVuZ3RoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOExlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuZnVuY3Rpb24gdXRmOFN1YnN0cmluZyhzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gdHNsaWJfMS5fX3NwcmVhZChzdHIpLnNsaWNlKHN0YXJ0LCBlbmQpLmpvaW4oJycpO1xufVxuZXhwb3J0cy51dGY4U3Vic3RyaW5nID0gdXRmOFN1YnN0cmluZztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXRmOFN1YnN0cmluZyA9IHV0ZjhTdWJzdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4U3Vic3RyaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vQmFzZUFQSVwiKTtcbnZhciBIZWxpeEJpdHNBUElfMSA9IHJlcXVpcmUoXCIuL0JpdHMvSGVsaXhCaXRzQVBJXCIpO1xudmFyIEhlbGl4Q2xpcEFQSV8xID0gcmVxdWlyZShcIi4vQ2xpcC9IZWxpeENsaXBBUElcIik7XG52YXIgSGVsaXhFeHRlbnNpb25zQVBJXzEgPSByZXF1aXJlKFwiLi9FeHRlbnNpb25zL0hlbGl4RXh0ZW5zaW9uc0FQSVwiKTtcbnZhciBIZWxpeEdhbWVBUElfMSA9IHJlcXVpcmUoXCIuL0dhbWUvSGVsaXhHYW1lQVBJXCIpO1xudmFyIEhlbGl4TW9kZXJhdGlvbkFQSV8xID0gcmVxdWlyZShcIi4vTW9kZXJhdGlvbi9IZWxpeE1vZGVyYXRpb25BUElcIik7XG52YXIgSGVsaXhTdHJlYW1BUElfMSA9IHJlcXVpcmUoXCIuL1N0cmVhbS9IZWxpeFN0cmVhbUFQSVwiKTtcbnZhciBIZWxpeFN1YnNjcmlwdGlvbkFQSV8xID0gcmVxdWlyZShcIi4vU3Vic2NyaXB0aW9ucy9IZWxpeFN1YnNjcmlwdGlvbkFQSVwiKTtcbnZhciBIZWxpeFVzZXJBUElfMSA9IHJlcXVpcmUoXCIuL1VzZXIvSGVsaXhVc2VyQVBJXCIpO1xudmFyIEhlbGl4VmlkZW9BUElfMSA9IHJlcXVpcmUoXCIuL1ZpZGVvL0hlbGl4VmlkZW9BUElcIik7XG52YXIgSGVsaXhXZWJIb29rc0FQSV8xID0gcmVxdWlyZShcIi4vV2ViSG9va3MvSGVsaXhXZWJIb29rc0FQSVwiKTtcbi8qKlxuICogR3JvdXBzIGFsbCBBUEkgY2FsbHMgYXZhaWxhYmxlIGluIEhlbGl4IGEuay5hLiB0aGUgXCJOZXcgVHdpdGNoIEFQSVwiLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyB7QFR3aXRjaENsaWVudCNoZWxpeH0uXG4gKi9cbnZhciBIZWxpeEFQSUdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4QVBJR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhBUElHcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwiYml0c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSGVsaXggYml0cyBBUEkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxpeEJpdHNBUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJjbGlwc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSGVsaXggY2xpcHMgQVBJIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVsaXhDbGlwQVBJXzEuZGVmYXVsdCh0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwiZXh0ZW5zaW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSGVsaXggZXh0ZW5zaW9ucyBBUEkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxpeEV4dGVuc2lvbnNBUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJnYW1lc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSGVsaXggZ2FtZSBBUEkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxpeEdhbWVBUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJtb2RlcmF0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIZWxpeCBtb2RlcmF0aW9uIEFQSSBtZXRob2RzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlbGl4TW9kZXJhdGlvbkFQSV8xLmRlZmF1bHQodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcInN0cmVhbXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhlbGl4IHN0cmVhbSBBUEkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFN0cmVhbUFQSV8xLmRlZmF1bHQodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcInN1YnNjcmlwdGlvbnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhlbGl4IHN1YnNjcmlwdGlvbiBBUEkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFN1YnNjcmlwdGlvbkFQSV8xLmRlZmF1bHQodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcInVzZXJzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIZWxpeCB1c2VyIEFQSSBtZXRob2RzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlbGl4VXNlckFQSV8xLmRlZmF1bHQodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcIndlYkhvb2tzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIZWxpeCBXZWJIb29rIEFQSSBtZXRob2RzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlbGl4V2ViSG9va3NBUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJ2aWRlb3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhlbGl4IHZpZGVvIEFQSSBtZXRob2RzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlbGl4VmlkZW9BUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcImJpdHNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwiY2xpcHNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwiZXh0ZW5zaW9uc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJnYW1lc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJtb2RlcmF0aW9uXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEhlbGl4QVBJR3JvdXAucHJvdG90eXBlLCBcInN0cmVhbXNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgSGVsaXhBUElHcm91cC5wcm90b3R5cGUsIFwic3Vic2NyaXB0aW9uc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJ1c2Vyc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJ3ZWJIb29rc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBIZWxpeEFQSUdyb3VwLnByb3RvdHlwZSwgXCJ2aWRlb3NcIiwgbnVsbCk7XG4gICAgSGVsaXhBUElHcm91cCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBIZWxpeEFQSUdyb3VwKTtcbiAgICByZXR1cm4gSGVsaXhBUElHcm91cDtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4QVBJR3JvdXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeEFQSUdyb3VwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhBUElHcm91cDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uLy4uL0Jhc2VBUElcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVHdpdGNoQ2xpZW50XCIpO1xudmFyIEhlbGl4Qml0c0xlYWRlcmJvYXJkXzEgPSByZXF1aXJlKFwiLi9IZWxpeEJpdHNMZWFkZXJib2FyZFwiKTtcbi8qKlxuICogVGhlIEhlbGl4IEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIGJpdHMuXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQuaGVsaXguYml0c2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IGxlYWRlcmJvYXJkID0gYXdhaXQgY2xpZW50LmhlbGl4LmJpdHMuZ2V0TGVhZGVyYm9hcmQoeyBwZXJpb2Q6ICdkYXknIH0pO1xuICogYGBgXG4gKi9cbnZhciBIZWxpeEJpdHNBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGVsaXhCaXRzQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlbGl4Qml0c0FQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgYml0cyBsZWFkZXJib2FyZCBvZiB5b3VyIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICovXG4gICAgSGVsaXhCaXRzQVBJLnByb3RvdHlwZS5nZXRMZWFkZXJib2FyZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBjb3VudCwgX2IsIHBlcmlvZCwgc3RhcnREYXRlLCBjb250ZXh0VXNlcklkLCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gcGFyYW1zLmNvdW50LCBjb3VudCA9IF9hID09PSB2b2lkIDAgPyAxMCA6IF9hLCBfYiA9IHBhcmFtcy5wZXJpb2QsIHBlcmlvZCA9IF9iID09PSB2b2lkIDAgPyAnYWxsJyA6IF9iLCBzdGFydERhdGUgPSBwYXJhbXMuc3RhcnREYXRlLCBjb250ZXh0VXNlcklkID0gcGFyYW1zLmNvbnRleHRVc2VySWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdiaXRzL2xlYWRlcmJvYXJkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdiaXRzOnJlYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJpb2Q6IHBlcmlvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWRfYXQ6IHN0YXJ0RGF0ZSA/IHN0YXJ0RGF0ZS50b0lTT1N0cmluZygpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcl9pZDogY29udGV4dFVzZXJJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEhlbGl4Qml0c0xlYWRlcmJvYXJkXzEuZGVmYXVsdChyZXN1bHQsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIZWxpeEJpdHNBUEk7XG59KEJhc2VBUElfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEJpdHNBUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeEJpdHNBUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeEJpdHNBUEk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL1R3aXRjaENsaWVudFwiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlcXVlc3RcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlc3VsdFwiKTtcbnZhciBIZWxpeENsaXBfMSA9IHJlcXVpcmUoXCIuL0hlbGl4Q2xpcFwiKTtcbi8qKlxuICogVGhlIEhlbGl4IEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIGNsaXBzLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmhlbGl4LmNsaXBzYCBvbiBhIHtAVHdpdGNoQ2xpZW50fSBpbnN0YW5jZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgY2xpZW50ID0gVHdpdGNoQ2xpZW50LndpdGhDcmVkZW50aWFscyhjbGllbnRJZCwgYWNjZXNzVG9rZW4pO1xuICogY29uc3QgY2xpcElkID0gYXdhaXQgY2xpZW50LmhlbGl4LmNsaXBzLmNyZWF0ZUNsaXAoeyBjaGFubmVsSWQ6ICcxMjUzMjg2NTUnIH0pO1xuICogYGBgXG4gKi9cbnZhciBIZWxpeENsaXBBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGVsaXhDbGlwQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlbGl4Q2xpcEFQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGxhdGVzdCBjbGlwcyBmb3IgdGhlIHNwZWNpZmllZCBicm9hZGNhc3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VySWQgVGhlIGJyb2FkY2FzdGVyJ3MgdXNlciBJRC5cbiAgICAgKiBAcGFyYW0gZmlsdGVyXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICovXG4gICAgSGVsaXhDbGlwQVBJLnByb3RvdHlwZS5nZXRDbGlwc0ZvckJyb2FkY2FzdGVyID0gZnVuY3Rpb24gKHVzZXJJZCwgZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9nZXRDbGlwcyh0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIGZpbHRlciksIHsgZmlsdGVyVHlwZTogJ2Jyb2FkY2FzdGVyX2lkJywgaWRzOiB1c2VySWQgfSkpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYWdpbmF0b3IgZm9yIHRoZSBsYXRlc3QgY2xpcHMgZm9yIHRoZSBzcGVjaWZpZWQgYnJvYWRjYXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcklkIFRoZSBicm9hZGNhc3RlcidzIHVzZXIgSUQuXG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqL1xuICAgIEhlbGl4Q2xpcEFQSS5wcm90b3R5cGUuZ2V0Q2xpcHNGb3JCcm9hZGNhc3RlclBhZ2luYXRlZCA9IGZ1bmN0aW9uICh1c2VySWQsIGZpbHRlcikge1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENsaXBzUGFnaW5hdGVkKHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgZmlsdGVyKSwgeyBmaWx0ZXJUeXBlOiAnYnJvYWRjYXN0ZXJfaWQnLCBpZHM6IHVzZXJJZCB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGxhdGVzdCBjbGlwcyBmb3IgdGhlIHNwZWNpZmllZCBnYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdhbWVJZCBUaGUgZ2FtZSBJRC5cbiAgICAgKiBAcGFyYW0gZmlsdGVyXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICovXG4gICAgSGVsaXhDbGlwQVBJLnByb3RvdHlwZS5nZXRDbGlwc0ZvckdhbWUgPSBmdW5jdGlvbiAoZ2FtZUlkLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7IGZpbHRlciA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2dldENsaXBzKHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgZmlsdGVyKSwgeyBmaWx0ZXJUeXBlOiAnZ2FtZV9pZCcsIGlkczogZ2FtZUlkIH0pKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciB0aGUgbGF0ZXN0IGNsaXBzIGZvciB0aGUgc3BlY2lmaWVkIGdhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2FtZUlkIFRoZSBnYW1lIElELlxuICAgICAqIEBwYXJhbSBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKi9cbiAgICBIZWxpeENsaXBBUEkucHJvdG90eXBlLmdldENsaXBzRm9yR2FtZVBhZ2luYXRlZCA9IGZ1bmN0aW9uIChnYW1lSWQsIGZpbHRlcikge1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENsaXBzUGFnaW5hdGVkKHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgZmlsdGVyKSwgeyBmaWx0ZXJUeXBlOiAnZ2FtZV9pZCcsIGlkczogZ2FtZUlkIH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2xpcHMgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4gSURzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkcyBUaGUgY2xpcCBJRHMuXG4gICAgICovXG4gICAgSGVsaXhDbGlwQVBJLnByb3RvdHlwZS5nZXRDbGlwc0J5SWRzID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0Q2xpcHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclR5cGU6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRzOiBpZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNsaXAgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGNsaXAgSUQuXG4gICAgICovXG4gICAgSGVsaXhDbGlwQVBJLnByb3RvdHlwZS5nZXRDbGlwQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbGlwcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldENsaXBzQnlJZHMoW2lkXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjbGlwcy5sZW5ndGggPyBjbGlwc1swXSA6IG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbGlwIG9mIGEgcnVubmluZyBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgY2xpcC5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKi9cbiAgICBIZWxpeENsaXBBUEkucHJvdG90eXBlLmNyZWF0ZUNsaXAgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxJZCwgX2EsIGNyZWF0ZUFmdGVyRGVsYXksIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gcGFyYW1zLmNoYW5uZWxJZCwgX2EgPSBwYXJhbXMuY3JlYXRlQWZ0ZXJEZWxheSwgY3JlYXRlQWZ0ZXJEZWxheSA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnY2xpcHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdjbGlwczplZGl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdGVyX2lkOiBjaGFubmVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNfZGVsYXk6IGNyZWF0ZUFmdGVyRGVsYXkudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LmRhdGFbMF0uaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhlbGl4Q2xpcEFQSS5wcm90b3R5cGUuX2dldENsaXBzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJUeXBlLCBpZHMsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgX2EsIGxpbWl0LCByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclR5cGUgPSBwYXJhbXMuZmlsdGVyVHlwZSwgaWRzID0gcGFyYW1zLmlkcywgc3RhcnREYXRlID0gcGFyYW1zLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IHBhcmFtcy5lbmREYXRlLCBfYSA9IHBhcmFtcy5saW1pdCwgbGltaXQgPSBfYSA9PT0gdm9pZCAwID8gMjAgOiBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2NsaXBzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IChfYiA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2JbZmlsdGVyVHlwZV0gPSBpZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zdGFydGVkX2F0ID0gc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IuZW5kZWRfYXQgPSBlbmREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IuZmlyc3QgPSBsaW1pdC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMS5jcmVhdGVQYWdpbmF0ZWRSZXN1bHQocmVzdWx0LCBIZWxpeENsaXBfMS5kZWZhdWx0LCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeENsaXBBUEkucHJvdG90eXBlLl9nZXRDbGlwc1BhZ2luYXRlZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmlsdGVyVHlwZSA9IHBhcmFtcy5maWx0ZXJUeXBlLCBpZHMgPSBwYXJhbXMuaWRzLCBzdGFydERhdGUgPSBwYXJhbXMuc3RhcnREYXRlLCBlbmREYXRlID0gcGFyYW1zLmVuZERhdGU7XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICdjbGlwcycsXG4gICAgICAgICAgICBxdWVyeTogKF9hID0ge30sXG4gICAgICAgICAgICAgICAgX2FbZmlsdGVyVHlwZV0gPSBpZHMsXG4gICAgICAgICAgICAgICAgX2Euc3RhcnRlZF9hdCA9IHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICBfYS5lbmRlZF9hdCA9IGVuZERhdGUsXG4gICAgICAgICAgICAgICAgX2EpXG4gICAgICAgIH0sIHRoaXMuX2NsaWVudCwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBIZWxpeENsaXBfMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIZWxpeENsaXBBUEk7XG59KEJhc2VBUElfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeENsaXBBUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeENsaXBBUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeENsaXBBUEk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL1R3aXRjaENsaWVudFwiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlcXVlc3RcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlc3VsdFwiKTtcbnZhciBIZWxpeFBhZ2luYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRpb25cIik7XG52YXIgSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vSGVsaXhFeHRlbnNpb25UcmFuc2FjdGlvblwiKTtcbi8qKlxuICogVGhlIEhlbGl4IEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIGV4dGVuc2lvbnMuXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQuaGVsaXguZXh0ZW5zaW9uc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGF3YWl0IGNsaWVudC5oZWxpeC5leHRpb25zaW9ucy5nZXRFeHRlbnNpb25UcmFuc2FjdGlvbnMoJ2FiY2QnKTtcbiAqIGBgYFxuICovXG52YXIgSGVsaXhFeHRlbnNpb25zQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4RXh0ZW5zaW9uc0FQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxpeEV4dGVuc2lvbnNBUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiB0cmFuc2FjdGlvbnMgZm9yIHRoZSBnaXZlbiBleHRlbnNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9uSWQgVGhlIElEIG9mIHRoZSBleHRlbnNpb24gdG8gcmV0cmlldmUgdHJhbnNhY3Rpb25zIGZvci5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIEFkZGl0aW9uYWwgZmlsdGVycy5cbiAgICAgKi9cbiAgICBIZWxpeEV4dGVuc2lvbnNBUEkucHJvdG90eXBlLmdldEV4dGVuc2lvblRyYW5zYWN0aW9ucyA9IGZ1bmN0aW9uIChleHRlbnNpb25JZCwgZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2V4dGVuc2lvbnMvdHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogdHNsaWJfMS5fX2Fzc2lnbih7IGV4dGVuc2lvbl9pZDogZXh0ZW5zaW9uSWQsIGlkOiBmaWx0ZXIudHJhbnNhY3Rpb25JZHMgfSwgSGVsaXhQYWdpbmF0aW9uXzEubWFrZVBhZ2luYXRpb25RdWVyeShmaWx0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMS5jcmVhdGVQYWdpbmF0ZWRSZXN1bHQocmVzdWx0LCBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uXzEuZGVmYXVsdCwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgdHJhbnNhY3Rpb25zIGZvciB0aGUgZ2l2ZW4gZXh0ZW5zaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV4dGVuc2lvbklkIFRoZSBJRCBvZiB0aGUgZXh0ZW5zaW9uIHRvIHJldHJpZXZlIHRyYW5zYWN0aW9ucyBmb3IuXG4gICAgICogQHBhcmFtIGZpbHRlciBBZGRpdGlvbmFsIGZpbHRlcnMuXG4gICAgICovXG4gICAgSGVsaXhFeHRlbnNpb25zQVBJLnByb3RvdHlwZS5nZXRFeHRlbnNpb25UcmFuc2FjdGlvbnNQYWdpbmF0ZWQgPSBmdW5jdGlvbiAoZXh0ZW5zaW9uSWQsIGZpbHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHVybDogJ2V4dGVuc2lvbnMvdHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uX2lkOiBleHRlbnNpb25JZCxcbiAgICAgICAgICAgICAgICBpZDogZmlsdGVyLnRyYW5zYWN0aW9uSWRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX2NsaWVudCwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBIZWxpeEV4dGVuc2lvblRyYW5zYWN0aW9uXzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVsaXhFeHRlbnNpb25zQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhFeHRlbnNpb25zQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhFeHRlbnNpb25zQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhFeHRlbnNpb25zQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ud2l0Y2hDbGllbnRcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uLy4uL0Jhc2VBUElcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXN1bHRcIik7XG52YXIgSGVsaXhQYWdpbmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0aW9uXCIpO1xudmFyIEhlbGl4R2FtZV8xID0gcmVxdWlyZShcIi4vSGVsaXhHYW1lXCIpO1xuLyoqXG4gKiBUaGUgSGVsaXggQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggZ2FtZXMuXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQuaGVsaXguZ2FtZXNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBnYW1lID0gYXdhaXQgY2xpZW50LmhlbGl4LmdhbWVzLmdldEdhbWVCeU5hbWUoJ0hlYXJ0aHN0b25lJyk7XG4gKiBgYGBcbiAqL1xudmFyIEhlbGl4R2FtZUFQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeEdhbWVBUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhHYW1lQVBJKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZ2FtZSBkYXRhIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiBnYW1lIElEcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZHMgVGhlIGdhbWUgSURzIHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICovXG4gICAgSGVsaXhHYW1lQVBJLnByb3RvdHlwZS5nZXRHYW1lc0J5SWRzID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9nZXRHYW1lcygnaWQnLCBpZHMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZ2FtZSBkYXRhIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiBnYW1lIG5hbWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVzIFRoZSBnYW1lIG5hbWVzIHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICovXG4gICAgSGVsaXhHYW1lQVBJLnByb3RvdHlwZS5nZXRHYW1lc0J5TmFtZXMgPSBmdW5jdGlvbiAobmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0R2FtZXMoJ25hbWUnLCBuYW1lcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBnYW1lIGRhdGEgZm9yIHRoZSBnaXZlbiBnYW1lIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSBnYW1lIElEIHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICovXG4gICAgSGVsaXhHYW1lQVBJLnByb3RvdHlwZS5nZXRHYW1lQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBnYW1lcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRHYW1lcygnaWQnLCBpZCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBnYW1lcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnYW1lcy5sZW5ndGggPyBnYW1lc1swXSA6IG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZ2FtZSBkYXRhIGZvciB0aGUgZ2l2ZW4gZ2FtZSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIGdhbWUgbmFtZSB5b3Ugd2FudCB0byBsb29rIHVwLlxuICAgICAqL1xuICAgIEhlbGl4R2FtZUFQSS5wcm90b3R5cGUuZ2V0R2FtZUJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGdhbWVzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEdhbWVzKCduYW1lJywgbmFtZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBnYW1lcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnYW1lcy5sZW5ndGggPyBnYW1lc1swXSA6IG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgdGhlIG1vc3Qgdmlld2VkIGdhbWVzIGF0IHRoZSBtb21lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnaW5hdGlvbiBQYWdpbmF0aW9uIGluZm8uXG4gICAgICovXG4gICAgSGVsaXhHYW1lQVBJLnByb3RvdHlwZS5nZXRUb3BHYW1lcyA9IGZ1bmN0aW9uIChwYWdpbmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnZ2FtZXMvdG9wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogSGVsaXhQYWdpbmF0aW9uXzEubWFrZVBhZ2luYXRpb25RdWVyeShwYWdpbmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMS5jcmVhdGVQYWdpbmF0ZWRSZXN1bHQocmVzdWx0LCBIZWxpeEdhbWVfMS5kZWZhdWx0LCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciB0aGUgbW9zdCB2aWV3ZWQgZ2FtZXMgYXQgdGhlIG1vbWVudC5cbiAgICAgKi9cbiAgICBIZWxpeEdhbWVBUEkucHJvdG90eXBlLmdldFRvcEdhbWVzUGFnaW5hdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgdXJsOiAnZ2FtZXMvdG9wJ1xuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhHYW1lXzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICBIZWxpeEdhbWVBUEkucHJvdG90eXBlLl9nZXRHYW1lcyA9IGZ1bmN0aW9uIChmaWx0ZXJUeXBlLCBmaWx0ZXJWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnZ2FtZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FbZmlsdGVyVHlwZV0gPSBmaWx0ZXJWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LmRhdGEubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gbmV3IEhlbGl4R2FtZV8xLmRlZmF1bHQoZW50cnksIF90aGlzLl9jbGllbnQpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEhlbGl4R2FtZUFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4R2FtZUFQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4R2FtZUFQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4R2FtZUFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgVXNlclRvb2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVG9vbGtpdC9Vc2VyVG9vbHNcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVHdpdGNoQ2xpZW50XCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGVkUmVxdWVzdFwiKTtcbnZhciBIZWxpeFBhZ2luYXRlZFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGVkUmVzdWx0XCIpO1xudmFyIEhlbGl4UGFnaW5hdGlvbl8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGlvblwiKTtcbnZhciBIZWxpeEJhbl8xID0gcmVxdWlyZShcIi4vSGVsaXhCYW5cIik7XG52YXIgSGVsaXhCYW5FdmVudF8xID0gcmVxdWlyZShcIi4vSGVsaXhCYW5FdmVudFwiKTtcbnZhciBIZWxpeE1vZGVyYXRvcl8xID0gcmVxdWlyZShcIi4vSGVsaXhNb2RlcmF0b3JcIik7XG52YXIgSGVsaXhNb2RlcmF0b3JFdmVudF8xID0gcmVxdWlyZShcIi4vSGVsaXhNb2RlcmF0b3JFdmVudFwiKTtcbi8qKlxuICogVGhlIEhlbGl4IEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIG1vZGVyYXRpb24uXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQuaGVsaXgubW9kZXJhdGlvbmAgb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IGdhbWUgPSBhd2FpdCBjbGllbnQuaGVsaXgubW9kZXJhdGlvbi5nZXRCYW5uZWRVc2VycygnNjEzNjkyMjMnKTtcbiAqIGBgYFxuICovXG52YXIgSGVsaXhNb2RlcmF0aW9uQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4TW9kZXJhdGlvbkFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxpeE1vZGVyYXRpb25BUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBiYW5uZWQgdXNlcnMgaW4gYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gcmV0cmlldmUgdGhlIGJhbm5lZCB1c2VycyBmcm9tLlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgQWRkaXRpb25hbCBmaWx0ZXJzIGZvciB0aGUgcmVzdWx0IHNldC5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRpb25BUEkucHJvdG90eXBlLmdldEJhbm5lZFVzZXJzID0gZnVuY3Rpb24gKGNoYW5uZWwsIGZpbHRlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnbW9kZXJhdGlvbi9iYW5uZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnbW9kZXJhdGlvbjpyZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogdHNsaWJfMS5fX2Fzc2lnbih7IGJyb2FkY2FzdGVyX2lkOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpLCB1c2VyX2lkOiAoX2EgPSBmaWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VySWQgfSwgSGVsaXhQYWdpbmF0aW9uXzEubWFrZVBhZ2luYXRpb25RdWVyeShmaWx0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMS5jcmVhdGVQYWdpbmF0ZWRSZXN1bHQocmVzdWx0LCBIZWxpeEJhbl8xLmRlZmF1bHQsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYWdpbmF0b3IgZm9yIGJhbm5lZCB1c2VycyBpbiBhIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byByZXRyaWV2ZSB0aGUgYmFubmVkIHVzZXJzIGZyb20uXG4gICAgICovXG4gICAgSGVsaXhNb2RlcmF0aW9uQVBJLnByb3RvdHlwZS5nZXRCYW5uZWRVc2Vyc1BhZ2luYXRlZCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICdtb2RlcmF0aW9uL2Jhbm5lZCcsXG4gICAgICAgICAgICBzY29wZTogJ21vZGVyYXRpb246cmVhZCcsXG4gICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdGVyX2lkOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX2NsaWVudCwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBIZWxpeEJhbl8xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiB1c2VyIGlzIGJhbm5lZCBpbiBhIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byBjaGVjayBmb3IgYSBiYW4gb2YgdGhlIGdpdmVuIHVzZXIuXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgdG8gY2hlY2sgZm9yIGEgYmFuIGluIHRoZSBnaXZlbiBjaGFubmVsLlxuICAgICAqL1xuICAgIEhlbGl4TW9kZXJhdGlvbkFQSS5wcm90b3R5cGUuY2hlY2tVc2VyQmFuID0gZnVuY3Rpb24gKGNoYW5uZWwsIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkLCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEJhbm5lZFVzZXJzKGNoYW5uZWwsIHsgdXNlcklkOiB1c2VySWQgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LmRhdGEuc29tZShmdW5jdGlvbiAoYmFuKSB7IHJldHVybiBiYW4udXNlcklkID09PSB1c2VySWQ7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGJhbiBldmVudHMgZm9yIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHJldHJpZXZlIHRoZSBiYW4gZXZlbnRzIGZyb20uXG4gICAgICogQHBhcmFtIGZpbHRlciBBZGRpdGlvbmFsIGZpbHRlcnMgZm9yIHRoZSByZXN1bHQgc2V0LlxuICAgICAqL1xuICAgIEhlbGl4TW9kZXJhdGlvbkFQSS5wcm90b3R5cGUuZ2V0QmFuRXZlbnRzID0gZnVuY3Rpb24gKGNoYW5uZWwsIGZpbHRlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdtb2RlcmF0aW9uL2Jhbm5lZC9ldmVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnbW9kZXJhdGlvbjpyZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogdHNsaWJfMS5fX2Fzc2lnbih7IGJyb2FkY2FzdGVyX2lkOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpLCB1c2VyX2lkOiAoX2EgPSBmaWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VySWQgfSwgSGVsaXhQYWdpbmF0aW9uXzEubWFrZVBhZ2luYXRpb25RdWVyeShmaWx0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHQuZGF0YS5tYXAoZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBIZWxpeEJhbkV2ZW50XzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogKF9iID0gcmVzdWx0LnBhZ2luYXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jdXJzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciBiYW4gZXZlbnRzIGZvciBhIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byByZXRyaWV2ZSB0aGUgYmFuIGV2ZW50cyBmcm9tLlxuICAgICAqL1xuICAgIEhlbGl4TW9kZXJhdGlvbkFQSS5wcm90b3R5cGUuZ2V0QmFuRXZlbnRzUGFnaW5hdGVkID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHVybDogJ21vZGVyYXRpb24vYmFubmVkL2V2ZW50cycsXG4gICAgICAgICAgICBzY29wZTogJ21vZGVyYXRpb246cmVhZCcsXG4gICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdGVyX2lkOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX2NsaWVudCwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBIZWxpeEJhbkV2ZW50XzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIG1vZGVyYXRvcnMgaW4gYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gcmV0cmlldmUgbW9kZXJhdG9ycyBmcm9tLlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgQWRkaXRpb25hbCBmaWx0ZXJzIGZvciB0aGUgcmVzdWx0IHNldC5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRpb25BUEkucHJvdG90eXBlLmdldE1vZGVyYXRvcnMgPSBmdW5jdGlvbiAoY2hhbm5lbCwgZmlsdGVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdtb2RlcmF0aW9uL21vZGVyYXRvcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnbW9kZXJhdGlvbjpyZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogdHNsaWJfMS5fX2Fzc2lnbih7IGJyb2FkY2FzdGVyX2lkOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpLCB1c2VyX2lkOiAoX2EgPSBmaWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VySWQgfSwgSGVsaXhQYWdpbmF0aW9uXzEubWFrZVBhZ2luYXRpb25RdWVyeShmaWx0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMS5jcmVhdGVQYWdpbmF0ZWRSZXN1bHQocmVzdWx0LCBIZWxpeE1vZGVyYXRvcl8xLmRlZmF1bHQsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYWdpbmF0b3IgZm9yIG1vZGVyYXRvcnMgaW4gYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gcmV0cmlldmUgbW9kZXJhdG9ycyBmcm9tLlxuICAgICAqL1xuICAgIEhlbGl4TW9kZXJhdGlvbkFQSS5wcm90b3R5cGUuZ2V0TW9kZXJhdG9yc1BhZ2luYXRlZCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICdtb2RlcmF0aW9uL21vZGVyYXRvcnMnLFxuICAgICAgICAgICAgc2NvcGU6ICdtb2RlcmF0aW9uOnJlYWQnLFxuICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3Rlcl9pZDogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhNb2RlcmF0b3JfMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gdXNlciBpcyBhIG1vZGVyYXRvciBvZiBhIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB0byBjaGVjay5cbiAgICAgKi9cbiAgICBIZWxpeE1vZGVyYXRpb25BUEkucHJvdG90eXBlLmNoZWNrVXNlck1vZCA9IGZ1bmN0aW9uIChjaGFubmVsLCB1c2VyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZCwgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRNb2RlcmF0b3JzKGNoYW5uZWwsIHsgdXNlcklkOiB1c2VySWQgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LmRhdGEuc29tZShmdW5jdGlvbiAobW9kKSB7IHJldHVybiBtb2QudXNlcklkID09PSB1c2VySWQ7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIG1vZGVyYXRvciBldmVudHMgZm9yIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHJldHJpZXZlIHRoZSBtb2RlcmF0b3IgZXZlbnRzIGZyb20uXG4gICAgICogQHBhcmFtIGZpbHRlciBBZGRpdGlvbmFsIGZpbHRlcnMgZm9yIHRoZSByZXN1bHQgc2V0LlxuICAgICAqL1xuICAgIEhlbGl4TW9kZXJhdGlvbkFQSS5wcm90b3R5cGUuZ2V0TW9kZXJhdG9yRXZlbnRzID0gZnVuY3Rpb24gKGNoYW5uZWwsIGZpbHRlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnbW9kZXJhdGlvbi9tb2RlcmF0b3JzL2V2ZW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdtb2RlcmF0aW9uOnJlYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB0c2xpYl8xLl9fYXNzaWduKHsgYnJvYWRjYXN0ZXJfaWQ6IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbCksIHVzZXJfaWQ6IChfYSA9IGZpbHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVzZXJJZCB9LCBIZWxpeFBhZ2luYXRpb25fMS5tYWtlUGFnaW5hdGlvblF1ZXJ5KGZpbHRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBIZWxpeFBhZ2luYXRlZFJlc3VsdF8xLmNyZWF0ZVBhZ2luYXRlZFJlc3VsdChyZXN1bHQsIEhlbGl4TW9kZXJhdG9yRXZlbnRfMS5kZWZhdWx0LCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciBtb2RlcmF0b3IgZXZlbnRzIGZvciBhIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byByZXRyaWV2ZSB0aGUgbW9kZXJhdG9yIGV2ZW50cyBmcm9tLlxuICAgICAqL1xuICAgIEhlbGl4TW9kZXJhdGlvbkFQSS5wcm90b3R5cGUuZ2V0TW9kZXJhdG9yRXZlbnRzUGFnaW5hdGVkID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHVybDogJ21vZGVyYXRpb24vbW9kZXJhdG9ycy9ldmVudHMnLFxuICAgICAgICAgICAgc2NvcGU6ICdtb2RlcmF0aW9uOnJlYWQnLFxuICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3Rlcl9pZDogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhNb2RlcmF0b3JFdmVudF8xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEhlbGl4TW9kZXJhdGlvbkFQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4TW9kZXJhdGlvbkFQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4TW9kZXJhdGlvbkFQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4TW9kZXJhdGlvbkFQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG52YXIgSFRUUFN0YXR1c0NvZGVFcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0Vycm9ycy9IVFRQU3RhdHVzQ29kZUVycm9yXCIpO1xudmFyIFN0cmVhbU5vdExpdmVFcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0Vycm9ycy9TdHJlYW1Ob3RMaXZlRXJyb3JcIik7XG52YXIgVXNlclRvb2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVG9vbGtpdC9Vc2VyVG9vbHNcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVHdpdGNoQ2xpZW50XCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGVkUmVxdWVzdFwiKTtcbnZhciBIZWxpeFBhZ2luYXRlZFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGVkUmVzdWx0XCIpO1xudmFyIEhlbGl4UGFnaW5hdGlvbl8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGlvblwiKTtcbnZhciBIZWxpeFN0cmVhbV8xID0gcmVxdWlyZShcIi4vSGVsaXhTdHJlYW1cIik7XG52YXIgSGVsaXhTdHJlYW1NYXJrZXJfMSA9IHJlcXVpcmUoXCIuL0hlbGl4U3RyZWFtTWFya2VyXCIpO1xudmFyIEhlbGl4U3RyZWFtTWFya2VyV2l0aFZpZGVvXzEgPSByZXF1aXJlKFwiLi9IZWxpeFN0cmVhbU1hcmtlcldpdGhWaWRlb1wiKTtcbi8qKlxuICogVGhlIEhlbGl4IEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIHN0cmVhbXMuXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQuaGVsaXguc3RyZWFtc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGNsaWVudC5oZWxpeC5zdHJlYW1zLmdldFN0cmVhbUJ5VXNlcklkKCcxMjUzMjg2NTUnKTtcbiAqIGBgYFxuICovXG52YXIgSGVsaXhTdHJlYW1BUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGVsaXhTdHJlYW1BUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhTdHJlYW1BUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBzdHJlYW1zLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtQVBJLnByb3RvdHlwZS5nZXRTdHJlYW1zID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdzdHJlYW1zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBIZWxpeFBhZ2luYXRpb25fMS5tYWtlUGFnaW5hdGlvblF1ZXJ5KGZpbHRlcikpLCB7IGNvbW11bml0eV9pZDogZmlsdGVyLmNvbW11bml0eSwgZ2FtZV9pZDogZmlsdGVyLmdhbWUsIGxhbmd1YWdlOiBmaWx0ZXIubGFuZ3VhZ2UsIHR5cGU6IGZpbHRlci50eXBlLCB1c2VyX2lkOiBmaWx0ZXIudXNlcklkLCB1c2VyX2xvZ2luOiBmaWx0ZXIudXNlck5hbWUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEuY3JlYXRlUGFnaW5hdGVkUmVzdWx0KHJlc3VsdCwgSGVsaXhTdHJlYW1fMS5kZWZhdWx0LCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciBzdHJlYW1zLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtQVBJLnByb3RvdHlwZS5nZXRTdHJlYW1zUGFnaW5hdGVkID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHVybDogJ3N0cmVhbXMnLFxuICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICBjb21tdW5pdHlfaWQ6IGZpbHRlci5jb21tdW5pdHksXG4gICAgICAgICAgICAgICAgZ2FtZV9pZDogZmlsdGVyLmdhbWUsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGZpbHRlci5sYW5ndWFnZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBmaWx0ZXIudHlwZSxcbiAgICAgICAgICAgICAgICB1c2VyX2lkOiBmaWx0ZXIudXNlcklkLFxuICAgICAgICAgICAgICAgIHVzZXJfbG9naW46IGZpbHRlci51c2VyTmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhTdHJlYW1fMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzdHJlYW0gZm9yIHRoZSBnaXZlbiB1c2VyIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciBuYW1lIHRvIHJldHJpZXZlIHRoZSBzdHJlYW0gZm9yLlxuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtQVBJLnByb3RvdHlwZS5nZXRTdHJlYW1CeVVzZXJOYW1lID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0U3RyZWFtcyh7IHVzZXJOYW1lOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlck5hbWUodXNlcikgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LmRhdGEubGVuZ3RoID8gcmVzdWx0LmRhdGFbMF0gOiBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc3RyZWFtIGZvciB0aGUgZ2l2ZW4gdXNlciBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIElEIHRvIHJldHJpZXZlIHRoZSBzdHJlYW0gZm9yLlxuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtQVBJLnByb3RvdHlwZS5nZXRTdHJlYW1CeVVzZXJJZCA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFN0cmVhbXMoeyB1c2VySWQ6IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcikgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LmRhdGEubGVuZ3RoID8gcmVzdWx0LmRhdGFbMF0gOiBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGFsbCBzdHJlYW0gbWFya2VycyBmb3IgYW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHRvIGxpc3QgdGhlIHN0cmVhbSBtYXJrZXJzIGZvci5cbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbUFQSS5wcm90b3R5cGUuZ2V0U3RyZWFtTWFya2Vyc0ZvclVzZXIgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9nZXRTdHJlYW1NYXJrZXJzKCd1c2VyX2lkJywgVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgYWxsIHN0cmVhbSBtYXJrZXJzIGZvciBhbiB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgdG8gbGlzdCB0aGUgc3RyZWFtIG1hcmtlcnMgZm9yLlxuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtQVBJLnByb3RvdHlwZS5nZXRTdHJlYW1NYXJrZXJzRm9yVXNlclBhZ2luYXRlZCA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTdHJlYW1NYXJrZXJzUGFnaW5hdGVkKCd1c2VyX2lkJywgVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGFsbCBzdHJlYW0gbWFya2VycyBmb3IgYSB2aWRlby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aWRlb0lkIFRoZSB2aWRlbyB0byBsaXN0IHRoZSBzdHJlYW0gbWFya2VycyBmb3IuXG4gICAgICovXG4gICAgSGVsaXhTdHJlYW1BUEkucHJvdG90eXBlLmdldFN0cmVhbU1hcmtlcnNGb3JWaWRlbyA9IGZ1bmN0aW9uICh2aWRlb0lkKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2dldFN0cmVhbU1hcmtlcnMoJ3ZpZGVvX2lkJywgdmlkZW9JZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgYWxsIHN0cmVhbSBtYXJrZXJzIGZvciBhIHZpZGVvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpZGVvSWQgVGhlIHZpZGVvIHRvIGxpc3QgdGhlIHN0cmVhbSBtYXJrZXJzIGZvci5cbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbUFQSS5wcm90b3R5cGUuZ2V0U3RyZWFtTWFya2Vyc0ZvclZpZGVvUGFnaW5hdGVkID0gZnVuY3Rpb24gKHZpZGVvSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN0cmVhbU1hcmtlcnNQYWdpbmF0ZWQoJ3ZpZGVvX2lkJywgdmlkZW9JZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN0cmVhbSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBPbmx5IHdvcmtzIHdoaWxlIHRoZSBzcGVjaWZpZWQgdXNlcidzIHN0cmVhbSBpcyBsaXZlLlxuICAgICAqL1xuICAgIEhlbGl4U3RyZWFtQVBJLnByb3RvdHlwZS5jcmVhdGVTdHJlYW1NYXJrZXIgPSBmdW5jdGlvbiAodXNlcklkLCBkZXNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGVfMTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnc3RyZWFtcy9tYXJrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ3VzZXI6ZWRpdDpicm9hZGNhc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgSGVsaXhTdHJlYW1NYXJrZXJfMS5kZWZhdWx0KHJlc3VsdC5kYXRhWzBdLCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSBpbnN0YW5jZW9mIEhUVFBTdGF0dXNDb2RlRXJyb3JfMS5kZWZhdWx0ICYmIGVfMS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RyZWFtTm90TGl2ZUVycm9yXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFN0cmVhbUFQSS5wcm90b3R5cGUuX2dldFN0cmVhbU1hcmtlcnMgPSBmdW5jdGlvbiAocXVlcnlUeXBlLCBpZCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3N0cmVhbXMvbWFya2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYVtxdWVyeVR5cGVdID0gaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ3VzZXI6cmVhZDpicm9hZGNhc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNoYXJlZF91dGlsc18xLmZsYXR0ZW4ocmVzdWx0LmRhdGEubWFwKEhlbGl4U3RyZWFtQVBJLl9tYXBHZXRTdHJlYW1NYXJrZXJzUmVzdWx0LmJpbmQodGhpcy5fY2xpZW50KSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IHJlc3VsdC5wYWdpbmF0aW9uICYmIHJlc3VsdC5wYWdpbmF0aW9uLmN1cnNvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhlbGl4U3RyZWFtQVBJLnByb3RvdHlwZS5fZ2V0U3RyZWFtTWFya2Vyc1BhZ2luYXRlZCA9IGZ1bmN0aW9uIChxdWVyeVR5cGUsIGlkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHVybDogJ3N0cmVhbXMvbWFya2VycycsXG4gICAgICAgICAgICBxdWVyeTogKF9hID0ge30sXG4gICAgICAgICAgICAgICAgX2FbcXVlcnlUeXBlXSA9IGlkLFxuICAgICAgICAgICAgICAgIF9hKSxcbiAgICAgICAgICAgIHNjb3BlOiAndXNlcjpyZWFkOmJyb2FkY2FzdCdcbiAgICAgICAgfSwgdGhpcy5fY2xpZW50LCBIZWxpeFN0cmVhbUFQSS5fbWFwR2V0U3RyZWFtTWFya2Vyc1Jlc3VsdC5iaW5kKHRoaXMuX2NsaWVudCkpO1xuICAgIH07XG4gICAgSGVsaXhTdHJlYW1BUEkuX21hcEdldFN0cmVhbU1hcmtlcnNSZXN1bHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZGF0YS52aWRlb3MucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHZpZGVvKSB7IHJldHVybiB0c2xpYl8xLl9fc3ByZWFkKHJlc3VsdCwgdmlkZW8ubWFya2Vycy5tYXAoZnVuY3Rpb24gKG1hcmtlcikgeyByZXR1cm4gbmV3IEhlbGl4U3RyZWFtTWFya2VyV2l0aFZpZGVvXzEuZGVmYXVsdChtYXJrZXIsIHZpZGVvLnZpZGVvX2lkLCBfdGhpcyk7IH0pKTsgfSwgW10pO1xuICAgIH07XG4gICAgcmV0dXJuIEhlbGl4U3RyZWFtQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdHJlYW1BUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFN0cmVhbUFQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4U3RyZWFtQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBIZWxpeFN0cmVhbU1hcmtlcl8xID0gcmVxdWlyZShcIi4vSGVsaXhTdHJlYW1NYXJrZXJcIik7XG52YXIgSGVsaXhTdHJlYW1NYXJrZXJXaXRoVmlkZW8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGVsaXhTdHJlYW1NYXJrZXJXaXRoVmlkZW8sIF9zdXBlcik7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhTdHJlYW1NYXJrZXJXaXRoVmlkZW8oZGF0YSwgX3ZpZGVvSWQsIGNsaWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkYXRhLCBjbGllbnQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl92aWRlb0lkID0gX3ZpZGVvSWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtTWFya2VyV2l0aFZpZGVvLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgdmlkZW8sIHdoaWNoIHdpbGwgc3RhcnQgcGxheWluZyBhdCB0aGUgcG9zaXRpb24gb2YgdGhlIHN0cmVhbSBtYXJrZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLlVSTDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlbGl4U3RyZWFtTWFya2VyV2l0aFZpZGVvLnByb3RvdHlwZSwgXCJ2aWRlb0lkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdmlkZW8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWRlb0lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZpZGVvIGRhdGEgb2YgdGhlIHZpZGVvIHRoZSBtYXJrZXIgd2FzIHNldCBpbi5cbiAgICAgKi9cbiAgICBIZWxpeFN0cmVhbU1hcmtlcldpdGhWaWRlby5wcm90b3R5cGUuZ2V0VmlkZW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5oZWxpeC52aWRlb3MuZ2V0VmlkZW9CeUlkKHRoaXMuX3ZpZGVvSWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIZWxpeFN0cmVhbU1hcmtlcldpdGhWaWRlbztcbn0oSGVsaXhTdHJlYW1NYXJrZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFN0cmVhbU1hcmtlcldpdGhWaWRlbztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4U3RyZWFtTWFya2VyV2l0aFZpZGVvO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdHJlYW1NYXJrZXJXaXRoVmlkZW87XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1Rvb2xraXQvVXNlclRvb2xzXCIpO1xudmFyIFR3aXRjaENsaWVudF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL1R3aXRjaENsaWVudFwiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlcXVlc3RcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9IZWxpeFBhZ2luYXRlZFJlc3VsdFwiKTtcbnZhciBIZWxpeFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vSGVsaXhTdWJzY3JpcHRpb25cIik7XG52YXIgSGVsaXhTdWJzY3JpcHRpb25FdmVudF8xID0gcmVxdWlyZShcIi4vSGVsaXhTdWJzY3JpcHRpb25FdmVudFwiKTtcbi8qKlxuICogVGhlIEhlbGl4IEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQuaGVsaXguc3Vic2NyaXB0aW9uc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBhd2FpdCBjbGllbnQuaGVsaXguc3Vic2NyaXB0aW9ucy5nZXRTdWJzY3JpcHRpb25zRm9yVXNlcnMoJzYxMzY5MjIzJywgJzEyNTMyODY1NScpO1xuICogYGBgXG4gKi9cbnZhciBIZWxpeFN1YnNjcmlwdGlvbkFQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeFN1YnNjcmlwdGlvbkFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxpeFN1YnNjcmlwdGlvbkFQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGFsbCBzdWJzY3JpcHRpb25zIHRvIGEgZ2l2ZW4gYnJvYWRjYXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIHRvIGxpc3Qgc3Vic2NyaXB0aW9ucyB0by5cbiAgICAgKi9cbiAgICBIZWxpeFN1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uIChicm9hZGNhc3Rlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3N1YnNjcmlwdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnY2hhbm5lbDpyZWFkOnN1YnNjcmlwdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdGVyX2lkOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGJyb2FkY2FzdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEuY3JlYXRlUGFnaW5hdGVkUmVzdWx0KHJlc3VsdCwgSGVsaXhTdWJzY3JpcHRpb25fMS5kZWZhdWx0LCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciBhbGwgc3Vic2NyaXB0aW9ucyB0byBhIGdpdmVuIGJyb2FkY2FzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciB0byBsaXN0IHN1YnNjcmlwdGlvbnMgdG8uXG4gICAgICovXG4gICAgSGVsaXhTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvbnNQYWdpbmF0ZWQgPSBmdW5jdGlvbiAoYnJvYWRjYXN0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBIZWxpeFBhZ2luYXRlZFJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHVybDogJ3N1YnNjcmlwdGlvbnMnLFxuICAgICAgICAgICAgc2NvcGU6ICdjaGFubmVsOnJlYWQ6c3Vic2NyaXB0aW9ucycsXG4gICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdGVyX2lkOiBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGJyb2FkY2FzdGVyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhTdWJzY3JpcHRpb25fMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc3Vic2V0IG9mIHRoZSBnaXZlbiB1c2VyIGxpc3QgdGhhdCBpcyBzdWJzY3JpYmVkIHRvIHRoZSBnaXZlbiBicm9hZGNhc3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBicm9hZGNhc3RlciBUaGUgYnJvYWRjYXN0ZXIgdG8gZmluZCBzdWJzY3JpcHRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB1c2VycyBUaGUgdXNlcnMgdGhhdCBzaG91bGQgYmUgY2hlY2tlZCBmb3Igc3Vic2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBIZWxpeFN1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9uc0ZvclVzZXJzID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyLCB1c2Vycykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdzdWJzY3JpcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ2NoYW5uZWw6cmVhZDpzdWJzY3JpcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3Rlcl9pZDogVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChicm9hZGNhc3RlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJzLm1hcChVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhLm1hcChmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IEhlbGl4U3Vic2NyaXB0aW9uXzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc3Vic2NyaXB0aW9uIGRhdGEgZm9yIGEgZ2l2ZW4gdXNlciB0byBhIGdpdmVuIGJyb2FkY2FzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB0byBjaGVjay5cbiAgICAgKi9cbiAgICBIZWxpeFN1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9uRm9yVXNlciA9IGZ1bmN0aW9uIChicm9hZGNhc3RlciwgdXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsaXN0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0U3Vic2NyaXB0aW9uc0ZvclVzZXJzKGJyb2FkY2FzdGVyLCBbdXNlcl0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsaXN0Lmxlbmd0aCA/IGxpc3RbMF0gOiBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1vc3QgcmVjZW50IHN1YnNjcmlwdGlvbiBldmVudHMgZm9yIGEgZ2l2ZW4gYnJvYWRjYXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIHRvIHJldHJpZXZlIHN1YnNjcmlwdGlvbiBldmVudHMgZm9yLlxuICAgICAqL1xuICAgIEhlbGl4U3Vic2NyaXB0aW9uQVBJLnByb3RvdHlwZS5nZXRTdWJzY3JpcHRpb25FdmVudHNGb3JCcm9hZGNhc3RlciA9IGZ1bmN0aW9uIChicm9hZGNhc3Rlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9nZXRTdWJzY3JpcHRpb25FdmVudHMoJ2Jyb2FkY2FzdGVyX2lkJywgVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChicm9hZGNhc3RlcikpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYWdpbmF0b3IgZm9yIHRoZSByZWNlbnQgc3Vic2NyaXB0aW9uIGV2ZW50cyBmb3IgYSBnaXZlbiBicm9hZGNhc3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBicm9hZGNhc3RlciBUaGUgYnJvYWRjYXN0ZXIgdG8gcmV0cmlldmUgc3Vic2NyaXB0aW9uIGV2ZW50cyBmb3IuXG4gICAgICovXG4gICAgSGVsaXhTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvbkV2ZW50c0ZvckJyb2FkY2FzdGVyUGFnaW5hdGVkID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICdzdWJzY3JpcHRpb25zL2V2ZW50cycsXG4gICAgICAgICAgICBzY29wZTogJ2NoYW5uZWw6cmVhZDpzdWJzY3JpcHRpb25zJyxcbiAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0ZXJfaWQ6IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoYnJvYWRjYXN0ZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX2NsaWVudCwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50XzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIGV2ZW50IGJ5IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSBldmVudCBJRC5cbiAgICAgKi9cbiAgICBIZWxpeFN1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9uRXZlbnRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2dldFN1YnNjcmlwdGlvbkV2ZW50cygnaWQnLCBpZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVsaXhTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLl9nZXRTdWJzY3JpcHRpb25FdmVudHMgPSBmdW5jdGlvbiAoYnksIGlkKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnc3Vic2NyaXB0aW9ucy9ldmVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnY2hhbm5lbDpyZWFkOnN1YnNjcmlwdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FbYnldID0gaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgSGVsaXhQYWdpbmF0ZWRSZXN1bHRfMS5jcmVhdGVQYWdpbmF0ZWRSZXN1bHQocmVzdWx0LCBIZWxpeFN1YnNjcmlwdGlvbkV2ZW50XzEuZGVmYXVsdCwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEhlbGl4U3Vic2NyaXB0aW9uQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhTdWJzY3JpcHRpb25BUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFN1YnNjcmlwdGlvbkFQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4U3Vic2NyaXB0aW9uQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBIZWxsRnJlZXplc092ZXJFcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0Vycm9ycy9IZWxsRnJlZXplc092ZXJFcnJvclwiKTtcbnZhciBVc2VyVG9vbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ub29sa2l0L1VzZXJUb29sc1wiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ud2l0Y2hDbGllbnRcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uLy4uL0Jhc2VBUElcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsXzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsXCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXN1bHRcIik7XG52YXIgSGVsaXhGb2xsb3dfMSA9IHJlcXVpcmUoXCIuL0hlbGl4Rm9sbG93XCIpO1xudmFyIEhlbGl4UHJpdmlsZWdlZFVzZXJfMSA9IHJlcXVpcmUoXCIuL0hlbGl4UHJpdmlsZWdlZFVzZXJcIik7XG52YXIgSGVsaXhVc2VyXzEgPSByZXF1aXJlKFwiLi9IZWxpeFVzZXJcIik7XG4vKiogQHByaXZhdGUgKi9cbnZhciBVc2VyTG9va3VwVHlwZTtcbihmdW5jdGlvbiAoVXNlckxvb2t1cFR5cGUpIHtcbiAgICBVc2VyTG9va3VwVHlwZVtcIklkXCJdID0gXCJpZFwiO1xuICAgIFVzZXJMb29rdXBUeXBlW1wiTG9naW5cIl0gPSBcImxvZ2luXCI7XG59KShVc2VyTG9va3VwVHlwZSB8fCAoVXNlckxvb2t1cFR5cGUgPSB7fSkpO1xuZXhwb3J0cy5Vc2VyTG9va3VwVHlwZSA9IFVzZXJMb29rdXBUeXBlO1xuLyoqXG4gKiBUaGUgSGVsaXggQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggdXNlcnMuXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQuaGVsaXgudXNlcnNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCB1c2VyID0gYXdhaXQgY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeUlkKCcxMjUzMjg2NTUnKTtcbiAqIGBgYFxuICovXG52YXIgSGVsaXhVc2VyQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4VXNlckFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxpeFVzZXJBUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgZm9yIHRoZSBnaXZlbiBsaXN0IG9mIHVzZXIgSURzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJJZHMgVGhlIHVzZXIgSURzIHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICovXG4gICAgSGVsaXhVc2VyQVBJLnByb3RvdHlwZS5nZXRVc2Vyc0J5SWRzID0gZnVuY3Rpb24gKHVzZXJJZHMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0VXNlcnMoVXNlckxvb2t1cFR5cGUuSWQsIHVzZXJJZHMubWFwKFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQpKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHVzZXIgZGF0YSBmb3IgdGhlIGdpdmVuIGxpc3Qgb2YgdXNlciBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyTmFtZXMgVGhlIHVzZXIgbmFtZXMgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKi9cbiAgICBIZWxpeFVzZXJBUEkucHJvdG90eXBlLmdldFVzZXJzQnlOYW1lcyA9IGZ1bmN0aW9uICh1c2VyTmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0VXNlcnMoVXNlckxvb2t1cFR5cGUuTG9naW4sIHVzZXJOYW1lcy5tYXAoVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJOYW1lKSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgZm9yIHRoZSBnaXZlbiB1c2VyIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJJZCBUaGUgdXNlciBJRCB5b3Ugd2FudCB0byBsb29rIHVwLlxuICAgICAqL1xuICAgIEhlbGl4VXNlckFQSS5wcm90b3R5cGUuZ2V0VXNlckJ5SWQgPSBmdW5jdGlvbiAodXNlcklkKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldFVzZXJzKFVzZXJMb29rdXBUeXBlLklkLCBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXJJZCkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdXNlcnMubGVuZ3RoID8gdXNlcnNbMF0gOiBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHVzZXIgZGF0YSBmb3IgdGhlIGdpdmVuIHVzZXIgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyTmFtZSBUaGUgdXNlciBuYW1lIHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICovXG4gICAgSGVsaXhVc2VyQVBJLnByb3RvdHlwZS5nZXRVc2VyQnlOYW1lID0gZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldFVzZXJzKFVzZXJMb29rdXBUeXBlLkxvZ2luLCBVc2VyVG9vbHNfMS5leHRyYWN0VXNlck5hbWUodXNlck5hbWUpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVzZXJzLmxlbmd0aCA/IHVzZXJzWzBdIDogbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgb2YgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2l0aEVtYWlsIFdoZXRoZXIgeW91IG5lZWQgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICAgICAqL1xuICAgIEhlbGl4VXNlckFQSS5wcm90b3R5cGUuZ2V0TWUgPSBmdW5jdGlvbiAod2l0aEVtYWlsKSB7XG4gICAgICAgIGlmICh3aXRoRW1haWwgPT09IHZvaWQgMCkgeyB3aXRoRW1haWwgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3VzZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogd2l0aEVtYWlsID8gJ3VzZXI6cmVhZDplbWFpbCcgOiAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5kYXRhIHx8ICFyZXN1bHQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSGVsbEZyZWV6ZXNPdmVyRXJyb3JfMS5kZWZhdWx0KCdDb3VsZCBub3QgZ2V0IGF1dGhlbnRpY2F0ZWQgdXNlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBIZWxpeFByaXZpbGVnZWRVc2VyXzEuZGVmYXVsdChyZXN1bHQuZGF0YVswXSwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlcidzIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byB1cGRhdGUuXG4gICAgICovXG4gICAgSGVsaXhVc2VyQVBJLnByb3RvdHlwZS51cGRhdGVVc2VyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICd1c2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ3VzZXI6ZWRpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRhdGEuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgSGVsaXhQcml2aWxlZ2VkVXNlcl8xLmRlZmF1bHQocmVzdWx0LmRhdGFbMF0sIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgZm9sbG93IHJlbGF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgU2V2ZXJhbCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb24gcGFyYW1ldGVycy4gU2VlIHRoZSB7QEhlbGl4Rm9sbG93RmlsdGVyfSBkb2N1bWVudGF0aW9uLlxuICAgICAqL1xuICAgIEhlbGl4VXNlckFQSS5wcm90b3R5cGUuZ2V0Rm9sbG93cyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnksIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBIZWxpeFVzZXJBUEkuX21ha2VGb2xsb3dzUXVlcnkoZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAndXNlcnMvZm9sbG93cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBIZWxpeFBhZ2luYXRlZFJlc3VsdF8xLmNyZWF0ZVBhZ2luYXRlZFJlc3VsdFdpdGhUb3RhbChyZXN1bHQsIEhlbGl4Rm9sbG93XzEuZGVmYXVsdCwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgZm9sbG93IHJlbGF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgU2V2ZXJhbCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb24gcGFyYW1ldGVycy4gU2VlIHRoZSB7QEhlbGl4Rm9sbG93RmlsdGVyfSBkb2N1bWVudGF0aW9uLlxuICAgICAqL1xuICAgIEhlbGl4VXNlckFQSS5wcm90b3R5cGUuZ2V0Rm9sbG93c1BhZ2luYXRlZCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gSGVsaXhVc2VyQVBJLl9tYWtlRm9sbG93c1F1ZXJ5KGZpbHRlcik7XG4gICAgICAgIHJldHVybiBuZXcgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0V2l0aFRvdGFsXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICB1cmw6ICd1c2Vycy9mb2xsb3dzJyxcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgICAgICB9LCB0aGlzLl9jbGllbnQsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgSGVsaXhGb2xsb3dfMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICB9O1xuICAgIEhlbGl4VXNlckFQSS5fbWFrZUZvbGxvd3NRdWVyeSA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0ge307XG4gICAgICAgIHZhciBoYXNVc2VySWRQYXJhbSA9IGZhbHNlO1xuICAgICAgICBpZiAoZmlsdGVyLnVzZXIpIHtcbiAgICAgICAgICAgIHF1ZXJ5LmZyb21faWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGZpbHRlci51c2VyKTtcbiAgICAgICAgICAgIGhhc1VzZXJJZFBhcmFtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyLmZvbGxvd2VkVXNlcikge1xuICAgICAgICAgICAgcXVlcnkudG9faWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGZpbHRlci5mb2xsb3dlZFVzZXIpO1xuICAgICAgICAgICAgaGFzVXNlcklkUGFyYW0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzVXNlcklkUGFyYW0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F0IGxlYXN0IG9uZSBvZiB1c2VyIGFuZCBmb2xsb3dlZFVzZXIgaGF2ZSB0byBiZSBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfTtcbiAgICBIZWxpeFVzZXJBUEkucHJvdG90eXBlLl9nZXRVc2VycyA9IGZ1bmN0aW9uIChsb29rdXBUeXBlLCBwYXJhbSkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSwgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSAoX2EgPSB7fSwgX2FbbG9va3VwVHlwZV0gPSBwYXJhbSwgX2EpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUd2l0Y2hDbGllbnRfMS5Ud2l0Y2hBUElDYWxsVHlwZS5IZWxpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAndXNlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQuZGF0YS5tYXAoZnVuY3Rpb24gKHVzZXJEYXRhKSB7IHJldHVybiBuZXcgSGVsaXhVc2VyXzEuZGVmYXVsdCh1c2VyRGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVsaXhVc2VyQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhVc2VyQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhVc2VyQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Vc2VyTG9va3VwVHlwZSA9IFVzZXJMb29rdXBUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhVc2VyQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBVc2VyVG9vbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ub29sa2l0L1VzZXJUb29sc1wiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Ud2l0Y2hDbGllbnRcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uLy4uL0Jhc2VBUElcIik7XG52YXIgSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vSGVsaXhQYWdpbmF0ZWRSZXF1ZXN0XCIpO1xudmFyIEhlbGl4UGFnaW5hdGlvbl8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGlvblwiKTtcbnZhciBIZWxpeFZpZGVvXzEgPSByZXF1aXJlKFwiLi9IZWxpeFZpZGVvXCIpO1xuLyoqXG4gKiBUaGUgSGVsaXggQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggdmlkZW9zLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmhlbGl4LnZpZGVvc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IHZpZGVvcyA9IGF3YWl0IGNsaWVudC5oZWxpeC52aWRlb3MuZ2V0VmlkZW9zQnlVc2VyKCcxMjUzMjg2NTUnKTtcbiAqIGBgYFxuICovXG52YXIgSGVsaXhWaWRlb0FQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIZWxpeFZpZGVvQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlbGl4VmlkZW9BUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2aWRlbyBkYXRhIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiB2aWRlbyBJRHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWRzIFRoZSB2aWRlbyBJRHMgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKi9cbiAgICBIZWxpeFZpZGVvQVBJLnByb3RvdHlwZS5nZXRWaWRlb3NCeUlkcyA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldFZpZGVvcygnaWQnLCBpZHMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZpZGVvIGRhdGEgZm9yIHRoZSBnaXZlbiB2aWRlbyBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdmlkZW8gSUQgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKi9cbiAgICBIZWxpeFZpZGVvQVBJLnByb3RvdHlwZS5nZXRWaWRlb0J5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlkZW9zO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0VmlkZW9zQnlJZHMoaWQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9zID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZpZGVvcy5sZW5ndGggPyB2aWRlb3NbMF0gOiBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZpZGVvcyBvZiB0aGUgZ2l2ZW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIHJldHJpZXZlIHZpZGVvcyBmcm9tLlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgQWRkaXRpb25hbCBmaWx0ZXJzIGZvciB0aGUgcmVzdWx0IHNldC5cbiAgICAgKi9cbiAgICBIZWxpeFZpZGVvQVBJLnByb3RvdHlwZS5nZXRWaWRlb3NCeVVzZXIgPSBmdW5jdGlvbiAodXNlciwgZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9nZXRWaWRlb3MoJ3VzZXJfaWQnLCB1c2VySWQsIGZpbHRlcildO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhZ2luYXRvciBmb3IgdmlkZW9zIG9mIHRoZSBnaXZlbiB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgeW91IHdhbnQgdG8gcmV0cmlldmUgdmlkZW9zIGZyb20uXG4gICAgICogQHBhcmFtIGZpbHRlciBBZGRpdGlvbmFsIGZpbHRlcnMgZm9yIHRoZSByZXN1bHQgc2V0LlxuICAgICAqL1xuICAgIEhlbGl4VmlkZW9BUEkucHJvdG90eXBlLmdldFZpZGVvc0J5VXNlclBhZ2luYXRlZCA9IGZ1bmN0aW9uICh1c2VyLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7IGZpbHRlciA9IHt9OyB9XG4gICAgICAgIHZhciB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VmlkZW9zUGFnaW5hdGVkKCd1c2VyX2lkJywgdXNlcklkLCBmaWx0ZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2aWRlb3Mgb2YgdGhlIGdpdmVuIGdhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2FtZUlkIFRoZSBnYW1lIHlvdSB3YW50IHRvIHJldHJpZXZlIHZpZGVvcyBmcm9tLlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgQWRkaXRpb25hbCBmaWx0ZXJzIGZvciB0aGUgcmVzdWx0IHNldC5cbiAgICAgKi9cbiAgICBIZWxpeFZpZGVvQVBJLnByb3RvdHlwZS5nZXRWaWRlb3NCeUdhbWUgPSBmdW5jdGlvbiAoZ2FtZUlkLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7IGZpbHRlciA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2dldFZpZGVvcygnZ2FtZV9pZCcsIGdhbWVJZCwgZmlsdGVyKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFnaW5hdG9yIGZvciB2aWRlb3Mgb2YgdGhlIGdpdmVuIGdhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2FtZUlkIFRoZSBnYW1lIHlvdSB3YW50IHRvIHJldHJpZXZlIHZpZGVvcyBmcm9tLlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgQWRkaXRpb25hbCBmaWx0ZXJzIGZvciB0aGUgcmVzdWx0IHNldC5cbiAgICAgKi9cbiAgICBIZWxpeFZpZGVvQVBJLnByb3RvdHlwZS5nZXRWaWRlb3NCeUdhbWVQYWdpbmF0ZWQgPSBmdW5jdGlvbiAoZ2FtZUlkLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7IGZpbHRlciA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRWaWRlb3NQYWdpbmF0ZWQoJ2dhbWVfaWQnLCBnYW1lSWQsIGZpbHRlcik7XG4gICAgfTtcbiAgICBIZWxpeFZpZGVvQVBJLnByb3RvdHlwZS5fZ2V0VmlkZW9zID0gZnVuY3Rpb24gKGZpbHRlclR5cGUsIGZpbHRlclZhbHVlcywgZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICd2aWRlb3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aXRjaENsaWVudF8xLlR3aXRjaEFQSUNhbGxUeXBlLkhlbGl4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIEhlbGl4VmlkZW9BUEkuX21ha2VWaWRlb3NRdWVyeShmaWx0ZXJUeXBlLCBmaWx0ZXJWYWx1ZXMsIGZpbHRlcikpLCBIZWxpeFBhZ2luYXRpb25fMS5tYWtlUGFnaW5hdGlvblF1ZXJ5KGZpbHRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLm1hcChmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IEhlbGl4VmlkZW9fMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiByZXN1bHQucGFnaW5hdGlvbiAmJiByZXN1bHQucGFnaW5hdGlvbi5jdXJzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFZpZGVvQVBJLnByb3RvdHlwZS5fZ2V0VmlkZW9zUGFnaW5hdGVkID0gZnVuY3Rpb24gKGZpbHRlclR5cGUsIGZpbHRlclZhbHVlcywgZmlsdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSB7fTsgfVxuICAgICAgICByZXR1cm4gbmV3IEhlbGl4UGFnaW5hdGVkUmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgdXJsOiAndmlkZW9zJyxcbiAgICAgICAgICAgIHF1ZXJ5OiBIZWxpeFZpZGVvQVBJLl9tYWtlVmlkZW9zUXVlcnkoZmlsdGVyVHlwZSwgZmlsdGVyVmFsdWVzLCBmaWx0ZXIpXG4gICAgICAgIH0sIHRoaXMuX2NsaWVudCwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBIZWxpeFZpZGVvXzEuZGVmYXVsdChkYXRhLCBfdGhpcy5fY2xpZW50KTsgfSk7XG4gICAgfTtcbiAgICBIZWxpeFZpZGVvQVBJLl9tYWtlVmlkZW9zUXVlcnkgPSBmdW5jdGlvbiAoZmlsdGVyVHlwZSwgZmlsdGVyVmFsdWVzLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0ge307IH1cbiAgICAgICAgdmFyIGxhbmd1YWdlID0gZmlsdGVyLmxhbmd1YWdlLCBwZXJpb2QgPSBmaWx0ZXIucGVyaW9kLCBvcmRlckJ5ID0gZmlsdGVyLm9yZGVyQnksIHR5cGUgPSBmaWx0ZXIudHlwZTtcbiAgICAgICAgcmV0dXJuIF9hID0ge30sXG4gICAgICAgICAgICBfYVtmaWx0ZXJUeXBlXSA9IGZpbHRlclZhbHVlcyxcbiAgICAgICAgICAgIF9hLmxhbmd1YWdlID0gbGFuZ3VhZ2UsXG4gICAgICAgICAgICBfYS5wZXJpb2QgPSBwZXJpb2QsXG4gICAgICAgICAgICBfYS5zb3J0ID0gb3JkZXJCeSxcbiAgICAgICAgICAgIF9hLnR5cGUgPSB0eXBlLFxuICAgICAgICAgICAgX2E7XG4gICAgfTtcbiAgICByZXR1cm4gSGVsaXhWaWRlb0FQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4VmlkZW9BUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFZpZGVvQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhWaWRlb0FQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgVXNlclRvb2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVG9vbGtpdC9Vc2VyVG9vbHNcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVHdpdGNoQ2xpZW50XCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIEhlbGl4UGFnaW5hdGVkUmVxdWVzdFdpdGhUb3RhbF8xID0gcmVxdWlyZShcIi4uL0hlbGl4UGFnaW5hdGVkUmVxdWVzdFdpdGhUb3RhbFwiKTtcbnZhciBIZWxpeFdlYkhvb2tTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuL0hlbGl4V2ViSG9va1N1YnNjcmlwdGlvblwiKTtcbi8qKlxuICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIFdlYkhvb2tzLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmhlbGl4LndlYkhvb2tzYCBvbiBhIHtAVHdpdGNoQ2xpZW50fSBpbnN0YW5jZS5cbiAqXG4gKiAjIyBCZWZvcmUgdXNpbmcgdGhlc2UgbWV0aG9kcy4uLlxuICpcbiAqIEFsbCBvZiB0aGUgbWV0aG9kcyBpbiB0aGlzIGNsYXNzIGFzc3VtZSB0aGF0IHlvdSBhcmUgYWxyZWFkeSBydW5uaW5nIGEgd29ya2luZyBXZWJIb29rIGxpc3RlbmVyIGF0IHRoZSBnaXZlbiBjYWxsYmFjayBVUkwuXG4gKlxuICogSWYgeW91IGRvbid0IGFscmVhZHkgaGF2ZSBvbmUsIHdlIHJlY29tbWVuZCB1c2Ugb2YgdGhlIGB0d2l0Y2gtd2ViaG9va3NgIGxpYnJhcnksIHdoaWNoIGhhbmRsZXMgc3Vic2NyaWJpbmcgYW5kIHVuc3Vic2NyaWJpbmcgdG8gdGhlc2UgdG9waWNzIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IGFjY2VwdGVkID0gYXdhaXQgY2xpZW50LmhlbGl4LndlYkhvb2tzLnN1YnNjcmliZVRvVXNlckZvbGxvd3NUbygnMTI1MzI4NjU1JywgeyBjYWxsYmFja1VybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20nIH0pO1xuICogYGBgXG4gKi9cbnZhciBIZWxpeFdlYkhvb2tzQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEhlbGl4V2ViSG9va3NBUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVsaXhXZWJIb29rc0FQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgV2ViSG9vayBzdWJzY3JpcHRpb25zIGZvciB0aGUgY3VycmVudCBjbGllbnQuXG4gICAgICpcbiAgICAgKiBSZXF1aXJlcyBhbiBhcHAgYWNjZXNzIHRva2VuIHRvIHdvcms7IGRvZXMgbm90IHdvcmsgd2l0aCB1c2VyIHRva2Vucy5cbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5nZXRTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEhlbGl4UGFnaW5hdGVkUmVxdWVzdFdpdGhUb3RhbF8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnd2ViaG9va3Mvc3Vic2NyaXB0aW9ucydcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5fY2xpZW50LCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IEhlbGl4V2ViSG9va1N1YnNjcmlwdGlvbl8xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGFyYml0cmFyeSByZXF1ZXN0IHRvIHN1YnNjcmliZSB0byBvciB1bnN1YnNjcmliZSBmcm9tIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnNlbmRIdWJSZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbW9kZSwgY2FsbGJhY2tVcmwsIHRvcGljVXJsLCBfYSwgdmFsaWRpdHlJblNlY29uZHMsIHNlY3JldCwgc2NvcGU7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBvcHRpb25zLm1vZGUsIGNhbGxiYWNrVXJsID0gb3B0aW9ucy5jYWxsYmFja1VybCwgdG9waWNVcmwgPSBvcHRpb25zLnRvcGljVXJsLCBfYSA9IG9wdGlvbnMudmFsaWRpdHlJblNlY29uZHMsIHZhbGlkaXR5SW5TZWNvbmRzID0gX2EgPT09IHZvaWQgMCA/IDM2MDAgOiBfYSwgc2VjcmV0ID0gb3B0aW9ucy5zZWNyZXQsIHNjb3BlID0gb3B0aW9ucy5zY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnd2ViaG9va3MvaHViJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuSGVsaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25Cb2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHViLm1vZGUnOiBtb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h1Yi50b3BpYyc6IHRvcGljVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h1Yi5jYWxsYmFjayc6IGNhbGxiYWNrVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h1Yi5sZWFzZV9zZWNvbmRzJzogbW9kZSA9PT0gJ3N1YnNjcmliZScgPyB2YWxpZGl0eUluU2Vjb25kcy50b1N0cmluZygpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h1Yi5zZWNyZXQnOiBzZWNyZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gZXZlbnRzIHJlcHJlc2VudGluZyBhIHVzZXIgZm9sbG93aW5nIG90aGVyIHVzZXJzLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgZm9yIHdoaWNoIHRvIGdldCBub3RpZmljYXRpb25zIGFib3V0IHRoZSB1c2VycyB0aGV5IHdpbGwgZm9sbG93LlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUuc3Vic2NyaWJlVG9Vc2VyRm9sbG93c0Zyb20gPSBmdW5jdGlvbiAodXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kVXNlckZvbGxvd3NIdWJSZXF1ZXN0KCdzdWJzY3JpYmUnLCAnZnJvbScsIHVzZXIsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gZXZlbnRzIHJlcHJlc2VudGluZyBhIHVzZXIgYmVpbmcgZm9sbG93ZWQgYnkgb3RoZXIgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciBmb3Igd2hpY2ggdG8gZ2V0IG5vdGlmaWNhdGlvbnMgYWJvdXQgdGhlIHVzZXJzIHRoZXkgd2lsbCBiZSBmb2xsb3dlZCBieS5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnN1YnNjcmliZVRvVXNlckZvbGxvd3NUbyA9IGZ1bmN0aW9uICh1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRVc2VyRm9sbG93c0h1YlJlcXVlc3QoJ3N1YnNjcmliZScsICd0bycsIHVzZXIsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGV2ZW50cyByZXByZXNlbnRpbmcgYSB1c2VyIGZvbGxvd2luZyBvdGhlciB1c2Vycy5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIGZvciB3aGljaCB0byBub3QgZ2V0IGFueSBtb3JlIG5vdGlmaWNhdGlvbnMgYWJvdXQgdGhlIHVzZXJzIHRoZXkgd2lsbCBmb2xsb3cuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS51bnN1YnNjcmliZUZyb21Vc2VyRm9sbG93c0Zyb20gPSBmdW5jdGlvbiAodXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kVXNlckZvbGxvd3NIdWJSZXF1ZXN0KCd1bnN1YnNjcmliZScsICdmcm9tJywgdXNlciwgb3B0aW9ucyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gZXZlbnRzIHJlcHJlc2VudGluZyBhIHVzZXIgYmVpbmcgZm9sbG93ZWQgYnkgb3RoZXIgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciBmb3Igd2hpY2ggdG8gbm90IGdldCBhbnkgbW9yZSBub3RpZmljYXRpb25zIGFib3V0IHRoZSB1c2VycyB0aGV5IHdpbGwgYmUgZm9sbG93ZWQgYnkuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS51bnN1YnNjcmliZUZyb21Vc2VyRm9sbG93c1RvID0gZnVuY3Rpb24gKHVzZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fc2VuZFVzZXJGb2xsb3dzSHViUmVxdWVzdCgndW5zdWJzY3JpYmUnLCAndG8nLCB1c2VyLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGV2ZW50cyByZXByZXNlbnRpbmcgYSBzdHJlYW0gY2hhbmdpbmcsIGkuZS4gZ29pbmcgbGl2ZSwgb2ZmbGluZSBvciBjaGFuZ2luZyBpdHMgdGl0bGUgb3IgY2F0ZWdvcnkuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciBmb3Igd2hpY2ggdG8gZ2V0IG5vdGlmaWNhdGlvbnMgYWJvdXQgdGhlaXIgc3RyZWFtcyBjaGFuZ2luZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnN1YnNjcmliZVRvU3RyZWFtQ2hhbmdlcyA9IGZ1bmN0aW9uICh1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRTdHJlYW1DaGFuZ2VIdWJSZXF1ZXN0KCdzdWJzY3JpYmUnLCB1c2VyLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBldmVudHMgcmVwcmVzZW50aW5nIGEgc3RyZWFtIGNoYW5naW5nLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgZm9yIHdoaWNoIG5vdCB0byBnZXQgYW55IG1vcmUgbm90aWZpY2F0aW9ucyBhYm91dCB0aGVpciBzdHJlYW1zIGNoYW5naW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUudW5zdWJzY3JpYmVGcm9tU3RyZWFtQ2hhbmdlcyA9IGZ1bmN0aW9uICh1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRTdHJlYW1DaGFuZ2VIdWJSZXF1ZXN0KCd1bnN1YnNjcmliZScsIHVzZXIsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gZXZlbnRzIHJlcHJlc2VudGluZyBhIHVzZXIgY2hhbmdpbmcgYSBwdWJsaWMgc2V0dGluZyBvciB0aGVpciBlbWFpbCBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgZm9yIHdoaWNoIHRvIGdldCBub3RpZmljYXRpb25zIGFib3V0IGNoYW5naW5nIGEgc2V0dGluZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB3aXRoRW1haWwgV2hldGhlciB0byBzdWJzY3JpYmUgdG8gZW1haWwgYWRkcmVzcyBjaGFuZ2VzLiBUaGlzIGFkZHMgdGhlIG5lY2Vzc2FyeSBzY29wZSB0byByZWFkIHRoZSBlbWFpbCBhZGRyZXNzIHRvIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnN1YnNjcmliZVRvVXNlckNoYW5nZXMgPSBmdW5jdGlvbiAodXNlciwgb3B0aW9ucywgd2l0aEVtYWlsKSB7XG4gICAgICAgIGlmICh3aXRoRW1haWwgPT09IHZvaWQgMCkgeyB3aXRoRW1haWwgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kVXNlckNoYW5nZUh1YlJlcXVlc3QoJ3N1YnNjcmliZScsIHVzZXIsIG9wdGlvbnMsIHdpdGhFbWFpbCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gZXZlbnRzIHJlcHJlc2VudGluZyBhIHVzZXIgY2hhbmdpbmcgYSBwdWJsaWMgc2V0dGluZyBvciB0aGVpciBlbWFpbCBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgZm9yIHdoaWNoIG5vdCB0byBnZXQgYW55IG1vcmUgbm90aWZpY2F0aW9ucyBhYm91dCBjaGFuZ2luZyBhIHNldHRpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS51bnN1YnNjcmliZUZyb21Vc2VyQ2hhbmdlcyA9IGZ1bmN0aW9uICh1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRVc2VyQ2hhbmdlSHViUmVxdWVzdCgndW5zdWJzY3JpYmUnLCB1c2VyLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGV2ZW50cyByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIGNoYW5uZWwgc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgZm9yIHdoaWNoIHRvIGdldCBub3RpZmljYXRpb25zIGFib3V0IHN1YnNjcmlwdGlvbnMgdG8gdGhlaXIgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnN1YnNjcmliZVRvU3Vic2NyaXB0aW9uRXZlbnRzID0gZnVuY3Rpb24gKHVzZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fc2VuZFN1YnNjcmlwdGlvbkV2ZW50c0h1YlJlcXVlc3QoJ3N1YnNjcmliZScsIHVzZXIsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGV2ZW50cyByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIGNoYW5uZWwgc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgZm9yIHdoaWNoIG5vdCB0byBnZXQgYW55IG1vcmUgbm90aWZpY2F0aW9ucyBhYm91dCBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMgdG8gdGhlaXIgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnVuc3Vic2NyaWJlRnJvbVN1YnNjcmlwdGlvbkV2ZW50cyA9IGZ1bmN0aW9uICh1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRTdWJzY3JpcHRpb25FdmVudHNIdWJSZXF1ZXN0KCd1bnN1YnNjcmliZScsIHVzZXIsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gZXh0ZW5zaW9uIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHRlbnNpb25JZCBUaGUgZXh0ZW5zaW9uIElEIGZvciB3aGljaCB0byBnZXQgbm90aWZpY2F0aW9ucyBhYm91dCB0cmFuc2FjdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5zdWJzY3JpYmVUb0V4dGVuc2lvblRyYW5zYWN0aW9ucyA9IGZ1bmN0aW9uIChleHRlbnNpb25JZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kRXh0ZW5zaW9uVHJhbnNhY3Rpb25zSHViUmVxdWVzdCgnc3Vic2NyaWJlJywgZXh0ZW5zaW9uSWQsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGV4dGVuc2lvbiB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9uSWQgVGhlIGV4dGVuc2lvbiBJRCBmb3Igd2hpY2ggbm90IHRvIGdldCBhbnkgbW9yZSBub3RpZmljYXRpb25zIGFib3V0IHRyYW5zYWN0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnVuc3Vic2NyaWJlRnJvbUV4dGVuc2lvblRyYW5zYWN0aW9ucyA9IGZ1bmN0aW9uIChleHRlbnNpb25JZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kRXh0ZW5zaW9uVHJhbnNhY3Rpb25zSHViUmVxdWVzdCgndW5zdWJzY3JpYmUnLCBleHRlbnNpb25JZCwgb3B0aW9ucyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBldmVudHMgcmVwcmVzZW50aW5nIGEgYmFuIG9yIHVuYmFuLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciBmb3Igd2hpY2ggdG8gZ2V0IG5vdGlmaWNhdGlvbnMgYWJvdXQgYmFucyBvciB1bmJhbnMgaW4gdGhlaXIgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnN1YnNjcmliZVRvQmFuRXZlbnRzID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRCYW5FdmVudHNIdWJSZXF1ZXN0KCdzdWJzY3JpYmUnLCBicm9hZGNhc3Rlciwgb3B0aW9ucyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gZXZlbnRzIHJlcHJlc2VudGluZyBhIGJhbiBvciB1bmJhbi5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBicm9hZGNhc3RlciBUaGUgYnJvYWRjYXN0ZXIgZm9yIHdoaWNoIG5vdCB0byBnZXQgYW55IG1vcmUgbm90aWZpY2F0aW9ucyBhYm91dCBiYW5zIG9yIHVuYmFucyBpbiB0aGVpciBjaGFubmVsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUudW5zdWJzY3JpYmVGcm9tQmFuRXZlbnRzID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRCYW5FdmVudHNIdWJSZXF1ZXN0KCd1bnN1YnNjcmliZScsIGJyb2FkY2FzdGVyLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGV2ZW50cyByZXByZXNlbnRpbmcgYSBiYW4gb3IgdW5iYW4uXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIGZvciB3aGljaCB0byBnZXQgbm90aWZpY2F0aW9ucyBhYm91dCBiYW5zIG9yIHVuYmFucyBpbiB0aGVpciBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHRoYXQgaXMgYmVpbmcgYmFubmVkIG9yIHVuYmFubmVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUuc3Vic2NyaWJlVG9CYW5FdmVudHNGb3JVc2VyID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyLCB1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRCYW5FdmVudHNIdWJSZXF1ZXN0KCdzdWJzY3JpYmUnLCBicm9hZGNhc3Rlciwgb3B0aW9ucywgdXNlcildO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gZXZlbnRzIHJlcHJlc2VudGluZyBhIGJhbiBvciB1bmJhbi5cbiAgICAgKlxuICAgICAqIEBleHBhbmRQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBicm9hZGNhc3RlciBUaGUgYnJvYWRjYXN0ZXIgZm9yIHdoaWNoIG5vdCB0byBnZXQgYW55IG1vcmUgbm90aWZpY2F0aW9ucyBhYm91dCBiYW5zIG9yIHVuYmFucyBpbiB0aGVpciBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHRoYXQgaXMgYmVpbmcgYmFubmVkIG9yIHVuYmFubmVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUudW5zdWJzY3JpYmVGcm9tQmFuRXZlbnRzRm9yVXNlciA9IGZ1bmN0aW9uIChicm9hZGNhc3RlciwgdXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kQmFuRXZlbnRzSHViUmVxdWVzdCgndW5zdWJzY3JpYmUnLCBicm9hZGNhc3Rlciwgb3B0aW9ucywgdXNlcildO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBldmVudHMgcmVwcmVzZW50aW5nIGEgdXNlciBnYWluaW5nIG9yIGxvc2luZyBtb2RlcmF0b3IgcHJpdmlsZWdlcyBpbiBhIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIGZvciB3aGljaCB0byBnZXQgbm90aWZpY2F0aW9ucyBhYm91dCBtb2RlcmF0b3IgY2hhbmdlcyBpbiB0aGVpciBjaGFubmVsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUuc3Vic2NyaWJlVG9Nb2RlcmF0b3JFdmVudHMgPSBmdW5jdGlvbiAoYnJvYWRjYXN0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fc2VuZE1vZGVyYXRvckV2ZW50c0h1YlJlcXVlc3QoJ3N1YnNjcmliZScsIGJyb2FkY2FzdGVyLCBvcHRpb25zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBldmVudHMgcmVwcmVzZW50aW5nIGEgdXNlciBnYWluaW5nIG9yIGxvc2luZyBtb2RlcmF0b3IgcHJpdmlsZWdlcyBpbiBhIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIGZvciB3aGljaCBub3QgdG8gZ2V0IGFueSBtb3JlIG5vdGlmaWNhdGlvbnMgYWJvdXQgbW9kZXJhdG9yIGNoYW5nZXMgaW4gdGhlaXIgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLnVuc3Vic2NyaWJlRnJvbU1vZGVyYXRvckV2ZW50cyA9IGZ1bmN0aW9uIChicm9hZGNhc3Rlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kTW9kZXJhdG9yRXZlbnRzSHViUmVxdWVzdCgndW5zdWJzY3JpYmUnLCBicm9hZGNhc3Rlciwgb3B0aW9ucyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBldmVudHMgcmVwcmVzZW50aW5nIGEgdXNlciBnYWluaW5nIG9yIGxvc2luZyBtb2RlcmF0b3IgcHJpdmlsZWdlcyBpbiBhIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAZXhwYW5kUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJvYWRjYXN0ZXIgVGhlIGJyb2FkY2FzdGVyIGZvciB3aGljaCB0byBnZXQgbm90aWZpY2F0aW9ucyBhYm91dCBtb2RlcmF0b3IgY2hhbmdlcyBpbiB0aGVpciBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHRoYXQgaXMgYmVpbmcgbW9kZGVkIG9yIHVubW9kZGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rc0FQSS5wcm90b3R5cGUuc3Vic2NyaWJlVG9Nb2RlcmF0b3JFdmVudHNGb3JVc2VyID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyLCB1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRNb2RlcmF0b3JFdmVudHNIdWJSZXF1ZXN0KCdzdWJzY3JpYmUnLCBicm9hZGNhc3Rlciwgb3B0aW9ucywgdXNlcildO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gZXZlbnRzIHJlcHJlc2VudGluZyBhIHVzZXIgZ2FpbmluZyBvciBsb3NpbmcgbW9kZXJhdG9yIHByaXZpbGVnZXMgaW4gYSBjaGFubmVsLlxuICAgICAqXG4gICAgICogQGV4cGFuZFBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIGJyb2FkY2FzdGVyIFRoZSBicm9hZGNhc3RlciBmb3Igd2hpY2ggbm90IHRvIGdldCBhbnkgbW9yZSBub3RpZmljYXRpb25zIGFib3V0IG1vZGVyYXRvciBjaGFuZ2VzIGluIHRoZWlyIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgdGhhdCBpcyBiZWluZyBtb2RkZWQgb3IgdW5tb2RkZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS51bnN1YnNjcmliZUZyb21Nb2RlcmF0b3JFdmVudHNGb3JVc2VyID0gZnVuY3Rpb24gKGJyb2FkY2FzdGVyLCB1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3NlbmRNb2RlcmF0b3JFdmVudHNIdWJSZXF1ZXN0KCd1bnN1YnNjcmliZScsIGJyb2FkY2FzdGVyLCBvcHRpb25zLCB1c2VyKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5fc2VuZFVzZXJGb2xsb3dzSHViUmVxdWVzdCA9IGZ1bmN0aW9uIChtb2RlLCBkaXJlY3Rpb24sIHVzZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5zZW5kSHViUmVxdWVzdCh0c2xpYl8xLl9fYXNzaWduKHsgbW9kZTogbW9kZSwgdG9waWNVcmw6IFwiaHR0cHM6Ly9hcGkudHdpdGNoLnR2L2hlbGl4L3VzZXJzL2ZvbGxvd3M/Zmlyc3Q9MSZcIiArIGRpcmVjdGlvbiArIFwiX2lkPVwiICsgdXNlcklkIH0sIG9wdGlvbnMpKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5fc2VuZFN0cmVhbUNoYW5nZUh1YlJlcXVlc3QgPSBmdW5jdGlvbiAobW9kZSwgdXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnNlbmRIdWJSZXF1ZXN0KHRzbGliXzEuX19hc3NpZ24oeyBtb2RlOiBtb2RlLCB0b3BpY1VybDogXCJodHRwczovL2FwaS50d2l0Y2gudHYvaGVsaXgvc3RyZWFtcz91c2VyX2lkPVwiICsgdXNlcklkIH0sIG9wdGlvbnMpKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFdlYkhvb2tzQVBJLnByb3RvdHlwZS5fc2VuZFVzZXJDaGFuZ2VIdWJSZXF1ZXN0ID0gZnVuY3Rpb24gKG1vZGUsIHVzZXIsIG9wdGlvbnMsIHdpdGhFbWFpbCkge1xuICAgICAgICBpZiAod2l0aEVtYWlsID09PSB2b2lkIDApIHsgd2l0aEVtYWlsID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5zZW5kSHViUmVxdWVzdCh0c2xpYl8xLl9fYXNzaWduKHsgbW9kZTogbW9kZSwgdG9waWNVcmw6IFwiaHR0cHM6Ly9hcGkudHdpdGNoLnR2L2hlbGl4L3VzZXJzP2lkPVwiICsgdXNlcklkLCBzY29wZTogd2l0aEVtYWlsID8gJ3VzZXI6cmVhZDplbWFpbCcgOiB1bmRlZmluZWQgfSwgb3B0aW9ucykpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLl9zZW5kU3Vic2NyaXB0aW9uRXZlbnRzSHViUmVxdWVzdCA9IGZ1bmN0aW9uIChtb2RlLCB1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuc2VuZEh1YlJlcXVlc3QodHNsaWJfMS5fX2Fzc2lnbih7IG1vZGU6IG1vZGUsIHRvcGljVXJsOiBcImh0dHBzOi8vYXBpLnR3aXRjaC50di9oZWxpeC9zdWJzY3JpcHRpb25zL2V2ZW50cz9icm9hZGNhc3Rlcl9pZD1cIiArIHVzZXJJZCArIFwiJmZpcnN0PTFcIiwgc2NvcGU6ICdjaGFubmVsOnJlYWQ6c3Vic2NyaXB0aW9ucycgfSwgb3B0aW9ucykpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLl9zZW5kRXh0ZW5zaW9uVHJhbnNhY3Rpb25zSHViUmVxdWVzdCA9IGZ1bmN0aW9uIChtb2RlLCBleHRlbnNpb25JZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnNlbmRIdWJSZXF1ZXN0KHRzbGliXzEuX19hc3NpZ24oeyBtb2RlOiBtb2RlLCB0b3BpY1VybDogXCJodHRwczovL2FwaS50d2l0Y2gudHYvaGVsaXgvZXh0ZW5zaW9ucy90cmFuc2FjdGlvbnM/ZXh0ZW5zaW9uX2lkPVwiICsgZXh0ZW5zaW9uSWQgKyBcIiZmaXJzdD0xXCIgfSwgb3B0aW9ucykpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLl9zZW5kQmFuRXZlbnRzSHViUmVxdWVzdCA9IGZ1bmN0aW9uIChtb2RlLCBicm9hZGNhc3Rlciwgb3B0aW9ucywgdXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBicm9hZGNhc3RlcklkLCB0b3BpY1VybDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdGVySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGJyb2FkY2FzdGVyKTtcbiAgICAgICAgICAgICAgICB0b3BpY1VybCA9IFwiaHR0cHM6Ly9hcGkudHdpdGNoLnR2L2hlbGl4L21vZGVyYXRpb24vYmFubmVkL2V2ZW50cz9icm9hZGNhc3Rlcl9pZD1cIiArIGJyb2FkY2FzdGVySWQgKyBcIiZmaXJzdD0xXCI7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNVcmwgKz0gXCImdXNlcl9pZD1cIiArIFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnNlbmRIdWJSZXF1ZXN0KHRzbGliXzEuX19hc3NpZ24oeyBtb2RlOiBtb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWNVcmw6IHRvcGljVXJsLCBzY29wZTogJ21vZGVyYXRpb246cmVhZCcgfSwgb3B0aW9ucykpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhlbGl4V2ViSG9va3NBUEkucHJvdG90eXBlLl9zZW5kTW9kZXJhdG9yRXZlbnRzSHViUmVxdWVzdCA9IGZ1bmN0aW9uIChtb2RlLCBicm9hZGNhc3Rlciwgb3B0aW9ucywgdXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBicm9hZGNhc3RlcklkLCB0b3BpY1VybDtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdGVySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGJyb2FkY2FzdGVyKTtcbiAgICAgICAgICAgICAgICB0b3BpY1VybCA9IFwiaHR0cHM6Ly9hcGkudHdpdGNoLnR2L2hlbGl4L21vZGVyYXRpb24vbW9kZXJhdG9ycy9ldmVudHM/YnJvYWRjYXN0ZXJfaWQ9XCIgKyBicm9hZGNhc3RlcklkICsgXCImZmlyc3Q9MVwiO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljVXJsICs9IFwiJnVzZXJfaWQ9XCIgKyBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5zZW5kSHViUmVxdWVzdCh0c2xpYl8xLl9fYXNzaWduKHsgbW9kZTogbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljVXJsOiB0b3BpY1VybCwgc2NvcGU6ICdtb2RlcmF0aW9uOnJlYWQnIH0sIG9wdGlvbnMpKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVsaXhXZWJIb29rc0FQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4V2ViSG9va3NBUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIZWxpeFdlYkhvb2tzQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGVsaXhXZWJIb29rc0FQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2hhcmVkX3V0aWxzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9zaGFyZWQtdXRpbHNcIik7XG4vKipcbiAqIEEgc3Vic2NyaXB0aW9uIHRvIGEgVHdpdGNoIFdlYkhvb2suXG4gKi9cbnZhciBIZWxpeFdlYkhvb2tTdWJzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gSGVsaXhXZWJIb29rU3Vic2NyaXB0aW9uKF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWxpeFdlYkhvb2tTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcInRvcGljVXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3BpYyB0aGUgV2ViSG9vayBpcyBsaXN0ZW5pbmcgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnRvcGljO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhXZWJIb29rU3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJjYWxsYmFja1VybFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIHRoYXQgd2lsbCBiZSBjYWxsZWQgZm9yIGV2ZXJ5IHN1YnNjcmliZWQgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmNhbGxiYWNrO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVsaXhXZWJIb29rU3Vic2NyaXB0aW9uLnByb3RvdHlwZSwgXCJleHBpcnlEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGV4cGlyZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2RhdGEuZXhwaXJlc19hdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIFdlYkhvb2suXG4gICAgICovXG4gICAgSGVsaXhXZWJIb29rU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmhlbGl4LndlYkhvb2tzLnNlbmRIdWJSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICd1bnN1YnNjcmliZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpY1VybDogdGhpcy50b3BpY1VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsOiB0aGlzLmNhbGxiYWNrVXJsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBIZWxpeFdlYkhvb2tTdWJzY3JpcHRpb24ucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gSGVsaXhXZWJIb29rU3Vic2NyaXB0aW9uO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4V2ViSG9va1N1YnNjcmlwdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEhlbGl4V2ViSG9va1N1YnNjcmlwdGlvbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4V2ViSG9va1N1YnNjcmlwdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgcmF0ZV9saW1pdGVyXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9yYXRlLWxpbWl0ZXJcIik7XG52YXIgVHdpdGNoQ2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vVHdpdGNoQ2xpZW50XCIpO1xudmFyIEhlbGl4UmF0ZUxpbWl0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGVsaXhSYXRlTGltaXRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWxpeFJhdGVMaW1pdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEhlbGl4UmF0ZUxpbWl0ZXIucHJvdG90eXBlLmRvUmVxdWVzdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIGNsaWVudElkID0gX2EuY2xpZW50SWQsIGFjY2Vzc1Rva2VuID0gX2EuYWNjZXNzVG9rZW47XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFR3aXRjaENsaWVudF8xLmRlZmF1bHQuX2NhbGxBUElSYXcob3B0aW9ucywgY2xpZW50SWQsIGFjY2Vzc1Rva2VuKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIZWxpeFJhdGVMaW1pdGVyLnByb3RvdHlwZS5uZWVkc1RvUmV0cnlBZnRlciA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgICAgcmV0dXJuICtyZXMuaGVhZGVycy5nZXQoJ3JhdGVsaW1pdC1yZXNldCcpICogMTAwMCAtIERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBIZWxpeFJhdGVMaW1pdGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzRnJvbVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICB2YXIgaGVhZGVycyA9IHJlcy5oZWFkZXJzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGltaXQ6ICtoZWFkZXJzLmdldCgncmF0ZWxpbWl0LWxpbWl0JyksXG4gICAgICAgICAgICByZW1haW5pbmc6ICtoZWFkZXJzLmdldCgncmF0ZWxpbWl0LXJlbWFpbmluZycpLFxuICAgICAgICAgICAgcmVzZXRzQXQ6ICtoZWFkZXJzLmdldCgncmF0ZWxpbWl0LXJlc2V0JykgKiAxMDAwXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSGVsaXhSYXRlTGltaXRlcjtcbn0ocmF0ZV9saW1pdGVyXzEuUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxpeFJhdGVMaW1pdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSGVsaXhSYXRlTGltaXRlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbGl4UmF0ZUxpbWl0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXNwb25zZUJhc2VkUmF0ZUxpbWl0ZXJfMSA9IHJlcXVpcmUoXCIuL1Jlc3BvbnNlQmFzZWRSYXRlTGltaXRlclwiKTtcbmV4cG9ydHMuUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyID0gUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyXzEuUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyO1xudmFyIFJldHJ5QWZ0ZXJFcnJvcl8xID0gcmVxdWlyZShcIi4vUmV0cnlBZnRlckVycm9yXCIpO1xuZXhwb3J0cy5SZXRyeUFmdGVyRXJyb3IgPSBSZXRyeUFmdGVyRXJyb3JfMS5SZXRyeUFmdGVyRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvbG9nZ2VyXCIpO1xudmFyIHByb21pc2VfYWxsc2V0dGxlZF8xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvcHJvbWlzZS5hbGxzZXR0bGVkXCIpO1xudmFyIFJldHJ5QWZ0ZXJFcnJvcl8xID0gcmVxdWlyZShcIi4vUmV0cnlBZnRlckVycm9yXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnZhciBSZXNwb25zZUJhc2VkUmF0ZUxpbWl0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyKGxvZ0xldmVsKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX2JhdGNoUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sb2dnZXIgPSBuZXcgbG9nZ2VyXzEuTG9nZ2VyKHsgbmFtZTogJ3JhdGUtbGltaXRlcicsIG1pbkxldmVsOiBsb2dMZXZlbCwgZW1vamk6IHRydWUgfSk7XG4gICAgfVxuICAgIFJlc3BvbnNlQmFzZWRSYXRlTGltaXRlci5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFTcGVjID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcTogcmVxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2JhdGNoUnVubmluZyB8fCBfdGhpcy5fbmV4dEJhdGNoVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcXVldWUucHVzaChyZXFTcGVjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ydW5SZXF1ZXN0QmF0Y2goW3JlcVNwZWNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyLnByb3RvdHlwZS5fcnVuUmVxdWVzdEJhdGNoID0gZnVuY3Rpb24gKHJlcVNwZWNzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzLCBzZXR0bGVkUHJvbWlzZXMsIHJlamVjdGVkUHJvbWlzZXMsIG5vdywgcmV0cnlBdCwgcmV0cnlBZnRlciwgcGFyYW1zLCBkZWxheTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhdGNoUnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZzEoXCJyZW1haW5pbmcgcmVxdWVzdHM6IFwiICsgdGhpcy5fcGFyYW1ldGVycy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnMihcImRvaW5nIFwiICsgcmVxU3BlY3MubGVuZ3RoICsgXCIgcmVxdWVzdHMsIG5ldyBxdWV1ZSBsZW5ndGggaXMgXCIgKyB0aGlzLl9xdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSByZXFTcGVjcy5tYXAoZnVuY3Rpb24gKHJlcVNwZWMpIHsgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEsIHJlc29sdmUsIHJlamVjdCwgcmVzdWx0LCByZXRyeSwgcGFyYW1zLCBlXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSByZXFTcGVjLnJlcSwgcmVzb2x2ZSA9IHJlcVNwZWMucmVzb2x2ZSwgcmVqZWN0ID0gcmVxU3BlYy5yZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kb1JlcXVlc3QocmVxKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5ID0gdGhpcy5uZWVkc1RvUmV0cnlBZnRlcihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS51bnNoaWZ0KHJlcVNwZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIlJldHJ5aW5nIGFmdGVyIFwiICsgcmV0cnkgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJldHJ5QWZ0ZXJFcnJvcl8xLlJldHJ5QWZ0ZXJFcnJvcihyZXRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMuZ2V0UGFyYW1ldGVyc0Zyb21SZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGFyYW1zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSBpbnN0YW5jZW9mIFJldHJ5QWZ0ZXJFcnJvcl8xLlJldHJ5QWZ0ZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm9taXNlX2FsbHNldHRsZWRfMS5kZWZhdWx0KShwcm9taXNlcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0bGVkUHJvbWlzZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RlZFByb21pc2VzID0gc2V0dGxlZFByb21pc2VzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5zdGF0dXMgPT09ICdyZWplY3RlZCc7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWplY3RlZFByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5QXQgPSBNYXRoLm1heC5hcHBseShNYXRoLCB0c2xpYl8xLl9fc3ByZWFkKFtub3ddLCByZWplY3RlZFByb21pc2VzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5yZWFzb24ucmV0cnlBdDsgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUFmdGVyID0gcmV0cnlBdCAtIG5vdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihcIndhaXRpbmcgZm9yIFwiICsgcmV0cnlBZnRlciArIFwiIG1zIGJlY2F1c2UgdGhlIHJhdGUgbGltaXQgd2FzIGV4Y2VlZGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25leHRCYXRjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcnVuTmV4dEJhdGNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmV0cnlBZnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBzZXR0bGVkUHJvbWlzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC52YWx1ZTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChjYXJyeSwgdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gdi5yZXNldHNBdCA+IGNhcnJ5LnJlc2V0c0F0ID8gdiA6IGNhcnJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5yZW1haW5pbmcgPCBjYXJyeS5yZW1haW5pbmcgPyB2IDogY2Fycnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYXRjaFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtZXRlcnMgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMucmVzZXRzQXQgPCBub3cgfHwgcGFyYW1zLnJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3J1bk5leHRCYXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBwYXJhbXMucmVzZXRzQXQgLSBub3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihcIldhaXRpbmcgZm9yIFwiICsgZGVsYXkgKyBcIiBtcyBiZWNhdXNlIHRoZSByYXRlIGxpbWl0IHdhcyByZWFjaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dEJhdGNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcnVuTmV4dEJhdGNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyLnByb3RvdHlwZS5fcnVuTmV4dEJhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhbW91bnQsIHJlcVNwZWNzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25leHRCYXRjaFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9uZXh0QmF0Y2hUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25leHRCYXRjaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbW91bnQgPSB0aGlzLl9wYXJhbWV0ZXJzID8gTWF0aC5taW4odGhpcy5fcGFyYW1ldGVycy5yZW1haW5pbmcsIHRoaXMuX3BhcmFtZXRlcnMubGltaXQgLyAxMCkgOiAxO1xuICAgICAgICAgICAgICAgIHJlcVNwZWNzID0gdGhpcy5fcXVldWUuc3BsaWNlKDAsIGFtb3VudCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcVNwZWNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydW5SZXF1ZXN0QmF0Y2gocmVxU3BlY3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyO1xufSgpKTtcbmV4cG9ydHMuUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyID0gUmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzcG9uc2VCYXNlZFJhdGVMaW1pdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogZXNsaW50LWRpc2FibGUgZmlsZW5hbWVzL21hdGNoLWV4cG9ydGVkICovXG52YXIgaXNOb2RlID0gcmVxdWlyZShcImRldGVjdC1ub2RlXCIpO1xudmFyIE5vZGVMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL05vZGVMb2dnZXJcIik7XG52YXIgQnJvd3NlckxvZ2dlcl8xID0gcmVxdWlyZShcIi4vQnJvd3NlckxvZ2dlclwiKTtcbnZhciBMb2dnZXIgPSBpc05vZGUgPyBOb2RlTG9nZ2VyXzEuTm9kZUxvZ2dlciA6IEJyb3dzZXJMb2dnZXJfMS5Ccm93c2VyTG9nZ2VyO1xuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG52YXIgTG9nTGV2ZWxfMSA9IHJlcXVpcmUoXCIuL0xvZ0xldmVsXCIpO1xuZXhwb3J0cy5Mb2dMZXZlbCA9IExvZ0xldmVsXzEuTG9nTGV2ZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfYSwgX2IsIF9jO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgTG9nTGV2ZWxfMSA9IHJlcXVpcmUoXCIuL0xvZ0xldmVsXCIpO1xudmFyIEJhc2VMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VMb2dnZXJcIik7XG5leHBvcnRzLkxvZ0xldmVsVG9FbW9qaSA9IChfYSA9IHt9LFxuICAgIF9hW0xvZ0xldmVsXzEuTG9nTGV2ZWwuQ1JJVElDQUxdID0gXCJcXHVEODNEXFx1REVEMVwiLFxuICAgIF9hW0xvZ0xldmVsXzEuTG9nTGV2ZWwuRVJST1JdID0gXCJcXHUyNzRDXCIsXG4gICAgLy8gdGhlc2UgZm9sbG93aW5nIHR3byBuZWVkIGV4dHJhIHNwYWNlcyBhdCB0aGUgZW5kIGJlY2F1c2Ugc29tZWhvdyB0aGV5IGNvbnN1bWUgbGVzcyBzcGFjZSBpbiBhIHRlcm1pbmFsIHRoYW4gdGhleSBzaG91bGQuLi5cbiAgICBfYVtMb2dMZXZlbF8xLkxvZ0xldmVsLldBUk5JTkddID0gXCJcXHUyNkEwXFx1RkUwRiBcIixcbiAgICBfYVtMb2dMZXZlbF8xLkxvZ0xldmVsLklORk9dID0gXCJcXHUyMTM5XFx1RkUwRiBcIixcbiAgICBfYVtMb2dMZXZlbF8xLkxvZ0xldmVsLkRFQlVHXSA9IFwiXFx1RDgzRFxcdURDMUVcIixcbiAgICBfYVtMb2dMZXZlbF8xLkxvZ0xldmVsLlRSQUNFXSA9IFwiXFx1RDgzRFxcdURDM0VcIixcbiAgICBfYSk7XG52YXIgY29sb3JzID0ge1xuICAgIGJsYWNrOiAzMCxcbiAgICByZWQ6IDMxLFxuICAgIGdyZWVuOiAzMixcbiAgICB5ZWxsb3c6IDMzLFxuICAgIGJsdWU6IDM0LFxuICAgIG1hZ2VudGE6IDM1LFxuICAgIGN5YW46IDM2LFxuICAgIHdoaXRlOiAzNyxcbiAgICBibGFja0JyaWdodDogOTAsXG4gICAgcmVkQnJpZ2h0OiA5MSxcbiAgICBncmVlbkJyaWdodDogOTIsXG4gICAgeWVsbG93QnJpZ2h0OiA5MyxcbiAgICBibHVlQnJpZ2h0OiA5NCxcbiAgICBtYWdlbnRhQnJpZ2h0OiA5NSxcbiAgICBjeWFuQnJpZ2h0OiA5NixcbiAgICB3aGl0ZUJyaWdodDogOTdcbn07XG52YXIgYmdDb2xvcnMgPSB7XG4gICAgYmdCbGFjazogNDAsXG4gICAgYmdSZWQ6IDQxLFxuICAgIGJnR3JlZW46IDQyLFxuICAgIGJnWWVsbG93OiA0MyxcbiAgICBiZ0JsdWU6IDQ0LFxuICAgIGJnTWFnZW50YTogNDUsXG4gICAgYmdDeWFuOiA0NixcbiAgICBiZ1doaXRlOiA0NyxcbiAgICBiZ0JsYWNrQnJpZ2h0OiAxMDAsXG4gICAgYmdSZWRCcmlnaHQ6IDEwMSxcbiAgICBiZ0dyZWVuQnJpZ2h0OiAxMDIsXG4gICAgYmdZZWxsb3dCcmlnaHQ6IDEwMyxcbiAgICBiZ0JsdWVCcmlnaHQ6IDEwNCxcbiAgICBiZ01hZ2VudGFCcmlnaHQ6IDEwNSxcbiAgICBiZ0N5YW5CcmlnaHQ6IDEwNixcbiAgICBiZ1doaXRlQnJpZ2h0OiAxMDdcbn07XG5mdW5jdGlvbiBjcmVhdGVHZW5lcmljV3JhcHBlcihjb2xvciwgZW5kaW5nLCBpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBcIlxcdTAwMUJbXCIgKyBjb2xvciArIFwibVwiICsgKGlubmVyID8gaW5uZXIoc3RyKSA6IHN0cikgKyBcIlxcdTAwMUJbXCIgKyBlbmRpbmcgKyBcIm1cIjsgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yV3JhcHBlcihjb2xvcikge1xuICAgIHJldHVybiBjcmVhdGVHZW5lcmljV3JhcHBlcihjb2xvcnNbY29sb3JdLCAzOSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCZ1dyYXBwZXIoY29sb3IsIGZnV3JhcHBlcikge1xuICAgIHJldHVybiBjcmVhdGVHZW5lcmljV3JhcHBlcihiZ0NvbG9yc1tjb2xvcl0sIDQ5LCBmZ1dyYXBwZXIpO1xufVxuZXhwb3J0cy5Mb2dMZXZlbFRvQ29sb3IgPSAoX2IgPSB7fSxcbiAgICBfYltMb2dMZXZlbF8xLkxvZ0xldmVsLkNSSVRJQ0FMXSA9IGNyZWF0ZUNvbG9yV3JhcHBlcigncmVkJyksXG4gICAgX2JbTG9nTGV2ZWxfMS5Mb2dMZXZlbC5FUlJPUl0gPSBjcmVhdGVDb2xvcldyYXBwZXIoJ3JlZEJyaWdodCcpLFxuICAgIF9iW0xvZ0xldmVsXzEuTG9nTGV2ZWwuV0FSTklOR10gPSBjcmVhdGVDb2xvcldyYXBwZXIoJ3llbGxvdycpLFxuICAgIF9iW0xvZ0xldmVsXzEuTG9nTGV2ZWwuSU5GT10gPSBjcmVhdGVDb2xvcldyYXBwZXIoJ2JsdWUnKSxcbiAgICBfYltMb2dMZXZlbF8xLkxvZ0xldmVsLkRFQlVHXSA9IGNyZWF0ZUNvbG9yV3JhcHBlcignbWFnZW50YScpLFxuICAgIF9iW0xvZ0xldmVsXzEuTG9nTGV2ZWwuVFJBQ0VdID0gY3JlYXRlR2VuZXJpY1dyYXBwZXIoMCwgMCksXG4gICAgX2IpO1xuZXhwb3J0cy5Mb2dMZXZlbFRvQmFja2dyb3VuZENvbG9yID0gKF9jID0ge30sXG4gICAgX2NbTG9nTGV2ZWxfMS5Mb2dMZXZlbC5DUklUSUNBTF0gPSBjcmVhdGVCZ1dyYXBwZXIoJ2JnUmVkJywgY3JlYXRlQ29sb3JXcmFwcGVyKCd3aGl0ZScpKSxcbiAgICBfY1tMb2dMZXZlbF8xLkxvZ0xldmVsLkVSUk9SXSA9IGNyZWF0ZUJnV3JhcHBlcignYmdSZWRCcmlnaHQnLCBjcmVhdGVDb2xvcldyYXBwZXIoJ3doaXRlJykpLFxuICAgIF9jW0xvZ0xldmVsXzEuTG9nTGV2ZWwuV0FSTklOR10gPSBjcmVhdGVCZ1dyYXBwZXIoJ2JnWWVsbG93JywgY3JlYXRlQ29sb3JXcmFwcGVyKCdibGFjaycpKSxcbiAgICBfY1tMb2dMZXZlbF8xLkxvZ0xldmVsLklORk9dID0gY3JlYXRlQmdXcmFwcGVyKCdiZ0JsdWUnLCBjcmVhdGVDb2xvcldyYXBwZXIoJ3doaXRlJykpLFxuICAgIF9jW0xvZ0xldmVsXzEuTG9nTGV2ZWwuREVCVUddID0gY3JlYXRlQmdXcmFwcGVyKCdiZ01hZ2VudGEnLCBjcmVhdGVDb2xvcldyYXBwZXIoJ2JsYWNrJykpLFxuICAgIF9jW0xvZ0xldmVsXzEuTG9nTGV2ZWwuVFJBQ0VdID0gY3JlYXRlR2VuZXJpY1dyYXBwZXIoNywgMjcpLFxuICAgIF9jKTtcbnZhciBOb2RlTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE5vZGVMb2dnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9kZUxvZ2dlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOb2RlTG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGxldmVsID4gdGhpcy5fbWluTGV2ZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nRm4gPSBMb2dMZXZlbF8xLkxvZ0xldmVsVG9Db25zb2xlRnVuY3Rpb25bbGV2ZWxdO1xuICAgICAgICB2YXIgYnVpbHRNZXNzYWdlID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICBidWlsdE1lc3NhZ2UgKz0gXCJbXCIgKyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyBcIl0gXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Vtb2ppKSB7XG4gICAgICAgICAgICB2YXIgZW1vamkgPSBleHBvcnRzLkxvZ0xldmVsVG9FbW9qaVtsZXZlbF07XG4gICAgICAgICAgICBidWlsdE1lc3NhZ2UgKz0gZW1vamkgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29sb3JzKSB7XG4gICAgICAgICAgICBidWlsdE1lc3NhZ2UgKz0gZXhwb3J0cy5Mb2dMZXZlbFRvQmFja2dyb3VuZENvbG9yW2xldmVsXSh0aGlzLl9uYW1lKSArIFwiIFwiICsgZXhwb3J0cy5Mb2dMZXZlbFRvQmFja2dyb3VuZENvbG9yW2xldmVsXShMb2dMZXZlbF8xLkxvZ0xldmVsW2xldmVsXSkgKyBcIiBcIiArIGV4cG9ydHMuTG9nTGV2ZWxUb0NvbG9yW2xldmVsXShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1aWx0TWVzc2FnZSArPSBcIltcIiArIHRoaXMuX25hbWUgKyBcIjpcIiArIExvZ0xldmVsXzEuTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCkgKyBcIl0gXCIgKyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGxvZ0ZuKGJ1aWx0TWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZUxvZ2dlcjtcbn0oQmFzZUxvZ2dlcl8xLkJhc2VMb2dnZXIpKTtcbmV4cG9ydHMuTm9kZUxvZ2dlciA9IE5vZGVMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob2RlTG9nZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgTG9nTGV2ZWxfMSA9IHJlcXVpcmUoXCIuL0xvZ0xldmVsXCIpO1xudmFyIEJhc2VMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VMb2dnZXJcIik7XG52YXIgQnJvd3NlckxvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCcm93c2VyTG9nZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJMb2dnZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQnJvd3NlckxvZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChsZXZlbCA+IHRoaXMuX21pbkxldmVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ0ZuID0gTG9nTGV2ZWxfMS5Mb2dMZXZlbFRvQ29uc29sZUZ1bmN0aW9uW2xldmVsXTtcbiAgICAgICAgdmFyIGZvcm1hdHRlZE1lc3NhZ2UgPSBcIltcIiArIHRoaXMuX25hbWUgKyBcIl0gXCIgKyBtZXNzYWdlO1xuICAgICAgICBpZiAodGhpcy5fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgZm9ybWF0dGVkTWVzc2FnZSA9IFwiW1wiICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCJdIFwiICsgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBsb2dGbihmb3JtYXR0ZWRNZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyTG9nZ2VyO1xufShCYXNlTG9nZ2VyXzEuQmFzZUxvZ2dlcikpO1xuZXhwb3J0cy5Ccm93c2VyTG9nZ2VyID0gQnJvd3NlckxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXJMb2dnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2NhbGxCaW5kJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxudmFyIHJlcXVpcmVQcm9taXNlID0gcmVxdWlyZSgnLi9yZXF1aXJlUHJvbWlzZScpO1xudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxucmVxdWlyZVByb21pc2UoKTtcbnZhciBib3VuZCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCkpO1xuXG52YXIgcmViaW5kYWJsZSA9IGZ1bmN0aW9uIGFsbFNldHRsZWQoaXRlcmFibGUpIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWludmFsaWQtdGhpc1xuXHRyZXR1cm4gYm91bmQodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnID8gUHJvbWlzZSA6IHRoaXMsIGl0ZXJhYmxlKTtcbn07XG5cbmRlZmluZShyZWJpbmRhYmxlLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSByZWJpbmRhYmxlO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHJlYmluZGFibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7XG5cbnZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGtleXNTaGltID0gb3JpZ0tleXMgPyBmdW5jdGlvbiBrZXlzKG8pIHsgcmV0dXJuIG9yaWdLZXlzKG8pOyB9IDogcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5c1NoaW07XG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdCd2YWx1ZU9mJyxcblx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHRcdCdjb25zdHJ1Y3Rvcidcblx0XTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0XHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG5cdH07XG5cdHZhciBleGNsdWRlZEtleXMgPSB7XG5cdFx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdFx0JGNvbnNvbGU6IHRydWUsXG5cdFx0JGV4dGVybmFsOiB0cnVlLFxuXHRcdCRmcmFtZTogdHJ1ZSxcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHRcdCRmcmFtZXM6IHRydWUsXG5cdFx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0XHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0XHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYXJlbnQ6IHRydWUsXG5cdFx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0XHQkc2Nyb2xsWDogdHJ1ZSxcblx0XHQkc2Nyb2xsWTogdHJ1ZSxcblx0XHQkc2VsZjogdHJ1ZSxcblx0XHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHRcdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0XHQkd2luZG93OiB0cnVlXG5cdH07XG5cdHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0oKSk7XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0a2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHRcdH1cblxuXHRcdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0XHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGVLZXlzO1xuXHR9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2FsbEJvdW5kJyk7XG5cbnZhciAkUHJvbWlzZVJlc29sdmUgPSBjYWxsQm91bmQoJ1Byb21pc2UucmVzb2x2ZScsIHRydWUpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOS4wLyNzZWMtcHJvbWlzZS1yZXNvbHZlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUHJvbWlzZVJlc29sdmUoQywgeCkge1xuXHRpZiAoISRQcm9taXNlUmVzb2x2ZSkge1xuXHRcdHRocm93IG5ldyBTeW50YXhFcnJvcignVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFByb21pc2VzLicpO1xuXHR9XG5cdHJldHVybiAkUHJvbWlzZVJlc29sdmUoQywgeCk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFR5cGUoeCkge1xuXHRpZiAoeCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiAnTnVsbCc7XG5cdH1cblx0aWYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiAnVW5kZWZpbmVkJztcblx0fVxuXHRpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuICdPYmplY3QnO1xuXHR9XG5cdGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcblx0XHRyZXR1cm4gJ051bWJlcic7XG5cdH1cblx0aWYgKHR5cGVvZiB4ID09PSAnYm9vbGVhbicpIHtcblx0XHRyZXR1cm4gJ0Jvb2xlYW4nO1xuXHR9XG5cdGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gJ1N0cmluZyc7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRJdGVyYXRvciA9IHJlcXVpcmUoJ2VzLWdldC1pdGVyYXRvcicpO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJ2l0ZXJhdGUtaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpdGVyYXRlVmFsdWUoaXRlcmFibGUpIHtcblx0dmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuXHRpZiAoIWl0ZXJhdG9yKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ25vbi1pdGVyYWJsZSB2YWx1ZSBwcm92aWRlZCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdHJldHVybiBpdGVyYXRlKGl0ZXJhdG9yLCBhcmd1bWVudHNbMV0pO1xuXHR9XG5cdHJldHVybiBpdGVyYXRlKGl0ZXJhdG9yKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBnbG9iYWwtcmVxdWlyZTogMCAqL1xuLy8gdGhlIGNvZGUgaXMgc3RydWN0dXJlZCB0aGlzIHdheSBzbyB0aGF0IGJ1bmRsZXJzIGNhblxuLy8gYWxpYXMgb3V0IGBoYXMtc3ltYm9sc2AgdG8gYCgpID0+IHRydWVgIG9yIGAoKSA9PiBmYWxzZWAgaWYgeW91ciB0YXJnZXRcbi8vIGVudmlyb25tZW50cycgU3ltYm9sIGNhcGFiaWxpdGllcyBhcmUga25vd24sIGFuZCB0aGVuIHVzZVxuLy8gZGVhZCBjb2RlIGVsaW1pbmF0aW9uIG9uIHRoZSByZXN0IG9mIHRoaXMgbW9kdWxlLlxuLy9cbi8vIFNpbWlsYXJseSwgYGlzYXJyYXlgIGNhbiBiZSBhbGlhc2VkIHRvIGBBcnJheS5pc0FycmF5YCBpZlxuLy8gYXZhaWxhYmxlIGluIGFsbCB0YXJnZXQgZW52aXJvbm1lbnRzLlxuXG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcblxuaWYgKHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKSB8fCByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpKCkpIHtcblx0dmFyICRpdGVyYXRvciA9IFN5bWJvbC5pdGVyYXRvcjtcblx0Ly8gU3ltYm9sIGlzIGF2YWlsYWJsZSBuYXRpdmVseSBvciBzaGFtbWVkXG5cdC8vIG5hdGl2ZWx5OlxuXHQvLyAgLSBDaHJvbWUgPj0gMzhcblx0Ly8gIC0gRWRnZSAxMi0xND8sIEVkZ2UgPj0gMTUgZm9yIHN1cmVcblx0Ly8gIC0gRkYgPj0gMzZcblx0Ly8gIC0gU2FmYXJpID49IDlcblx0Ly8gIC0gbm9kZSA+PSAwLjEyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0SXRlcmF0b3IoaXRlcmFibGUpIHtcblx0XHQvLyBhbHRlcm5hdGl2ZWx5LCBgaXRlcmFibGVbJGl0ZXJhdG9yXT8uKClgXG5cdFx0aWYgKGl0ZXJhYmxlICE9IG51bGwgJiYgdHlwZW9mIGl0ZXJhYmxlWyRpdGVyYXRvcl0gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gaXRlcmFibGVbJGl0ZXJhdG9yXSgpO1xuXHRcdH1cblx0XHRpZiAoaXNBcmd1bWVudHMoaXRlcmFibGUpKSB7XG5cdFx0XHQvLyBhcmd1bWVudHMgb2JqZWN0cyBsYWNrIFN5bWJvbC5pdGVyYXRvclxuXHRcdFx0Ly8gLSBub2RlIDAuMTJcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGVbJGl0ZXJhdG9yXS5jYWxsKGl0ZXJhYmxlKTtcblx0XHR9XG5cdH07XG59IGVsc2Uge1xuXHQvLyBTeW1ib2wgaXMgbm90IGF2YWlsYWJsZSwgbmF0aXZlIG9yIHNoYW1tZWRcblx0dmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cdHZhciBpc1N0cmluZyA9IHJlcXVpcmUoJ2lzLXN0cmluZycpO1xuXHR2YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvR2V0SW50cmluc2ljJyk7XG5cdHZhciAkTWFwID0gR2V0SW50cmluc2ljKCclTWFwJScsIHRydWUpO1xuXHR2YXIgJFNldCA9IEdldEludHJpbnNpYygnJVNldCUnLCB0cnVlKTtcblx0dmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvY2FsbEJvdW5kJyk7XG5cdHZhciAkYXJyYXlQdXNoID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUucHVzaCcpO1xuXHR2YXIgJGNoYXJDb2RlQXQgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdCcpO1xuXHR2YXIgJHN0cmluZ1NsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG5cblx0dmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IGZ1bmN0aW9uIGFkdmFuY2VTdHJpbmdJbmRleChTLCBpbmRleCkge1xuXHRcdHZhciBsZW5ndGggPSBTLmxlbmd0aDtcblx0XHRpZiAoKGluZGV4ICsgMSkgPj0gbGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggKyAxO1xuXHRcdH1cblxuXHRcdHZhciBmaXJzdCA9ICRjaGFyQ29kZUF0KFMsIGluZGV4KTtcblx0XHRpZiAoZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYpIHtcblx0XHRcdHJldHVybiBpbmRleCArIDE7XG5cdFx0fVxuXG5cdFx0dmFyIHNlY29uZCA9ICRjaGFyQ29kZUF0KFMsIGluZGV4ICsgMSk7XG5cdFx0aWYgKHNlY29uZCA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkYpIHtcblx0XHRcdHJldHVybiBpbmRleCArIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4ICsgMjtcblx0fTtcblxuXHR2YXIgZ2V0QXJyYXlJdGVyYXRvciA9IGZ1bmN0aW9uIGdldEFycmF5SXRlcmF0b3IoYXJyYXlsaWtlKSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHJldHVybiB7XG5cdFx0XHRuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuXHRcdFx0XHR2YXIgZG9uZSA9IGkgPj0gYXJyYXlsaWtlLmxlbmd0aDtcblx0XHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0XHRpZiAoIWRvbmUpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGFycmF5bGlrZVtpXTtcblx0XHRcdFx0XHRpICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRkb25lOiBkb25lLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cblx0dmFyIGdldE5vbkNvbGxlY3Rpb25JdGVyYXRvciA9IGZ1bmN0aW9uIGdldE5vbkNvbGxlY3Rpb25JdGVyYXRvcihpdGVyYWJsZSkge1xuXHRcdGlmIChpc0FycmF5KGl0ZXJhYmxlKSB8fCBpc0FyZ3VtZW50cyhpdGVyYWJsZSkpIHtcblx0XHRcdHJldHVybiBnZXRBcnJheUl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0XHR9XG5cdFx0aWYgKGlzU3RyaW5nKGl0ZXJhYmxlKSkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcblx0XHRcdFx0XHR2YXIgbmV4dEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KGl0ZXJhYmxlLCBpKTtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSAkc3RyaW5nU2xpY2UoaXRlcmFibGUsIGksIG5leHRJbmRleCk7XG5cdFx0XHRcdFx0aSA9IG5leHRJbmRleDtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZG9uZTogbmV4dEluZGV4ID4gaXRlcmFibGUubGVuZ3RoLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cblx0aWYgKCEkTWFwICYmICEkU2V0KSB7XG5cdFx0Ly8gdGhlIG9ubHkgbGFuZ3VhZ2UgaXRlcmFibGVzIGFyZSBBcnJheSwgU3RyaW5nLCBhcmd1bWVudHNcblx0XHQvLyAtIFNhZmFyaSA8PSA2LjBcblx0XHQvLyAtIENocm9tZSA8IDM4XG5cdFx0Ly8gLSBub2RlIDwgMC4xMlxuXHRcdC8vIC0gRkYgPCAxM1xuXHRcdC8vIC0gSUUgPCAxMVxuXHRcdC8vIC0gRWRnZSA8IDExXG5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdldE5vbkNvbGxlY3Rpb25JdGVyYXRvcjtcblx0fSBlbHNlIHtcblx0XHQvLyBlaXRoZXIgTWFwIG9yIFNldCBhcmUgYXZhaWxhYmxlLCBidXQgU3ltYm9sIGlzIG5vdFxuXHRcdC8vIC0gZXM2LXNoaW0gb24gYW4gRVM1IGJyb3dzZXJcblx0XHQvLyAtIFNhZmFyaSA2LjIgKG1heWJlIDYuMT8pXG5cdFx0Ly8gLSBGRiB2WzEzLCAzNilcblx0XHQvLyAtIElFIDExXG5cdFx0Ly8gLSBFZGdlIDExXG5cdFx0Ly8gLSBTYWZhcmkgdls2LCA5KVxuXG5cdFx0dmFyIGlzTWFwID0gcmVxdWlyZSgnaXMtbWFwJyk7XG5cdFx0dmFyIGlzU2V0ID0gcmVxdWlyZSgnaXMtc2V0Jyk7XG5cblx0XHQvLyBGaXJlZm94ID49IDI3LCBJRSAxMSwgU2FmYXJpIDYuMiAtIDksIEVkZ2UgMTEsIGVzNi1zaGltIGluIG9sZGVyIGVudnMsIGFsbCBoYXZlIGZvckVhY2hcblx0XHR2YXIgJG1hcEZvckVhY2ggPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuZm9yRWFjaCcsIHRydWUpO1xuXHRcdHZhciAkc2V0Rm9yRWFjaCA9IGNhbGxCb3VuZCgnU2V0LnByb3RvdHlwZS5mb3JFYWNoJywgdHJ1ZSk7XG5cdFx0aWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhcHJvY2Vzcy52ZXJzaW9ucyB8fCAhcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSB7IC8vIFwiaWYgaXMgbm90IG5vZGVcIlxuXG5cdFx0XHQvLyBGaXJlZm94IDE3IC0gMjYgaGFzIGAuaXRlcmF0b3IoKWAsIHdob3NlIGl0ZXJhdG9yIGAubmV4dCgpYCBlaXRoZXJcblx0XHRcdC8vIHJldHVybnMgYSB2YWx1ZSwgb3IgdGhyb3dzIGEgU3RvcEl0ZXJhdGlvbiBvYmplY3QuIFRoZXNlIGJyb3dzZXJzXG5cdFx0XHQvLyBkbyBub3QgaGF2ZSBhbnkgb3RoZXIgbWVjaGFuaXNtIGZvciBpdGVyYXRpb24uXG5cdFx0XHR2YXIgJG1hcEl0ZXJhdG9yID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLml0ZXJhdG9yJywgdHJ1ZSk7XG5cdFx0XHR2YXIgJHNldEl0ZXJhdG9yID0gY2FsbEJvdW5kKCdTZXQucHJvdG90eXBlLml0ZXJhdG9yJywgdHJ1ZSk7XG5cdFx0XHR2YXIgZ2V0U3RvcEl0ZXJhdGlvbkl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG5cdFx0XHRcdHZhciBkb25lID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0ZG9uZTogZG9uZSxcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IGl0ZXJhdG9yLm5leHQoKVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRkb25lOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlOiB1bmRlZmluZWRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH1cblx0XHQvLyBGaXJlZm94IDI3LTM1LCBhbmQgc29tZSBvbGRlciBlczYtc2hpbSB2ZXJzaW9ucywgdXNlIGEgc3RyaW5nIFwiQEBpdGVyYXRvclwiIHByb3BlcnR5XG5cdFx0Ly8gdGhpcyByZXR1cm5zIGEgcHJvcGVyIGl0ZXJhdG9yIG9iamVjdCwgc28gd2Ugc2hvdWxkIHVzZSBpdCBpbnN0ZWFkIG9mIGZvckVhY2guXG5cdFx0Ly8gbmV3ZXIgZXM2LXNoaW0gdmVyc2lvbnMgdXNlIGEgc3RyaW5nIFwiX2VzNi1zaGltIGl0ZXJhdG9yX1wiIHByb3BlcnR5LlxuXHRcdHZhciAkbWFwQXRBdEl0ZXJhdG9yID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLkBAaXRlcmF0b3InLCB0cnVlKSB8fCBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuX2VzNi1zaGltIGl0ZXJhdG9yXycsIHRydWUpO1xuXHRcdHZhciAkc2V0QXRBdEl0ZXJhdG9yID0gY2FsbEJvdW5kKCdTZXQucHJvdG90eXBlLkBAaXRlcmF0b3InLCB0cnVlKSB8fCBjYWxsQm91bmQoJ1NldC5wcm90b3R5cGUuX2VzNi1zaGltIGl0ZXJhdG9yXycsIHRydWUpO1xuXG5cdFx0dmFyIGdldENvbGxlY3Rpb25JdGVyYXRvciA9IGZ1bmN0aW9uIGdldENvbGxlY3Rpb25JdGVyYXRvcihpdGVyYWJsZSkge1xuXHRcdFx0aWYgKGlzTWFwKGl0ZXJhYmxlKSkge1xuXHRcdFx0XHRpZiAoJG1hcEl0ZXJhdG9yKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdldFN0b3BJdGVyYXRpb25JdGVyYXRvcigkbWFwSXRlcmF0b3IoaXRlcmFibGUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJG1hcEF0QXRJdGVyYXRvcikge1xuXHRcdFx0XHRcdHJldHVybiAkbWFwQXRBdEl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJG1hcEZvckVhY2gpIHtcblx0XHRcdFx0XHR2YXIgZW50cmllcyA9IFtdO1xuXHRcdFx0XHRcdCRtYXBGb3JFYWNoKGl0ZXJhYmxlLCBmdW5jdGlvbiAodiwgaykge1xuXHRcdFx0XHRcdFx0JGFycmF5UHVzaChlbnRyaWVzLCBbaywgdl0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBnZXRBcnJheUl0ZXJhdG9yKGVudHJpZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNTZXQoaXRlcmFibGUpKSB7XG5cdFx0XHRcdGlmICgkc2V0SXRlcmF0b3IpIHtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0U3RvcEl0ZXJhdGlvbkl0ZXJhdG9yKCRzZXRJdGVyYXRvcihpdGVyYWJsZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgkc2V0QXRBdEl0ZXJhdG9yKSB7XG5cdFx0XHRcdFx0cmV0dXJuICRzZXRBdEF0SXRlcmF0b3IoaXRlcmFibGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgkc2V0Rm9yRWFjaCkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblx0XHRcdFx0XHQkc2V0Rm9yRWFjaChpdGVyYWJsZSwgZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0XHRcdCRhcnJheVB1c2godmFsdWVzLCB2KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0QXJyYXlJdGVyYXRvcih2YWx1ZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0SXRlcmF0b3IoaXRlcmFibGUpIHtcblx0XHRcdHJldHVybiBnZXRDb2xsZWN0aW9uSXRlcmF0b3IoaXRlcmFibGUpIHx8IGdldE5vbkNvbGxlY3Rpb25JdGVyYXRvcihpdGVyYWJsZSk7XG5cdFx0fTtcblx0fVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdHRvU3RyLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkTWFwID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXAucHJvdG90eXBlID8gTWFwIDogbnVsbDtcbnZhciAkU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBTZXQucHJvdG90eXBlID8gU2V0IDogbnVsbDtcblxudmFyIGV4cG9ydGVkO1xuXG5pZiAoISRNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cdGV4cG9ydGVkID0gZnVuY3Rpb24gaXNNYXAoeCkge1xuXHRcdC8vIGBNYXBgIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgZW52aXJvbm1lbnQuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG52YXIgJG1hcEhhcyA9ICRNYXAgPyBNYXAucHJvdG90eXBlLmhhcyA6IG51bGw7XG52YXIgJHNldEhhcyA9ICRTZXQgPyBTZXQucHJvdG90eXBlLmhhcyA6IG51bGw7XG5pZiAoIWV4cG9ydGVkICYmICEkbWFwSGFzKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXHRleHBvcnRlZCA9IGZ1bmN0aW9uIGlzTWFwKHgpIHtcblx0XHQvLyBgTWFwYCBkb2VzIG5vdCBoYXZlIGEgYGhhc2AgbWV0aG9kXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVkIHx8IGZ1bmN0aW9uIGlzTWFwKHgpIHtcblx0aWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdCRtYXBIYXMuY2FsbCh4KTtcblx0XHRpZiAoJHNldEhhcykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0JHNldEhhcy5jYWxsKHgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHggaW5zdGFuY2VvZiAkTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcblx0fSBjYXRjaCAoZSkge31cblx0cmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRNYXAgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIE1hcC5wcm90b3R5cGUgPyBNYXAgOiBudWxsO1xudmFyICRTZXQgPSB0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIFNldC5wcm90b3R5cGUgPyBTZXQgOiBudWxsO1xuXG52YXIgZXhwb3J0ZWQ7XG5cbmlmICghJFNldCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblx0ZXhwb3J0ZWQgPSBmdW5jdGlvbiBpc1NldCh4KSB7XG5cdFx0Ly8gYFNldGAgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBlbnZpcm9ubWVudC5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbnZhciAkbWFwSGFzID0gJE1hcCA/IE1hcC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciAkc2V0SGFzID0gJFNldCA/IFNldC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbmlmICghZXhwb3J0ZWQgJiYgISRzZXRIYXMpIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cdGV4cG9ydGVkID0gZnVuY3Rpb24gaXNTZXQoeCkge1xuXHRcdC8vIGBTZXRgIGRvZXMgbm90IGhhdmUgYSBgaGFzYCBtZXRob2Rcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQgfHwgZnVuY3Rpb24gaXNTZXQoeCkge1xuXHRpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHRyeSB7XG5cdFx0JHNldEhhcy5jYWxsKHgpO1xuXHRcdGlmICgkbWFwSGFzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQkbWFwSGFzLmNhbGwoeCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4geCBpbnN0YW5jZW9mICRTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuXHR9IGNhdGNoIChlKSB7fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGl0ZXJhdGVJdGVyYXRvcihpdGVyYXRvcikge1xuXHRpZiAoIWl0ZXJhdG9yIHx8IHR5cGVvZiBpdGVyYXRvci5uZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggYSBgbmV4dGAgbWV0aG9kJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuXHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgY2FsbGJhY2tgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0fVxuXHR9XG5cdHZhciB2YWx1ZXMgPSBjYWxsYmFjayB8fCBbXTtcblx0dmFyIHJlc3VsdDtcblx0d2hpbGUgKChyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCkpICYmICFyZXN1bHQuZG9uZSkge1xuXHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2socmVzdWx0LnZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWVzLnB1c2gocmVzdWx0LnZhbHVlKTtcblx0XHR9XG5cdH1cblx0aWYgKCFjYWxsYmFjaykge1xuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIFJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDE5L1JlcXVpcmVPYmplY3RDb2VyY2libGUnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2NhbGxCb3VuZCcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLnNsaWNlJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIGJvdW5kTWFwU2hpbSA9IGZ1bmN0aW9uIG1hcChhcnJheSwgY2FsbGJhY2tmbikge1xuXHRSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFycmF5KTtcblx0cmV0dXJuIHBvbHlmaWxsLmFwcGx5KGFycmF5LCAkc2xpY2UoYXJndW1lbnRzLCAxKSk7XG59O1xuZGVmaW5lKGJvdW5kTWFwU2hpbSwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYm91bmRNYXBTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG4vLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOS4xMFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENoZWNrT2JqZWN0Q29lcmNpYmxlKHZhbHVlLCBvcHRNZXNzYWdlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3Iob3B0TWVzc2FnZSB8fCAoJ0Nhbm5vdCBjYWxsIG1ldGhvZCBvbiAnICsgdmFsdWUpKTtcblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkQXJyYXkgPSBHZXRJbnRyaW5zaWMoJyVBcnJheSUnKTtcbnZhciAkc3BlY2llcyA9IEdldEludHJpbnNpYygnJVN5bWJvbC5zcGVjaWVzJScsIHRydWUpO1xudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBHZXQgPSByZXF1aXJlKCcuL0dldCcpO1xudmFyIElzQXJyYXkgPSByZXF1aXJlKCcuL0lzQXJyYXknKTtcbnZhciBJc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9Jc0NvbnN0cnVjdG9yJyk7XG52YXIgSXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9Jc0ludGVnZXInKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG5cdGlmICghSXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDwgMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBsZW5ndGggbXVzdCBiZSBhbiBpbnRlZ2VyID49IDAnKTtcblx0fVxuXHR2YXIgbGVuID0gbGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aDtcblx0dmFyIEM7XG5cdHZhciBpc0FycmF5ID0gSXNBcnJheShvcmlnaW5hbEFycmF5KTtcblx0aWYgKGlzQXJyYXkpIHtcblx0XHRDID0gR2V0KG9yaWdpbmFsQXJyYXksICdjb25zdHJ1Y3RvcicpO1xuXHRcdC8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRvIG1ha2UgYSBjcm9zcy1yZWFsbSBub3JtYWwgQXJyYXksIGEgc2FtZS1yZWFsbSBBcnJheVxuXHRcdC8vIGlmIChJc0NvbnN0cnVjdG9yKEMpKSB7XG5cdFx0Ly8gXHRpZiBDIGlzIGFub3RoZXIgcmVhbG0ncyBBcnJheSwgQyA9IHVuZGVmaW5lZFxuXHRcdC8vIFx0T2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXJyYXkpKSkgPT09IG51bGwgP1xuXHRcdC8vIH1cblx0XHRpZiAoJHNwZWNpZXMgJiYgVHlwZShDKSA9PT0gJ09iamVjdCcpIHtcblx0XHRcdEMgPSBHZXQoQywgJHNwZWNpZXMpO1xuXHRcdFx0aWYgKEMgPT09IG51bGwpIHtcblx0XHRcdFx0QyA9IHZvaWQgMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYgKHR5cGVvZiBDID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiAkQXJyYXkobGVuKTtcblx0fVxuXHRpZiAoIUlzQ29uc3RydWN0b3IoQykpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQyBtdXN0IGJlIGEgY29uc3RydWN0b3InKTtcblx0fVxuXHRyZXR1cm4gbmV3IEMobGVuKTsgLy8gQ29uc3RydWN0KEMsIGxlbik7XG59O1xuXG4iLCJ2YXIgaGFzTWFwID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXAucHJvdG90eXBlO1xudmFyIG1hcFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNNYXAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1hcC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIG1hcFNpemUgPSBoYXNNYXAgJiYgbWFwU2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIG1hcFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG1hcFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgbWFwRm9yRWFjaCA9IGhhc01hcCAmJiBNYXAucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBTZXQucHJvdG90eXBlO1xudmFyIHNldFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNTZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFNldC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIHNldFNpemUgPSBoYXNTZXQgJiYgc2V0U2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIHNldFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgc2V0Rm9yRWFjaCA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIFdlYWtNYXAucHJvdG90eXBlO1xudmFyIHdlYWtNYXBIYXMgPSBoYXNXZWFrTWFwID8gV2Vha01hcC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgJiYgV2Vha1NldC5wcm90b3R5cGU7XG52YXIgd2Vha1NldEhhcyA9IGhhc1dlYWtTZXQgPyBXZWFrU2V0LnByb3RvdHlwZS5oYXMgOiBudWxsO1xudmFyIGJvb2xlYW5WYWx1ZU9mID0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZjtcbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBtYXRjaCA9IFN0cmluZy5wcm90b3R5cGUubWF0Y2g7XG52YXIgYmlnSW50VmFsdWVPZiA9IHR5cGVvZiBCaWdJbnQgPT09ICdmdW5jdGlvbicgPyBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YgOiBudWxsO1xuXG52YXIgaW5zcGVjdEN1c3RvbSA9IHJlcXVpcmUoJy4vdXRpbC5pbnNwZWN0JykuY3VzdG9tO1xudmFyIGluc3BlY3RTeW1ib2wgPSBpbnNwZWN0Q3VzdG9tICYmIGlzU3ltYm9sKGluc3BlY3RDdXN0b20pID8gaW5zcGVjdEN1c3RvbSA6IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5zcGVjdF8ob2JqLCBvcHRpb25zLCBkZXB0aCwgc2Vlbikge1xuICAgIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChoYXMob3B0cywgJ3F1b3RlU3R5bGUnKSAmJiAob3B0cy5xdW90ZVN0eWxlICE9PSAnc2luZ2xlJyAmJiBvcHRzLnF1b3RlU3R5bGUgIT09ICdkb3VibGUnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJxdW90ZVN0eWxlXCIgbXVzdCBiZSBcInNpbmdsZVwiIG9yIFwiZG91YmxlXCInKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgICBoYXMob3B0cywgJ21heFN0cmluZ0xlbmd0aCcpICYmICh0eXBlb2Ygb3B0cy5tYXhTdHJpbmdMZW5ndGggPT09ICdudW1iZXInXG4gICAgICAgICAgICA/IG9wdHMubWF4U3RyaW5nTGVuZ3RoIDwgMCAmJiBvcHRzLm1heFN0cmluZ0xlbmd0aCAhPT0gSW5maW5pdHlcbiAgICAgICAgICAgIDogb3B0cy5tYXhTdHJpbmdMZW5ndGggIT09IG51bGxcbiAgICAgICAgKVxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJtYXhTdHJpbmdMZW5ndGhcIiwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBJbmZpbml0eSwgb3IgYG51bGxgJyk7XG4gICAgfVxuICAgIHZhciBjdXN0b21JbnNwZWN0ID0gaGFzKG9wdHMsICdjdXN0b21JbnNwZWN0JykgPyBvcHRzLmN1c3RvbUluc3BlY3QgOiB0cnVlO1xuICAgIGlmICh0eXBlb2YgY3VzdG9tSW5zcGVjdCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcImN1c3RvbUluc3BlY3RcIiwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYHRydWVgIG9yIGBmYWxzZWAnKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnaW5kZW50JylcbiAgICAgICAgJiYgb3B0cy5pbmRlbnQgIT09IG51bGxcbiAgICAgICAgJiYgb3B0cy5pbmRlbnQgIT09ICdcXHQnXG4gICAgICAgICYmICEocGFyc2VJbnQob3B0cy5pbmRlbnQsIDEwKSA9PT0gb3B0cy5pbmRlbnQgJiYgb3B0cy5pbmRlbnQgPiAwKVxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIFwiaW5kZW50XCIgbXVzdCBiZSBcIlxcXFx0XCIsIGFuIGludGVnZXIgPiAwLCBvciBgbnVsbGAnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIG9iaiA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKG9iaiwgb3B0cyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAob2JqID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHkgLyBvYmogPiAwID8gJzAnIDogJy0wJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nKG9iaik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnYmlnaW50JykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHZhbGlkLXR5cGVvZlxuICAgICAgICByZXR1cm4gU3RyaW5nKG9iaikgKyAnbic7XG4gICAgfVxuXG4gICAgdmFyIG1heERlcHRoID0gdHlwZW9mIG9wdHMuZGVwdGggPT09ICd1bmRlZmluZWQnID8gNSA6IG9wdHMuZGVwdGg7XG4gICAgaWYgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcpIHsgZGVwdGggPSAwOyB9XG4gICAgaWYgKGRlcHRoID49IG1heERlcHRoICYmIG1heERlcHRoID4gMCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheShvYmopID8gJ1tBcnJheV0nIDogJ1tPYmplY3RdJztcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50ID0gZ2V0SW5kZW50KG9wdHMsIGRlcHRoKTtcblxuICAgIGlmICh0eXBlb2Ygc2VlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VlbiA9IFtdO1xuICAgIH0gZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBvYmopID49IDApIHtcbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNwZWN0KHZhbHVlLCBmcm9tLCBub0luZGVudCkge1xuICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgc2VlbiA9IHNlZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIHNlZW4ucHVzaChmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9JbmRlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdPcHRzID0ge1xuICAgICAgICAgICAgICAgIGRlcHRoOiBvcHRzLmRlcHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0cy5xdW90ZVN0eWxlID0gb3B0cy5xdW90ZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBuZXdPcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgb3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVPZihvYmopO1xuICAgICAgICByZXR1cm4gJ1tGdW5jdGlvbicgKyAobmFtZSA/ICc6ICcgKyBuYW1lIDogJyAoYW5vbnltb3VzKScpICsgJ10nO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wob2JqKSkge1xuICAgICAgICB2YXIgc3ltU3RyaW5nID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyA/IG1hcmtCb3hlZChzeW1TdHJpbmcpIDogc3ltU3RyaW5nO1xuICAgIH1cbiAgICBpZiAoaXNFbGVtZW50KG9iaikpIHtcbiAgICAgICAgdmFyIHMgPSAnPCcgKyBTdHJpbmcob2JqLm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSAnICcgKyBhdHRyc1tpXS5uYW1lICsgJz0nICsgd3JhcFF1b3RlcyhxdW90ZShhdHRyc1tpXS52YWx1ZSksICdkb3VibGUnLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBzICs9ICc+JztcbiAgICAgICAgaWYgKG9iai5jaGlsZE5vZGVzICYmIG9iai5jaGlsZE5vZGVzLmxlbmd0aCkgeyBzICs9ICcuLi4nOyB9XG4gICAgICAgIHMgKz0gJzwvJyArIFN0cmluZyhvYmoubm9kZU5hbWUpLnRvTG93ZXJDYXNlKCkgKyAnPic7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAwKSB7IHJldHVybiAnW10nOyB9XG4gICAgICAgIHZhciB4cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgaWYgKGluZGVudCAmJiAhc2luZ2xlTGluZVZhbHVlcyh4cykpIHtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBpbmRlbnRlZEpvaW4oeHMsIGluZGVudCkgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdbICcgKyB4cy5qb2luKCcsICcpICsgJyBdJztcbiAgICB9XG4gICAgaWYgKGlzRXJyb3Iob2JqKSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbJyArIFN0cmluZyhvYmopICsgJ10nOyB9XG4gICAgICAgIHJldHVybiAneyBbJyArIFN0cmluZyhvYmopICsgJ10gJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgY3VzdG9tSW5zcGVjdCkge1xuICAgICAgICBpZiAoaW5zcGVjdFN5bWJvbCAmJiB0eXBlb2Ygb2JqW2luc3BlY3RTeW1ib2xdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2luc3BlY3RTeW1ib2xdKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iai5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmluc3BlY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNNYXAob2JqKSkge1xuICAgICAgICB2YXIgbWFwUGFydHMgPSBbXTtcbiAgICAgICAgbWFwRm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIG1hcFBhcnRzLnB1c2goaW5zcGVjdChrZXksIG9iaiwgdHJ1ZSkgKyAnID0+ICcgKyBpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ01hcCcsIG1hcFNpemUuY2FsbChvYmopLCBtYXBQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzU2V0KG9iaikpIHtcbiAgICAgICAgdmFyIHNldFBhcnRzID0gW107XG4gICAgICAgIHNldEZvckVhY2guY2FsbChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc2V0UGFydHMucHVzaChpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ1NldCcsIHNldFNpemUuY2FsbChvYmopLCBzZXRQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha01hcChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrTWFwJyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtTZXQob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1NldCcpO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoTnVtYmVyKG9iaikpKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnSW50KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KGJpZ0ludFZhbHVlT2YuY2FsbChvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4ob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGJvb2xlYW5WYWx1ZU9mLmNhbGwob2JqKSk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChTdHJpbmcob2JqKSkpO1xuICAgIH1cbiAgICBpZiAoIWlzRGF0ZShvYmopICYmICFpc1JlZ0V4cChvYmopKSB7XG4gICAgICAgIHZhciB5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgaWYgKHlzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJ3t9JzsgfVxuICAgICAgICBpZiAoaW5kZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gJ3snICsgaW5kZW50ZWRKb2luKHlzLCBpbmRlbnQpICsgJ30nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAneyAnICsgeXMuam9pbignLCAnKSArICcgfSc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcob2JqKTtcbn07XG5cbmZ1bmN0aW9uIHdyYXBRdW90ZXMocywgZGVmYXVsdFN0eWxlLCBvcHRzKSB7XG4gICAgdmFyIHF1b3RlQ2hhciA9IChvcHRzLnF1b3RlU3R5bGUgfHwgZGVmYXVsdFN0eWxlKSA9PT0gJ2RvdWJsZScgPyAnXCInIDogXCInXCI7XG4gICAgcmV0dXJuIHF1b3RlQ2hhciArIHMgKyBxdW90ZUNoYXI7XG59XG5cbmZ1bmN0aW9uIHF1b3RlKHMpIHtcbiAgICByZXR1cm4gU3RyaW5nKHMpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7IH1cbmZ1bmN0aW9uIGlzRGF0ZShvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJzsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBSZWdFeHBdJzsgfVxuZnVuY3Rpb24gaXNFcnJvcihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEVycm9yXSc7IH1cbmZ1bmN0aW9uIGlzU3ltYm9sKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgU3ltYm9sXSc7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7IH1cbmZ1bmN0aW9uIGlzQmlnSW50KG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQmlnSW50XSc7IH1cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJzsgfVxuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgaW4gdGhpczsgfTtcbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd24uY2FsbChvYmosIGtleSk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyKG9iaikge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIG5hbWVPZihmKSB7XG4gICAgaWYgKGYubmFtZSkgeyByZXR1cm4gZi5uYW1lOyB9XG4gICAgdmFyIG0gPSBtYXRjaC5jYWxsKGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChmKSwgL15mdW5jdGlvblxccyooW1xcdyRdKykvKTtcbiAgICBpZiAobSkgeyByZXR1cm4gbVsxXTsgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHsgcmV0dXJuIHhzLmluZGV4T2YoeCk7IH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHsgcmV0dXJuIGk7IH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBpc01hcCh4KSB7XG4gICAgaWYgKCFtYXBTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBNYXA7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtNYXAoeCkge1xuICAgIGlmICghd2Vha01hcEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha01hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU2V0KHgpIHtcbiAgICBpZiAoIXNldFNpemUgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc2V0U2l6ZS5jYWxsKHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWFwU2l6ZS5jYWxsKHgpO1xuICAgICAgICB9IGNhdGNoIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFNldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha1NldCh4KSB7XG4gICAgaWYgKCF3ZWFrU2V0SGFzIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdlYWtTZXRIYXMuY2FsbCh4LCB3ZWFrU2V0SGFzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdlYWtNYXBIYXMuY2FsbCh4LCB3ZWFrTWFwSGFzKTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXZWFrU2V0OyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50KHgpIHtcbiAgICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB4Lm5vZGVOYW1lID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgeC5nZXRBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RTdHJpbmcoc3RyLCBvcHRzKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPiBvcHRzLm1heFN0cmluZ0xlbmd0aCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gc3RyLmxlbmd0aCAtIG9wdHMubWF4U3RyaW5nTGVuZ3RoO1xuICAgICAgICB2YXIgdHJhaWxlciA9ICcuLi4gJyArIHJlbWFpbmluZyArICcgbW9yZSBjaGFyYWN0ZXInICsgKHJlbWFpbmluZyA+IDEgPyAncycgOiAnJyk7XG4gICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKHN0ci5zbGljZSgwLCBvcHRzLm1heFN0cmluZ0xlbmd0aCksIG9wdHMpICsgdHJhaWxlcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICB2YXIgcyA9IHN0ci5yZXBsYWNlKC8oWydcXFxcXSkvZywgJ1xcXFwkMScpLnJlcGxhY2UoL1tcXHgwMC1cXHgxZl0vZywgbG93Ynl0ZSk7XG4gICAgcmV0dXJuIHdyYXBRdW90ZXMocywgJ3NpbmdsZScsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBsb3dieXRlKGMpIHtcbiAgICB2YXIgbiA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgeCA9IHtcbiAgICAgICAgODogJ2InLCA5OiAndCcsIDEwOiAnbicsIDEyOiAnZicsIDEzOiAncidcbiAgICB9W25dO1xuICAgIGlmICh4KSB7IHJldHVybiAnXFxcXCcgKyB4OyB9XG4gICAgcmV0dXJuICdcXFxceCcgKyAobiA8IDB4MTAgPyAnMCcgOiAnJykgKyBuLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gbWFya0JveGVkKHN0cikge1xuICAgIHJldHVybiAnT2JqZWN0KCcgKyBzdHIgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHdlYWtDb2xsZWN0aW9uT2YodHlwZSkge1xuICAgIHJldHVybiB0eXBlICsgJyB7ID8gfSc7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25PZih0eXBlLCBzaXplLCBlbnRyaWVzLCBpbmRlbnQpIHtcbiAgICB2YXIgam9pbmVkRW50cmllcyA9IGluZGVudCA/IGluZGVudGVkSm9pbihlbnRyaWVzLCBpbmRlbnQpIDogZW50cmllcy5qb2luKCcsICcpO1xuICAgIHJldHVybiB0eXBlICsgJyAoJyArIHNpemUgKyAnKSB7JyArIGpvaW5lZEVudHJpZXMgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZUxpbmVWYWx1ZXMoeHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbmRleE9mKHhzW2ldLCAnXFxuJykgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRlbnQob3B0cywgZGVwdGgpIHtcbiAgICB2YXIgYmFzZUluZGVudDtcbiAgICBpZiAob3B0cy5pbmRlbnQgPT09ICdcXHQnKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSAnXFx0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmluZGVudCA9PT0gJ251bWJlcicgJiYgb3B0cy5pbmRlbnQgPiAwKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSBBcnJheShvcHRzLmluZGVudCArIDEpLmpvaW4oJyAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZTogYmFzZUluZGVudCxcbiAgICAgICAgcHJldjogQXJyYXkoZGVwdGggKyAxKS5qb2luKGJhc2VJbmRlbnQpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZW50ZWRKb2luKHhzLCBpbmRlbnQpIHtcbiAgICBpZiAoeHMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuICAgIHZhciBsaW5lSm9pbmVyID0gJ1xcbicgKyBpbmRlbnQucHJldiArIGluZGVudC5iYXNlO1xuICAgIHJldHVybiBsaW5lSm9pbmVyICsgeHMuam9pbignLCcgKyBsaW5lSm9pbmVyKSArICdcXG4nICsgaW5kZW50LnByZXY7XG59XG5cbmZ1bmN0aW9uIGFyck9iaktleXMob2JqLCBpbnNwZWN0KSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmopO1xuICAgIHZhciB4cyA9IFtdO1xuICAgIGlmIChpc0Fycikge1xuICAgICAgICB4cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeHNbaV0gPSBoYXMob2JqLCBpKSA/IGluc3BlY3Qob2JqW2ldLCBvYmopIDogJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGlmICghaGFzKG9iaiwga2V5KSkgeyBjb250aW51ZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICBpZiAoaXNBcnIgJiYgU3RyaW5nKE51bWJlcihrZXkpKSA9PT0ga2V5ICYmIGtleSA8IG9iai5sZW5ndGgpIHsgY29udGludWU7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgaWYgKCgvW15cXHckXS8pLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgeHMucHVzaChpbnNwZWN0KGtleSwgb2JqKSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhzLnB1c2goa2V5ICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0sIG9iaikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4cztcbn1cbiIsIi8qIChpZ25vcmVkKSAqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYy5qcycpO1xuXG52YXIgJGNvbnN0cnVjdCA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuY29uc3RydWN0JScsIHRydWUpO1xuXG52YXIgRGVmaW5lUHJvcGVydHlPclRocm93ID0gcmVxdWlyZSgnLi9EZWZpbmVQcm9wZXJ0eU9yVGhyb3cnKTtcbnRyeSB7XG5cdERlZmluZVByb3BlcnR5T3JUaHJvdyh7fSwgJycsIHsgJ1tbR2V0XV0nOiBmdW5jdGlvbiAoKSB7fSB9KTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gQWNjZXNzb3IgcHJvcGVydGllcyBhcmVuJ3Qgc3VwcG9ydGVkXG5cdERlZmluZVByb3BlcnR5T3JUaHJvdyA9IG51bGw7XG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNjb25zdHJ1Y3RvclxuXG5pZiAoRGVmaW5lUHJvcGVydHlPclRocm93ICYmICRjb25zdHJ1Y3QpIHtcblx0dmFyIGlzQ29uc3RydWN0b3JNYXJrZXIgPSB7fTtcblx0dmFyIGJhZEFycmF5TGlrZSA9IHt9O1xuXHREZWZpbmVQcm9wZXJ0eU9yVGhyb3coYmFkQXJyYXlMaWtlLCAnbGVuZ3RoJywge1xuXHRcdCdbW0dldF1dJzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgaXNDb25zdHJ1Y3Rvck1hcmtlcjtcblx0XHR9LFxuXHRcdCdbW0VudW1lcmFibGVdXSc6IHRydWVcblx0fSk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGBSZWZsZWN0LmNvbnN0cnVjdGAgaW52b2tlcyBgSXNDb25zdHJ1Y3Rvcih0YXJnZXQpYCBiZWZvcmUgYEdldChhcmdzLCAnbGVuZ3RoJylgOlxuXHRcdFx0JGNvbnN0cnVjdChhcmd1bWVudCwgYmFkQXJyYXlMaWtlKTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHJldHVybiBlcnIgPT09IGlzQ29uc3RydWN0b3JNYXJrZXI7XG5cdFx0fVxuXHR9O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG5cdFx0Ly8gdW5mb3J0dW5hdGVseSB0aGVyZSdzIG5vIHdheSB0byB0cnVseSBjaGVjayB0aGlzIHdpdGhvdXQgdHJ5L2NhdGNoIGBuZXcgYXJndW1lbnRgIGluIG9sZCBlbnZpcm9ubWVudHNcblx0XHRyZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSAnZnVuY3Rpb24nICYmICEhYXJndW1lbnQucHJvdG90eXBlO1xuXHR9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgaXNQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgRGVmaW5lT3duUHJvcGVydHkgPSByZXF1aXJlKCcuLi9oZWxwZXJzL0RlZmluZU93blByb3BlcnR5Jyk7XG5cbnZhciBGcm9tUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9Gcm9tUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgSXNBY2Nlc3NvckRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL0lzQWNjZXNzb3JEZXNjcmlwdG9yJyk7XG52YXIgSXNEYXRhRGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vSXNEYXRhRGVzY3JpcHRvcicpO1xudmFyIElzUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuL0lzUHJvcGVydHlLZXknKTtcbnZhciBTYW1lVmFsdWUgPSByZXF1aXJlKCcuL1NhbWVWYWx1ZScpO1xudmFyIFRvUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9Ub1Byb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1kZWZpbmVwcm9wZXJ0eW9ydGhyb3dcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEZWZpbmVQcm9wZXJ0eU9yVGhyb3coTywgUCwgZGVzYykge1xuXHRpZiAoVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogVHlwZShPKSBpcyBub3QgT2JqZWN0Jyk7XG5cdH1cblxuXHRpZiAoIUlzUHJvcGVydHlLZXkoUCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogSXNQcm9wZXJ0eUtleShQKSBpcyBub3QgdHJ1ZScpO1xuXHR9XG5cblx0dmFyIERlc2MgPSBpc1Byb3BlcnR5RGVzY3JpcHRvcih7XG5cdFx0VHlwZTogVHlwZSxcblx0XHRJc0RhdGFEZXNjcmlwdG9yOiBJc0RhdGFEZXNjcmlwdG9yLFxuXHRcdElzQWNjZXNzb3JEZXNjcmlwdG9yOiBJc0FjY2Vzc29yRGVzY3JpcHRvclxuXHR9LCBkZXNjKSA/IGRlc2MgOiBUb1Byb3BlcnR5RGVzY3JpcHRvcihkZXNjKTtcblx0aWYgKCFpc1Byb3BlcnR5RGVzY3JpcHRvcih7XG5cdFx0VHlwZTogVHlwZSxcblx0XHRJc0RhdGFEZXNjcmlwdG9yOiBJc0RhdGFEZXNjcmlwdG9yLFxuXHRcdElzQWNjZXNzb3JEZXNjcmlwdG9yOiBJc0FjY2Vzc29yRGVzY3JpcHRvclxuXHR9LCBEZXNjKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBEZXNjIGlzIG5vdCBhIHZhbGlkIFByb3BlcnR5IERlc2NyaXB0b3InKTtcblx0fVxuXG5cdHJldHVybiBEZWZpbmVPd25Qcm9wZXJ0eShcblx0XHRJc0RhdGFEZXNjcmlwdG9yLFxuXHRcdFNhbWVWYWx1ZSxcblx0XHRGcm9tUHJvcGVydHlEZXNjcmlwdG9yLFxuXHRcdE8sXG5cdFx0UCxcblx0XHREZXNjXG5cdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIElzUHJvcGVydHlEZXNjcmlwdG9yKEVTLCBEZXNjKSB7XG5cdGlmIChFUy5UeXBlKERlc2MpICE9PSAnT2JqZWN0Jykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR2YXIgYWxsb3dlZCA9IHtcblx0XHQnW1tDb25maWd1cmFibGVdXSc6IHRydWUsXG5cdFx0J1tbRW51bWVyYWJsZV1dJzogdHJ1ZSxcblx0XHQnW1tHZXRdXSc6IHRydWUsXG5cdFx0J1tbU2V0XV0nOiB0cnVlLFxuXHRcdCdbW1ZhbHVlXV0nOiB0cnVlLFxuXHRcdCdbW1dyaXRhYmxlXV0nOiB0cnVlXG5cdH07XG5cblx0Zm9yICh2YXIga2V5IGluIERlc2MpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuXHRcdGlmIChoYXMoRGVzYywga2V5KSAmJiAhYWxsb3dlZFtrZXldKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0aWYgKEVTLklzRGF0YURlc2NyaXB0b3IoRGVzYykgJiYgRVMuSXNBY2Nlc3NvckRlc2NyaXB0b3IoRGVzYykpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignUHJvcGVydHkgRGVzY3JpcHRvcnMgbWF5IG5vdCBiZSBib3RoIGFjY2Vzc29yIGFuZCBkYXRhIGRlc2NyaXB0b3JzJyk7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG5cbnZhciBhc3NlcnRSZWNvcmQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Fzc2VydFJlY29yZCcpO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzYWNjZXNzb3JkZXNjcmlwdG9yXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSXNBY2Nlc3NvckRlc2NyaXB0b3IoRGVzYykge1xuXHRpZiAodHlwZW9mIERlc2MgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0YXNzZXJ0UmVjb3JkKFR5cGUsICdQcm9wZXJ0eSBEZXNjcmlwdG9yJywgJ0Rlc2MnLCBEZXNjKTtcblxuXHRpZiAoIWhhcyhEZXNjLCAnW1tHZXRdXScpICYmICFoYXMoRGVzYywgJ1tbU2V0XV0nKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJE1hdGggPSBHZXRJbnRyaW5zaWMoJyVNYXRoJScpO1xuXG52YXIgJGZsb29yID0gJE1hdGguZmxvb3I7XG52YXIgJGFicyA9ICRNYXRoLmFicztcblxudmFyICRpc05hTiA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNOYU4nKTtcbnZhciAkaXNGaW5pdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzRmluaXRlJyk7XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNpbnRlZ2VyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSXNJbnRlZ2VyKGFyZ3VtZW50KSB7XG5cdGlmICh0eXBlb2YgYXJndW1lbnQgIT09ICdudW1iZXInIHx8ICRpc05hTihhcmd1bWVudCkgfHwgISRpc0Zpbml0ZShhcmd1bWVudCkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dmFyIGFicyA9ICRhYnMoYXJndW1lbnQpO1xuXHRyZXR1cm4gJGZsb29yKGFicykgPT09IGFicztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkaXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgIT09IGE7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgISRpc05hTih4KSAmJiB4ICE9PSBJbmZpbml0eSAmJiB4ICE9PSAtSW5maW5pdHk7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGxCb3VuZCcpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBjYWxsQm91bmQoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtY2FsbFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENhbGwoRiwgVikge1xuXHR2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogW107XG5cdHJldHVybiAkYXBwbHkoRiwgViwgYXJncyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgQ3JlYXRlRGF0YVByb3BlcnR5ID0gcmVxdWlyZSgnLi9DcmVhdGVEYXRhUHJvcGVydHknKTtcbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyAvLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtY3JlYXRlZGF0YXByb3BlcnR5b3J0aHJvd1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3coTywgUCwgVikge1xuXHRpZiAoVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogVHlwZShPKSBpcyBub3QgT2JqZWN0Jyk7XG5cdH1cblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IElzUHJvcGVydHlLZXkoUCkgaXMgbm90IHRydWUnKTtcblx0fVxuXHR2YXIgc3VjY2VzcyA9IENyZWF0ZURhdGFQcm9wZXJ0eShPLCBQLCBWKTtcblx0aWYgKCFzdWNjZXNzKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ3VuYWJsZSB0byBjcmVhdGUgZGF0YSBwcm9wZXJ0eScpO1xuXHR9XG5cdHJldHVybiBzdWNjZXNzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIERlZmluZU93blByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaGVscGVycy9EZWZpbmVPd25Qcm9wZXJ0eScpO1xuXG52YXIgRnJvbVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vRnJvbVByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIE9yZGluYXJ5R2V0T3duUHJvcGVydHkgPSByZXF1aXJlKCcuL09yZGluYXJ5R2V0T3duUHJvcGVydHknKTtcbnZhciBJc0RhdGFEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9Jc0RhdGFEZXNjcmlwdG9yJyk7XG52YXIgSXNFeHRlbnNpYmxlID0gcmVxdWlyZSgnLi9Jc0V4dGVuc2libGUnKTtcbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgU2FtZVZhbHVlID0gcmVxdWlyZSgnLi9TYW1lVmFsdWUnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtY3JlYXRlZGF0YXByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ3JlYXRlRGF0YVByb3BlcnR5KE8sIFAsIFYpIHtcblx0aWYgKFR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFR5cGUoTykgaXMgbm90IE9iamVjdCcpO1xuXHR9XG5cdGlmICghSXNQcm9wZXJ0eUtleShQKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBJc1Byb3BlcnR5S2V5KFApIGlzIG5vdCB0cnVlJyk7XG5cdH1cblx0dmFyIG9sZERlc2MgPSBPcmRpbmFyeUdldE93blByb3BlcnR5KE8sIFApO1xuXHR2YXIgZXh0ZW5zaWJsZSA9ICFvbGREZXNjIHx8IElzRXh0ZW5zaWJsZShPKTtcblx0dmFyIGltbXV0YWJsZSA9IG9sZERlc2MgJiYgKCFvbGREZXNjWydbW1dyaXRhYmxlXV0nXSB8fCAhb2xkRGVzY1snW1tDb25maWd1cmFibGVdXSddKTtcblx0aWYgKGltbXV0YWJsZSB8fCAhZXh0ZW5zaWJsZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gRGVmaW5lT3duUHJvcGVydHkoXG5cdFx0SXNEYXRhRGVzY3JpcHRvcixcblx0XHRTYW1lVmFsdWUsXG5cdFx0RnJvbVByb3BlcnR5RGVzY3JpcHRvcixcblx0XHRPLFxuXHRcdFAsXG5cdFx0e1xuXHRcdFx0J1tbQ29uZmlndXJhYmxlXV0nOiB0cnVlLFxuXHRcdFx0J1tbRW51bWVyYWJsZV1dJzogdHJ1ZSxcblx0XHRcdCdbW1ZhbHVlXV0nOiBWLFxuXHRcdFx0J1tbV3JpdGFibGVdXSc6IHRydWVcblx0XHR9XG5cdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2FsbEJvdW5kJyk7XG5cbnZhciAkaXNFbnVtZXJhYmxlID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlJyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcblxudmFyIElzQXJyYXkgPSByZXF1aXJlKCcuL0lzQXJyYXknKTtcbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgSXNSZWdFeHAgPSByZXF1aXJlKCcuL0lzUmVnRXhwJyk7XG52YXIgVG9Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL1RvUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9yZGluYXJ5Z2V0b3ducHJvcGVydHlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBPcmRpbmFyeUdldE93blByb3BlcnR5KE8sIFApIHtcblx0aWYgKFR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IE8gbXVzdCBiZSBhbiBPYmplY3QnKTtcblx0fVxuXHRpZiAoIUlzUHJvcGVydHlLZXkoUCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogUCBtdXN0IGJlIGEgUHJvcGVydHkgS2V5Jyk7XG5cdH1cblx0aWYgKCFoYXMoTywgUCkpIHtcblx0XHRyZXR1cm4gdm9pZCAwO1xuXHR9XG5cdGlmICghJGdPUEQpIHtcblx0XHQvLyBFUzMgLyBJRSA4IGZhbGxiYWNrXG5cdFx0dmFyIGFycmF5TGVuZ3RoID0gSXNBcnJheShPKSAmJiBQID09PSAnbGVuZ3RoJztcblx0XHR2YXIgcmVnZXhMYXN0SW5kZXggPSBJc1JlZ0V4cChPKSAmJiBQID09PSAnbGFzdEluZGV4Jztcblx0XHRyZXR1cm4ge1xuXHRcdFx0J1tbQ29uZmlndXJhYmxlXV0nOiAhKGFycmF5TGVuZ3RoIHx8IHJlZ2V4TGFzdEluZGV4KSxcblx0XHRcdCdbW0VudW1lcmFibGVdXSc6ICRpc0VudW1lcmFibGUoTywgUCksXG5cdFx0XHQnW1tWYWx1ZV1dJzogT1tQXSxcblx0XHRcdCdbW1dyaXRhYmxlXV0nOiB0cnVlXG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gVG9Qcm9wZXJ0eURlc2NyaXB0b3IoJGdPUEQoTywgUCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScpO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJG1hdGNoID0gR2V0SW50cmluc2ljKCclU3ltYm9sLm1hdGNoJScsIHRydWUpO1xuXG52YXIgaGFzUmVnRXhwTWF0Y2hlciA9IHJlcXVpcmUoJ2lzLXJlZ2V4Jyk7XG5cbnZhciBUb0Jvb2xlYW4gPSByZXF1aXJlKCcuL1RvQm9vbGVhbicpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNyZWdleHBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJc1JlZ0V4cChhcmd1bWVudCkge1xuXHRpZiAoIWFyZ3VtZW50IHx8IHR5cGVvZiBhcmd1bWVudCAhPT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKCRtYXRjaCkge1xuXHRcdHZhciBpc1JlZ0V4cCA9IGFyZ3VtZW50WyRtYXRjaF07XG5cdFx0aWYgKHR5cGVvZiBpc1JlZ0V4cCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBUb0Jvb2xlYW4oaXNSZWdFeHApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gaGFzUmVnRXhwTWF0Y2hlcihhcmd1bWVudCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IGhhc1N5bWJvbHMgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG52YXIgaGFzT3duUHJvcGVydHk7XG52YXIgcmVnZXhFeGVjO1xudmFyIGlzUmVnZXhNYXJrZXI7XG52YXIgYmFkU3RyaW5naWZpZXI7XG5cbmlmIChoYXNUb1N0cmluZ1RhZykge1xuXHRoYXNPd25Qcm9wZXJ0eSA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblx0cmVnZXhFeGVjID0gRnVuY3Rpb24uY2FsbC5iaW5kKFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cdGlzUmVnZXhNYXJrZXIgPSB7fTtcblxuXHR2YXIgdGhyb3dSZWdleE1hcmtlciA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aHJvdyBpc1JlZ2V4TWFya2VyO1xuXHR9O1xuXHRiYWRTdHJpbmdpZmllciA9IHtcblx0XHR0b1N0cmluZzogdGhyb3dSZWdleE1hcmtlcixcblx0XHR2YWx1ZU9mOiB0aHJvd1JlZ2V4TWFya2VyXG5cdH07XG5cblx0aWYgKHR5cGVvZiBTeW1ib2wudG9QcmltaXRpdmUgPT09ICdzeW1ib2wnKSB7XG5cdFx0YmFkU3RyaW5naWZpZXJbU3ltYm9sLnRvUHJpbWl0aXZlXSA9IHRocm93UmVnZXhNYXJrZXI7XG5cdH1cbn1cblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciByZWdleENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVG9TdHJpbmdUYWdcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdD8gZnVuY3Rpb24gaXNSZWdleCh2YWx1ZSkge1xuXHRcdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRCh2YWx1ZSwgJ2xhc3RJbmRleCcpO1xuXHRcdHZhciBoYXNMYXN0SW5kZXhEYXRhUHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGhhc093blByb3BlcnR5KGRlc2NyaXB0b3IsICd2YWx1ZScpO1xuXHRcdGlmICghaGFzTGFzdEluZGV4RGF0YVByb3BlcnR5KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHJlZ2V4RXhlYyh2YWx1ZSwgYmFkU3RyaW5naWZpZXIpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBlID09PSBpc1JlZ2V4TWFya2VyO1xuXHRcdH1cblx0fVxuXHQ6IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcblx0XHQvLyBJbiBvbGRlciBicm93c2VycywgdHlwZW9mIHJlZ2V4IGluY29ycmVjdGx5IHJldHVybnMgJ2Z1bmN0aW9uJ1xuXHRcdGlmICghdmFsdWUgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gcmVnZXhDbGFzcztcblx0fTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJE9iamVjdCA9IEdldEludHJpbnNpYygnJU9iamVjdCUnKTtcblxudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc1ByaW1pdGl2ZScpO1xuXG52YXIgJHByZXZlbnRFeHRlbnNpb25zID0gJE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcbnZhciAkaXNFeHRlbnNpYmxlID0gJE9iamVjdC5pc0V4dGVuc2libGU7XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNleHRlbnNpYmxlLW9cblxubW9kdWxlLmV4cG9ydHMgPSAkcHJldmVudEV4dGVuc2lvbnNcblx0PyBmdW5jdGlvbiBJc0V4dGVuc2libGUob2JqKSB7XG5cdFx0cmV0dXJuICFpc1ByaW1pdGl2ZShvYmopICYmICRpc0V4dGVuc2libGUob2JqKTtcblx0fVxuXHQ6IGZ1bmN0aW9uIElzRXh0ZW5zaWJsZShvYmopIHtcblx0XHRyZXR1cm4gIWlzUHJpbWl0aXZlKG9iaik7XG5cdH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaGFzcHJvcGVydHlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBIYXNQcm9wZXJ0eShPLCBQKSB7XG5cdGlmIChUeXBlKE8pICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBgT2AgbXVzdCBiZSBhbiBPYmplY3QnKTtcblx0fVxuXHRpZiAoIUlzUHJvcGVydHlLZXkoUCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogYFBgIG11c3QgYmUgYSBQcm9wZXJ0eSBLZXknKTtcblx0fVxuXHRyZXR1cm4gUCBpbiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRvTnVtYmVyID0gcmVxdWlyZSgnLi9Ub051bWJlcicpO1xuXG4vLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOS42XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuXHRyZXR1cm4gVG9OdW1iZXIoeCkgPj4+IDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnLi4vR2V0SW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xudmFyICROdW1iZXIgPSBHZXRJbnRyaW5zaWMoJyVOdW1iZXIlJyk7XG52YXIgJFJlZ0V4cCA9IEdldEludHJpbnNpYygnJVJlZ0V4cCUnKTtcbnZhciAkcGFyc2VJbnRlZ2VyID0gR2V0SW50cmluc2ljKCclcGFyc2VJbnQlJyk7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGxCb3VuZCcpO1xudmFyIHJlZ2V4VGVzdGVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZWdleFRlc3RlcicpO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc1ByaW1pdGl2ZScpO1xuXG52YXIgJHN0clNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgaXNCaW5hcnkgPSByZWdleFRlc3RlcigvXjBiWzAxXSskL2kpO1xudmFyIGlzT2N0YWwgPSByZWdleFRlc3RlcigvXjBvWzAtN10rJC9pKTtcbnZhciBpc0ludmFsaWRIZXhMaXRlcmFsID0gcmVnZXhUZXN0ZXIoL15bLStdMHhbMC05YS1mXSskL2kpO1xudmFyIG5vbldTID0gWydcXHUwMDg1JywgJ1xcdTIwMGInLCAnXFx1ZmZmZSddLmpvaW4oJycpO1xudmFyIG5vbldTcmVnZXggPSBuZXcgJFJlZ0V4cCgnWycgKyBub25XUyArICddJywgJ2cnKTtcbnZhciBoYXNOb25XUyA9IHJlZ2V4VGVzdGVyKG5vbldTcmVnZXgpO1xuXG4vLyB3aGl0ZXNwYWNlIGZyb206IGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjUuNC4yMFxuLy8gaW1wbGVtZW50YXRpb24gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vYmxvYi92My40LjAvZXM1LXNoaW0uanMjTDEzMDQtTDEzMjRcbnZhciB3cyA9IFtcblx0J1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyxcblx0J1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4Jyxcblx0J1xcdTIwMjlcXHVGRUZGJ1xuXS5qb2luKCcnKTtcbnZhciB0cmltUmVnZXggPSBuZXcgUmVnRXhwKCcoXlsnICsgd3MgKyAnXSspfChbJyArIHdzICsgJ10rJCknLCAnZycpO1xudmFyICRyZXBsYWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UnKTtcbnZhciAkdHJpbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gJHJlcGxhY2UodmFsdWUsIHRyaW1SZWdleCwgJycpO1xufTtcblxudmFyIFRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9Ub1ByaW1pdGl2ZScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbnVtYmVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9OdW1iZXIoYXJndW1lbnQpIHtcblx0dmFyIHZhbHVlID0gaXNQcmltaXRpdmUoYXJndW1lbnQpID8gYXJndW1lbnQgOiBUb1ByaW1pdGl2ZShhcmd1bWVudCwgJE51bWJlcik7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgbnVtYmVyJyk7XG5cdH1cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRpZiAoaXNCaW5hcnkodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gVG9OdW1iZXIoJHBhcnNlSW50ZWdlcigkc3RyU2xpY2UodmFsdWUsIDIpLCAyKSk7XG5cdFx0fSBlbHNlIGlmIChpc09jdGFsKHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIFRvTnVtYmVyKCRwYXJzZUludGVnZXIoJHN0clNsaWNlKHZhbHVlLCAyKSwgOCkpO1xuXHRcdH0gZWxzZSBpZiAoaGFzTm9uV1ModmFsdWUpIHx8IGlzSW52YWxpZEhleExpdGVyYWwodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gTmFOO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdHJpbW1lZCA9ICR0cmltKHZhbHVlKTtcblx0XHRcdGlmICh0cmltbWVkICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gVG9OdW1iZXIodHJpbW1lZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiAkTnVtYmVyKHZhbHVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICR0ZXN0ID0gR2V0SW50cmluc2ljKCdSZWdFeHAucHJvdG90eXBlLnRlc3QnKTtcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnLi9jYWxsQmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZ2V4VGVzdGVyKHJlZ2V4KSB7XG5cdHJldHVybiBjYWxsQmluZCgkdGVzdCwgcmVnZXgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnZXMtdG8tcHJpbWl0aXZlL2VzMjAxNScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvcHJpbWl0aXZlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0cmV0dXJuIHRvUHJpbWl0aXZlKGlucHV0LCBhcmd1bWVudHNbMV0pO1xuXHR9XG5cdHJldHVybiB0b1ByaW1pdGl2ZShpbnB1dCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCc7XG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc1ByaW1pdGl2ZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCdpcy1jYWxsYWJsZScpO1xudmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcblxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcblx0aWYgKHR5cGVvZiBPID09PSAndW5kZWZpbmVkJyB8fCBPID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgbWV0aG9kIG9uICcgKyBPKTtcblx0fVxuXHRpZiAodHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnIHx8IChoaW50ICE9PSAnbnVtYmVyJyAmJiBoaW50ICE9PSAnc3RyaW5nJykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiJyk7XG5cdH1cblx0dmFyIG1ldGhvZE5hbWVzID0gaGludCA9PT0gJ3N0cmluZycgPyBbJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXSA6IFsndmFsdWVPZicsICd0b1N0cmluZyddO1xuXHR2YXIgbWV0aG9kLCByZXN1bHQsIGk7XG5cdGZvciAoaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7ICsraSkge1xuXHRcdG1ldGhvZCA9IE9bbWV0aG9kTmFtZXNbaV1dO1xuXHRcdGlmIChpc0NhbGxhYmxlKG1ldGhvZCkpIHtcblx0XHRcdHJlc3VsdCA9IG1ldGhvZC5jYWxsKE8pO1xuXHRcdFx0aWYgKGlzUHJpbWl0aXZlKHJlc3VsdCkpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0dGhyb3cgbmV3IFR5cGVFcnJvcignTm8gZGVmYXVsdCB2YWx1ZScpO1xufTtcblxudmFyIEdldE1ldGhvZCA9IGZ1bmN0aW9uIEdldE1ldGhvZChPLCBQKSB7XG5cdHZhciBmdW5jID0gT1tQXTtcblx0aWYgKGZ1bmMgIT09IG51bGwgJiYgdHlwZW9mIGZ1bmMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0aWYgKCFpc0NhbGxhYmxlKGZ1bmMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bmMgKyAnIHJldHVybmVkIGZvciBwcm9wZXJ0eSAnICsgUCArICcgb2Ygb2JqZWN0ICcgKyBPICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuYztcblx0fVxuXHRyZXR1cm4gdm9pZCAwO1xufTtcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0KSB7XG5cdGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcblx0XHRyZXR1cm4gaW5wdXQ7XG5cdH1cblx0dmFyIGhpbnQgPSAnZGVmYXVsdCc7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdGlmIChhcmd1bWVudHNbMV0gPT09IFN0cmluZykge1xuXHRcdFx0aGludCA9ICdzdHJpbmcnO1xuXHRcdH0gZWxzZSBpZiAoYXJndW1lbnRzWzFdID09PSBOdW1iZXIpIHtcblx0XHRcdGhpbnQgPSAnbnVtYmVyJztcblx0XHR9XG5cdH1cblxuXHR2YXIgZXhvdGljVG9QcmltO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdGlmIChTeW1ib2wudG9QcmltaXRpdmUpIHtcblx0XHRcdGV4b3RpY1RvUHJpbSA9IEdldE1ldGhvZChpbnB1dCwgU3ltYm9sLnRvUHJpbWl0aXZlKTtcblx0XHR9IGVsc2UgaWYgKGlzU3ltYm9sKGlucHV0KSkge1xuXHRcdFx0ZXhvdGljVG9QcmltID0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mO1xuXHRcdH1cblx0fVxuXHRpZiAodHlwZW9mIGV4b3RpY1RvUHJpbSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIGhpbnQpO1xuXHRcdGlmIChpc1ByaW1pdGl2ZShyZXN1bHQpKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmFibGUgdG8gY29udmVydCBleG90aWMgb2JqZWN0IHRvIHByaW1pdGl2ZScpO1xuXHR9XG5cdGlmIChoaW50ID09PSAnZGVmYXVsdCcgJiYgKGlzRGF0ZShpbnB1dCkgfHwgaXNTeW1ib2woaW5wdXQpKSkge1xuXHRcdGhpbnQgPSAnc3RyaW5nJztcblx0fVxuXHRyZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgaGludCA9PT0gJ2RlZmF1bHQnID8gJ251bWJlcicgOiBoaW50KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RGF5ID0gRGF0ZS5wcm90b3R5cGUuZ2V0RGF5O1xudmFyIHRyeURhdGVPYmplY3QgPSBmdW5jdGlvbiB0cnlEYXRlR2V0RGF5Q2FsbCh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGdldERheS5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRGF0ZU9iamVjdCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlEYXRlT2JqZWN0KHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSBkYXRlQ2xhc3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG5cbmlmIChoYXNTeW1ib2xzKSB7XG5cdHZhciBzeW1Ub1N0ciA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBzeW1TdHJpbmdSZWdleCA9IC9eU3ltYm9sXFwoLipcXCkkLztcblx0dmFyIGlzU3ltYm9sT2JqZWN0ID0gZnVuY3Rpb24gaXNSZWFsU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZS52YWx1ZU9mKCkgIT09ICdzeW1ib2wnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBzeW1TdHJpbmdSZWdleC50ZXN0KHN5bVRvU3RyLmNhbGwodmFsdWUpKTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAodG9TdHIuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gaXNTeW1ib2xPYmplY3QodmFsdWUpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG59IGVsc2Uge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcblx0XHQvLyB0aGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU3ltYm9scy5cblx0XHRyZXR1cm4gZmFsc2UgJiYgdmFsdWU7XG5cdH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMnKTtcblxudmFyICRPYmplY3QgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QlJyk7XG5cbnZhciBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlJyk7XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9vYmplY3RcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUb09iamVjdCh2YWx1ZSkge1xuXHRSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHZhbHVlKTtcblx0cmV0dXJuICRPYmplY3QodmFsdWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJy4uL0dldEludHJpbnNpYycpO1xuXG52YXIgJFN0cmluZyA9IEdldEludHJpbnNpYygnJVN0cmluZyUnKTtcbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvc3RyaW5nXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9TdHJpbmcoYXJndW1lbnQpIHtcblx0aWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N5bWJvbCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcblx0fVxuXHRyZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuXHQvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxuXHR2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG5cdHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcblx0dmFyIHRocmV3RXhjZXB0aW9uID0gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5cdFx0XHRtZXRob2QuY2FsbCgnZicsIGZ1bmN0aW9uIChfLCBfXywgTykge1xuXHRcdFx0XHRpZiAodHlwZW9mIE8gIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0cHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0bWV0aG9kLmNhbGwoXG5cdFx0XHRcdFtudWxsXSxcblx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdCd1c2Ugc3RyaWN0JztcblxuXHRcdFx0XHRcdHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCd4J1xuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR0aHJld0V4Y2VwdGlvbiA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAhdGhyZXdFeGNlcHRpb24gJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1BcnJheVByb3RvdHlwZU1hcCgpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKFxuXHRcdEFycmF5LnByb3RvdHlwZSxcblx0XHR7IG1hcDogcG9seWZpbGwgfSxcblx0XHR7IG1hcDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcCAhPT0gcG9seWZpbGw7IH0gfVxuXHQpO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZVByb21pc2UgPSByZXF1aXJlKCcuL3JlcXVpcmVQcm9taXNlJyk7XG5cbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1BbGxTZXR0bGVkKCkge1xuXHRyZXF1aXJlUHJvbWlzZSgpO1xuXG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShQcm9taXNlLCB7IGFsbFNldHRsZWQ6IHBvbHlmaWxsIH0sIHtcblx0XHRhbGxTZXR0bGVkOiBmdW5jdGlvbiB0ZXN0QWxsU2V0dGxlZCgpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQgIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLyoqIEBwcml2YXRlICovXG52YXIgQ3VzdG9tRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ3VzdG9tRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IoKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgcGFyYW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIHRzbGliXzEuX19zcHJlYWQocGFyYW1zKSkgfHwgdGhpcztcbiAgICAgICAgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW5cbiAgICAgICAgdmFyIGFjdHVhbFByb3RvID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgYWN0dWFsUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIF90aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIF9uZXdUYXJnZXQuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUVycm9yLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkN1c3RvbUVycm9yID0gQ3VzdG9tRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DdXN0b21FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNhY2hlX2RlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL2NhY2hlLWRlY29yYXRvcnNcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uL0Jhc2VBUElcIik7XG52YXIgQml0c0FQSV8xID0gcmVxdWlyZShcIi4vQml0cy9CaXRzQVBJXCIpO1xudmFyIENoYW5uZWxBUElfMSA9IHJlcXVpcmUoXCIuL0NoYW5uZWwvQ2hhbm5lbEFQSVwiKTtcbnZhciBDaGF0QVBJXzEgPSByZXF1aXJlKFwiLi9DaGF0L0NoYXRBUElcIik7XG52YXIgU2VhcmNoQVBJXzEgPSByZXF1aXJlKFwiLi9TZWFyY2gvU2VhcmNoQVBJXCIpO1xudmFyIFN0cmVhbUFQSV8xID0gcmVxdWlyZShcIi4vU3RyZWFtL1N0cmVhbUFQSVwiKTtcbnZhciBUZWFtQVBJXzEgPSByZXF1aXJlKFwiLi9UZWFtL1RlYW1BUElcIik7XG52YXIgVXNlckFQSV8xID0gcmVxdWlyZShcIi4vVXNlci9Vc2VyQVBJXCIpO1xuLyoqXG4gKiBHcm91cHMgYWxsIEFQSSBjYWxscyBhdmFpbGFibGUgaW4gS3Jha2VuIHY1LlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyB7QFR3aXRjaENsaWVudCNrcmFrZW59LlxuICovXG52YXIgS3Jha2VuQVBJR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoS3Jha2VuQVBJR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gS3Jha2VuQVBJR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJiaXRzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBiaXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpdHNBUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLcmFrZW5BUElHcm91cC5wcm90b3R5cGUsIFwiY2hhbm5lbHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIGNoYW5uZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYW5uZWxBUElfMS5kZWZhdWx0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLcmFrZW5BUElHcm91cC5wcm90b3R5cGUsIFwiY2hhdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggY2hhdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGF0QVBJXzEuZGVmYXVsdCh0aGlzLl9jbGllbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS3Jha2VuQVBJR3JvdXAucHJvdG90eXBlLCBcInNlYXJjaFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggc2VhcmNoaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlYXJjaEFQSV8xLmRlZmF1bHQodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJzdHJlYW1zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBzdHJlYW1zLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUFQSV8xLmRlZmF1bHQodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJ1c2Vyc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggdXNlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXNlckFQSV8xLmRlZmF1bHQodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJ0ZWFtc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggdGVhbXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVhbUFQSV8xLmRlZmF1bHQodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgS3Jha2VuQVBJR3JvdXAucHJvdG90eXBlLCBcImJpdHNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgS3Jha2VuQVBJR3JvdXAucHJvdG90eXBlLCBcImNoYW5uZWxzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJjaGF0XCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJzZWFyY2hcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgS3Jha2VuQVBJR3JvdXAucHJvdG90eXBlLCBcInN0cmVhbXNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZEdldHRlcigpXG4gICAgXSwgS3Jha2VuQVBJR3JvdXAucHJvdG90eXBlLCBcInVzZXJzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWRHZXR0ZXIoKVxuICAgIF0sIEtyYWtlbkFQSUdyb3VwLnByb3RvdHlwZSwgXCJ0ZWFtc1wiLCBudWxsKTtcbiAgICBLcmFrZW5BUElHcm91cCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBLcmFrZW5BUElHcm91cCk7XG4gICAgcmV0dXJuIEtyYWtlbkFQSUdyb3VwO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gS3Jha2VuQVBJR3JvdXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBLcmFrZW5BUElHcm91cDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEtyYWtlbkFQSUdyb3VwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjYWNoZV9kZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzXCIpO1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1Rvb2xraXQvVXNlclRvb2xzXCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIENoZWVybW90ZUxpc3RfMSA9IHJlcXVpcmUoXCIuL0NoZWVybW90ZUxpc3RcIik7XG4vKipcbiAqIFRoZSBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBCaXRzL0NoZWVybW90ZXMuXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQua3Jha2VuLmJpdHNgIG9uIGEge0BUd2l0Y2hDbGllbnR9IGluc3RhbmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGllbnQgPSBUd2l0Y2hDbGllbnQud2l0aENyZWRlbnRpYWxzKGNsaWVudElkLCBhY2Nlc3NUb2tlbik7XG4gKiBjb25zdCBjaGVlcm1vdGVzID0gYXdhaXQgY2xpZW50LmtyYWtlbi5iaXRzLmdldENoZWVybW90ZXMoKTtcbiAqIGBgYFxuICovXG52YXIgQml0c0FQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCaXRzQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJpdHNBUEkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGdsb2JhbCBhbmQgY2hhbm5lbCBjaGVlcm1vdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgeW91IHdhbnQgdG8gcmV0cmlldmUgdGhlIGF2YWlsYWJsZSBjaGVlcm1vdGVzIGZvci5cbiAgICAgKiBJZiBub3QgZ2l2ZW4sIHRoaXMgbWV0aG9kIHJldHJpZXZlcyBhIGxpc3Qgb2YgZ2xvYmFsbHkgYXZhaWxhYmxlIGNoZWVybW90ZXMuXG4gICAgICogQHBhcmFtIGluY2x1ZGVTcG9uc29yZWQgV2hldGhlciB0byBpbmNsdWRlIHNwb25zb3JlZCBjaGVlcm1vdGVzIGluIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIEJpdHNBUEkucHJvdG90eXBlLmdldENoZWVybW90ZXMgPSBmdW5jdGlvbiAoY2hhbm5lbCwgaW5jbHVkZVNwb25zb3JlZCkge1xuICAgICAgICBpZiAoaW5jbHVkZVNwb25zb3JlZCA9PT0gdm9pZCAwKSB7IGluY2x1ZGVTcG9uc29yZWQgPSB0cnVlOyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5LCBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5jaGFubmVsX2lkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlU3BvbnNvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkuaW5jbHVkZV9zcG9uc29yZWQgPSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7IHVybDogJ2JpdHMvYWN0aW9ucycsIHF1ZXJ5OiBxdWVyeSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IENoZWVybW90ZUxpc3RfMS5kZWZhdWx0KGRhdGEuYWN0aW9ucywgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIEJpdHNBUEkucHJvdG90eXBlLCBcImdldENoZWVybW90ZXNcIiwgbnVsbCk7XG4gICAgQml0c0FQSSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBCaXRzQVBJKTtcbiAgICByZXR1cm4gQml0c0FQSTtcbn0oQmFzZUFQSV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJpdHNBUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBCaXRzQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQml0c0FQSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBIVFRQU3RhdHVzQ29kZUVycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRXJyb3JzL0hUVFBTdGF0dXNDb2RlRXJyb3JcIik7XG52YXIgTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FcnJvcnMvTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JcIik7XG52YXIgVXNlclRvb2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVG9vbGtpdC9Vc2VyVG9vbHNcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uLy4uL0Jhc2VBUElcIik7XG52YXIgVXNlcl8xID0gcmVxdWlyZShcIi4uL1VzZXIvVXNlclwiKTtcbnZhciBDaGFubmVsXzEgPSByZXF1aXJlKFwiLi9DaGFubmVsXCIpO1xudmFyIENoYW5uZWxGb2xsb3dfMSA9IHJlcXVpcmUoXCIuL0NoYW5uZWxGb2xsb3dcIik7XG52YXIgQ2hhbm5lbFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vQ2hhbm5lbFN1YnNjcmlwdGlvblwiKTtcbnZhciBQcml2aWxlZ2VkQ2hhbm5lbF8xID0gcmVxdWlyZShcIi4vUHJpdmlsZWdlZENoYW5uZWxcIik7XG52YXIgVGVhbV8xID0gcmVxdWlyZShcIi4uL1RlYW0vVGVhbVwiKTtcbi8qKlxuICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIGNoYW5uZWxzLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmtyYWtlbi5jaGFubmVsc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IGNoYW5uZWwgPSBhd2FpdCBjbGllbnQua3Jha2VuLmNoYW5uZWxzLmdldE15Q2hhbm5lbCgpO1xuICogYGBgXG4gKi9cbnZhciBDaGFubmVsQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENoYW5uZWxBUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbEFQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjaGFubmVsIHRoZSBjbGllbnQgaXMgbG9nZ2VkIGluIHRvLlxuICAgICAqL1xuICAgIENoYW5uZWxBUEkucHJvdG90eXBlLmdldE15Q2hhbm5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gUHJpdmlsZWdlZENoYW5uZWxfMS5kZWZhdWx0LmJpbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7IHVybDogJ2NoYW5uZWwnLCBzY29wZTogJ2NoYW5uZWxfcmVhZCcgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgKF9hLmFwcGx5KFByaXZpbGVnZWRDaGFubmVsXzEuZGVmYXVsdCwgW3ZvaWQgMCwgX2Iuc2VudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsaWVudF0pKSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNoYW5uZWwgZm9yIHRoZSBnaXZlbiB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgeW91IHdhbnQgdG8gcmV0cmlldmUgdGhlIGNoYW5uZWwgZm9yLlxuICAgICAqL1xuICAgIENoYW5uZWxBUEkucHJvdG90eXBlLmdldENoYW5uZWwgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBDaGFubmVsXzEuZGVmYXVsdC5iaW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6IFwiY2hhbm5lbHMvXCIgKyBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IChfYS5hcHBseShDaGFubmVsXzEuZGVmYXVsdCwgW3ZvaWQgMCwgX2Iuc2VudCgpLCB0aGlzLl9jbGllbnRdKSkoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gY2hhbm5lbCB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgeW91IHdhbnQgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSB1cGRhdGVkIGNoYW5uZWwgZGF0YS5cbiAgICAgKi9cbiAgICBDaGFubmVsQVBJLnByb3RvdHlwZS51cGRhdGVDaGFubmVsID0gZnVuY3Rpb24gKGNoYW5uZWwsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbElkO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiY2hhbm5lbHMvXCIgKyBjaGFubmVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25Cb2R5OiB7IGNoYW5uZWw6IGRhdGEgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdjaGFubmVsX2VkaXRvcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgdXNlcnMgdGhhdCBoYXZlIGVkaXRvciByaWdodHMgdG8gdGhlIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB5b3Ugd2FudCB0byByZXRyaWV2ZSB0aGUgbGlzdCBvZiBlZGl0b3JzIGZvci5cbiAgICAgKi9cbiAgICBDaGFubmVsQVBJLnByb3RvdHlwZS5nZXRDaGFubmVsRWRpdG9ycyA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxJZCwgZGF0YTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJjaGFubmVscy9cIiArIGNoYW5uZWxJZCArIFwiL2VkaXRvcnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdjaGFubmVsX3JlYWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEudXNlcnMubWFwKGZ1bmN0aW9uICh1c2VyRGF0YSkgeyByZXR1cm4gbmV3IFVzZXJfMS5kZWZhdWx0KHVzZXJEYXRhLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBmb2xsb3dlcnMgb2YgdGhlIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbCB5b3Ugd2FudCB0byByZXRyaWV2ZSB0aGUgbGlzdCBvZiBmb2xsb3dlcnMgb2YuXG4gICAgICogQHBhcmFtIHBhZ2UgVGhlIHJlc3VsdCBwYWdlIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBsaW1pdCBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIG9yZGVyRGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdG8gb3JkZXIgaW4gLSBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZy5cbiAgICAgKi9cbiAgICBDaGFubmVsQVBJLnByb3RvdHlwZS5nZXRDaGFubmVsRm9sbG93ZXJzID0gZnVuY3Rpb24gKGNoYW5uZWwsIHBhZ2UsIGxpbWl0LCBvcmRlckRpcmVjdGlvbikge1xuICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IDI1OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxJZCwgcXVlcnksIGRhdGE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB7IGxpbWl0OiBsaW1pdC50b1N0cmluZygpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9mZnNldCA9ICgocGFnZSAtIDEpICogbGltaXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5kaXJlY3Rpb24gPSBvcmRlckRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImNoYW5uZWxzL1wiICsgY2hhbm5lbElkICsgXCIvZm9sbG93c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YS5mb2xsb3dzLm1hcChmdW5jdGlvbiAoZm9sbG93KSB7IHJldHVybiBuZXcgQ2hhbm5lbEZvbGxvd18xLmRlZmF1bHQoZm9sbG93LCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBzdWJzY3JpYmVycyBvZiB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHlvdSB3YW50IHRvIHJldHJpZXZlIHRoZSBsaXN0IG9mIHN1YnNjcmliZXJzIG9mLlxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSByZXN1bHQgcGFnZSB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgVGhlIG51bWJlciBvZiByZXN1bHRzIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBvcmRlckRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRvIG9yZGVyIGluIC0gYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcuXG4gICAgICovXG4gICAgQ2hhbm5lbEFQSS5wcm90b3R5cGUuZ2V0Q2hhbm5lbFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoY2hhbm5lbCwgcGFnZSwgbGltaXQsIG9yZGVyRGlyZWN0aW9uKSB7XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gMjU7IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0Q2hhbm5lbFN1YnNjcmlwdGlvbnMoY2hhbm5lbCwgcGFnZSwgbGltaXQsIG9yZGVyRGlyZWN0aW9uKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YS5zdWJzY3JpcHRpb25zLm1hcChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBuZXcgQ2hhbm5lbFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQoc3ViLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdG90YWwgbnVtYmVyIG9mIHN1YnNjcmliZXJzIGZvciB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHlvdSB3YW50IHRvIHJldHJpZXZlIHRoZSBudW1iZXIgb2Ygc3Vic2NyaWJlcnMgZm9yLlxuICAgICAqL1xuICAgIENoYW5uZWxBUEkucHJvdG90eXBlLmdldENoYW5uZWxTdWJzY3JpcHRpb25Db3VudCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0Q2hhbm5lbFN1YnNjcmlwdGlvbnMoY2hhbm5lbCwgMCwgMSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEuX3RvdGFsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHN1YnNjcmlwdGlvbiBkYXRhIGZvciB0aGUgZ2l2ZW4gdXNlciB0byBhIGdpdmVuIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgaWYgdGhlIGNoYW5uZWwgZG9lc24ndCBoYXZlIGEgc3Vic2NyaXB0aW9uIHByb2dyYW0gb3IgdGhlIHVzZXIgaXMgbm90IHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCByZXF1aXJlcyBhY2Nlc3MgdG8gdGhlIGNoYW5uZWwuIElmIHlvdSBvbmx5IGhhdmUgYWNjZXNzIHRvIHRoZSB1c2VyLFxuICAgICAqIHVzZSB7QFVzZXJBUEkjZ2V0U3Vic2NyaXB0aW9uRGF0YX0gaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIGNoZWNrIHRoZSBzdWJzY3JpcHRpb24gdG8uXG4gICAgICogQHBhcmFtIGJ5VXNlciBUaGUgdXNlciB0byBjaGVjayB0aGUgc3Vic2NyaXB0aW9uIGZvci5cbiAgICAgKi9cbiAgICBDaGFubmVsQVBJLnByb3RvdHlwZS5nZXRDaGFubmVsU3Vic2NyaXB0aW9uQnlVc2VyID0gZnVuY3Rpb24gKGNoYW5uZWwsIGJ5VXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsSWQsIHVzZXJJZCwgX2EsIGVfMTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQoYnlVc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gQ2hhbm5lbFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQuYmluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImNoYW5uZWxzL1wiICsgY2hhbm5lbElkICsgXCIvc3Vic2NyaXB0aW9ucy9cIiArIHVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdjaGFubmVsX2NoZWNrX3N1YnNjcmlwdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyAoX2EuYXBwbHkoQ2hhbm5lbFN1YnNjcmlwdGlvbl8xLmRlZmF1bHQsIFt2b2lkIDAsIF9iLnNlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnRdKSkoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEgaW5zdGFuY2VvZiBIVFRQU3RhdHVzQ29kZUVycm9yXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZV8xLnN0YXR1c0NvZGUgPT09IDQyMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMS5kZWZhdWx0KGNoYW5uZWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIHRlYW1zIG9mIHRoZSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgeW91IHdhbnQgdG8gcmV0cmlldmUgdGhlIGxpc3Qgb2YgdGVhbXMgb2YuXG4gICAgICovXG4gICAgQ2hhbm5lbEFQSS5wcm90b3R5cGUuZ2V0Q2hhbm5lbFRlYW1zID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbElkLCBkYXRhO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImNoYW5uZWxzL1wiICsgY2hhbm5lbElkICsgXCIvdGVhbXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhLnRlYW1zLm1hcChmdW5jdGlvbiAodGVhbSkgeyByZXR1cm4gbmV3IFRlYW1fMS5kZWZhdWx0KHRlYW0sIF90aGlzLl9jbGllbnQpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgY29tbWVyY2lhbCBpbiB0aGUgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHN0YXJ0IHRoZSBjb21tZXJjaWFsIGluLlxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgY29tbWVyY2lhbC5cbiAgICAgKi9cbiAgICBDaGFubmVsQVBJLnByb3RvdHlwZS5zdGFydENoYW5uZWxDb21tZXJjaWFsID0gZnVuY3Rpb24gKGNoYW5uZWwsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsSWQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsSWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiY2hhbm5lbHMvXCIgKyBjaGFubmVsSWQgKyBcIi9jb21tZXJjaWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25Cb2R5OiB7IGxlbmd0aDogbGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ2NoYW5uZWxfY29tbWVyY2lhbCdcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBnaXZlbiBjaGFubmVsJ3Mgc3RyZWFtIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHJlc2V0IHRoZSBzdHJlYW0ga2V5IGZvci5cbiAgICAgKi9cbiAgICBDaGFubmVsQVBJLnByb3RvdHlwZS5yZXNldENoYW5uZWxTdHJlYW1LZXkgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsSWQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsSWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiY2hhbm5lbHMvXCIgKyBjaGFubmVsSWQgKyBcIi9zdHJlYW1fa2V5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICdjaGFubmVsX3N0cmVhbSdcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hhbm5lbEFQSS5wcm90b3R5cGUuX2dldENoYW5uZWxTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKGNoYW5uZWwsIHBhZ2UsIGxpbWl0LCBvcmRlckRpcmVjdGlvbikge1xuICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IDI1OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxJZCwgcXVlcnksIGVfMjtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0geyBsaW1pdDogbGltaXQudG9TdHJpbmcoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vZmZzZXQgPSAoKHBhZ2UgLSAxKSAqIGxpbWl0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkuZGlyZWN0aW9uID0gb3JkZXJEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJjaGFubmVscy9cIiArIGNoYW5uZWxJZCArIFwiL3N1YnNjcmlwdGlvbnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ2NoYW5uZWxfc3Vic2NyaXB0aW9ucydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzIgaW5zdGFuY2VvZiBIVFRQU3RhdHVzQ29kZUVycm9yXzEuZGVmYXVsdCAmJiBlXzIuc3RhdHVzQ29kZSA9PT0gNDIyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3Vic2NyaXB0aW9uUHJvZ3JhbUVycm9yXzEuZGVmYXVsdChjaGFubmVsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8yO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgQ2hhbm5lbEFQSS5wcm90b3R5cGUsIFwiZ2V0TXlDaGFubmVsXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBDaGFubmVsQVBJLnByb3RvdHlwZSwgXCJnZXRDaGFubmVsXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DbGVhcnNDYWNoZSgnZ2V0Q2hhbm5lbCcsIDEpXG4gICAgXSwgQ2hhbm5lbEFQSS5wcm90b3R5cGUsIFwidXBkYXRlQ2hhbm5lbFwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgQ2hhbm5lbEFQSS5wcm90b3R5cGUsIFwiZ2V0Q2hhbm5lbEVkaXRvcnNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzMClcbiAgICBdLCBDaGFubmVsQVBJLnByb3RvdHlwZSwgXCJnZXRDaGFubmVsRm9sbG93ZXJzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzApXG4gICAgXSwgQ2hhbm5lbEFQSS5wcm90b3R5cGUsIFwiZ2V0Q2hhbm5lbFN1YnNjcmlwdGlvbnNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzMClcbiAgICBdLCBDaGFubmVsQVBJLnByb3RvdHlwZSwgXCJnZXRDaGFubmVsU3Vic2NyaXB0aW9uQ291bnRcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIENoYW5uZWxBUEkucHJvdG90eXBlLCBcImdldENoYW5uZWxTdWJzY3JpcHRpb25CeVVzZXJcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzMClcbiAgICBdLCBDaGFubmVsQVBJLnByb3RvdHlwZSwgXCJnZXRDaGFubmVsVGVhbXNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNsZWFyc0NhY2hlKCdnZXRNeUNoYW5uZWwnKVxuICAgIF0sIENoYW5uZWxBUEkucHJvdG90eXBlLCBcInJlc2V0Q2hhbm5lbFN0cmVhbUtleVwiLCBudWxsKTtcbiAgICBDaGFubmVsQVBJID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIENoYW5uZWxBUEkpO1xuICAgIHJldHVybiBDaGFubmVsQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbEFQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENoYW5uZWxBUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFubmVsQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjYWNoZV9kZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzXCIpO1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1Rvb2xraXQvVXNlclRvb2xzXCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIENoYXRFbW90ZUxpc3RfMSA9IHJlcXVpcmUoXCIuL0NoYXRFbW90ZUxpc3RcIik7XG52YXIgQ2hhdFJvb21fMSA9IHJlcXVpcmUoXCIuL0NoYXRSb29tXCIpO1xuLyoqXG4gKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggY2hhdCBhbmQgY2hhdHJvb21zLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmtyYWtlbi5jaGF0YCBvbiBhIHtAVHdpdGNoQ2xpZW50fSBpbnN0YW5jZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgY2xpZW50ID0gVHdpdGNoQ2xpZW50LndpdGhDcmVkZW50aWFscyhjbGllbnRJZCwgYWNjZXNzVG9rZW4pO1xuICogY29uc3QgZW1vdGVzID0gYXdhaXQgY2xpZW50LmtyYWtlbi5jaGF0LmdldEVtb3Rlc0J5U2V0cygnMScpO1xuICogYGBgXG4gKi9cbnZhciBDaGF0QVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENoYXRBUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhdEFQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGVtb3RlcyBmb3IgYSBnaXZlbiBsaXN0IG9mIGVub3RlIHNldCBJRHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW1vdGVzZXRzIFRoZSBsaXN0IG9mIGVtb3RlIHNldCBJRHMsIGVpdGhlciBhcyBhcnJheSBvZiBzdHJpbmdzIG9yIGFzIGEgY29tbWEgc2VwYXJhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBDaGF0QVBJLnByb3RvdHlwZS5nZXRFbW90ZXNCeVNldHMgPSBmdW5jdGlvbiAoZW1vdGVzZXRzKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW1vdGVzZXRzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtb3Rlc2V0cyA9IGVtb3Rlc2V0cy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2NoYXQvZW1vdGljb25faW1hZ2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtb3Rlc2V0czogZW1vdGVzZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IENoYXRFbW90ZUxpc3RfMS5kZWZhdWx0KGRhdGEuZW1vdGljb25zLCB0aGlzLl9jbGllbnQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGNoYXQgcm9vbXMgZm9yIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHJldHJpZXZlIHRoZSBjaGF0IHJvb21zIG9mLlxuICAgICAqL1xuICAgIENoYXRBUEkucHJvdG90eXBlLmdldENoYXRSb29tc0ZvckNoYW5uZWwgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImNoYXQvXCIgKyBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpICsgXCIvcm9vbXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEucm9vbXMubWFwKGZ1bmN0aW9uIChyb29tKSB7IHJldHVybiBuZXcgQ2hhdFJvb21fMS5kZWZhdWx0KHJvb20sIF90aGlzLl9jbGllbnQpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIENoYXRBUEkucHJvdG90eXBlLCBcImdldEVtb3Rlc0J5U2V0c1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgQ2hhdEFQSS5wcm90b3R5cGUsIFwiZ2V0Q2hhdFJvb21zRm9yQ2hhbm5lbFwiLCBudWxsKTtcbiAgICBDaGF0QVBJID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIENoYXRBUEkpO1xuICAgIHJldHVybiBDaGF0QVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEFQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENoYXRBUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGF0QVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjYWNoZV9kZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIENoYXRFbW90ZV8xID0gcmVxdWlyZShcIi4vQ2hhdEVtb3RlXCIpO1xuLyoqXG4gKiBBIGxpc3Qgb2YgZW1vdGVzLlxuICovXG52YXIgQ2hhdEVtb3RlTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBDaGF0RW1vdGVMaXN0KF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0RW1vdGVMaXN0LnByb3RvdHlwZSwgXCJlbW90ZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGFsbCBlbW90ZXMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5tYXAoZnVuY3Rpb24gKGVtb3RlKSB7IHJldHVybiBuZXcgQ2hhdEVtb3RlXzEuZGVmYXVsdChlbW90ZSwgX3RoaXMuX2NsaWVudCk7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBlbW90ZXMgZnJvbSB0aGUgbGlzdCB0aGF0IGFyZSBmcm9tIGEgZ2l2ZW4gZW1vdGUgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNldElkXG4gICAgICovXG4gICAgQ2hhdEVtb3RlTGlzdC5wcm90b3R5cGUuZ2V0QWxsRnJvbVNldCA9IGZ1bmN0aW9uIChzZXRJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZW1vdGUpIHsgcmV0dXJuIGVtb3RlLmVtb3RpY29uX3NldCA9PT0gc2V0SWQ7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlbW90ZSkgeyByZXR1cm4gbmV3IENoYXRFbW90ZV8xLmRlZmF1bHQoZW1vdGUsIF90aGlzLl9jbGllbnQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgc2luZ2xlIGVtb3RlIGJ5IGl0cyBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZFxuICAgICAqL1xuICAgIENoYXRFbW90ZUxpc3QucHJvdG90eXBlLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhLmZpbmQoZnVuY3Rpb24gKGVtb3RlKSB7IHJldHVybiBlbW90ZS5pZCA9PT0gaWQ7IH0pO1xuICAgICAgICByZXR1cm4gZGF0YSA/IG5ldyBDaGF0RW1vdGVfMS5kZWZhdWx0KGRhdGEsIHRoaXMuX2NsaWVudCkgOiBudWxsO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIENoYXRFbW90ZUxpc3QucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkR2V0dGVyKClcbiAgICBdLCBDaGF0RW1vdGVMaXN0LnByb3RvdHlwZSwgXCJlbW90ZXNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgpXG4gICAgXSwgQ2hhdEVtb3RlTGlzdC5wcm90b3R5cGUsIFwiZ2V0QWxsRnJvbVNldFwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKClcbiAgICBdLCBDaGF0RW1vdGVMaXN0LnByb3RvdHlwZSwgXCJnZXRCeUlkXCIsIG51bGwpO1xuICAgIENoYXRFbW90ZUxpc3QgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVhYmxlXG4gICAgXSwgQ2hhdEVtb3RlTGlzdCk7XG4gICAgcmV0dXJuIENoYXRFbW90ZUxpc3Q7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEVtb3RlTGlzdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENoYXRFbW90ZUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGF0RW1vdGVMaXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbi8qKlxuICogQSBjaGF0IGVtb3RlLlxuICovXG52YXIgQ2hhdEVtb3RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIENoYXRFbW90ZShfZGF0YSwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdEVtb3RlLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZW1vdGUgSUQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdEVtb3RlLnByb3RvdHlwZSwgXCJjb2RlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlbW90ZSBjb2RlLCBpLmUuIGhvdyB5b3Ugd3JpdGUgaXQgaW4gY2hhdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuY29kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRFbW90ZS5wcm90b3R5cGUsIFwic2V0SWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBlbW90ZSBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmVtb3RpY29uX3NldDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIENoYXRFbW90ZS5wcm90b3R5cGUsIFwiX2NsaWVudFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBDaGF0RW1vdGU7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEVtb3RlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ2hhdEVtb3RlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhdEVtb3RlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8qKiBAcHJpdmF0ZSAqL1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xudmFyIENoYXRSb29tID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIENoYXRSb29tKF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0Um9vbS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBjaGF0IHJvb20uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRSb29tLnByb3RvdHlwZSwgXCJvd25lcklkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1c2VyIElEIG9mIHRoZSBjaGF0IHJvb20gb3duZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLm93bmVyX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHVzZXIgZGF0YSBvZiB0aGUgY2hhdCByb29tIG93bmVyLlxuICAgICAqL1xuICAgIENoYXRSb29tLnByb3RvdHlwZS5nZXRPd25lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2xpZW50LmtyYWtlbi51c2Vycy5nZXRVc2VyKHRoaXMuX2RhdGEub3duZXJfaWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0Um9vbS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY2hhdCByb29tLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdFJvb20ucHJvdG90eXBlLCBcInRvcGljXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3BpYyBvZiB0aGUgY2hhdCByb29tLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS50b3BpYztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXRSb29tLnByb3RvdHlwZSwgXCJpc1ByZXZpZXdhYmxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNoYXQgcm9vbSBpcyBwcmV2aWV3YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaXNfcHJldmlld2FibGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGF0Um9vbS5wcm90b3R5cGUsIFwibWluUm9sZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluaW11bSByb2xlIGFsbG93ZWQgdG8gZW50ZXIgdGhpcyBjaGF0IHJvb20uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLm1pbmltdW1fYWxsb3dlZF9yb2xlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhdFJvb20ucHJvdG90eXBlLCBcImlyY05hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIElSQyBjaGFubmVsIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhpcyBjaGF0IHJvb20uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIiNjaGF0cm9vbXM6XCIgKyB0aGlzLl9kYXRhLm93bmVyX2lkICsgXCI6XCIgKyB0aGlzLl9kYXRhLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgc2hhcmVkX3V0aWxzXzEuTm9uRW51bWVyYWJsZVxuICAgIF0sIENoYXRSb29tLnByb3RvdHlwZSwgXCJfY2xpZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIENoYXRSb29tO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYXRSb29tO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ2hhdFJvb207XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGF0Um9vbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBCYXNlQVBJXzEgPSByZXF1aXJlKFwiLi4vLi4vQmFzZUFQSVwiKTtcbnZhciBDaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vQ2hhbm5lbC9DaGFubmVsXCIpO1xudmFyIFN0cmVhbV8xID0gcmVxdWlyZShcIi4uL1N0cmVhbS9TdHJlYW1cIik7XG4vKipcbiAqIFRoZSBBUEkgbWV0aG9kcyB0aGF0IGRlYWwgd2l0aCBzZWFyY2hpbmcuXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQua3Jha2VuLnNlYXJjaGAgb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IGNoYW5uZWwgPSBhd2FpdCBjbGllbnQua3Jha2VuLnNlYXJjaC5zZWFyY2hTdHJlYW1zKCdIZWFydGhzdG9uZScpO1xuICogYGBgXG4gKi9cbnZhciBTZWFyY2hBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2VhcmNoQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlYXJjaEFQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGNoYW5uZWxzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHNlYXJjaCB0ZXJtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRlcm0gVGhlIHRlcm0geW91IHdhbnQgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0gcGFnZSBUaGUgcmVzdWx0IHBhZ2UgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIGxpbWl0IFRoZSBudW1iZXIgb2YgcmVzdWx0cyB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBTZWFyY2hBUEkucHJvdG90eXBlLnNlYXJjaENoYW5uZWxzID0gZnVuY3Rpb24gKHRlcm0sIHBhZ2UsIGxpbWl0KSB7XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gMjU7IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnksIGRhdGE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHsgcXVlcnk6IHRlcm0sIGxpbWl0OiBsaW1pdC50b1N0cmluZygpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9mZnNldCA9ICgocGFnZSAtIDEpICogbGltaXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7IHVybDogJ3NlYXJjaC9jaGFubmVscycsIHF1ZXJ5OiBxdWVyeSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YS5jaGFubmVscy5tYXAoZnVuY3Rpb24gKGNoYW5uZWxEYXRhKSB7IHJldHVybiBuZXcgQ2hhbm5lbF8xLmRlZmF1bHQoY2hhbm5lbERhdGEsIF90aGlzLl9jbGllbnQpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBzdHJlYW1zIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHNlYXJjaCB0ZXJtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRlcm0gVGhlIHRlcm0geW91IHdhbnQgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0gcGFnZSBUaGUgcmVzdWx0IHBhZ2UgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIGxpbWl0IFRoZSBudW1iZXIgb2YgcmVzdWx0cyB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gaGxzIFdoZXRoZXIgeW91IHdhbnQgb25seSBITFMgb3Igb25seSBub24tSExTIChSVE1QKSBzdHJlYW1zLiBJZiBub3Qgc2V0LCBmaW5kcyBib3RoIHR5cGVzIG9mIHN0cmVhbXMuXG4gICAgICovXG4gICAgU2VhcmNoQVBJLnByb3RvdHlwZS5zZWFyY2hTdHJlYW1zID0gZnVuY3Rpb24gKHRlcm0sIHBhZ2UsIGxpbWl0LCBobHMpIHtcbiAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSAyNTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSwgZGF0YTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0geyBxdWVyeTogdGVybSwgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkub2Zmc2V0ID0gKChwYWdlIC0gMSkgKiBsaW1pdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LmhscyA9IGhscy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6ICdzZWFyY2gvc3RyZWFtcycsIHF1ZXJ5OiBxdWVyeSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YS5zdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtRGF0YSkgeyByZXR1cm4gbmV3IFN0cmVhbV8xLmRlZmF1bHQoc3RyZWFtRGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDMwMClcbiAgICBdLCBTZWFyY2hBUEkucHJvdG90eXBlLCBcInNlYXJjaENoYW5uZWxzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzAwKVxuICAgIF0sIFNlYXJjaEFQSS5wcm90b3R5cGUsIFwic2VhcmNoU3RyZWFtc1wiLCBudWxsKTtcbiAgICBTZWFyY2hBUEkgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVhYmxlXG4gICAgXSwgU2VhcmNoQVBJKTtcbiAgICByZXR1cm4gU2VhcmNoQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2VhcmNoQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU2VhcmNoQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2VhcmNoQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjYWNoZV9kZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzXCIpO1xudmFyIFVzZXJUb29sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1Rvb2xraXQvVXNlclRvb2xzXCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIFN0cmVhbV8xID0gcmVxdWlyZShcIi4vU3RyZWFtXCIpO1xuLyoqXG4gKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggc3RyZWFtcy5cbiAqXG4gKiBDYW4gYmUgYWNjZXNzZWQgdXNpbmcgYGNsaWVudC5rcmFrZW4uc3RyZWFtc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGNsaWVudC5rcmFrZW4uc3RyZWFtcy5nZXRTdHJlYW1CeUNoYW5uZWwoJzEyNTMyODY1NScpO1xuICogYGBgXG4gKi9cbnZhciBTdHJlYW1BUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3RyZWFtQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cmVhbUFQSSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc3RyZWFtIG9uIHRoZSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWxcbiAgICAgKi9cbiAgICBTdHJlYW1BUEkucHJvdG90eXBlLmdldFN0cmVhbUJ5Q2hhbm5lbCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxJZCwgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHsgdXJsOiBcInN0cmVhbXMvXCIgKyBjaGFubmVsSWQgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEuc3RyZWFtID8gbmV3IFN0cmVhbV8xLmRlZmF1bHQoZGF0YS5zdHJlYW0sIHRoaXMuX2NsaWVudCkgOiBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIHN0cmVhbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbHMgQSBjaGFubmVsIElEIG9yIGEgbGlzdCB0aGVyZW9mLlxuICAgICAqIEBwYXJhbSBnYW1lIFNob3cgb25seSBzdHJlYW1zIHBsYXlpbmcgYSBjZXJ0YWluIGdhbWUuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlQ29kZSBTaG93IG9ubHkgc3RyZWFtcyBpbiBhIGNlcnRhaW4gbGFuZ3VhZ2UuXG4gICAgICogQHBhcmFtIHR5cGUgU2hvdyBvbmx5IHN0cmVhbXMgb2YgYSBjZXJ0YWluIHR5cGUuXG4gICAgICogQHBhcmFtIHBhZ2UgVGhlIHJlc3VsdCBwYWdlIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBsaW1pdCBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICovXG4gICAgU3RyZWFtQVBJLnByb3RvdHlwZS5nZXRTdHJlYW1zID0gZnVuY3Rpb24gKGNoYW5uZWxzLCBnYW1lLCBsYW5ndWFnZUNvZGUsIHR5cGUsIHBhZ2UsIGxpbWl0KSB7XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gMjU7IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnksIGRhdGE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHsgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LmNoYW5uZWwgPSB0eXBlb2YgY2hhbm5lbHMgPT09ICdzdHJpbmcnID8gY2hhbm5lbHMgOiBjaGFubmVscy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LmdhbWUgPSBnYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lmxhbmd1YWdlID0gbGFuZ3VhZ2VDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5zdHJlYW1fdHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9mZnNldCA9ICgocGFnZSAtIDEpICogbGltaXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7IHVybDogJ3N0cmVhbXMnLCBxdWVyeTogcXVlcnkgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGEuc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbURhdGEpIHsgcmV0dXJuIG5ldyBTdHJlYW1fMS5kZWZhdWx0KHN0cmVhbURhdGEsIF90aGlzLl9jbGllbnQpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgc3RyZWFtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSByZXN1bHQgcGFnZSB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgVGhlIG51bWJlciBvZiByZXN1bHRzIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIFN0cmVhbUFQSS5wcm90b3R5cGUuZ2V0QWxsU3RyZWFtcyA9IGZ1bmN0aW9uIChwYWdlLCBsaW1pdCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmdldFN0cmVhbXModW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyZWFtXzEuU3RyZWFtVHlwZS5BbGwsIHBhZ2UsIGxpbWl0KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGFsbCBsaXZlIHN0cmVhbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZSBUaGUgcmVzdWx0IHBhZ2UgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIGxpbWl0IFRoZSBudW1iZXIgb2YgcmVzdWx0cyB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBTdHJlYW1BUEkucHJvdG90eXBlLmdldEFsbExpdmVTdHJlYW1zID0gZnVuY3Rpb24gKHBhZ2UsIGxpbWl0KSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZ2V0U3RyZWFtcyh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJlYW1fMS5TdHJlYW1UeXBlLkxpdmUsIHBhZ2UsIGxpbWl0KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGFsbCBzdHJlYW1zIG9uIGNoYW5uZWxzIHRoZSBjdXJyZW50bHkgYXV0aGVudGljYXRlZCB1c2VyIGlzIGZvbGxvd2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIFNob3cgb25seSBzdHJlYW1zIG9mIGEgY2VydGFpbiB0eXBlLlxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSByZXN1bHQgcGFnZSB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgVGhlIG51bWJlciBvZiByZXN1bHRzIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIFN0cmVhbUFQSS5wcm90b3R5cGUuZ2V0Rm9sbG93ZWRTdHJlYW1zID0gZnVuY3Rpb24gKHR5cGUsIHBhZ2UsIGxpbWl0KSB7XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gMjU7IH1cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnksIGRhdGE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHsgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9mZnNldCA9ICgocGFnZSAtIDEpICogbGltaXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ3N0cmVhbXMvZm9sbG93ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAndXNlcl9yZWFkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhLnN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW1EYXRhKSB7IHJldHVybiBuZXcgU3RyZWFtXzEuZGVmYXVsdChzdHJlYW1EYXRhLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoNjApXG4gICAgXSwgU3RyZWFtQVBJLnByb3RvdHlwZSwgXCJnZXRTdHJlYW1CeUNoYW5uZWxcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCg2MClcbiAgICBdLCBTdHJlYW1BUEkucHJvdG90eXBlLCBcImdldEZvbGxvd2VkU3RyZWFtc1wiLCBudWxsKTtcbiAgICBTdHJlYW1BUEkgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVhYmxlXG4gICAgXSwgU3RyZWFtQVBJKTtcbiAgICByZXR1cm4gU3RyZWFtQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RyZWFtQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU3RyZWFtQVBJO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RyZWFtQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjYWNoZV9kZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiQGQtZmlzY2hlci9jYWNoZS1kZWNvcmF0b3JzXCIpO1xudmFyIEJhc2VBUElfMSA9IHJlcXVpcmUoXCIuLi8uLi9CYXNlQVBJXCIpO1xudmFyIFRlYW1fMSA9IHJlcXVpcmUoXCIuL1RlYW1cIik7XG52YXIgVGVhbVdpdGhVc2Vyc18xID0gcmVxdWlyZShcIi4vVGVhbVdpdGhVc2Vyc1wiKTtcbi8qKlxuICogVGhlIEFQSSBtZXRob2RzIHRoYXQgZGVhbCB3aXRoIHRlYW1zLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LmtyYWtlbi50ZWFtc2Agb24gYSB7QFR3aXRjaENsaWVudH0gaW5zdGFuY2UuXG4gKlxuICogIyMgRXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIGFjY2Vzc1Rva2VuKTtcbiAqIGNvbnN0IHRlYW0gPSBhd2FpdCBjbGllbnQua3Jha2VuLnRlYW1zLmdldFRlYW1CeU5hbWUoJ3N0YWZmJyk7XG4gKiBgYGBcbiAqL1xudmFyIFRlYW1BUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGVhbUFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZWFtQVBJKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdGVhbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZSBUaGUgcmVzdWx0IHBhZ2UgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIGxpbWl0IFRoZSBudW1iZXIgb2YgcmVzdWx0cyB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBUZWFtQVBJLnByb3RvdHlwZS5nZXRUZWFtcyA9IGZ1bmN0aW9uIChwYWdlLCBsaW1pdCkge1xuICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IDI1OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5LCBkYXRhO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkub2Zmc2V0ID0gKChwYWdlIC0gMSkgKiBsaW1pdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LmxpbWl0ID0gbGltaXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAndGVhbXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YS50ZWFtcy5tYXAoZnVuY3Rpb24gKHRlYW0pIHsgcmV0dXJuIG5ldyBUZWFtXzEuZGVmYXVsdCh0ZWFtLCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdGVhbSBkYXRhIGZvciB0aGUgZ2l2ZW4gdGVhbSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRlYW0gVGhlIHRlYW0gbmFtZSB5b3Ugd2FudCB0byBsb29rIHVwLlxuICAgICAqL1xuICAgIFRlYW1BUEkucHJvdG90eXBlLmdldFRlYW1CeU5hbWUgPSBmdW5jdGlvbiAodGVhbSkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0ZWFtRGF0YTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7IHVybDogXCJ0ZWFtcy9cIiArIHRlYW0gfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtRGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgVGVhbVdpdGhVc2Vyc18xLmRlZmF1bHQodGVhbURhdGEsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBUZWFtQVBJLnByb3RvdHlwZSwgXCJnZXRUZWFtc1wiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgVGVhbUFQSS5wcm90b3R5cGUsIFwiZ2V0VGVhbUJ5TmFtZVwiLCBudWxsKTtcbiAgICBUZWFtQVBJID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlYWJsZVxuICAgIF0sIFRlYW1BUEkpO1xuICAgIHJldHVybiBUZWFtQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVGVhbUFQSTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFRlYW1BUEk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUZWFtQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBUZWFtXzEgPSByZXF1aXJlKFwiLi9UZWFtXCIpO1xudmFyIFVzZXJfMSA9IHJlcXVpcmUoXCIuLi9Vc2VyL1VzZXJcIik7XG52YXIgVGVhbVdpdGhVc2VycyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUZWFtV2l0aFVzZXJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlYW1XaXRoVXNlcnMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgdXNlcnMgaW4gdGhlIHRlYW0uXG4gICAgICovXG4gICAgVGVhbVdpdGhVc2Vycy5wcm90b3R5cGUuZ2V0VXNlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9kYXRhLnVzZXJzLm1hcChmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IFVzZXJfMS5kZWZhdWx0KGRhdGEsIF90aGlzLl9jbGllbnQpOyB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVhbVdpdGhVc2Vycztcbn0oVGVhbV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRlYW1XaXRoVXNlcnM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBUZWFtV2l0aFVzZXJzO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gVGVhbVdpdGhVc2VycztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBIZWxsRnJlZXplc092ZXJFcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0Vycm9ycy9IZWxsRnJlZXplc092ZXJFcnJvclwiKTtcbnZhciBIVFRQU3RhdHVzQ29kZUVycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRXJyb3JzL0hUVFBTdGF0dXNDb2RlRXJyb3JcIik7XG52YXIgTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FcnJvcnMvTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JcIik7XG52YXIgVXNlclRvb2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVG9vbGtpdC9Vc2VyVG9vbHNcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uLy4uL0Jhc2VBUElcIik7XG52YXIgRW1vdGVTZXRMaXN0XzEgPSByZXF1aXJlKFwiLi4vQ2hhbm5lbC9FbW90ZVNldExpc3RcIik7XG52YXIgUHJpdmlsZWdlZFVzZXJfMSA9IHJlcXVpcmUoXCIuL1ByaXZpbGVnZWRVc2VyXCIpO1xudmFyIFVzZXJfMSA9IHJlcXVpcmUoXCIuL1VzZXJcIik7XG52YXIgVXNlckJsb2NrXzEgPSByZXF1aXJlKFwiLi9Vc2VyQmxvY2tcIik7XG52YXIgVXNlckNoYXRJbmZvXzEgPSByZXF1aXJlKFwiLi9Vc2VyQ2hhdEluZm9cIik7XG52YXIgVXNlckZvbGxvd18xID0gcmVxdWlyZShcIi4vVXNlckZvbGxvd1wiKTtcbnZhciBVc2VyU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9Vc2VyU3Vic2NyaXB0aW9uXCIpO1xuLyoqXG4gKiBUaGUgQVBJIG1ldGhvZHMgdGhhdCBkZWFsIHdpdGggdXNlcnMuXG4gKlxuICogQ2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBjbGllbnQua3Jha2VuLnVzZXJzYCBvbiBhIHtAVHdpdGNoQ2xpZW50fSBpbnN0YW5jZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgY2xpZW50ID0gVHdpdGNoQ2xpZW50LndpdGhDcmVkZW50aWFscyhjbGllbnRJZCwgYWNjZXNzVG9rZW4pO1xuICogY29uc3QgdXNlciA9IGF3YWl0IGNsaWVudC5rcmFrZW4udXNlcnMuZ2V0VXNlcignMTI1MzI4NjU1Jyk7XG4gKiBgYGBcbiAqL1xudmFyIFVzZXJBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVXNlckFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVc2VyQVBJKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3VzZXJCeU5hbWVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHVzZXIgZGF0YSBvZiB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlci5cbiAgICAgKi9cbiAgICBVc2VyQVBJLnByb3RvdHlwZS5nZXRNZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gUHJpdmlsZWdlZFVzZXJfMS5kZWZhdWx0LmJpbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7IHVybDogJ3VzZXInLCBzY29wZTogJ3VzZXJfcmVhZCcgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgKF9hLmFwcGx5KFByaXZpbGVnZWRVc2VyXzEuZGVmYXVsdCwgW3ZvaWQgMCwgX2Iuc2VudCgpLCB0aGlzLl9jbGllbnRdKSkoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgZm9yIHRoZSBnaXZlbiB1c2VyIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJJZCBUaGUgdXNlciBJRCB5b3Ugd2FudCB0byBsb29rIHVwLlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLmdldFVzZXIgPSBmdW5jdGlvbiAodXNlcklkKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJEYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHsgdXJsOiBcInVzZXJzL1wiICsgVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VySWQpIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEhlbGxGcmVlemVzT3ZlckVycm9yXzEuZGVmYXVsdCgnQ291bGQgbm90IGdldCBhdXRoZW50aWNhdGVkIHVzZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgVXNlcl8xLmRlZmF1bHQodXNlckRhdGEsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdXNlciBkYXRhIGZvciB0aGUgZ2l2ZW4gdXNlciBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJOYW1lIFRoZSB1c2VyIG5hbWUgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKi9cbiAgICBVc2VyQVBJLnByb3RvdHlwZS5nZXRVc2VyQnlOYW1lID0gZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJzLCB1c2VyO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgdXNpbmcgdGhlIGRlY29yYXRvcidzIGNhY2hlIGhlcmUgYXMgdXNlcnMtYnktbmFtZSBpcyBzbGlnaHRseSBtb3JlIGNvbXBsZXggdG8gY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFuVXNlckNhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXNlckJ5TmFtZUNhY2hlLmhhcyh1c2VyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fdXNlckJ5TmFtZUNhY2hlLmdldCh1c2VyTmFtZSkudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6ICd1c2VycycsIHF1ZXJ5OiB7IGxvZ2luOiB1c2VyTmFtZSB9IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnMgPSAoX2Euc2VudCgpKS51c2VycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2Vycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyID0gbmV3IFVzZXJfMS5kZWZhdWx0KHVzZXJzWzBdLCB0aGlzLl9jbGllbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXNlckJ5TmFtZUNhY2hlLnNldCh1c2VyTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1c2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXM6IERhdGUubm93KCkgKyAzNjAwICogMTAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdXNlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgZm9yIHRoZSBnaXZlbiB1c2VyIG5hbWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJOYW1lcyBUaGUgdXNlciBuYW1lcyB5b3Ugd2FudCB0byBsb29rIHVwLlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLmdldFVzZXJzQnlOYW1lcyA9IGZ1bmN0aW9uICh1c2VyTmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVkRW50cmllcywgY2FjaGVkT2JqZWN0LCBjYWNoZWRVc2VycywgdG9GZXRjaCwgdXNlcnNEYXRhLCB1c2Vyc0FyciwgdXNlcnM7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhblVzZXJDYWNoZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlck5hbWVzID0gdXNlck5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEVudHJpZXMgPSBBcnJheS5mcm9tKHRoaXMuX3VzZXJCeU5hbWVDYWNoZS5lbnRyaWVzKCkpLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChfYSwgMSksIGtleSA9IF9iWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VyTmFtZXMuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkT2JqZWN0ID0gc2hhcmVkX3V0aWxzXzEuZW50cmllc1RvT2JqZWN0KGNhY2hlZEVudHJpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkVXNlcnMgPSBzaGFyZWRfdXRpbHNfMS5tYXBPYmplY3QoY2FjaGVkT2JqZWN0LCBmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LnZhbHVlOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvRmV0Y2ggPSB1c2VyTmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhKG5hbWUgaW4gY2FjaGVkVXNlcnMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdG9GZXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2FjaGVkVXNlcnNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6ICd1c2VycycsIHF1ZXJ5OiB7IGxvZ2luOiB0b0ZldGNoLmpvaW4oJywnKSB9IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnNEYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnNBcnIgPSB1c2Vyc0RhdGEudXNlcnMubWFwKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgVXNlcl8xLmRlZmF1bHQoZGF0YSwgX3RoaXMuX2NsaWVudCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnNBcnIuZm9yRWFjaChmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdXNlckJ5TmFtZUNhY2hlLnNldCh1c2VyLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVzZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXM6IERhdGUubm93KCkgKyAzNjAwICogMTAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VycyA9IHNoYXJlZF91dGlsc18xLmluZGV4QnkodXNlcnNBcnIsICduYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBjYWNoZWRVc2VycyksIHVzZXJzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSB1c2VyJ3MgY2hhdCBhcHBlYXJhbmNlIGFuZCBwcml2aWxlZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgeW91IHdhbnQgdG8gZ2V0IGNoYXQgaW5mbyBmb3IuXG4gICAgICovXG4gICAgVXNlckFQSS5wcm90b3R5cGUuZ2V0Q2hhdEluZm8gPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQsIGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7IHVybDogXCJ1c2Vycy9cIiArIHVzZXJJZCArIFwiL2NoYXRcIiB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFVzZXJDaGF0SW5mb18xLmRlZmF1bHQoZGF0YSwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBlbW90ZXMgYSBnaXZlbiB1c2VyIGNhbiB1c2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB5b3Ugd2FudCB0byBnZXQgZW1vdGVzIGZvci5cbiAgICAgKi9cbiAgICBVc2VyQVBJLnByb3RvdHlwZS5nZXRVc2VyRW1vdGVzID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlcklkLCBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6IFwidXNlcnMvXCIgKyB1c2VySWQgKyBcIi9lbW90ZXNcIiwgc2NvcGU6ICd1c2VyX3N1YnNjcmlwdGlvbnMnIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRW1vdGVTZXRMaXN0XzEuZGVmYXVsdChkYXRhLmVtb3RpY29uX3NldHMpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHN1YnNjcmlwdGlvbiBkYXRhIGZvciBhIGdpdmVuIHVzZXIgdG8gYSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgdG8gcmV0cmlldmUgdGhlIHN1YnNjcmlwdGlvbiBkYXRhIG9mLlxuICAgICAqIEBwYXJhbSB0b0NoYW5uZWwgVGhlIGNoYW5uZWwgeW91IHdhbnQgdG8gcmV0cmlldmUgdGhlIHN1YnNjcmlwdGlvbiBkYXRhIHRvLlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvbkRhdGEgPSBmdW5jdGlvbiAodXNlciwgdG9DaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZCwgY2hhbm5lbElkLCBfYSwgZV8xO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh0b0NoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBVc2VyU3Vic2NyaXB0aW9uXzEuZGVmYXVsdC5iaW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwidXNlcnMvXCIgKyB1c2VySWQgKyBcIi9zdWJzY3JpcHRpb25zL1wiICsgY2hhbm5lbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJ3VzZXJfc3Vic2NyaXB0aW9ucydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyAoX2EuYXBwbHkoVXNlclN1YnNjcmlwdGlvbl8xLmRlZmF1bHQsIFt2b2lkIDAsIF9iLnNlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnRdKSkoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEgaW5zdGFuY2VvZiBIVFRQU3RhdHVzQ29kZUVycm9yXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZV8xLnN0YXR1c0NvZGUgPT09IDQyMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9TdWJzY3JpcHRpb25Qcm9ncmFtRXJyb3JfMS5kZWZhdWx0KGNoYW5uZWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGNoYW5uZWxzIGEgZ2l2ZW4gdXNlciBmb2xsb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgeW91IHdhbnQgdG8gcmV0cmlldmUgdGhlIGZvbGxvd3Mgb2YuXG4gICAgICogQHBhcmFtIHBhZ2UgVGhlIHJlc3VsdCBwYWdlIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBsaW1pdCBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIG9yZGVyQnkgVGhlIGZpZWxkIHRvIG9yZGVyIGJ5LlxuICAgICAqIEBwYXJhbSBvcmRlckRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRvIG9yZGVyIGluIC0gYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcuXG4gICAgICovXG4gICAgVXNlckFQSS5wcm90b3R5cGUuZ2V0Rm9sbG93ZWRDaGFubmVscyA9IGZ1bmN0aW9uICh1c2VyLCBwYWdlLCBsaW1pdCwgb3JkZXJCeSwgb3JkZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSAyNTsgfVxuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQsIHF1ZXJ5LCBkYXRhO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9mZnNldCA9ICgocGFnZSAtIDEpICogbGltaXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5saW1pdCA9IGxpbWl0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXJCeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LnNvcnRieSA9IG9yZGVyQnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5kaXJlY3Rpb24gPSBvcmRlckRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcInVzZXJzL1wiICsgdXNlcklkICsgXCIvZm9sbG93cy9jaGFubmVsc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YS5mb2xsb3dzLm1hcChmdW5jdGlvbiAoZm9sbG93KSB7IHJldHVybiBuZXcgVXNlckZvbGxvd18xLmRlZmF1bHQoZm9sbG93LCBfdGhpcy5fY2xpZW50KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBmb2xsb3cgZGF0YSBmb3IgYSBnaXZlbiB1c2VyIHRvIGEgZ2l2ZW4gY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIHJldHJpZXZlIGZvbGxvdyBkYXRhIG9mLlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHlvdSB3YW50IHRvIHJldHJpZXZlIGZvbGxvdyBkYXRhIHRvLlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLmdldEZvbGxvd2VkQ2hhbm5lbCA9IGZ1bmN0aW9uICh1c2VyLCBjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZCwgY2hhbm5lbElkLCBkYXRhLCBlXzI7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY2xpZW50LmNhbGxBUEkoeyB1cmw6IFwidXNlcnMvXCIgKyB1c2VySWQgKyBcIi9mb2xsb3dzL2NoYW5uZWxzL1wiICsgY2hhbm5lbElkIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgVXNlckZvbGxvd18xLmRlZmF1bHQoZGF0YSwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzIgaW5zdGFuY2VvZiBIVFRQU3RhdHVzQ29kZUVycm9yXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzIuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXzI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvbGxvd3MgYSBnaXZlbiBjaGFubmVsIHdpdGggYSBnaXZlbiB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgeW91IHdhbnQgdG8gZm9sbG93IHdpdGguXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gZm9sbG93LlxuICAgICAqIEBwYXJhbSBub3RpZmljYXRpb25zIFdoZXRoZXIgdGhlIHVzZXIgd2lsbCByZWNlaXZlIG5vdGlmaWNhdGlvbnMuXG4gICAgICovXG4gICAgVXNlckFQSS5wcm90b3R5cGUuZm9sbG93Q2hhbm5lbCA9IGZ1bmN0aW9uICh1c2VyLCBjaGFubmVsLCBub3RpZmljYXRpb25zKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZCwgY2hhbm5lbElkLCBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcInVzZXJzL1wiICsgdXNlcklkICsgXCIvZm9sbG93cy9jaGFubmVscy9cIiArIGNoYW5uZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICd1c2VyX2ZvbGxvd3NfZWRpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgbm90aWZpY2F0aW9uczogQm9vbGVhbihub3RpZmljYXRpb25zKS50b1N0cmluZygpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFVzZXJGb2xsb3dfMS5kZWZhdWx0KGRhdGEsIHRoaXMuX2NsaWVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuZm9sbG93cyBhIGdpdmVuIGNoYW5uZWwgd2l0aCBhIGdpdmVuIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciBUaGUgdXNlciB5b3Ugd2FudCB0byB1bmZvbGxvdyB3aXRoLlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIHVuZm9sbG93LlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLnVuZm9sbG93Q2hhbm5lbCA9IGZ1bmN0aW9uICh1c2VyLCBjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZCwgY2hhbm5lbElkO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NsaWVudC5jYWxsQVBJKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcInVzZXJzL1wiICsgdXNlcklkICsgXCIvZm9sbG93cy9jaGFubmVscy9cIiArIGNoYW5uZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICd1c2VyX2ZvbGxvd3NfZWRpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIHVzZXJzIGEgZ2l2ZW4gdXNlciBoYXMgYmxvY2tlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIHJldHJpZXZlIHRoZSBibG9jayBsaXN0IG9mLlxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSByZXN1bHQgcGFnZSB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgVGhlIG51bWJlciBvZiByZXN1bHRzIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLmdldEJsb2NrZWRVc2VycyA9IGZ1bmN0aW9uICh1c2VyLCBwYWdlLCBsaW1pdCkge1xuICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IDI1OyB9XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVzZXJJZCwgcXVlcnksIGRhdGE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlcklkKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB7IGxpbWl0OiBsaW1pdC50b1N0cmluZygpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9mZnNldCA9ICgocGFnZSAtIDEpICogbGltaXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJ1c2Vycy9cIiArIHVzZXJJZCArIFwiL2Jsb2Nrc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAndXNlcl9ibG9ja3NfcmVhZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YS5ibG9ja3MubWFwKGZ1bmN0aW9uIChibG9jaykgeyByZXR1cm4gbmV3IFVzZXJCbG9ja18xLmRlZmF1bHQoYmxvY2ssIF90aGlzLl9jbGllbnQpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmxvY2tzIGEgZ2l2ZW4gdXNlciB3aXRoIGFub3RoZXIgZ2l2ZW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFRoZSB1c2VyIHlvdSB3YW50IHRvIGJsb2NrIHdpdGguXG4gICAgICogQHBhcmFtIHVzZXJUb0Jsb2NrIFRoZSB1c2VyIHRvIGJsb2NrLlxuICAgICAqL1xuICAgIFVzZXJBUEkucHJvdG90eXBlLmJsb2NrVXNlciA9IGZ1bmN0aW9uICh1c2VyLCB1c2VyVG9CbG9jaykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQsIHVzZXJJZFRvQmxvY2ssIGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZCA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWRUb0Jsb2NrID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyVG9CbG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJ1c2Vycy9cIiArIHVzZXJJZCArIFwiL2Jsb2Nrcy9cIiArIHVzZXJJZFRvQmxvY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAndXNlcl9ibG9ja3NfZWRpdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFVzZXJCbG9ja18xLmRlZmF1bHQoZGF0YSwgdGhpcy5fY2xpZW50KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5ibG9ja3MgYSBnaXZlbiB1c2VyIHdpdGggYW5vdGhlciBnaXZlbiB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgVGhlIHVzZXIgeW91IHdhbnQgdG8gdW5ibG9jayB3aXRoLlxuICAgICAqIEBwYXJhbSB1c2VyVG9VbmJsb2NrIFRoZSB1c2VyIHRvIHVuYmxvY2suXG4gICAgICovXG4gICAgVXNlckFQSS5wcm90b3R5cGUudW5ibG9ja1VzZXIgPSBmdW5jdGlvbiAodXNlciwgdXNlclRvVW5ibG9jaykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQsIHVzZXJJZFRvVW5ibG9jaztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkID0gVXNlclRvb2xzXzEuZXh0cmFjdFVzZXJJZCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZFRvVW5ibG9jayA9IFVzZXJUb29sc18xLmV4dHJhY3RVc2VySWQodXNlclRvVW5ibG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJ1c2Vycy9cIiArIHVzZXJJZCArIFwiL2Jsb2Nrcy9cIiArIHVzZXJJZFRvVW5ibG9jayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICd1c2VyX2Jsb2Nrc19lZGl0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFVzZXJBUEkucHJvdG90eXBlLl9jbGVhblVzZXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuX3VzZXJCeU5hbWVDYWNoZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgICAgICAgaWYgKHZhbC5leHBpcmVzIDwgbm93KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VzZXJCeU5hbWVDYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgVXNlckFQSS5wcm90b3R5cGUsIFwiZ2V0TWVcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIFVzZXJBUEkucHJvdG90eXBlLCBcImdldFVzZXJcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzNjAwKVxuICAgIF0sIFVzZXJBUEkucHJvdG90eXBlLCBcImdldENoYXRJbmZvXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBVc2VyQVBJLnByb3RvdHlwZSwgXCJnZXRVc2VyRW1vdGVzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzYwMClcbiAgICBdLCBVc2VyQVBJLnByb3RvdHlwZSwgXCJnZXRTdWJzY3JpcHRpb25EYXRhXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWQoMzAwKVxuICAgIF0sIFVzZXJBUEkucHJvdG90eXBlLCBcImdldEZvbGxvd2VkQ2hhbm5lbHNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNhY2hlZCgzMDApXG4gICAgXSwgVXNlckFQSS5wcm90b3R5cGUsIFwiZ2V0Rm9sbG93ZWRDaGFubmVsXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DbGVhcnNDYWNoZSgnZ2V0Rm9sbG93ZWRDaGFubmVscycsIDEpLFxuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2xlYXJzQ2FjaGUoJ2dldEZvbGxvd2VkQ2hhbm5lbCcsIDIpXG4gICAgXSwgVXNlckFQSS5wcm90b3R5cGUsIFwiZm9sbG93Q2hhbm5lbFwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2xlYXJzQ2FjaGUoJ2dldEZvbGxvd2VkQ2hhbm5lbHMnLCAxKSxcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNsZWFyc0NhY2hlKCdnZXRGb2xsb3dlZENoYW5uZWwnLCAyKVxuICAgIF0sIFVzZXJBUEkucHJvdG90eXBlLCBcInVuZm9sbG93Q2hhbm5lbFwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDM2MDApXG4gICAgXSwgVXNlckFQSS5wcm90b3R5cGUsIFwiZ2V0QmxvY2tlZFVzZXJzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DbGVhcnNDYWNoZSgnZ2V0QmxvY2tlZFVzZXJzJywgMSlcbiAgICBdLCBVc2VyQVBJLnByb3RvdHlwZSwgXCJibG9ja1VzZXJcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGVfZGVjb3JhdG9yc18xLkNsZWFyc0NhY2hlKCdnZXRCbG9ja2VkVXNlcnMnLCAxKVxuICAgIF0sIFVzZXJBUEkucHJvdG90eXBlLCBcInVuYmxvY2tVc2VyXCIsIG51bGwpO1xuICAgIFVzZXJBUEkgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVhYmxlXG4gICAgXSwgVXNlckFQSSk7XG4gICAgcmV0dXJuIFVzZXJBUEk7XG59KEJhc2VBUElfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVc2VyQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVXNlckFQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVzZXJBUEk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHNoYXJlZF91dGlsc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvc2hhcmVkLXV0aWxzXCIpO1xuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCBhIHVzZXIncyBjaGF0IGFwcGVhcmFuY2UgYW5kIHByaXZpbGVnZXMuXG4gKi9cbnZhciBVc2VyQ2hhdEluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gVXNlckNoYXRJbmZvKF9kYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQ2hhdEluZm8ucHJvdG90eXBlLCBcInVzZXJJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG1vcmUgZGF0YSBhYm91dCB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBVc2VyQ2hhdEluZm8ucHJvdG90eXBlLmdldFVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NsaWVudC5rcmFrZW4udXNlcnMuZ2V0VXNlcih0aGlzLl9kYXRhLl9pZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJDaGF0SW5mby5wcm90b3R5cGUsIFwidXNlck5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmxvZ2luO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckNoYXRJbmZvLnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5kaXNwbGF5X25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQ2hhdEluZm8ucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xvciB0aGF0IHRoZSB1c2VyIGFwcGVhcnMgaW4gaW4gY2hhdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuY29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQ2hhdEluZm8ucHJvdG90eXBlLCBcImlzS25vd25Cb3RcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdXNlciBpcyBhIGtub3duIGJvdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaXNfa25vd25fYm90O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckNoYXRJbmZvLnByb3RvdHlwZSwgXCJpc1ZlcmlmaWVkQm90XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgaXMgYSB2ZXJpZmllZCBib3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlzX3ZlcmlmaWVkX2JvdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJDaGF0SW5mby5wcm90b3R5cGUsIFwiaXNBdExlYXN0S25vd25Cb3RcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdXNlciBpcyBhdCBsZWFzdCBhIGtub3duIGJvdCAoaS5lLiBrbm93biBvciB2ZXJpZmllZCkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmlzX2tub3duX2JvdCB8fCB0aGlzLl9kYXRhLmlzX3ZlcmlmaWVkX2JvdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGFjY2VzcyB0byBhIGdpdmVuIGdsb2JhbCBiYWRnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgb2YgYSBiYWRnZS5cbiAgICAgKi9cbiAgICBVc2VyQ2hhdEluZm8ucHJvdG90eXBlLmhhc0JhZGdlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmJhZGdlcy5zb21lKGZ1bmN0aW9uIChiYWRnZSkgeyByZXR1cm4gYmFkZ2UuaWQgPT09IGlkOyB9KTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBVc2VyQ2hhdEluZm8ucHJvdG90eXBlLCBcIl9jbGllbnRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gVXNlckNoYXRJbmZvO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVzZXJDaGF0SW5mbztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFVzZXJDaGF0SW5mbztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVzZXJDaGF0SW5mbztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2FjaGVfZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIkBkLWZpc2NoZXIvY2FjaGUtZGVjb3JhdG9yc1wiKTtcbnZhciBVc2VyVG9vbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9Ub29sa2l0L1VzZXJUb29sc1wiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9Ud2l0Y2hDbGllbnRcIik7XG52YXIgQmFzZUFQSV8xID0gcmVxdWlyZShcIi4uL0Jhc2VBUElcIik7XG52YXIgQ2hhdHRlcnNMaXN0XzEgPSByZXF1aXJlKFwiLi9DaGF0dGVyc0xpc3RcIik7XG4vKipcbiAqIERpZmZlcmVudCBBUEkgbWV0aG9kcyB0aGF0IGFyZSBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQgYnkgVHdpdGNoLlxuICpcbiAqIENhbiBiZSBhY2Nlc3NlZCB1c2luZyBgY2xpZW50LnVuc3VwcG9ydGVkYCBvbiBhIHtAVHdpdGNoQ2xpZW50fSBpbnN0YW5jZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgY2xpZW50ID0gVHdpdGNoQ2xpZW50LndpdGhDcmVkZW50aWFscyhjbGllbnRJZCwgYWNjZXNzVG9rZW4pO1xuICogY29uc3QgZXZlbnRzID0gYXdhaXQgY2xpZW50LnVuc3VwcG9ydGVkLmdldEV2ZW50cygnMTI1MzI4NjU1Jyk7XG4gKiBgYGBcbiAqL1xudmFyIFVuc3VwcG9ydGVkQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFVuc3VwcG9ydGVkQVBJLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuc3VwcG9ydGVkQVBJKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgY2hhdHRlcnMgaW4gdGhlIFR3aXRjaCBjaGF0IG9mIHRoZSBnaXZlbiBjaGFubmVsLlxuICAgICAqXG4gICAgICogKipXQVJOSU5HKio6IEluIGNvbnRyYXN0IHRvIG1vc3Qgb3RoZXIgbWV0aG9kcywgdGhpcyB0YWtlcyBhIGNoYW5uZWwgKm5hbWUqLCBub3QgYSB1c2VyIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gcmV0cmlldmUgdGhlIGNoYXR0ZXJzIGZvci5cbiAgICAgKi9cbiAgICBVbnN1cHBvcnRlZEFQSS5wcm90b3R5cGUuZ2V0Q2hhdHRlcnMgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsTmFtZSwgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbE5hbWUgPSBVc2VyVG9vbHNfMS5leHRyYWN0VXNlck5hbWUoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jbGllbnQuY2FsbEFQSSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJodHRwczovL3RtaS50d2l0Y2gudHYvZ3JvdXAvdXNlci9cIiArIGNoYW5uZWxOYW1lICsgXCIvY2hhdHRlcnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpdGNoQ2xpZW50XzEuVHdpdGNoQVBJQ2FsbFR5cGUuQ3VzdG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBDaGF0dGVyc0xpc3RfMS5kZWZhdWx0KGRhdGEpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZV9kZWNvcmF0b3JzXzEuQ2FjaGVkKDYwKVxuICAgIF0sIFVuc3VwcG9ydGVkQVBJLnByb3RvdHlwZSwgXCJnZXRDaGF0dGVyc1wiLCBudWxsKTtcbiAgICBVbnN1cHBvcnRlZEFQSSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlX2RlY29yYXRvcnNfMS5DYWNoZWFibGVcbiAgICBdLCBVbnN1cHBvcnRlZEFQSSk7XG4gICAgcmV0dXJuIFVuc3VwcG9ydGVkQVBJO1xufShCYXNlQVBJXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVW5zdXBwb3J0ZWRBUEk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBVbnN1cHBvcnRlZEFQSTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFVuc3VwcG9ydGVkQVBJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzaGFyZWRfdXRpbHNfMSA9IHJlcXVpcmUoXCJAZC1maXNjaGVyL3NoYXJlZC11dGlsc1wiKTtcbnZhciBUd2l0Y2hDbGllbnRfMSA9IHJlcXVpcmUoXCIuLi9Ud2l0Y2hDbGllbnRcIik7XG4vKipcbiAqIEFuIGF1dGggcHJvdmlkZXIgdGhhdCByZXRyaWV2ZSB0b2tlbnMgdXNpbmcgY2xpZW50IGNyZWRlbnRpYWxzLlxuICovXG52YXIgQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhdXRoIHByb3ZpZGVyIHRvIHJlY2VpdmUgYW4gYXBwbGljYXRpb24gdG9rZW4gd2l0aCB1c2luZyB0aGUgY2xpZW50IElEIGFuZCBzZWNyZXQuXG4gICAgICpcbiAgICAgKiBZb3UgZG9uJ3QgdXN1YWxseSBoYXZlIHRvIGNyZWF0ZSB0aGlzIG1hbnVhbGx5LiBZb3Ugc2hvdWxkIHVzZSBgVHdpdGNoQ2xpZW50LndpdGhDbGllbnRDcmVkZW50aWFsc2AgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnRJZCBUaGUgY2xpZW50IElEIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIGNsaWVudFNlY3JldCBUaGUgY2xpZW50IHNlY3JldCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqXG4gICAgICogWW91IG5lZWQgdG8gb2J0YWluIG9uZSB1c2luZyBvbmUgb2YgdGhlIFtUd2l0Y2ggT0F1dGggZmxvd3NdKGh0dHBzOi8vZGV2LnR3aXRjaC50di9kb2NzL2F1dGhlbnRpY2F0aW9uL2dldHRpbmctdG9rZW5zLW9hdXRoLykuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXIoY2xpZW50SWQsIGNsaWVudFNlY3JldCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdG9rZW5zIHRoaXMgcHJvdmlkZXIgZ2VuZXJhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGF1dGggcHJvdmlkZXIgZ2VuZXJhdGVzIGFwcCB0b2tlbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRva2VuVHlwZSA9ICdhcHAnO1xuICAgICAgICB0aGlzLl9jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB0aGlzLl9jbGllbnRTZWNyZXQgPSBjbGllbnRTZWNyZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhY2Nlc3MgdG9rZW4uXG4gICAgICpcbiAgICAgKiBJZiBhbnkgc2NvcGVzIGFyZSBwcm92aWRlZCwgdGhpcyB0aHJvd3MuIFRoZSBjbGllbnQgY3JlZGVudGlhbHMgZmxvdyBkb2VzIG5vdCBzdXBwb3J0IHNjb3Blcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY29wZXMgVGhlIHJlcXVlc3RlZCBzY29wZXMuXG4gICAgICovXG4gICAgQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXIucHJvdG90eXBlLmdldEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKHNjb3Blcykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmIChzY29wZXMgJiYgc2NvcGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NvcGUgXCIgKyAodHlwZW9mIHNjb3BlcyA9PT0gJ3N0cmluZycgPyBzY29wZXMgOiBzY29wZXMuam9pbignLCcpKSArIFwiIHJlcXVlc3RlZCBidXQgdGhlIGNsaWVudCBjcmVkZW50aWFscyBmbG93IGRvZXMgbm90IHN1cHBvcnQgc2NvcGVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Rva2VuIHx8IHRoaXMuX3Rva2VuLmlzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5yZWZyZXNoKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fdG9rZW5dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbmV3IGFwcCBhY2Nlc3MgdG9rZW4uXG4gICAgICovXG4gICAgQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBUd2l0Y2hDbGllbnRfMS5kZWZhdWx0LmdldEFwcEFjY2Vzc1Rva2VuKHRoaXMuX2NsaWVudElkLCB0aGlzLl9jbGllbnRTZWNyZXQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLl90b2tlbiA9IF9iLnNlbnQoKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyLnByb3RvdHlwZS5zZXRBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB0aGlzLl90b2tlbiA9IHRva2VuO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyLnByb3RvdHlwZSwgXCJjbGllbnRJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IElELlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50SWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlci5wcm90b3R5cGUsIFwiY3VycmVudFNjb3Blc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NvcGVzIHRoYXQgYXJlIGN1cnJlbnRseSBhdmFpbGFibGUgdXNpbmcgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBzaGFyZWRfdXRpbHNfMS5Ob25FbnVtZXJhYmxlXG4gICAgXSwgQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXIucHJvdG90eXBlLCBcIl9jbGllbnRJZFwiLCB2b2lkIDApO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBDbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlci5wcm90b3R5cGUsIFwiX2NsaWVudFNlY3JldFwiLCB2b2lkIDApO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIHNoYXJlZF91dGlsc18xLk5vbkVudW1lcmFibGVcbiAgICBdLCBDbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlci5wcm90b3R5cGUsIFwiX3Rva2VuXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENsaWVudENyZWRlbnRpYWxzQXV0aFByb3ZpZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ2xpZW50Q3JlZGVudGlhbHNBdXRoUHJvdmlkZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDbGllbnRDcmVkZW50aWFsc0F1dGhQcm92aWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQ3VzdG9tRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0N1c3RvbUVycm9yXCIpO1xuLyoqXG4gKiBUaHJvd24gd2hlbmV2ZXIgYSBkaWZmZXJlbnQgdG9rZW4gdHlwZSAodXNlciB2cy4gYXBwKSBpcyBleHBlY3RlZCBpbiB0aGUgbWV0aG9kIHlvdSdyZSBjYWxsaW5nLlxuICovXG52YXIgSW52YWxpZFRva2VuVHlwZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEludmFsaWRUb2tlblR5cGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnZhbGlkVG9rZW5UeXBlRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEludmFsaWRUb2tlblR5cGVFcnJvcjtcbn0oQ3VzdG9tRXJyb3JfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbnZhbGlkVG9rZW5UeXBlRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBJbnZhbGlkVG9rZW5UeXBlRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbnZhbGlkVG9rZW5UeXBlRXJyb3I7XG4iLCJcclxuXHJcbmNvbnN0IGRlZmF1bHRDbGllbnRJZCA9IFwiNTl4OGp5YXVkdzNwbnlpNzIyeDNlMng5YXdoMzg1XCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBDb25maWdNYW5hZ2VyIHtcclxuICAgIHN0YXRpYyB1c2VyQ2xpZW50SWQgOiBzdHJpbmc7XHJcblxyXG4gICAgc3RhdGljIHNldFVzZXJDbGllbnRJZChjbGllbnRJZDogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy51c2VyQ2xpZW50SWQgPSBjbGllbnRJZDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0Q2xpZW50SWQoKSA6IHN0cmluZyB7XHJcbiAgICAgICAgaWYodGhpcy51c2VyQ2xpZW50SWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckNsaWVudElkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmYXVsdENsaWVudElkO1xyXG4gICAgfVxyXG59IiwiLy8gRmlsZSB3aXRoIGNvbmZpZyB2YWx1ZXMgYW5kIGNvbnN0YW50c1xyXG5cclxuZXhwb3J0IGNvbnN0IGNsaWVudElkID0gXCJ5YnVtMWZ2dXJzbm80bmYzY2t6eDU2am1ocXluamtcIjsgIC8vIEFkZCBjbGllbnQgSUQgaGVyZVxyXG5cclxuZXhwb3J0IGNvbnN0IGRlZmF1bHRIZWFkZXJzID0ge1xyXG4gICAgXCJDbGllbnQtSURcIjogY2xpZW50SWQsXHJcbiAgICBcIkFjY2VwdFwiOiBcImFwcGxpY2F0aW9uL3ZuZC50d2l0Y2h0di52NStqc29uXCIsXHJcbiAgICBcIkF1dGhvcml6YXRpb25cIjogXCJPQXV0aCBnY3U5cGQwa2NuNngyeDNkcml4NmVzYmhscmZxZnZcIixcclxufVxyXG5cclxuLy8gVHlwZVNjcmlwdCBkb2VzIG5vdCBhbGxvdyBwYXJhbWV0cml6ZWQgc3RyaW5nIHRvIGJlIGZvcm1hdHRlZCBpbiBydW50aW1lLFxyXG4vLyBzbyB0aGlzIGlzIHRoZSBiZXN0IHdheSB0byBnZXQgYSBmb3JtYXR0ZWQgVVJMLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBpVXJsKHZpZGVvSWQ6IHN0cmluZywgbmV4dEN1cnNvcjogc3RyaW5nKSA6IHN0cmluZyB7XHJcbiAgICBpZihuZXh0Q3Vyc29yKSB7XHJcbiAgICAgICAgcmV0dXJuIGBodHRwczovL2FwaS50d2l0Y2gudHYvdjUvdmlkZW9zLyR7dmlkZW9JZH0vY29tbWVudHM/Y3Vyc29yPSR7bmV4dEN1cnNvcn1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGBodHRwczovL2FwaS50d2l0Y2gudHYvdjUvdmlkZW9zLyR7dmlkZW9JZH0vY29tbWVudHNgO1xyXG59IiwiXHJcbmltcG9ydCB7IGdldEFwaVVybCwgZGVmYXVsdEhlYWRlcnMgfSBmcm9tICcuL2NvbmZpZyc7XHJcblxyXG5jb25zdCB0b29NYW55UmVxdWVzdHMgPSA0Mjk7ICAvLyBIVFRQIDQyOSB0b28gbWFueSByZXF1ZXN0cyByZXNwb25zZSBjb2RlXHJcblxyXG5cclxuYXN5bmMgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcikgOiBQcm9taXNlPGFueT4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKF8gPT4gc2V0VGltZW91dChfLCBtcykpO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGZXRjaFJlc3BvbnNlIHtcclxuICAgIHN0YXR1czogbnVtYmVyO1xyXG4gICAgdGV4dDogc3RyaW5nO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgTG9vcEV2ZW50SGFuZGxlciA9ICh0dXJuOiBudW1iZXIsIHN0YXR1czogbnVtYmVyLCBkb3dubG9hZENvdW50OiBudW1iZXIpID0+IHZvaWQ7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIENoYXREb3dubG9hZGVyIHtcclxuICAgIGxvb3BIYW5kbGVyOiBMb29wRXZlbnRIYW5kbGVyO1xyXG5cclxuICAgIGFkZExvb3BFdmVudExpc3RlbmVyKGhhbmRsZXI6IExvb3BFdmVudEhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLmxvb3BIYW5kbGVyID0gaGFuZGxlcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEb3dubG9hZCBjaGF0IG9mIHNpbmdsZSBUd2l0Y2ggdmlkZW9cclxuICAgIGFzeW5jIGRvd25sb2FkQ2hhdCh2aWRlb0lkOiBzdHJpbmcpIDogUHJvbWlzZTxBcnJheTxhbnk+PiB7XHJcbiAgICAgICAgY29uc3QgY29tbWVudHMgPSBbXTtcclxuICAgICAgICBsZXQgdHVybiA9IDA7XHJcbiAgICAgICAgbGV0IG5leHRDdXJzb3IgOiBzdHJpbmcgPSBudWxsO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxBcGkodmlkZW9JZCwgbmV4dEN1cnNvcik7XHJcbiAgICAgICAgICAgIGlmKHJlc3BvbnNlLnRleHQpIHsgIC8vIHJlc3BvbnNlLnRleHQgaXMgbnVsbCBpZiBzdGF0dXMgaXMgbm90IG9rLlxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uQ29udGVudCA9IEpTT04ucGFyc2UocmVzcG9uc2UudGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBuZXdDb21tZW50IG9mIGpzb25Db250ZW50W1wiY29tbWVudHNcIl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChuZXdDb21tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dEN1cnNvciA9IGpzb25Db250ZW50W1wiX25leHRcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgdHVybiArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9vcEhhbmRsZXI/Lih0dXJuLCByZXNwb25zZS5zdGF0dXMsIGNvbW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGVuIHBhcnNpbmcgSlNPTiByZXNwb25zZTogJHtyZXNwb25zZS50ZXh0fWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9vcEhhbmRsZXI/Lih0dXJuLCByZXNwb25zZS5zdGF0dXMsIGNvbW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihyZXNwb25zZS5zdGF0dXMgPT0gdG9vTWFueVJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvb3BIYW5kbGVyPy4odHVybiwgcmVzcG9uc2Uuc3RhdHVzLCBjb21tZW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgLy8gQXMgb2YgMjAyMC0wNy0yNSwgS3Jha2VuIEFQSSBkb2VzIG5vdCBzZWVtIHRvIHVzZSA0MjkgcmVzcG9uc2UgY29kZSBhdCBhbGwuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNsZWVwIGlzIGhlcmUgb25seSBhcyBhbiBhZGRpdGlvbmFsIGNoZWNrXHJcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCg1MDApOyAgLy8gU2xlZXAgZm9yIDEgc2Vjb25kXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBUEkgY2FsbCBmYWlsZWQgd2l0aCBlcnJvciBjb2RlOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9vcEhhbmRsZXI/Lih0dXJuLCByZXNwb25zZS5zdGF0dXMsIGNvbW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUobmV4dEN1cnNvcik7XHJcblxyXG4gICAgICAgIHJldHVybiBjb21tZW50cztcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxsIFR3aXRjaCBBUEkgb25lIHRpbWVcclxuICAgIHByaXZhdGUgYXN5bmMgY2FsbEFwaSh2aWRlb0lkOiBzdHJpbmcsIGN1cnNvcjogc3RyaW5nKSA6IFByb21pc2U8RmV0Y2hSZXNwb25zZT4ge1xyXG4gICAgICAgIGNvbnN0IHVybCA9IGdldEFwaVVybCh2aWRlb0lkLCBjdXJzb3IpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7aGVhZGVyczogZGVmYXVsdEhlYWRlcnN9KTtcclxuICAgICAgICBpZighcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgdGV4dDogbnVsbH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgcmV0dXJuIHtzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgdGV4dDogY29udGVudH07XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFR3aXRjaENsaWVudCwgeyBIZWxpeFVzZXIgfSBmcm9tICd0d2l0Y2gnO1xyXG5pbXBvcnQgeyBDb25maWdNYW5hZ2VyIH0gZnJvbSAnLi9jb25maWcnO1xyXG5pbXBvcnQgeyBDaGF0RG93bmxvYWRlciB9IGZyb20gJy4vZG93bmxvYWRlci9jaGF0JztcclxuXHJcblxyXG5sZXQgdHdpdGNoQ2xpZW50IDogVHdpdGNoQ2xpZW50O1xyXG5cclxuZnVuY3Rpb24gZ2V0VHdpdGNoQ2xpZW50KCkgOiBUd2l0Y2hDbGllbnQge1xyXG4gICAgaWYodHdpdGNoQ2xpZW50ICE9PSBudWxsICYmIHR3aXRjaENsaWVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHR3aXRjaENsaWVudDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVc2VyIG5vdCBsb2dnZWQgaW5cclxuICAgIGNvbnN0IHRva2VuID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcInR3aXRjaF9jaGF0X2FuYWx5emVyX2FjY2Vzc190b2tlblwiKTtcclxuICAgIGlmKCF0b2tlbikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNsaWVudElkID0gQ29uZmlnTWFuYWdlci5nZXRDbGllbnRJZCgpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gVHdpdGNoQ2xpZW50LndpdGhDcmVkZW50aWFscyhjbGllbnRJZCwgdG9rZW4pO1xyXG4gICAgdHdpdGNoQ2xpZW50ID0gY2xpZW50O1xyXG4gICAgcmV0dXJuIGNsaWVudDtcclxufVxyXG5cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFN0cmVhbWVySW5mbyh1c2VybmFtZTogc3RyaW5nKSA6IFByb21pc2U8SGVsaXhVc2VyPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJ0d2l0Y2hfY2hhdF9hbmFseXplcl9hY2Nlc3NfdG9rZW5cIik7XHJcbiAgICBpZighdG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjbGllbnRJZCA9IENvbmZpZ01hbmFnZXIuZ2V0Q2xpZW50SWQoKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IFR3aXRjaENsaWVudC53aXRoQ3JlZGVudGlhbHMoY2xpZW50SWQsIHRva2VuKTtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBjbGllbnQuaGVsaXgudXNlcnMuZ2V0VXNlckJ5TmFtZSh1c2VybmFtZSk7XHJcbiAgICBcclxuICAgIHJldHVybiB1c2VyO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gYWRkRm9sbG93ZXJEb3dubG9hZGVyTGlzdGVuZXJzKCkge1xyXG4gICAgY29uc3Qgc3RyZWFtZXJOYW1lSW5wdXRFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdHJlYW1lci11c2VybmFtZS1pbnB1dFwiKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgY29uc3Qgc3RyZWFtZXJTZWFyY2hCdXR0b21FbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdHJlYW1lci1zZWFyY2gtYnV0dG9uXCIpO1xyXG4gICAgY29uc3Qgc3RyZWFtZXJJbmZvRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RyZWFtZXItaW5mb1wiKTtcclxuICAgIGNvbnN0IGRvd25sb2FkQnV0dG9uRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZm9sbG93ZXItbGlzdC1kb3dubG9hZC1idXR0b25cIik7XHJcbiAgICBcclxuICAgIHN0cmVhbWVyU2VhcmNoQnV0dG9tRWxlbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBzdHJlYW1lck5hbWVJbnB1dEVsZW0udmFsdWU7XHJcbiAgICAgICAgY29uc3QgY2xpZW50ID0gZ2V0VHdpdGNoQ2xpZW50KCk7XHJcbiAgICAgICAgY2xpZW50LmhlbGl4LnVzZXJzLmdldFVzZXJCeU5hbWUobmFtZSkudGhlbigoaGVsaXhVc2VyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmKCFoZWxpeFVzZXIpIHtcclxuICAgICAgICAgICAgICAgIHN0cmVhbWVySW5mb0VsZW0udGV4dENvbnRlbnQgPSBg7Iqk7Yq466as66i466W8IOywvuydhCDsiJgg7JeG7Iq164uI64ukOiAke25hbWV9YDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHJlYW1lckluZm9FbGVtLnRleHRDb250ZW50ID0gYOyKpO2KuOumrOuouDogJHtoZWxpeFVzZXIuZGlzcGxheU5hbWV9YDtcclxuICAgICAgICAgICAgLy8gU2hvdyBkb3dubG9hZCBidXR0b25cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRvd25sb2FkQnV0dG9uRWxlbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIC8vIERpc3BsYXkgZG93bmxvYWQgc3RhdHVzXHJcbiAgICAgICAgLy8gZG93bmxvYWRcclxuICAgICAgICAvLyBXaGVuIGZpbmlzaGVkIGRvd25sb2FkaW5nLCBkb3dubG9hZCB0aGUgZmlsZSB0byBsb2NhbCBkaXNrXHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQ2hhdERvd25sb2FkZXJMaXN0ZW5lcnMoKSB7XHJcbiAgICBjb25zdCB2aWRlb0lkSW5wdXRFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ2aWRlby1pZC1pbnB1dFwiKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgY29uc3QgdmlkZW9TZWFyY2hCdXR0b21FbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ2aWRlby1zZWFyY2gtYnV0dG9uXCIpO1xyXG4gICAgY29uc3QgdmlkZW9JbmZvRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmlkZW8taW5mb1wiKTtcclxuICAgIGNvbnN0IGRvd25sb2FkQnV0dG9uRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmlkZW8tY2hhdC1kb3dubG9hZC1idXR0b25cIik7XHJcblxyXG4gICAgdmlkZW9TZWFyY2hCdXR0b21FbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmlkZW9JZCA9IHZpZGVvSWRJbnB1dEVsZW0udmFsdWU7XHJcbiAgICAgICAgY29uc3QgY2xpZW50ID0gZ2V0VHdpdGNoQ2xpZW50KCk7XHJcbiAgICAgICAgY2xpZW50LmhlbGl4LnZpZGVvcy5nZXRWaWRlb0J5SWQodmlkZW9JZCkudGhlbigodmlkZW8pID0+IHtcclxuICAgICAgICAgICAgLy8gUG9wdWxhdGUgdmlkZW8gaW5mbyBlbGVtXHJcbiAgICAgICAgICAgIHZpZGVvSW5mb0VsZW0udGV4dENvbnRlbnQgPSB2aWRlby50aXRsZSArIFwiLCBcIiArIHZpZGVvLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbG9vcEhhbmRsZXIgPSAodHVybjogbnVtYmVyLCBzdGF0dXM6IG51bWJlciwgZG93bmxvYWRDb3VudDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgLy8gRGlzcGxheSBkb3dubG9hZCBzdGF0dXMgaW4gc29tZSA8ZGl2PlxyXG4gICAgfTtcclxuXHJcbiAgICBkb3dubG9hZEJ1dHRvbkVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB2aWRlb0lkID0gdmlkZW9JZElucHV0RWxlbS52YWx1ZTtcclxuICAgICAgICBjb25zdCBkb3dubG9hZGVyID0gbmV3IENoYXREb3dubG9hZGVyKCk7XHJcbiAgICAgICAgZG93bmxvYWRlci5hZGRMb29wRXZlbnRMaXN0ZW5lcihsb29wSGFuZGxlcik7XHJcbiAgICAgICAgY29uc3QgY2hhdHMgPSBhd2FpdCBkb3dubG9hZGVyLmRvd25sb2FkQ2hhdCh2aWRlb0lkKTtcclxuICAgICAgICAvLyBEaXNwbGF5IGRvd25sb2FkIHN0YXR1c1xyXG4gICAgICAgIC8vIGRvd25sb2FkXHJcbiAgICAgICAgLy8gV2hlbiBmaW5pc2hlZCBkb3dubG9hZGluZywgZG93bmxvYWQgdGhlIGZpbGUgdG8gbG9jYWwgZGlza1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbmFkZEZvbGxvd2VyRG93bmxvYWRlckxpc3RlbmVycygpO1xyXG5hZGRDaGF0RG93bmxvYWRlckxpc3RlbmVycygpO1xyXG5cclxuXHJcblxyXG59KSgpO1xyXG5cclxuXHJcblxyXG4vKlxyXG5mdW5jdGlvbiBtYWluKCkge1xyXG5cclxuICAvL2NvbnN0IGlucHV0ID0gXCJyYW5kb20gZmlsdGVyIG5hbWUgJiBGb2xsb3cgMWRheSB8IHN1YnNjcmliZXIgJiBhYWFhYSAmIChCYmJiKVwiO1xyXG4gIC8vY29uc3QgaW5wdXQgPSBcIiEo656c642k7ZWcIO2VhO2EsCDsnbTrpoQpICYg7YyU66Gc7JqwIDHsnbwg7J207ZWYIHwg67mE6rWs64+F7J6QICYg6re464OlIOydtOqyg+yggOqygyAmICjslYTrrLTqsbDrgpgg7J206rKD7KCA6rKDKVwiO1xyXG4gIGNvbnN0IGlucHV0ID0gXCIhKOuenOuNpO2VnCDtlYTthLAg7J2066aEKSB8IO2MlOuhnOyasCAx7J28IOydtO2VmHwgKOu5hOq1rOuPheyekCB8Ieq3uOuDpSDsnbTqsoPsoIDqsoMpICYg7JWE66y06rGw64KYIOydtOqyg+yggOqyg1wiO1xyXG4gIGNvbnN0IGYgPSBnZXRGaWx0ZXIoaW5wdXQpO1xyXG4gIGNvbnNvbGUubG9nKFwiZjogXCIgKyBmKTtcclxuICBjb25zb2xlLmxvZyhcInR5cGUgZjogXCIgKyBPYmplY3Qua2V5cyhmKSk7XHJcbiAgY29uc29sZS5sb2coXCJ0b1N0cmluZzogXCIgKyBmLnRvU3RyaW5nKCkpO1xyXG5cclxuICByZXR1cm47XHJcblxyXG4gIGNvbnN0IGJlZm9yZUZpbGUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICBjb25zdCBmaWxlQ29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgXCJ1dGY4XCIpO1xyXG4gIGNvbnN0IGZpbGVKc29uID0gSlNPTi5wYXJzZShmaWxlQ29udGVudCk7XHJcbiAgY29uc3QgY29tbWVudHNEYXRhID0gZmlsZUpzb25bXCJjb21tZW50c1wiXSBhcyBBcnJheTxDb21tZW50RGF0YT47XHJcbiAgXHJcbiAgY29uc3QgcmVwb3NpdG9yeSA9IG5ldyBDb21tZW50UmVwb3NpdG9yeShjb21tZW50c0RhdGEpO1xyXG4gIGNvbnNvbGUubG9nKFwiVXNlciBjb3VudDogXCIgKyByZXBvc2l0b3J5LnVzZXJDb3VudCgpKTtcclxuICBjb25zb2xlLmxvZyhcIkNoYXQgY291bnQ6IFwiICsgcmVwb3NpdG9yeS5jb21tZW50Q291bnQoKSk7XHJcbiAgXHJcbiAgY29uc3QgZ3JvdXAgPSBuZXcgQW5kRXhwcmVzc2lvbkdyb3VwKCk7XHJcbiAgZ3JvdXAuYWRkUmVnZXgoe3R5cGU6IFwidXNlclwiLCBrZXk6IFwidXNlcm5hbWVcIn0sIFwiY1wiKTtcclxuICBncm91cC5hZGRSZWdleCh7dHlwZTogXCJjb21tZW50XCIsIGtleTogXCJyYXdUZXh0XCJ9LCBcImhlYXJ0XCIpO1xyXG4gIGdyb3VwLmFkZEdyZWF0ZXJUaGFuKHt0eXBlOiBcImNvbW1lbnRcIiwga2V5OiBcInJlbGF0aXZlVGltZVwifSwgMjAwKTtcclxuXHJcbiAgY29uc3QgYmVmb3JlRmlsdGVyID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgY29uc29sZS5sb2coXCJSZXBvc2l0b3J5IGNyZWF0ZWQgaW4gXCIgKyAoYmVmb3JlRmlsdGVyIC0gYmVmb3JlRmlsZSkgKyBcIiBtaWxsaXNlY29uZHNcIik7XHJcbiAgY29uc3QgZmlsdGVyZWQgPSByZXBvc2l0b3J5LmZpbHRlcihncm91cCk7XHJcbiAgLy9jb25zdCBmaWx0ZXIgPSBuZXcgUmVnZXhFeHByZXNzaW9uKHt0eXBlOiBcImNvbW1lbnRcIiwga2V5OiBcInJhd1RleHRcIn0sIFwi44WL44WL44WLXCIpO1xyXG4gIC8vY29uc3QgZmlsdGVyID0gbmV3IFJlZ2V4RXhwcmVzc2lvbih7dHlwZTogXCJ1c2VyXCIsIGtleTogXCJ1c2VybmFtZVwifSwgXCJyXCIpO1xyXG5cclxuICAvL2NvbnN0IGZpbHRlcmVkID0gcmVwb3NpdG9yeS5maWx0ZXIoZmlsdGVyKTtcclxuICBcclxuICBjb25zdCBhZnRlckZpbHRlciA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gIGNvbnNvbGUubG9nKFwiRmlsdGVyZWQgY29tcGxldGUgaW4gXCIgKyAoYWZ0ZXJGaWx0ZXIgLSBiZWZvcmVGaWx0ZXIpICsgXCIgbWlsbGlzZWNvbmRzXCIpO1xyXG5cclxuICBjb25zb2xlLmxvZyhmaWx0ZXJlZC5sZW5ndGgpO1xyXG4gIGZvcihsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGZpbHRlcmVkW2ldLnRvRGlzcGxheVN0cmluZygpKTtcclxuICB9XHJcbiAgZm9yKGxldCBjaGF0IG9mIGZpbHRlcmVkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGNoYXQudG9EaXNwbGF5U3RyaW5nKCkpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbm1haW4oKTtcclxuXHJcbiovIl0sInNvdXJjZVJvb3QiOiIifQ==